C 22 Oct 14 - DGF - pad commons for FMO 5.1
C 21 May 13 - DGF - pad commons for FMO 5.0
C 15 MAR 13 - CMC - rewrite of code structure and added new routines
C 18 Feb 13 - JAB - GLOBDR: fix generation of "linear" random configs 
C 19 Oct 12 - MWS - synchronize FRGINF common
C 24 JUL 12 - DGF - PAD COMMON FOR FMO 4.3
C 17 APR 12 - MWS - DUMP LIST OF CHEMICAL SYMBOLS AT TOP OF .TRJ FILE
C 23 MAR 12 - DGF - PAD COMMON BLOCKS
C 28 DEC 11 - DGF - PAD COMMONS FOR FMO 4.2
C 11 AUG 11 - HL  - FIX FOR LJ TERM
C 15 APR 11 - TN  - CHANGES FOR THE FMO ANALYTIC GRADIENT
C 12 DEC 10 - PB  - GLOPDR: COMPUTE NGEOPT BEFORE USE IN STORAGE ALLOCS
C 11 AUG 10 - TN  - CHANGES TO ENABLE FMO RUNS 
C 25 MAR 10 - MWS - CHANGE PRINTING FOR RANDOMIZED INITIAL CLUSTERS
C  1 MAY 09 - NMT - NEW DIMENSION FOR EFPBAS AND FRAGMT
C  1 MAY 09 - JMN - RANDOM STRUC. CREATION'S INIT.OPT. OBEYS USER INPUT
C 15 DEC 08 - MWS - DEACTIVATE SIMEN/SIMCOR/MOVIE2 OUTPUTS
C 23 OCT 08 - LVS - SYNCHRONIZE THE POLTMP AND POL2 COMMON
C 20 AUG 07 - DRM - PROVIDE RANDOM INITIAL CLUSTER GENERATION OPTION
C 28 DEc 11 - DGF - PAD COMMONS FOR FMO 4.2
C 20 AUG 07 - LVS - STCOR,RSTCOR: SAVE DISPERSION COEFS FOR EFP1-MP2
C 24 MAR 07 - MWS - PAD THE FRGINF,EFPPAR COMMON BLOCKS
C 22 DEC 06 - TN  - GLOBOP INTERFACED WITH FMO
C 14 NOV 05 - DGF - PAD COMMON BLOCK SCFOPT
C 19 SEP 05 - IA  - SYNCHRONIZE FRGINF COMMON
C  5 JUL 05 - MWS - SELECT NEW ATOM,BASIS,EFP,PCM,DAF DIMENSIONS
C 27 JUN 05 - HL  - GLOPDR: FIX RANDOM NUMBERS FOR PARALLEL GLOBOP
C 14 MAR 05 - HL  - STCOR,RSTCOR: SAVE CANONICAL MO, UPDATE EFDSPL ARGS
C  7 MAR 05 - IA  - STCOR,RSTCOR: SAVE DYNAMIC POLARIZABILITY
C 13 FEB 05 - JS  - ADD EFP MP2 CHANGES TO GLOFRG
C 22 NOV 04 - IA  - FIX STORING BEST EFP2 PAULI REPULSION INFORMATION
C  9 DEC 03 - MWS - SYNCH COMMON BLOCK RUNOPT
C  3 JUL 03 - JMM - SUPPRESS PRINTING FOR MONTE CARLO JOBS
C 26 MAR 03 - PND - CHANGE MOVIE OUTPUTS
C 17 AUG 02 - MWS - FIX COORDINATE STORAGE PROBLEM FROM 7 AUG 02 CHANGE
C  7 AUG 02 - HT  - USE DYNAMIC MEMORY FOR EFP PAULI REPULSION
C 17 APR 02 - MWS - SYNCH UP EFMULT AND FRGINF COMMON
C 26 MAR 02 - MWS - FIXES RELATING TO ONLY AB INITIO ATOMS PRESENT
C  6 SEP 01 - KRG - RAND3: ENSURE POSITIVE SEEDING
C 25 JUN 01 - MWS - ALTER COMMON BLOCK SCFOPT
C 13 JUN 01 - MWS - GLOFRG: CALL MEMORY ROUTINE FOR CAVITY CONSTRUCTION
C 20 FEB 01 - PND - MONTE CARLO/SIMULATED ANNEALING GLOBAL OPTIMIZER
C
C*MODULE GLOBOP  *DECK GLOPDR
C> @brief main driver for Monte Carlo Runs
C>
C> @details handles the default and input settings.
C>          Contains the main loop and tracks statistics as
C>          well as the final output.
C>
C>          The Metropolis Monte Carlo method implemented here
C>          takes some combination of  EFP/FMO/AI groups and randomly
C>          moves or rotates one or more groups at each step. The
C>          energy is calculated and if it is lower than the previous
C>          energy, the new coordinates are accepted.  If the
C>          energy is higher, then the new coordinates are accepted
C>          with a probability dependent on the temperature.
C>
C>          Simulated annealing is implemented.
C>
C> @author Caleb Carlin
C>   - April 2014
C>
C> @date Feb 2001 - Paul N. Day
C>   - Subroutine written
C> @date Jan 2013, Jerry A. Boatz  
C> - Allocated sufficient memory for array of random numbers
C> @date Jan 2016, E.Guidez
C> - Allocated extra memory for dynamic polarizabilities for dispersion
C>
      SUBROUTINE GLOPDR
C
      use connglob
      use DYNPOL_DIST 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,MCMIN
      LOGICAL OPTN,MIN_C,RNDINI,LSCZVFLG,ACCEPT
C
      PARAMETER (MXATM=2000, MXAO=8192,MXSHEF=1000, MXGEFP=4000,
     *           MXPT=2000, MXFRG=1050, MXDFG=5, MXFGPT=12000,
     *           MXDPPT=63000,SCALTM=3.1667606D-06)
C
C
      CHARACTER*8 :: LJNAME,ELJNAM
      CHARACTER*4 :: ATMSYM(106)
      DOUBLE PRECISION :: SCALE(2)
      INTEGER, allocatable :: IFXFRG(:),AIFRG(:), IFXFMO(:)
      INTEGER, allocatable :: IBNDS(:),IPRBNDA(:)
      DOUBLE PRECISION, allocatable :: DELMXC(:),DELMXA(:),DELA(:)
      DOUBLE PRECISION, allocatable :: RND(:),DELC(:),PSBND(:),PRSEP(:)
      DOUBLE PRECISION, allocatable :: AVEXYZ(:,:),BAVEXYZ(:,:)
      LOGICAL :: JSTRND
      CHARACTER*8 FRGNME
C
      COMMON /FRGNRG/ CCNRG,CDNRG,CQNRG,CONRG,DDNRG,DQNRG,QQNRG,
     *                ESNRG,REPNRG,POLNRG,DISNRG,DISNRG8,
     *                EDISD,CHTNRG,EDISP7,EDISD6
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),LMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CANFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /FMCOM / XX(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,MODFD,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,LIACTFG,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /GLOFMO/ MCMIN,IFMOID(MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC,IPTRAJ
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00,
     *           UNITS = ONE/0.52917724924D+00)
C
      PARAMETER (NNAM=37)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA QNAM/8HTEMPI   ,8HTEMPF   ,8HNTEMPS  ,8HNGEOPT  ,
     *          8HSCALE   ,8HALPHA   ,8HMOVIE2  ,8HBOLTWT  ,
     *          8HXMIN    ,8HXMAX    ,8HYMIN    ,8HYMAX    ,
     *          8HZMIN    ,8HZMAX    ,8HSEPTOL  ,8HNPRT    ,
     *          8HRANDOM  ,8HNFRMOV  ,8HDACRAT  ,8HNFMOMOV ,
     *          8HUPDFAC  ,8HMCMIN   ,8HNTRAN   ,8HNROT    ,
     *          8HOPTN    ,8HNBLOCK  ,8HAIMOVE  ,8HNSTMIN  ,
     *          8HRNDINI  ,8HRIORD   ,8HIFXFRG  ,8HNAIFG   ,
     *          8HMCTYP   ,8HNPRBND  ,8HNSMSTP  ,8HSMTEMP  ,
     *          8HJSTRND  /
      DATA KQNAM / 3,  3,1,1,
     *            23,  3,0,5,
     *             3,  3,3,3,
     *             3,  3,3,1,
     *             5,  1,3,1,
     *             3,  0,1,1,
     *             0,  1,3,1,
     *             0,  5,-11,1,
     *             1,1,1,3,
     *             0/
C     These arrays are separate since they depend on NAIFG and NPRBND
      PARAMETER (NBNAM=6)
      DIMENSION QBNAM(NBNAM),KQBNAM(NBNAM)
      DATA QBNAM/8HIFXFMO  ,8HAIFRG   ,8HNAICUT  ,8HIBNDS   ,
     *           8HPRSEP   ,8HINDEP   /
      DATA KQBNAM /-11, -11,1,-11,-13,1/
C
      DATA GLOBOP/8HGLOBOP  /, GLBFRG/8HGLBFRG  /
      DATA STANDARD /8HSTANDARD/, AVESTEP/8HAVESTEP /
      DATA DEBUG /8HDEBUG   /, RAND1/8HRAND1   /,RAND3/8HRAND3   /
      DATA RAND /8HRAND    /, OPT/8HOPTIMIZE/
C
C
C
C     ---- MAIN DRIVER FOR MONTE CARLO/SIMUMATED ANNEALING RUNS -----
C
C        THE FOLLOWING IS CONSIDERED THE MAIN OUTPUT FILE,
C        FOR BOTH ENERGIES AND COORDINATES.
C
      IPTRAJ = 4
      CALL SEQOPN(IPTRAJ,'TRAJECT','NEW',.FALSE.,'FORMATTED')
C
C        START THE FILE WITH A LIST OF CHEMICAL SYMBOLS FOR EASIER
C        IDENTIFICATION OF ATOMS
C
      CALL SETLAB(3,ATMSYM)
      IF(MASWRK) THEN
         WRITE(IPTRAJ,8010)
         DO IAT=1,NAT
            NUCZ = INT(ZAN(IAT)) + IZCORE(IAT)
            WRITE(IPTRAJ,8030) ATMSYM(NUCZ)
         ENDDO
         IAT=0
         KMASS=0
         DO IFRG=1,NFRG
            DO III=1,NMPTS(IFRG)
               IAT=IAT+1
               IF(FMASS(III+KMASS).GT.ZERO) THEN
                  NUCZ = INT(FGNUC(III+KMASS)+0.001D+00)
                  WRITE(IPTRAJ,8030) ATMSYM(NUCZ)
               END IF
            ENDDO
            KMASS=KMASS+NMPTS(IFRG)
         ENDDO
         WRITE(IPTRAJ,8020)
         CALL FLSHBF(IPTRAJ)
      END IF
C
      NPUNCH=-2
      TEMPER=0.0D+00
C---------------------
C  Default parameters
      TEMPI = 20000.0D+00
      TEMPF = 0.0D+00
      NTEMPS = 1
      NFRMOV = 1
      NFMOMOV = 1
      NGEOPT=100
      NTRAN = 5
      NROT = 5
      MCMIN=.TRUE.
      OPTN=.FALSE.
      NAIFG=NAT
      NFMOMOV=1
      NBLOCK=0
C
      MIN_C = .FALSE.
      NSTMIN= 10
      AIMOVE=0.0D+00
C
      SCALE(1) = ONE
      SCALE(2) = ONE
      ALPHA = ZERO
      DACRAT = 0.5D+00
      UPDFAC = 0.95D+00
      SEPTOL = 1.5D+00
      XMIN = -1.0D+1
      XMAX =  1.0D+1
      YMIN = -1.0D+1
      YMAX =  1.0D+1
      ZMIN = -1.0D+1
      ZMAX =  1.0D+1
      BOLTWT = STANDARD
      RNDINI=.FALSE.
      RIORD=RAND
      DAVE=1
      NPRBND=0
C     MCTYP is a bitwise flag for what type of groups are present      
C     (2=FMO,4=EFP,1=ab initio. so MCTYP=6 is FMO and EFP)
C     The assumption is an EFP run. Old style AI movements
C     are handled by AIMOVE.  For fully AI MC, set MCTYP=1,3, or 5
      MCTYP=4
C     controls the secondary MC for FMO and ab initio
      NSMSTP=0
      SMTEMP=0.0D+00
      JSTRND=.TRUE.
C
C          NPRTGO=1 MEANS NORMAL PRINTING
C                =2 MEANS SUPPRESSED PRINTING
C
      NPRTGO = 1
C
C          IGOFLG=1 MEANS MONTE CARLO GLOBAL OPTIMIZATION IN PROGRESS
C                =2 MEANS ORDINARY GEOMETRY OPTIMIZATION
C
      IGOFLG = 1
      RANDOM = RAND3
C
C  Sets up IFXFRG to have a dynamic size
      ALLOCATE (IFXFRG(NFRG))
      KQNAM(31)=10*NFRG+1
      DO IFR=1,NFRG
         IFXFRG(IFR)=0
      END DO
C
      JRET = 0
      CALL NAMEIO (IR,JRET,GLOBOP,NNAM,QNAM,KQNAM,
     *             TEMPI,TEMPF,NTEMPS,NGEOPT,SCALE,ALPHA,MOVIE2,
     *             BOLTWT,XMIN,XMAX,YMIN,YMAX,ZMIN,ZMAX,
     *             SEPTOL,NPRTGO,RANDOM,NFRMOV,DACRAT,NFMOMOV,
     *             UPDFAC,MCMIN,NTRAN,NROT,OPTN,NBLOCK,AIMOVE,NSTMIN,
     *             RNDINI,RIORD,IFXFRG,NAIFG,MCTYP,NPRBND,
     *     NSMSTP,SMTEMP,JSTRND,0,0,     0,0,0,0,0,
     *     0,0,0,0,0,     0,0,0,0,0,     0,0,0,0,0,     0,0,0,0,0)
      IF(JRET.GT.1) THEN
         IF(MASWRK) WRITE(IW,*) 'ERROR IN $GLOBOP GROUP'
         CALL ABRT
      END IF
C
C  Sets up AIFRAG with dynamic size and puts all atoms in 1 fragment
C  by default
      ALLOCATE (AIFRG(NAT))
      KQBNAM(2)=10*NAT+1
      DO IRF=1,NAT
         AIFRG(IRF)=IRF
      END DO
C  Set up fragment tracking for AI or FMO, which is being used
      IF (iand(MCTYP,1).EQ.0) NAIFG=0
      NMCFRG=NFG+NAIFG
      ALLOCATE (IFXFMO(NMCFRG))
      KQBNAM(1)=10*NMCFRG+1
      DO IGH=1,NMCFRG
         IFXFMO(IGH)=0
      END DO
      NAICUT=0
C  Set up array for FMO pair bond array
      IF (NPRBND.GT.0) THEN
C       Length of array of bond pairs
        NPRBNDT=2*NPRBND
        ALLOCATE (IBNDS(NPRBNDT))
        KQBNAM(4)=10*NPRBNDT+1
        ALLOCATE (PRSEP(NPRBND))
        KQBNAM(5)=10*NPRBND+3
        DO IRQ=1,NPRBND
              PRSEP(IRQ)=0.0D+00
        END DO
        DO IRR=1,NPRBNDT
             IBNDS(IRR)=0
        END DO
      END IF
C
      IF(NAIFG.NE.NAT.AND.NAIFG.NE.0.OR.NPRBND.NE.0) THEN
         INDEP=0
         JRET = 0
         CALL NAMEIO (IR,JRET,GLBFRG ,NBNAM,QBNAM,KQBNAM,
     *             IFXFMO,AIFRG,NAICUT,IBNDS,PRSEP,
     *             INDEP,0,0,0,0,0,0,
     *             0,0,0,0,0,0,
     *             0,0,0,0,0,0,
     *             0,0,0,0,0,
     *     0,0,0,0,0,  0,0,0,0,0,     0,0,0,0,0,
     *     0,0,0,0,0,     0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0)
         IF(JRET.GT.1) THEN
            IF(MASWRK) WRITE(IW,*) 'ERROR IN $GLBFRG GROUP'
            CALL ABRT
         END IF
C     convert IBNDS to more useful form
C     IPRBNDA is a symmetric array where each position and
C     value represent a pair of atoms that are distance constrained
         IF (NPRBND.NE.0) THEN
             ALLOCATE (IPRBNDA(NAT))
             ALLOCATE (PSBND(NAT))
             DO IBB=1,NAT
                  IPRBNDA(IBB)=0
                  PSBND(IBB)=0.0D+00
             END DO
             JKEEPER=1
             DO IRB=1,NPRBND
                 ITEMP=IBNDS(JKEEPER)
                 JTEMP=IBNDS(JKEEPER+1)
                 IF ((ITEMP==0).OR.(JTEMP==0)) THEN
                     IF(MASWRK) WRITE(IW,*)
     *     'IBNDS must have 2*NPRBND entries',ITEMP,JTEMP
                     CALL ABRT
                 END IF
                 IPRBNDA(ITEMP)=JTEMP
                 IPRBNDA(JTEMP)=ITEMP
                 PSBND(ITEMP)=PRSEP(IRB)
                 PSBND(JTEMP)=PRSEP(IRB)
                 JKEEPER=JKEEPER+2
              END DO
         END IF
         IF (AIFRG(1).eq.0) CALL MC_AI_FRGCONV(NAIFG,AIFRG)
C        
         IF(NAICUT.GT.0) THEN
            JSTEPER=1
            KSTEPER=1
            DO JIK=1,NAIFG
               DO JJK=1,NAICUT
                  AIFRG(KSTEPER)=JSTEPER
                  KSTEPER=KSTEPER+1
               END DO
               JSTEPER=JSTEPER+1
            END DO
         END IF
      END IF
      IF (MASWRK .AND. NAIFG.GT.0) THEN
          WRITE(IW,9122) (AIFRG(IIK),IIK=1,NAT)
      END IF
 9122 FORMAT(1X,'AIFRG=',10I5)
C
      IF(iand(MCTYP,1).NE.0) THEN
         DO JKU=1,NAT
            IFMOID(JKU)=AIFRG(JKU)
         END DO
      ENDIF
C  at this point we finally have all the information we need
C  to set up the bonded pairs array for AI runs.
      IF(NPRBND.NE.0) THEN
            call mc_fill_elemrad
            call buildarrays(NMCFRG,IPRBNDA,PSBND)
            DEALLOCATE(IBNDS)
            DEALLOCATE(PRSEP)
      END IF
C     We deallocate it here because it was either never used or
C     Has been copied over to IFMOID
      DEALLOCATE(AIFRG)
C      
      IF(NBLOCK.EQ.0) THEN
         NBLOCK=NGEOPT/(NTRAN+NROT)
      ELSE
         NGEOPT = NBLOCK*(NTRAN+NROT)
      END IF
C
      IF(MCTYP.NE.4.AND.AIMOVE.NE.0.0D+00) THEN
           IF (MASWRK) WRITE(IW,*) 'AIMOVE only works for MCTYP=4'
           CALL ABRT
      END IF
      IF(NBLOCK.EQ.0) THEN
          IF (MASWRK) WRITE (IW,*) 'NBLOCK must be greater than 0'
          CALL ABRT
      END IF
      IF(MCTYP==3) THEN
          IF (MASWRK) WRITE(IW,*) 'Cannot have ab initio and FMO'
          CALL ABRT
      END IF
C
      IF(MASWRK) THEN
          WRITE(IW,9100) TEMPI,TEMPF,NTEMPS,NGEOPT,
     *                   NFRMOV,NTRAN,NROT,NBLOCK,SCALE,SEPTOL,
     *                   MCMIN,NSTMIN,OPTN,
     *                   XMIN,XMAX,YMIN,YMAX,ZMIN,ZMAX,
     *                   ALPHA,DACRAT,UPDFAC,BOLTWT,
     *                   AIMOVE,NPRTGO,RANDOM,RNDINI,RIORD,NAIFG,
     *                   NFMOMOV
          WRITE(IW,9101) (IFXFRG(III),III=1,NFRG)
      END IF
 9100 FORMAT(/10X,'---- MONTE CARLO/SIMULATED ANNEALING OPTIONS -----'/
     *    1X,'TEMPI=',F10.1,' TEMPF=',F10.1,
     *       ' NTEMPS=',I4,' NGEOPT=',I5/
     *    1X,'NFRMOV=',I4,' NTRAN=',I4,' NROT=',I4,' NBLOCK=',I4,
     *       ' SCALE=',2F6.2,' SEPTOL=',F6.3/
     *    1X,'MCMIN=',L2,' NSTMIN=',I4,' OPTN=',L2/
     *    1X,1P,'XMIN/XMAX=',2E10.2/
     *    1X,1P,'YMIN/YMAX=',2E10.2/
     *    1X,1P,'ZMIN/ZMAX=',2E10.2,0P/
     *    1X,'ALPHA=',F10.4,' DACRAT=',F10.4,' UPDFAC=',F10.4,
     *       ' BOLTWT=',A8/
     *    1X,'AIMOVE=',F9.4,'  NPRT=',I4,'  RANDOM=',A8,
     *    1X,'RNDINI=',L2,'  RIORD=',A8,/
     *    1X,'  NAIFG=',I4,' NFMOMOV=',I4,/
     *    1X,'NSMSTP=',I4,' SMTEMP=',F9.4)
 9101 FORMAT(1X,'IFXFRG=',10I5)
      CALL FLSHBF(IW)
C
C        THIS OPTION SHARES A UNIT NUMBER WITH THE TRAJECTORY FILE,
C        SO IT IS TURNED OFF SO WE GET THAT MORE USEFUL DATA, INSTEAD.
C
C
C------------------
C  Calculating parameters based on inputs
C
C     Convert lengths to atomic units
      XMIN = XMIN * UNITS
      XMAX = XMAX * UNITS
      YMIN = YMIN * UNITS
      YMAX = YMAX * UNITS
      ZMIN = ZMIN * UNITS
      ZMAX = ZMAX * UNITS
      XRANGE = XMAX - XMIN
      YRANGE = YMAX - YMIN
      ZRANGE = ZMAX - ZMIN
      SEPTOL = SEPTOL * UNITS
      SCALE(1) = SCALE(1) * UNITS
C      SCALE(2) = SCALE(2) * UNITS
C
C     NTFRG is the total number of fragments
C     NMCFRG is the total number of FMO frags and AI groups
      NTFRG = NFRG + NMCFRG
C
      IF(TEMPI.LE.ZERO) THEN
        IF(MASWRK) WRITE(IW,*)
     *      'INITIAL TEMPERATURE MUST BE GREATER THAN ZERO.'
        CALL ABRT
      END IF
      GAMR = 1.0D+00
      IF(TEMPF.LT.ZERO) THEN
        IF(MASWRK) WRITE(IW,*)
     *      'FINAL TEMPERATURE MUST BE GREATER THAN ZERO.'
        CALL ABRT
      ELSE IF(TEMPF.GT.TEMPI) THEN
        IF(MASWRK) WRITE(IW,*)
     *      'FINAL TEMPERATURE CAN NOT BE GREATER THAN INITIAL.'
        CALL ABRT
      ELSE IF(TEMPF.EQ.ZERO) THEN
        IF(NTEMPS.GT.1) THEN
C CALCULATE FINAL TEMPERATURE BASED ON COOLING RATE OF 0.95
          GAMR=0.95D+00
C         GAMR=0.98D+00
         TEMPF=TEMPI*GAMR**(NTEMPS-1)
        ELSE IF(NTEMPS.LT.1) THEN
         IF(MASWRK) WRITE(IW,*)'NTEMPS MUST BE POSITIVE'
         CALL ABRT
        END IF
      ELSE
        IF(NTEMPS.GT.1) THEN
         GAMR = (TEMPF/TEMPI)**(ONE/(NTEMPS-1))
        ELSE IF(NTEMPS.LT.1) THEN
         IF(MASWRK) WRITE(IW,*)'NTEMPS MUST BE POSITIVE'
         CALL ABRT
        ELSE
C CALCULATE NUMBER OF TEMPERATURES BASED ON COOLING RATE OF 0.95
         GAMR=0.95D+00
C         GAMR=0.98D+00
         NTEMPS=INT(LOG(TEMPF/TEMPI)/LOG(GAMR))+1
         IF(MASWRK) WRITE(IW,*)'NUMBER OF TEMPERATURES WILL BE ',NTEMPS
        END IF
      END IF
      IF(NGEOPT.LE.0) THEN
       IF(MASWRK) WRITE(IW,*) 'NGEOPT MUST BE POSITIVE'
       CALL ABRT
      END IF
      IF(BOLTWT.EQ.STANDARD) THEN
        IBWM = 0
      ELSE IF(BOLTWT.EQ.AVESTEP) THEN
        IBWM = 1
      ELSE
        IF(MASWRK) WRITE(IW,*)'ILLEGAL VALUE FOR BOLTWT IN $GLOBOP'
        CALL ABRT
      END IF
      IF(RANDOM.EQ.DEBUG) THEN
        IRTP = 0
      ELSE IF(RANDOM.EQ.RAND1) THEN
        IRTP = 1
      ELSE IF(RANDOM.EQ.RAND3) THEN
        IRTP = 3
      ELSE
        IF(MASWRK) WRITE(IW,*)'ILLEGAL VALUE FOR RANDOM IN $GLOBOP'
        CALL ABRT
      END IF
      IF(RIORD.NE.STANDARD.AND.RIORD.NE.RAND) THEN
        IF(MASWRK) WRITE(IW,*)'ILLEGAL VALUE FOR RIORD IN $GLOBOP'
        CALL ABRT
      END IF
      IF(NFRMOV.LT.0) THEN
        IF(MASWRK) WRITE(IW,*) 'NFRMOV CANNOT BE NEGATIVE'
        CALL ABRT
      ELSE IF(NFRMOV.GT.NFRG) THEN
        IF(MASWRK) WRITE(IW,*)'NFRMOV=',NFRMOV,
     *         ' IS GREATER THAN THE NUMBER OF FRAGMENTS=',NFRG
C        CALL ABRT
      END IF
C     For mixed runs, calculate ratio of number fragments
      RATIO=0.0D+00
      IF(NMCFRG.GT.0.AND.NFRG.GT.0) RATIO=(DBLE(NFRG)/
     * (DBLE(NMCFRG)+DBLE(NFRG)))
C
C     End of calculation of parameters.  Now setting up memory allocation
C------------------
C 
C
C    NPBFMX will equal largest value in NPBF
      NPBFMX=NPBF(1)
      DO 15 IFRG=2,NFRG
        IF(NPBF(IFRG).GT.NPBFMX) NPBFMX=NPBF(IFRG)
 15   CONTINUE
C
C        SELECT THE STORAGE SIZE FOR RANDOM NUMBERS
C
C-orig-jab-24jan2013
C      IF(AIMOVE.EQ.0.0D+00) THEN
C         IMXRAN = NBLOCK*(6*(NFRG+NAT)+1)
C      ELSE
C         IMXRAN = NBLOCK*(6*(NFRG+NAT)+3*NAT+1)
C      END IF
C-orig-jab-24jan2013
C-modified-cmc-13may2013
C      mptsum = 0
C      if(nfrg > 0) Then
C          do ifrg=1,nfrg
C              mptsum = mptsum + nmpts(ifrg)
C          end do
C      end if
C      imxran = nfrg*6*mptsum+nat*6+1
C
C     We allocate a large array here for initial randomization
      IF(RNDINI) THEN
         IMXRAN=NMCFRG*6+NFRG*10
         ALLOCATE(RND(IMXRAN))
      END IF
C      
      MXBF=0
      DO I = 1, NFRG
         MXBF=MAX(MXBF,NPBF(I))
      END DO
C
C  ALLOCATE DYNAMIC MEMORY
C
      CALL VALFM(LOADFM)
      LWRK    = LOADFM  + 1
      LCMIN   = LWRK    + NUM*NUM
      LCOLD   = LCMIN   + 3*NAT + 22*NMTTPT + 12*NPTTPT + 75*NDPTTPT
     *                  + 3*NRTTPT + 3*NTPATM + MXBF*NTMO
     *                  + MXBF*NTAO + 3*NTMO + 3*NDTTPT + 3*NLJTTPT
      LPROVEC = LCOLD   + 3*NAT + 22*NMTTPT + 12*NPTTPT + 75*NDPTTPT
     *                  + 3*NRTTPT + 3*NTPATM + MXBF*NTMO
     *                  + MXBF*NTAO + 3*NTMO + 3*NDTTPT + 3*NLJTTPT
      LCTVEC  = LPROVEC + MXBF*NTAO
      LAST    = LCTVEC  + MXBF*NTAO
C 
C     TREATMENT OF FMO DENSITIES AND Z-VECTOR
C------------------------------- 
      IF (NFG.NE.0) THEN
        NDPNT=0
        IF(IAND(NGUESS,8).NE.0) NDPNT=(NFG*NFG-NFG)/2
        NDAR30=0
        IF(IAND(MODPAR,512+1024).NE.0) NDAR30=1+NFG*2*2
C
        LIDMPNT = LAST
        LIDDPNT = LIDMPNT + (NDAR30-1)/NWDVAR+1
        LAST    = LIDDPNT + (NDPNT-1)/NWDVAR+1 

        LSCZVFLG = IAND(MODGRD,32).NE.0.AND.IAND(MODPAR,512).NE.0
C        LSCZVFLG = MCMIN.AND.IAND(MODGRD,32).NE.0.AND.
C     *             IAND(MODPAR,512).NE.0
        IF (LSCZVFLG) THEN
          LIPTZVEC = LAST
C         LAST     = LIPTZVEC + 2*NFG/NWDVAR + 1
          LIPTLG   = LIPTZVEC + 2*NFG/NWDVAR + 1
          LAST     = LIPTLG   +   NFG/NWDVAR + 1
        END IF
      END IF
C   
      NEED = LAST  - LOADFM - 1
      CALL GETFM(NEED)
C
      LENPV=MXBF*NTMO
      IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
         CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
      END IF
      LENCV=MXBF*NTCTMO
      IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
         CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
      END IF
      ALLOCATE(DELMXC(3*NTFRG),DELMXA(3*NTFRG))
      ALLOCATE(DELC(3*NTFRG),DELA(3*NTFRG))
C
C   BUILDING ARRAY OF AVERAGE COORDINATES
C
      ALLOCATE(AVEXYZ(3,NTFRG))
      ALLOCATE(BAVEXYZ(3,NTFRG))
      IAT=0
      IF(NFRG.GT.0) THEN
         DO MFRG=1,NFRG
            AVEXYZ(1,MFRG)=ZERO
            AVEXYZ(2,MFRG)=ZERO
            AVEXYZ(3,MFRG)=ZERO
            DO IIR=1,NMPTS(MFRG)
               IAT=IAT+1
               AVEXYZ(1,MFRG)=AVEXYZ(1,MFRG)+EFC(1,IAT)
               AVEXYZ(2,MFRG)=AVEXYZ(2,MFRG)+EFC(2,IAT)
               AVEXYZ(3,MFRG)=AVEXYZ(3,MFRG)+EFC(3,IAT)
            END DO
            DENOM=NMPTS(MFRG)
            AVEXYZ(1,MFRG)=AVEXYZ(1,MFRG)/DENOM
            AVEXYZ(2,MFRG)=AVEXYZ(2,MFRG)/DENOM
            AVEXYZ(3,MFRG)=AVEXYZ(3,MFRG)/DENOM
C  if not randomizing, fill up BAVEXYZ now
           IF (.NOT.RNDINI) THEN
              BAVEXYZ(1,MFRG)=AVEXYZ(1,MFRG)
              BAVEXYZ(2,MFRG)=AVEXYZ(2,MFRG)
              BAVEXYZ(3,MFRG)=AVEXYZ(3,MFRG)
           END IF
         END DO
      END IF
      IF(NMCFRG.GT.0) THEN
        DO IFRG=1,NMCFRG
          IAT=IAT+1
          AVEXYZ(1,IAT)=0.0D+00
          AVEXYZ(2,IAT)=0.0D+00
          AVEXYZ(3,IAT)=0.0D+00
          DENOM=0
          DO III=1,NAT
            IF(IFMOID(III).EQ.IFRG) THEN
              AVEXYZ(1,IAT)=AVEXYZ(1,IAT)+C(1,III)
              AVEXYZ(2,IAT)=AVEXYZ(2,IAT)+C(2,III)
              AVEXYZ(3,IAT)=AVEXYZ(3,IAT)+C(3,III)
              DENOM=DENOM+1
            END IF
          END DO
          AVEXYZ(1,IAT)=AVEXYZ(1,IAT)/DENOM
          AVEXYZ(2,IAT)=AVEXYZ(2,IAT)/DENOM
          AVEXYZ(3,IAT)=AVEXYZ(3,IAT)/DENOM
C  if not randomizing, fill up BAVEXYZ now
           IF (.NOT.RNDINI) THEN
              BAVEXYZ(1,IAT)=AVEXYZ(1,IAT)
              BAVEXYZ(2,IAT)=AVEXYZ(2,IAT)
              BAVEXYZ(3,IAT)=AVEXYZ(3,IAT)
           END IF
        END DO
      END IF
C
C   GETTING RANDOM INITIAL CLUSTER
C
      IF (RNDINI) THEN
        INIT=0
        IF(MASWRK)THEN
           CALL FLSHBF(IW)
           CALL RNGEN(RND,IMXRAN,IRTP,INIT)
           CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
        ELSE
           CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
        END IF
        IRN=1
C           
         IF(NFRG.GT.0) CALL MC_EFP_RAND(RND,
     *   XX(LPROVEC),XX(LCTVEC),IRN,MXBF,RIORD,
     *   IMXRAN,IRTP,IFXFRG,AVEXYZ)
         IF(IAND(MCTYP,3).NE.0) CALL MC_FMO_RAND(IMXRAN,RND,IRN,
     *   IRTP,NMCFRG,IFXFMO,AVEXYZ)
         DEALLOCATE(RND)
         IF (MASWRK) THEN
           WRITE(IW,*)'Randomized coordinates:'
           CALL PRATM(IW,1)
         END IF
      END IF
C    Now we can choose a smaller size for temperature loops
      IF(NFMOMOV > NFRMOV) THEN
          NMOVMAX=NFMOMOV
      ELSE
          NMOVMAX=NFRMOV
      END IF
      IMXRAN = 2 + 5*NTRAN*NMOVMAX +5* NROT*NMOVMAX
      IF (AIMOVE .NE. 0.0D+00) IMXRAN = IMXRAN + NAT*3
      ALLOCATE(RND(IMXRAN))
C---------------------------------
C    Done with preparations, now to work
C---------------------------------

C
C  INITIALIZE GLOBAL OPTIMIZATION COUNT
C
      IGLO=0
      NACC=0
      NRPA=0
      NREJ=0
C
C  INITIALIZE DELMX
C
      IDMC=1
      IDMA=1
      DO 25 INF=1,NTFRG
       DELMXC(IDMC  ) = SCALE(1)
       DELMXC(IDMC+1) = SCALE(1)
       DELMXC(IDMC+2) = SCALE(1)
       DELMXA(IDMA  ) = SCALE(2)
       DELMXA(IDMA+1) = SCALE(2)
       DELMXA(IDMA+2) = SCALE(2)
       IDMC=IDMC+3
       IDMA=IDMA+3
 25   CONTINUE
C 
C   EVALUATE ENERGY AND WAVE FUNCTION AT FIRST GEOMETRY
C
      XRAN=ZERO
      IF(MASWRK .AND. NPRINT.NE.-5) WRITE(IW,9050)
      CALL MC_ENERGY(0,XX(LCMIN),XX(LPROVEC),
     *      XX(LCTVEC),ACCEPT,XRAN,ZERO,NSTMIN,MCTYP,
     *      XX(LCOLD),MXBF)
C     Store initial coordinates
      IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
         CALL DAREAD(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
      END IF
      IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
         CALL DAREAD(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
      END IF
      CALL STCOR(XX(LCOLD),XX(LPROVEC),XX(LCTVEC),MXBF)
      NPRINT=-5
C     if we just want the random coordinates, we quite here
      IF (RNDINI.AND.JSTRND) THEN
             DEALLOCATE(DELMXC,DELMXA,DELC,DELA)
             IF (ALLOCATED(IPRBNDA)) DEALLOCATE (IPRBNDA)
             DEALLOCATE (IFXFRG)
             DEALLOCATE (IFXFMO)
             IF (ALLOCATED(PSBND)) DEALLOCATE (PSBND)
             CALL RETFM(NEED)
             RETURN
      END IF
C
      TEMPER = TEMPI
      ACCRATT = DACRAT
      IF(MASWRK) WRITE(IW,9126) GAMR,DACRAT,UPDFAC
C
C     ----LOOP OVER TEMPERATURE STARTS HERE ----
C
      INIT=0
      IF (RNDINI) INIT=1
      DO ITM=1,NTEMPS

      IF(MASWRK) WRITE(IW,9020) ITM,TEMPER
      NACCT=0
      NRPAT=0
      NREJT=0
      BETA = ONE/(TEMPER*SCALTM)
      IF(IBWM.EQ.1) BETA = BETA/DAVE
C
C      RESTORE THE COORDINATES OF THE LOWEST ENERGY CONFIGURATIONS
C      FROM THE PREVIOUS TEMPERATURE
C
      IF(IGLO.GT.1.AND.MIN_C) THEN
         CALL RSTCOR(XX(LCMIN),XX(LPROVEC),XX(LCTVEC),MXBF)
         IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
         END IF
         IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
         END IF
      END IF      
C
C  UPDATE MAXIMUM STEP SIZES TO GET DESIRED ACCEPTANCE RATIO
C  This can result in runaway max step sizes, so setting
C  DACRAT = 0.0 disables this
C
      IF (DACRAT.NE.ZERO) THEN
         IF(ACCRATT.GT.DACRAT) THEN
            UFAC = ONE/UPDFAC
         ELSE IF(ACCRATT.LT.DACRAT) THEN
            UFAC = UPDFAC
         ELSE
            UFAC = ONE
         END IF
      ELSE
         UFAC = ONE
      END IF
C
      IDMC=1
      IDMA=1
      IDC=1
      IDA=1
      DO 225 INF=1,NTFRG
       DELMXC(IDMC  ) = DELMXC(IDMC  ) * UFAC
       DELMXC(IDMC+1) = DELMXC(IDMC+1) * UFAC
       DELMXC(IDMC+2) = DELMXC(IDMC+2) * UFAC
       DELMXA(IDMA  ) = DELMXA(IDMA  ) * UFAC
       DELMXA(IDMA+1) = DELMXA(IDMA+1) * UFAC
       DELMXA(IDMA+2) = DELMXA(IDMA+2) * UFAC
       IF(MASWRK) WRITE(IW,229) INF,DELMXC(IDMC),DELMXC(IDMC+1),
     * DELMXC(IDMC+2),DELMXA(IDMA),DELMXA(IDMA+1),DELMXA(IDMA+2)                             
 229   FORMAT(1X,'MAX.DISP.:',I3,6F10.5)
       DELC(IDC  ) = ZERO
       DELC(IDC+1) = ZERO
       DELC(IDC+2) = ZERO
       DELA(IDA  ) = ZERO
       DELA(IDA+1) = ZERO
       DELA(IDA+2) = ZERO
       IDC=IDC+3
       IDA=IDA+3
       IDMC=IDMC+3
       IDMA=IDMA+3
 225   CONTINUE
C
      NACCT=0
      NRPAT=0
      NREJT=0
C
C
C        BIG LOOP OVER BLOCKS OF RANDOM COORDINATES
C        First loop over NBLOCK and within loop over translations
C        and rotations separately.  For mixed type runs, the type
C        moved is randomly determined.
      DO ii=1,NBLOCK
        IF(MASWRK) THEN
           WRITE(IW,*) 'MC NBLOCK ii at temp number', ii, ITM
        END IF
        CALL FLSHBF(IW)
C
C  GENERATE IMXRAN RANDOM NUMBERS
C
        IF(MASWRK)THEN
            CALL RNGEN(RND,IMXRAN,IRTP,INIT)
            CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
        ELSE
            CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
        END IF
        INIT=1
        IRN=1
C
C       loop over translation steps
        DO ITRAN=1,NTRAN
            IGLO=IGLO+1
            IF(RATIO.EQ.0.0D+00) THEN
               If(iand(MCTYP,4).NE.0) CALL MC_EFP_BLOCK(DELC,DELMXC,
     *            DELA,DELMXA,NFRMOV,XX(LPROVEC),XX(LCTVEC),RND,IRN,
     *            IFXFRG,.True.,NSTMIN,MCTYP,BETA,XX(LCOLD),IGLO,
     *            MXBF,XX(LCMIN),AIMOVE,AVEXYZ,BAVEXYZ,IMXRAN,IRTP)
               If(iand(MCTYP,3).NE.0) CALL MC_FMO_BLOCK(RND,IRN,DELA,
     *       DELC,DELMXC,DELMXA,.true.,NFMOMOV,IFXFMO,NSTMIN,MCTYP,
     *       BETA,XX(LPROVEC),XX(LCTVEC),XX(LCOLD),IGLO,MXBF,XX(LCMIN),
     *       NMCFRG,NPRBND,IPRBNDA,TEMPER,IRTP,NSMSTP,SMTEMP,IMXRAN,
     *       PSBND,INDEP,AVEXYZ,BAVEXYZ)
            ELSE
               If(RND(IRN).LE.RATIO) THEN
                   CALL MC_EFP_BLOCK(DELC,DELMXC,
     *            DELA,DELMXA,NFRMOV,XX(LPROVEC),XX(LCTVEC),RND,IRN,
     *            IFXFRG,.True.,NSTMIN,MCTYP,BETA,XX(LCOLD),IGLO,
     *            MXBF,XX(LCMIN),AIMOVE,AVEXYZ,BAVEXYZ,IMXRAN,IRTP)
               ELSE
                   CALL MC_FMO_BLOCK(RND,IRN,DELA,
     *       DELC,DELMXC,DELMXA,.true.,NFMOMOV,IFXFMO,NSTMIN,MCTYP,
     *       BETA,XX(LPROVEC),XX(LCTVEC),XX(LCOLD),IGLO,MXBF,XX(LCMIN),
     *       NMCFRG,NPRBND,IPRBNDA,TEMPER,IRTP,NSMSTP,SMTEMP,IMXRAN,
     *       PSBND,INDEP,AVEXYZ,BAVEXYZ)
               END IF
               IRN=IRN+1
            END IF
        END DO
C
C       loop over Rotation steps
        DO IROT=1,NROT
            IGLO=IGLO+1
            IF(RATIO.EQ.0.0D+00) THEN
               If(iand(MCTYP,4).NE.0) CALL MC_EFP_BLOCK(DELC,DELMXC,
     *            DELA,DELMXA,NFRMOV,XX(LPROVEC),XX(LCTVEC),RND,IRN,
     *            IFXFRG,.false.,NSTMIN,MCTYP,BETA,XX(LCOLD),IGLO,
     *            MXBF,XX(LCMIN),AIMOVE,AVEXYZ,BAVEXYZ,IMXRAN,IRTP)
               If(iand(MCTYP,3).NE.0) CALL MC_FMO_BLOCK(RND,IRN,DELA,
     *       DELC,DELMXC,DELMXA,.false.,NFMOMOV,IFXFMO,NSTMIN,MCTYP,
     *       BETA,XX(LPROVEC),XX(LCTVEC),XX(LCOLD),IGLO,MXBF,XX(LCMIN),
     *       NMCFRG,NPRBND,IPRBNDA,TEMPER,IRTP,NSMSTP,SMTEMP,IMXRAN,
     *       PSBND,INDEP,AVEXYZ,BAVEXYZ)
            ELSE
               If(RND(IRN).LE.RATIO) THEN
                   CALL MC_EFP_BLOCK(DELC,DELMXC,
     *            DELA,DELMXA,NFRMOV,XX(LPROVEC),XX(LCTVEC),RND,IRN,
     *            IFXFRG,.false.,NSTMIN,MCTYP,BETA,XX(LCOLD),IGLO,
     *            MXBF,XX(LCMIN),AIMOVE,AVEXYZ,BAVEXYZ,IMXRAN,IRTP)
               ELSE
                   CALL MC_FMO_BLOCK(RND,IRN,DELA,
     *       DELC,DELMXC,DELMXA,.false.,NFMOMOV,IFXFMO,NSTMIN,MCTYP,
     *       BETA,XX(LPROVEC),XX(LCTVEC),XX(LCOLD),IGLO,MXBF,XX(LCMIN),
     *       NMCFRG,NPRBND,IPRBNDA,TEMPER,IRTP,NSMSTP,SMTEMP,IMXRAN,
     *       PSBND,INDEP,AVEXYZ,BAVEXYZ)
               END IF
               IRN=IRN+1
            END IF
        END DO
      END DO
C  end of loop over NBLOCKS 
      ACCRATT=NACCT
      ACCRATT=ACCRATT/(NACCT+NREJT)
      IF(MASWRK) WRITE(IW,9011) TEMPER,NRPAT,NREJT+NACCT,NREJT,
     $                          NACCT,ACCRATT,EMIN,IGOMIN
      TEMPER = TEMPER * GAMR
      END DO
C  end of temperature loop
      ACCRAT=NACC
      ACCRAT=ACCRAT/(NACC+NREJ)
      IF(MASWRK) THEN
         WRITE(IW,9005)
         WRITE(IW,9010) IGLO,NRPA,NREJ+NACC,NREJ,NACC,ACCRAT,
     *                  EPREV,EMIN,IGOMIN
         CALL PRFC
         CALL PRMNC(XX(LCMIN))
      END IF

C  GEOMETRY OPTIMIZATION ON FINAL SA GEOMETRY
C
      IF(OPTN) THEN
         IF(MASWRK) WRITE(IW,9003)
         RUNTYP=OPT 
         CALL SIGX(.FALSE.)
         RUNTYP=GLOBOP
         IF(MASWRK) WRITE(IW,9002)
      END IF
C
C  GEOMETRY OPTIMIZATION ON MINIMUM-ENERGY SA GEOMETRY
C
      IF(OPTN) THEN
         IF(MASWRK) WRITE(IW,9004)
C
         CALL RSTCOR(XX(LCMIN),XX(LPROVEC),XX(LCTVEC),MXBF)
         IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,XX(LPROVEC),LENPV,267,0)
         END IF
         IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,XX(LCTVEC),LENCV,269,0)
         END IF
C
         RUNTYP=OPT
         CALL SIGX(.FALSE.)
         RUNTYP=GLOBOP
         IF(MASWRK) WRITE(IW,9001)
      END IF
C
      CALL RETFM(NEED)
C   
      IF (IAND(MCTYP,2).NE.0) THEN
        IF (LSCZVFLG) CALL RETZVEC
        CALL RETDD
      END IF
C
      IF(MASWRK) WRITE(IW,*) '..... END OF GLOBAL OPTIMIZATION .....'
      NPRTGO= 1
      CALL TIMIT(1)
      IF (ALLOCATED(IPRBNDA)) DEALLOCATE (IPRBNDA)
      IF (ALLOCATED(PSBND)) DEALLOCATE (PSBND)
      DEALLOCATE (IFXFRG)
      DEALLOCATE (IFXFMO)
      DEALLOCATE (RND)
      DEALLOCATE (DELC)
      DEALLOCATE (DELA)
      DEALLOCATE (DELMXC)
      DEALLOCATE (DELMXA)
      RETURN
C
 8010 FORMAT('CHEMICAL SYMBOL OF ALL ATOMS (QM AND/OR EFP)')
 8020 FORMAT('END OF CHEMICAL SYMBOL LIST')
 8030 FORMAT(A4)
C
 9001 FORMAT(/10X,'***MINIMIZATION FROM MINIMUM-ENERGY SA ',
     *       'GEOMETRY COMPLETE***'/)
 9002 FORMAT(/10X,'***MINIMIZATION FROM FINAL SA GEOMETRY',
     *        ' COMPLETE***'/)
 9003 FORMAT(/10X,'***MINIMIZING ENERGY FROM FINAL SA GEOMETRY',
     *        '***'/)
 9004 FORMAT(/10X,'***MINIMIZING ENERGY FROM MINIMUM-ENERGY ',
     *        'SA GEOMETRY***'/)
 9005 FORMAT(/10X,'***GLOBAL OPTIMIZATION COMPLETE*** '/)
 9010 FORMAT(1X,'TOTAL NUMBER OF GEOMETRIES =   ',I6/
     *       1X,'NUMBER OF GEOMETRIES REJECTED '/
     *       1X,' DUE TO PROXIMITY ALERT =      ',I6/
     *       1X,'NUMBER OF ENERGY EVALUATIONS = ',I6/
     *       1X,'NUMBER OF ENERGIES REJECTED =  ',I6/
     *       1X,'NUMBER OF ENERGIES ACCEPTED =  ',I6/
     *       1X,'ACCEPTANCE RATIO =            ',F11.3/
     *       1X,'FINAL ENERGY FOUND =            ',F16.10/
     *       1X,'MINIMUM ENERGY FOUND =          ',F16.10,1X,
     *       1X,'AT GEOMETRY NUMBER ',I6//)
 9011 FORMAT(/10X,31(1H-)/10X,31HSTATISTICS FROM MONTE CARLO RUN/10X,
     *       31(1H-),//
     *       1X,'AT TEMPERATURE =               ',F9.2/
     *       1X,'NUMBER OF GEOMETRIES REJECTED ',/
     *       1X,' DUE TO PROXIMITY ALERT =      ',I6/
     *       1X,'NUMBER OF ENERGY EVALUATIONS = ',I6/
     *       1X,'NUMBER OF ENERGIES REJECTED =  ',I6/
     *       1X,'NUMBER OF ENERGIES ACCEPTED =  ',I6/
     *       1X,'ACCEPTANCE RATIO =            ',F11.3/
     *       1X,'MINIMUM ENERGY FOUND SO FAR =   ',F16.10,1X,
     *       1X,'AT GEOMETRY NUMBER ',I6,//)
 9020 FORMAT(1X,'TEMPERATURE NUMBER ',I3,' IS ',F9.2)
 9126 FORMAT(1X,'GAMR=',F12.6,' DACRAT=',F12.6,' UPDFAC=',F12.6)
 9050 FORMAT(/1X,19(1H-),5X,46(1H-)/
     *        1X,'GLOBAL OPTIMIZATION',5X,
     *        'WRITTEN BY PAUL DAY AND PRADIPTA BANDYOPADHYAY'/
     *        1X,19(1H-),5X,46(1H-))
      END
C*MODULE GLOBOP  *DECK STCOR
C> @brief stores minimum energy coordinates 
C>
C> @details stores EFP information including coordinates
C>          and coordinates in C, which means FMO and ab initio
C>
C> @param CMIN array of current minimum energy coordinates
C> @param PROVEC array of EFP values
C> @param CTVEC array of EFP values
C> @param MXBF largest size of EFP fragment
C> @date January 2016, E.Guidez, Saved updated dynamic polarizabilities
C>        in CMIN for Monte-Carlo runs
C>
      SUBROUTINE STCOR(CMIN,PROVEC,CTVEC,MXBF)

      use DYNPOL_DIST

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXAO=8192, MXSHEF=1000, MXGEFP=4000,
     *           MXFRG=1050, MXFGPT=12000, MXDFG=5, MXIFRQ=12,
     *           MXDPPT=MXFRG*MXDFG*12, MXPT=2000)
C
      CHARACTER*8 FRGNME,REPNAM,POLNAM,DPOLNAM,DNAME,DPSNAM
      CHARACTER*8 LJNAME,ELJNAM
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /POL2  / DCORD(3,MXPT),CDIS(3,MXFGPT),
     *                CLPD(4*MXFGPT),ZLPD(4*MXFGPT),
     *                NLPD(4*MXFGPT),KFD(MXFGPT),KLD(MXFGPT),
     *                DNAME(MXPT),DPSNAM(MXFGPT)
      COMMON /REPPAR/ CREP(3,MXFGPT),CLPR(4*MXFGPT),ZLPR(4*MXFGPT),
     *                NLPR(4*MXFGPT),KFR(MXFGPT),KLR(MXFGPT),
     *                REPNAM(MXFGPT)
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
C
      DIMENSION CMIN(*)
C
      DIMENSION PROVEC(MXBF,*),CTVEC(MXBF,*)
C
C     STORE NEW MINIMUM ENERGY COORDINATES
C
         IMN=1
         IF(ICOORD.NE.4) THEN
         DO 100 I = 1,NAT
            CMIN(IMN  ) = C(1,I)
            CMIN(IMN+1) = C(2,I)
            CMIN(IMN+2) = C(3,I)
            IMN=IMN+3
  100    CONTINUE
         END IF
C
         IF(NFRG.GT.0) THEN
            IAT=0
            DO 120 IFRG=1,NFRG
               DO 110 III=1,NMPTS(IFRG)
                  IAT=IAT+1
                  CMIN(IMN  ) = EFC(1,IAT)
                  CMIN(IMN+1) = EFC(2,IAT)
                  CMIN(IMN+2) = EFC(3,IAT)
                  IMN=IMN+3
  110         CONTINUE
  120      CONTINUE
C
            IAT=0
            NPST=0
            NLJST=0
            NDPST=0
            NRST=0
            NATST=0
            NORST=0
            NCTMOST=0
            NDST=0
            DO 121 IFRG=1,NFRG
               DO 119 III=1,NMPTS(IFRG)
                  IAT=IAT+1
C
                  CMIN(IMN  ) =  EFDIP(1,IAT)
                  CMIN(IMN+1) =  EFDIP(2,IAT)
                  CMIN(IMN+2) =  EFDIP(3,IAT)
                  CMIN(IMN+3) =  EFQAD(1,IAT)
                  CMIN(IMN+4) =  EFQAD(2,IAT)
                  CMIN(IMN+5) =  EFQAD(3,IAT)
                  CMIN(IMN+6) =  EFQAD(4,IAT)
                  CMIN(IMN+7) =  EFQAD(5,IAT)
                  CMIN(IMN+8) =  EFQAD(6,IAT)
                  CMIN(IMN+9) =  EFOCT(1,IAT)
                  CMIN(IMN+10) =  EFOCT(2,IAT)
                  CMIN(IMN+11) =  EFOCT(3,IAT)
                  CMIN(IMN+12) =  EFOCT(4,IAT)
                  CMIN(IMN+13) =  EFOCT(5,IAT)
                  CMIN(IMN+14) =  EFOCT(6,IAT)
                  CMIN(IMN+15) =  EFOCT(7,IAT)
                  CMIN(IMN+16) =  EFOCT(8,IAT)
                  CMIN(IMN+17) =  EFOCT(9,IAT)
                  CMIN(IMN+18) =  EFOCT(10,IAT)
                  IMN=IMN+19
  119         CONTINUE
              DO 111 III=1,NPPTS(IFRG)
                  NPST=NPST+1
                  CMIN(IMN  ) =  EFP(1,NPST)
                  CMIN(IMN+1) =  EFP(2,NPST)
                  CMIN(IMN+2) =  EFP(3,NPST)
                  CMIN(IMN+3) =  EFPOL(1,NPST)
                  CMIN(IMN+4) =  EFPOL(2,NPST)
                  CMIN(IMN+5) =  EFPOL(3,NPST)
                  CMIN(IMN+6) =  EFPOL(4,NPST)
                  CMIN(IMN+7) =  EFPOL(5,NPST)
                  CMIN(IMN+8) =  EFPOL(6,NPST)
                  CMIN(IMN+9) =  EFPOL(7,NPST)
                  CMIN(IMN+10) =  EFPOL(8,NPST)
                  CMIN(IMN+11) =  EFPOL(9,NPST)
                  IMN=IMN+12
  111         CONTINUE
              DO 112 III=1,NRPTS(IFRG)
                  NRST=NRST+1
                  CMIN(IMN  ) =  CREP(1,NRST)
                  CMIN(IMN+1) =  CREP(2,NRST)
                  CMIN(IMN+2) =  CREP(3,NRST)
                  IMN=IMN+3
  112         CONTINUE
              DO 113 III=1,NATEF(ISET(IFRG))
                  NATST=NATST+1
                  CMIN(IMN  ) =  PRCORD(1,NATST)
                  CMIN(IMN+1) =  PRCORD(2,NATST)
                  CMIN(IMN+2) =  PRCORD(3,NATST)
                  IMN=IMN+3
  113         CONTINUE
              DO 114 III=1,NLJPTS(IFRG)
                  NLJST=NLJST+1
                  CMIN(IMN  ) =  CORDLJ(1,NLJST)
                  CMIN(IMN+1) =  CORDLJ(2,NLJST)
                  CMIN(IMN+2) =  CORDLJ(3,NLJST)
                  IMN=IMN+3
  114         CONTINUE
              DO 115 NSHL = 1,NSHELL(ISET(IFRG))
                 ITYP=KMAX(NSHL,ISET(IFRG))-KMIN(NSHL,ISET(IFRG))+1
                 LOC = KLOC(NSHL,ISET(IFRG))
                 IF(ITYP.EQ.3) THEN
                   DO  III=1,NORB(IFRG)
                    CMIN(IMN  ) =  PROVEC(LOC  ,NORST+III)
                    CMIN(IMN+1) =  PROVEC(LOC+1,NORST+III)
                    CMIN(IMN+2) =  PROVEC(LOC+2,NORST+III)
                    IMN=IMN+3
                   END DO
                 END IF
                 IF(ITYP.EQ.4) THEN
                   DO  III=1,NORB(IFRG)
                    CMIN(IMN  ) =  PROVEC(LOC+1,NORST+III)
                    CMIN(IMN+1) =  PROVEC(LOC+2,NORST+III)
                    CMIN(IMN+2) =  PROVEC(LOC+3,NORST+III)
                    IMN=IMN+3
                   END DO
                 END IF
                 IF(ITYP.EQ.6) THEN
                   DO  III=1,NORB(IFRG)
                    CMIN(IMN  ) =  PROVEC(LOC  ,NORST+III)
                    CMIN(IMN+1) =  PROVEC(LOC+1,NORST+III)
                    CMIN(IMN+2) =  PROVEC(LOC+2,NORST+III)
                    CMIN(IMN+3) =  PROVEC(LOC+3,NORST+III)
                    CMIN(IMN+4) =  PROVEC(LOC+4,NORST+III)
                    CMIN(IMN+5) =  PROVEC(LOC+5,NORST+III)
                    IMN=IMN+6
                   END DO
                 END IF
                 IF(ITYP.EQ.10) THEN
                   DO  III=1,NORB(IFRG)
                    CMIN(IMN  ) =  PROVEC(LOC  ,NORST+III)
                    CMIN(IMN+1) =  PROVEC(LOC+1,NORST+III)
                    CMIN(IMN+2) =  PROVEC(LOC+2,NORST+III)
                    CMIN(IMN+3) =  PROVEC(LOC+3,NORST+III)
                    CMIN(IMN+4) =  PROVEC(LOC+4,NORST+III)
                    CMIN(IMN+5) =  PROVEC(LOC+5,NORST+III)
                    CMIN(IMN+6) =  PROVEC(LOC+6,NORST+III)
                    CMIN(IMN+7) =  PROVEC(LOC+7,NORST+III)
                    CMIN(IMN+8) =  PROVEC(LOC+8,NORST+III)
                    CMIN(IMN+9) =  PROVEC(LOC+9,NORST+III)
                    IMN=IMN+10
                   END DO
                 END IF
                 IF(ITYP.EQ.15) THEN
                   DO  III=1,NORB(IFRG)
                    CMIN(IMN  ) =  PROVEC(LOC  ,NORST+III)
                    CMIN(IMN+1) =  PROVEC(LOC+1,NORST+III)
                    CMIN(IMN+2) =  PROVEC(LOC+2,NORST+III)
                    CMIN(IMN+3) =  PROVEC(LOC+3,NORST+III)
                    CMIN(IMN+4) =  PROVEC(LOC+4,NORST+III)
                    CMIN(IMN+5) =  PROVEC(LOC+5,NORST+III)
                    CMIN(IMN+6) =  PROVEC(LOC+6,NORST+III)
                    CMIN(IMN+7) =  PROVEC(LOC+7,NORST+III)
                    CMIN(IMN+8) =  PROVEC(LOC+8,NORST+III)
                    CMIN(IMN+9) =  PROVEC(LOC+9,NORST+III)
                    CMIN(IMN+10) =  PROVEC(LOC+10,NORST+III)
                    CMIN(IMN+11) =  PROVEC(LOC+11,NORST+III)
                    CMIN(IMN+12) =  PROVEC(LOC+12,NORST+III)
                    CMIN(IMN+13) =  PROVEC(LOC+13,NORST+III)
                    CMIN(IMN+14) =  PROVEC(LOC+14,NORST+III)
                    IMN=IMN+15
                   END DO
                 END IF
                 IF(ITYP.EQ.3) THEN
                   DO  III=1,NCTMO(ISET(IFRG))
                    CMIN(IMN  ) =  CTVEC(LOC  ,NCTMOST+III)
                    CMIN(IMN+1) =  CTVEC(LOC+1,NCTMOST+III)
                    CMIN(IMN+2) =  CTVEC(LOC+2,NCTMOST+III)
                    IMN=IMN+3
                   END DO
                 END IF
                 IF(ITYP.EQ.4) THEN
                   DO  III=1,NCTMO(ISET(IFRG))
                    CMIN(IMN  ) =  CTVEC(LOC+1,NCTMOST+III)
                    CMIN(IMN+1) =  CTVEC(LOC+2,NCTMOST+III)
                    CMIN(IMN+2) =  CTVEC(LOC+3,NCTMOST+III)
                    IMN=IMN+3
                   END DO
                 END IF
                 IF(ITYP.EQ.6) THEN
                   DO  III=1,NCTMO(ISET(IFRG))
                    CMIN(IMN  ) =  CTVEC(LOC  ,NCTMOST+III)
                    CMIN(IMN+1) =  CTVEC(LOC+1,NCTMOST+III)
                    CMIN(IMN+2) =  CTVEC(LOC+2,NCTMOST+III)
                    CMIN(IMN+3) =  CTVEC(LOC+3,NCTMOST+III)
                    CMIN(IMN+4) =  CTVEC(LOC+4,NCTMOST+III)
                    CMIN(IMN+5) =  CTVEC(LOC+5,NCTMOST+III)
                    IMN=IMN+6
                   END DO
                 END IF
                 IF(ITYP.EQ.10) THEN
                   DO  III=1,NCTMO(ISET(IFRG))
                    CMIN(IMN  ) =  CTVEC(LOC  ,NCTMOST+III)
                    CMIN(IMN+1) =  CTVEC(LOC+1,NCTMOST+III)
                    CMIN(IMN+2) =  CTVEC(LOC+2,NCTMOST+III)
                    CMIN(IMN+3) =  CTVEC(LOC+3,NCTMOST+III)
                    CMIN(IMN+4) =  CTVEC(LOC+4,NCTMOST+III)
                    CMIN(IMN+5) =  CTVEC(LOC+5,NCTMOST+III)
                    CMIN(IMN+6) =  CTVEC(LOC+6,NCTMOST+III)
                    CMIN(IMN+7) =  CTVEC(LOC+7,NCTMOST+III)
                    CMIN(IMN+8) =  CTVEC(LOC+8,NCTMOST+III)
                    CMIN(IMN+9) =  CTVEC(LOC+9,NCTMOST+III)
                    IMN=IMN+10
                   END DO
                 END IF
                 IF(ITYP.EQ.15) THEN
                   DO  III=1,NCTMO(ISET(IFRG))
                    CMIN(IMN  ) =  CTVEC(LOC  ,NCTMOST+III)
                    CMIN(IMN+1) =  CTVEC(LOC+1,NCTMOST+III)
                    CMIN(IMN+2) =  CTVEC(LOC+2,NCTMOST+III)
                    CMIN(IMN+3) =  CTVEC(LOC+3,NCTMOST+III)
                    CMIN(IMN+4) =  CTVEC(LOC+4,NCTMOST+III)
                    CMIN(IMN+5) =  CTVEC(LOC+5,NCTMOST+III)
                    CMIN(IMN+6) =  CTVEC(LOC+6,NCTMOST+III)
                    CMIN(IMN+7) =  CTVEC(LOC+7,NCTMOST+III)
                    CMIN(IMN+8) =  CTVEC(LOC+8,NCTMOST+III)
                    CMIN(IMN+9) =  CTVEC(LOC+9,NCTMOST+III)
                    CMIN(IMN+10) = CTVEC(LOC+10,NCTMOST+III)
                    CMIN(IMN+11) = CTVEC(LOC+11,NCTMOST+III)
                    CMIN(IMN+12) = CTVEC(LOC+12,NCTMOST+III)
                    CMIN(IMN+13) = CTVEC(LOC+13,NCTMOST+III)
                    CMIN(IMN+14) = CTVEC(LOC+14,NCTMOST+III)
                    IMN=IMN+15
                   END DO
                 END IF
  115         CONTINUE
                 DO  III=1,NORB(IFRG)
                   CMIN(IMN  ) =  CENTCD(1,NORST+III)
                   CMIN(IMN+1) =  CENTCD(2,NORST+III)
                   CMIN(IMN+2) =  CENTCD(3,NORST+III)
                   IMN=IMN+3
                 END DO
                 NORST=NORST+NORB(IFRG)
                 NCTMOST=NCTMOST+NCTMO(ISET(IFRG))
C
C SAVE DYNAMIC POLARIZABILITY
C
              DO 116 III=1,NDPPTS(IFRG)
                  NDPST=NDPST+1
                  CMIN(IMN  ) =  EFDP(1,NDPST)
                  CMIN(IMN+1) =  EFDP(2,NDPST)
                  CMIN(IMN+2) =  EFDP(3,NDPST)
                  CMIN(IMN+3) =  EFDPOL(1,NDPST)
                  CMIN(IMN+4) =  EFDPOL(2,NDPST)
                  CMIN(IMN+5) =  EFDPOL(3,NDPST)
                  CMIN(IMN+6) =  EFDPOL(4,NDPST)
                  CMIN(IMN+7) =  EFDPOL(5,NDPST)
                  CMIN(IMN+8) =  EFDPOL(6,NDPST)
                  CMIN(IMN+9) =  EFDPOL(7,NDPST)
                  CMIN(IMN+10) =  EFDPOL(8,NDPST)
                  CMIN(IMN+11) =  EFDPOL(9,NDPST)
                  IMN=IMN+12
                  CMIN(IMN) =  DYNDD_LMO_ROT(1,III,IFRG)
                  CMIN(IMN+1) =  DYNDD_LMO_ROT(2,III,IFRG)
                  CMIN(IMN+2) =  DYNDD_LMO_ROT(3,III,IFRG)
                  CMIN(IMN+3) =  DYNDD_LMO_ROT(4,III,IFRG)
                  CMIN(IMN+4) =  DYNDD_LMO_ROT(5,III,IFRG)
                  CMIN(IMN+5) =  DYNDD_LMO_ROT(6,III,IFRG)
                  CMIN(IMN+6) =  DYNDD_LMO_ROT(7,III,IFRG)
                  CMIN(IMN+7) =  DYNDD_LMO_ROT(8,III,IFRG)
                  CMIN(IMN+8) =  DYNDD_LMO_ROT(9,III,IFRG)
                  IMN=IMN+9
                  CMIN(IMN)= DYNDQ_LMO_NEW(1,NDPST)
                  CMIN(IMN+1)= DYNDQ_LMO_NEW(2,NDPST)
                  CMIN(IMN+2)= DYNDQ_LMO_NEW(3,NDPST)
                  CMIN(IMN+3)= DYNDQ_LMO_NEW(4,NDPST)
                  CMIN(IMN+4)= DYNDQ_LMO_NEW(5,NDPST)
                  CMIN(IMN+5)= DYNDQ_LMO_NEW(6,NDPST)
                  CMIN(IMN+6)= DYNDQ_LMO_NEW(7,NDPST)
                  CMIN(IMN+7)= DYNDQ_LMO_NEW(8,NDPST)
                  CMIN(IMN+8)= DYNDQ_LMO_NEW(9,NDPST)
                  CMIN(IMN+9)= DYNDQ_LMO_NEW(10,NDPST)
                  CMIN(IMN+10)= DYNDQ_LMO_NEW(11,NDPST)
                  CMIN(IMN+11)= DYNDQ_LMO_NEW(12,NDPST)
                  CMIN(IMN+12)= DYNDQ_LMO_NEW(13,NDPST)
                  CMIN(IMN+13)= DYNDQ_LMO_NEW(14,NDPST)
                  CMIN(IMN+14)= DYNDQ_LMO_NEW(15,NDPST)
                  CMIN(IMN+15)= DYNDQ_LMO_NEW(16,NDPST)
                  CMIN(IMN+16)= DYNDQ_LMO_NEW(17,NDPST)
                  CMIN(IMN+17)= DYNDQ_LMO_NEW(18,NDPST)
                  CMIN(IMN+18)= DYNDQ_LMO_NEW(19,NDPST)
                  CMIN(IMN+19)= DYNDQ_LMO_NEW(20,NDPST)
                  CMIN(IMN+20)= DYNDQ_LMO_NEW(21,NDPST)
                  CMIN(IMN+21)= DYNDQ_LMO_NEW(22,NDPST)
                  CMIN(IMN+22)= DYNDQ_LMO_NEW(23,NDPST)
                  CMIN(IMN+23)= DYNDQ_LMO_NEW(24,NDPST)
                  CMIN(IMN+24)= DYNDQ_LMO_NEW(25,NDPST)
                  CMIN(IMN+25)= DYNDQ_LMO_NEW(26,NDPST)
                  CMIN(IMN+26)= DYNDQ_LMO_NEW(27,NDPST)
                  IMN=IMN+27
                  CMIN(IMN)= DYNDQ_LMO_ROT(1,III,IFRG)
                  CMIN(IMN+1)= DYNDQ_LMO_ROT(2,III,IFRG)
                  CMIN(IMN+2)= DYNDQ_LMO_ROT(3,III,IFRG)
                  CMIN(IMN+3)= DYNDQ_LMO_ROT(4,III,IFRG)
                  CMIN(IMN+4)= DYNDQ_LMO_ROT(5,III,IFRG)
                  CMIN(IMN+5)= DYNDQ_LMO_ROT(6,III,IFRG)
                  CMIN(IMN+6)= DYNDQ_LMO_ROT(7,III,IFRG)
                  CMIN(IMN+7)= DYNDQ_LMO_ROT(8,III,IFRG)
                  CMIN(IMN+8)= DYNDQ_LMO_ROT(9,III,IFRG)
                  CMIN(IMN+9)= DYNDQ_LMO_ROT(10,III,IFRG)
                  CMIN(IMN+10)= DYNDQ_LMO_ROT(11,III,IFRG)
                  CMIN(IMN+11)= DYNDQ_LMO_ROT(12,III,IFRG)
                  CMIN(IMN+12)= DYNDQ_LMO_ROT(13,III,IFRG)
                  CMIN(IMN+13)= DYNDQ_LMO_ROT(14,III,IFRG)
                  CMIN(IMN+14)= DYNDQ_LMO_ROT(15,III,IFRG)
                  CMIN(IMN+15)= DYNDQ_LMO_ROT(16,III,IFRG)
                  CMIN(IMN+16)= DYNDQ_LMO_ROT(17,III,IFRG)
                  CMIN(IMN+17)= DYNDQ_LMO_ROT(18,III,IFRG)
                  CMIN(IMN+18)= DYNDQ_LMO_ROT(19,III,IFRG)
                  CMIN(IMN+19)= DYNDQ_LMO_ROT(20,III,IFRG)
                  CMIN(IMN+20)= DYNDQ_LMO_ROT(21,III,IFRG)
                  CMIN(IMN+21)= DYNDQ_LMO_ROT(22,III,IFRG)
                  CMIN(IMN+22)= DYNDQ_LMO_ROT(23,III,IFRG)
                  CMIN(IMN+23)= DYNDQ_LMO_ROT(24,III,IFRG)
                  CMIN(IMN+24)= DYNDQ_LMO_ROT(25,III,IFRG)
                  CMIN(IMN+25)= DYNDQ_LMO_ROT(26,III,IFRG)
                  CMIN(IMN+26)= DYNDQ_LMO_ROT(27,III,IFRG)
                  IMN=IMN+27
  116         CONTINUE
C
C SAVE DISPERSION COEFFICIENTS FOR EFP1-MP2
C
              DO 117 III=1,NDPTS(IFRG)
                  NDST=NDST+1
                  CMIN(IMN  ) =  CDIS(1,NDST)
                  CMIN(IMN+1) =  CDIS(2,NDST)
                  CMIN(IMN+2) =  CDIS(3,NDST)
                  IMN=IMN+3
  117         CONTINUE
  121      CONTINUE
         END IF
      RETURN
      END
C*MODULE GLOBOP  *DECK RSTCOR
C> @brief restores coordinates of minimum energy
C>
C> @details restores EFP information including coordinates
C>          and coordinates in C, which means FMO and ab initio
C>
C> @param CMIN array of current minimum energy coordinates
C> @param PROVEC array of EFP values
C> @param CTVEC array of EFP values
C> @param MXBF largest size of EFP fragment
C> @date January 2016, E.Guidez,recover dynamic polarizabilities for
C>       dispersion
      SUBROUTINE RSTCOR(CMIN,PROVEC,CTVEC,MXBF)
C
      use DYNPOL_DIST
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXAO=8192, MXSHEF=1000, MXGEFP=4000,
     *           MXFRG=1050, MXFGPT=12000, MXDFG=5, MXIFRQ=12,
     *           MXDPPT=MXFRG*MXDFG*12, MXPT=2000)
C
      CHARACTER*8 FRGNME,REPNAM,POLNAM,DPOLNAM,DNAME,DPSNAM
      CHARACTER*8 LJNAME,ELJNAM
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),
     *                JNLPR(4*MXPT),JKFR(MXPT),JKLR(MXPT),
     *                NDPTS(MXFRG),NDTTPT
      COMMON /POL2  / DCORD(3,MXPT),CDIS(3,MXFGPT),
     *                CLPD(4*MXFGPT),ZLPD(4*MXFGPT),
     *                NLPD(4*MXFGPT),KFD(MXFGPT),KLD(MXFGPT),
     *                DNAME(MXPT),DPSNAM(MXFGPT)
      COMMON /REPPAR/ CREP(3,MXFGPT),CLPR(4*MXFGPT),ZLPR(4*MXFGPT),
     *                NLPR(4*MXFGPT),KFR(MXFGPT),KLR(MXFGPT),
     *                REPNAM(MXFGPT)
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
C
      DIMENSION CMIN(*)
C
      DIMENSION PROVEC(MXBF,*),CTVEC(MXBF,*)
C
C     RESTORE MINIMUM ENERGY COORDINATES OF AB INITIO ATOMS
C
      IMN=1
      IF(ICOORD.NE.4) THEN
         DO 100 I = 1,NAT
            C(1,I) = CMIN(IMN)
            C(2,I) = CMIN(IMN+1)
            C(3,I) = CMIN(IMN+2)
            IMN=IMN+3
  100    CONTINUE
      END IF
C
      IF(NFRG.GT.0) THEN
C
C     RESTORE MINIMUM ENERGY COORDINATES OF THE EFP
C
         IAT=0
         DO 120 IFRG=1,NFRG
            DO 110 III=1,NMPTS(IFRG)
               IAT=IAT+1
               EFC(1,IAT) = CMIN(IMN)
               EFC(2,IAT) = CMIN(IMN+1)
               EFC(3,IAT) = CMIN(IMN+2)
               IMN=IMN+3
  110       CONTINUE
  120    CONTINUE
C
         IAT=0
         NPST=0
         NLJST=0
         NDPST=0
         NRST=0
         NATST=0
         NORST=0
         NCTMOST=0
         NDST=0
C
         DO 121 IFRG=1,NFRG
C
C   RECOVER MULTIPOLE POTENTIAL
C
            DO 119 III=1,NMPTS(IFRG)
               IAT=IAT+1
               EFDIP(1,IAT) =  CMIN(IMN)
               EFDIP(2,IAT) =  CMIN(IMN+1)
               EFDIP(3,IAT) =  CMIN(IMN+2)
               EFQAD(1,IAT) =  CMIN(IMN+3)
               EFQAD(2,IAT) =  CMIN(IMN+4)
               EFQAD(3,IAT) =  CMIN(IMN+5)
               EFQAD(4,IAT) =  CMIN(IMN+6)
               EFQAD(5,IAT) =  CMIN(IMN+7)
               EFQAD(6,IAT) =  CMIN(IMN+8)
               EFOCT(1,IAT) =  CMIN(IMN+9)
               EFOCT(2,IAT) =  CMIN(IMN+10)
               EFOCT(3,IAT) =  CMIN(IMN+11)
               EFOCT(4,IAT) =  CMIN(IMN+12)
               EFOCT(5,IAT) =  CMIN(IMN+13)
               EFOCT(6,IAT) =  CMIN(IMN+14)
               EFOCT(7,IAT) =  CMIN(IMN+15)
               EFOCT(8,IAT) =  CMIN(IMN+16)
               EFOCT(9,IAT) =  CMIN(IMN+17)
               EFOCT(10,IAT) = CMIN(IMN+18)
               IMN=IMN+19
  119       CONTINUE
C
C     RECOVER DIPOLE POLARIZABILITY TENSORS
C
            DO 111 III=1,NPPTS(IFRG)
               NPST=NPST+1
               EFP(1,NPST) = CMIN(IMN)
               EFP(2,NPST) = CMIN(IMN+1)
               EFP(3,NPST) = CMIN(IMN+2)
               EFPOL(1,NPST) = CMIN(IMN+3)
               EFPOL(2,NPST) = CMIN(IMN+4)
               EFPOL(3,NPST) = CMIN(IMN+5)
               EFPOL(4,NPST) = CMIN(IMN+6)
               EFPOL(5,NPST) = CMIN(IMN+7)
               EFPOL(6,NPST) = CMIN(IMN+8)
               EFPOL(7,NPST) = CMIN(IMN+9)
               EFPOL(8,NPST) = CMIN(IMN+10)
               EFPOL(9,NPST) = CMIN(IMN+11)
               IMN=IMN+12
  111       CONTINUE
C
C       RECOVER FITTED REPULSION POTENTIAL
C
            DO 112 III=1,NRPTS(IFRG)
               NRST=NRST+1
               CREP(1,NRST) = CMIN(IMN)
               CREP(2,NRST) = CMIN(IMN+1)
               CREP(3,NRST) = CMIN(IMN+2)
               IMN=IMN+3
  112       CONTINUE
C
C       RECOVER PAULI FORMULA FOR EXCHANGE POTENTIAL
C
            DO 113 III=1,NATEF(ISET(IFRG))
               NATST=NATST+1
               PRCORD(1,NATST) = CMIN(IMN)
               PRCORD(2,NATST) = CMIN(IMN+1)
               PRCORD(3,NATST) = CMIN(IMN+2)
               IMN=IMN+3
  113       CONTINUE
C
            DO 114 III=1,NLJPTS(IFRG)
                NLJST=NLJST+1
                CORDLJ(1,NLJST) = CMIN(IMN  )
                CORDLJ(2,NLJST) = CMIN(IMN+1)
                CORDLJ(3,NLJST) = CMIN(IMN+2)
                IMN=IMN+3
  114       CONTINUE
C
            DO 115 NSHL = 1,NSHELL(ISET(IFRG))
               ITYP=KMAX(NSHL,ISET(IFRG))-KMIN(NSHL,ISET(IFRG))+1
               LOC = KLOC(NSHL,ISET(IFRG))
               IF(ITYP.EQ.3) THEN
                  DO III=1,NORB(IFRG)
                     PROVEC(LOC,NORST+III) = CMIN(IMN)
                     PROVEC(LOC+1,NORST+III) = CMIN(IMN+1)
                     PROVEC(LOC+2,NORST+III) = CMIN(IMN+2)
                     IMN=IMN+3
                  END DO
               END IF
               IF(ITYP.EQ.4) THEN
                  DO III=1,NORB(IFRG)
                     PROVEC(LOC+1,NORST+III) = CMIN(IMN)
                     PROVEC(LOC+2,NORST+III) = CMIN(IMN+1)
                     PROVEC(LOC+3,NORST+III) = CMIN(IMN+2)
                     IMN=IMN+3
                  END DO
               END IF
               IF(ITYP.EQ.6) THEN
                  DO III=1,NORB(IFRG)
                     PROVEC(LOC,NORST+III) = CMIN(IMN)
                     PROVEC(LOC+1,NORST+III) = CMIN(IMN+1)
                     PROVEC(LOC+2,NORST+III) = CMIN(IMN+2)
                     PROVEC(LOC+3,NORST+III) = CMIN(IMN+3)
                     PROVEC(LOC+4,NORST+III) = CMIN(IMN+4)
                     PROVEC(LOC+5,NORST+III) = CMIN(IMN+5)
                     IMN=IMN+6
                  END DO
               END IF
               IF(ITYP.EQ.10) THEN
                  DO  III=1,NORB(IFRG)
                     PROVEC(LOC,NORST+III) = CMIN(IMN)
                     PROVEC(LOC+1,NORST+III) = CMIN(IMN+1)
                     PROVEC(LOC+2,NORST+III) = CMIN(IMN+2)
                     PROVEC(LOC+3,NORST+III) = CMIN(IMN+3)
                     PROVEC(LOC+4,NORST+III) = CMIN(IMN+4)
                     PROVEC(LOC+5,NORST+III) = CMIN(IMN+5)
                     PROVEC(LOC+6,NORST+III) = CMIN(IMN+6)
                     PROVEC(LOC+7,NORST+III) = CMIN(IMN+7)
                     PROVEC(LOC+8,NORST+III) = CMIN(IMN+8)
                     PROVEC(LOC+9,NORST+III) = CMIN(IMN+9)
                     IMN=IMN+10
                  END DO
               END IF
               IF(ITYP.EQ.15) THEN
                  DO  III=1,NORB(IFRG)
                     PROVEC(LOC,NORST+III) = CMIN(IMN)
                     PROVEC(LOC+1,NORST+III) = CMIN(IMN+1)
                     PROVEC(LOC+2,NORST+III) = CMIN(IMN+2)
                     PROVEC(LOC+3,NORST+III) = CMIN(IMN+3)
                     PROVEC(LOC+4,NORST+III) = CMIN(IMN+4)
                     PROVEC(LOC+5,NORST+III) = CMIN(IMN+5)
                     PROVEC(LOC+6,NORST+III) = CMIN(IMN+6)
                     PROVEC(LOC+7,NORST+III) = CMIN(IMN+7)
                     PROVEC(LOC+8,NORST+III) = CMIN(IMN+8)
                     PROVEC(LOC+9,NORST+III) = CMIN(IMN+9)
                     PROVEC(LOC+10,NORST+III) = CMIN(IMN+10)
                     PROVEC(LOC+11,NORST+III) = CMIN(IMN+11)
                     PROVEC(LOC+12,NORST+III) = CMIN(IMN+12)
                     PROVEC(LOC+13,NORST+III) = CMIN(IMN+13)
                     PROVEC(LOC+14,NORST+III) = CMIN(IMN+14)
                     IMN=IMN+15
                  END DO
               END IF
               IF(ITYP.EQ.3) THEN
                  DO  III=1,NCTMO(ISET(IFRG))
                     CTVEC(LOC,NCTMOST+III) = CMIN(IMN)
                     CTVEC(LOC+1,NCTMOST+III) = CMIN(IMN+1)
                     CTVEC(LOC+2,NCTMOST+III) = CMIN(IMN+2)
                     IMN=IMN+3
                  END DO
               END IF
               IF(ITYP.EQ.4) THEN
                  DO  III=1,NCTMO(ISET(IFRG))
                     CTVEC(LOC+1,NCTMOST+III) = CMIN(IMN)
                     CTVEC(LOC+2,NCTMOST+III) = CMIN(IMN+1)
                     CTVEC(LOC+3,NCTMOST+III) = CMIN(IMN+2)
                     IMN=IMN+3
                  END DO
               END IF
               IF(ITYP.EQ.6) THEN
                  DO  III=1,NCTMO(ISET(IFRG))
                     CTVEC(LOC,NCTMOST+III) = CMIN(IMN)
                     CTVEC(LOC+1,NCTMOST+III) = CMIN(IMN+1)
                     CTVEC(LOC+2,NCTMOST+III) = CMIN(IMN+2)
                     CTVEC(LOC+3,NCTMOST+III) = CMIN(IMN+3)
                     CTVEC(LOC+4,NCTMOST+III) = CMIN(IMN+4)
                     CTVEC(LOC+5,NCTMOST+III) = CMIN(IMN+5)
                     IMN=IMN+6
                  END DO
               END IF
               IF(ITYP.EQ.10) THEN
                  DO  III=1,NCTMO(ISET(IFRG))
                     CTVEC(LOC,NCTMOST+III) = CMIN(IMN)
                     CTVEC(LOC+1,NCTMOST+III) = CMIN(IMN+1)
                     CTVEC(LOC+2,NCTMOST+III) = CMIN(IMN+2)
                     CTVEC(LOC+3,NCTMOST+III) = CMIN(IMN+3)
                     CTVEC(LOC+4,NCTMOST+III) = CMIN(IMN+4)
                     CTVEC(LOC+5,NCTMOST+III) = CMIN(IMN+5)
                     CTVEC(LOC+6,NCTMOST+III) = CMIN(IMN+6)
                     CTVEC(LOC+7,NCTMOST+III) = CMIN(IMN+7)
                     CTVEC(LOC+8,NCTMOST+III) = CMIN(IMN+8)
                     CTVEC(LOC+9,NCTMOST+III) = CMIN(IMN+9)
                     IMN=IMN+10
                  END DO
               END IF
               IF(ITYP.EQ.15) THEN
                  DO  III=1,NCTMO(ISET(IFRG))
                     CTVEC(LOC,NCTMOST+III) = CMIN(IMN)
                     CTVEC(LOC+1,NCTMOST+III) = CMIN(IMN+1)
                     CTVEC(LOC+2,NCTMOST+III) = CMIN(IMN+2)
                     CTVEC(LOC+3,NCTMOST+III) = CMIN(IMN+3)
                     CTVEC(LOC+4,NCTMOST+III) = CMIN(IMN+4)
                     CTVEC(LOC+5,NCTMOST+III) = CMIN(IMN+5)
                     CTVEC(LOC+6,NCTMOST+III) = CMIN(IMN+6)
                     CTVEC(LOC+7,NCTMOST+III) = CMIN(IMN+7)
                     CTVEC(LOC+8,NCTMOST+III) = CMIN(IMN+8)
                     CTVEC(LOC+9,NCTMOST+III) = CMIN(IMN+9)
                     CTVEC(LOC+10,NCTMOST+III) = CMIN(IMN+10)
                     CTVEC(LOC+11,NCTMOST+III) = CMIN(IMN+11)
                     CTVEC(LOC+12,NCTMOST+III) = CMIN(IMN+12)
                     CTVEC(LOC+13,NCTMOST+III) = CMIN(IMN+13)
                     CTVEC(LOC+14,NCTMOST+III) = CMIN(IMN+14)
                     IMN=IMN+15
                  END DO
               END IF
  115       CONTINUE
            DO III=1,NORB(IFRG)
               CENTCD(1,NORST+III) = CMIN(IMN)
               CENTCD(2,NORST+III) = CMIN(IMN+1)
               CENTCD(3,NORST+III) = CMIN(IMN+2)
               IMN=IMN+3
            END DO
            NORST=NORST+NORB(IFRG)
            NCTMOST=NCTMOST+NCTMO(ISET(IFRG))
C
C RECOVER DYNAMIC POLARIZABILITY
C
            DO 116 III=1,NDPPTS(IFRG)
               NDPST=NDPST+1
               EFDP(1,NDPST) = CMIN(IMN)
               EFDP(2,NDPST) = CMIN(IMN+1)
               EFDP(3,NDPST) = CMIN(IMN+2)
               EFDPOL(1,NDPST) = CMIN(IMN+3)
               EFDPOL(2,NDPST) = CMIN(IMN+4)
               EFDPOL(3,NDPST) = CMIN(IMN+5)
               EFDPOL(4,NDPST) = CMIN(IMN+6)
               EFDPOL(5,NDPST) = CMIN(IMN+7)
               EFDPOL(6,NDPST) = CMIN(IMN+8)
               EFDPOL(7,NDPST) = CMIN(IMN+9)
               EFDPOL(8,NDPST) = CMIN(IMN+10)
               EFDPOL(9,NDPST) = CMIN(IMN+11)
               IMN=IMN+12
               DYNDD_LMO_ROT(1,III,IFRG)=CMIN(IMN)
               DYNDD_LMO_ROT(2,III,IFRG)=CMIN(IMN+1)
               DYNDD_LMO_ROT(3,III,IFRG)=CMIN(IMN+2)
               DYNDD_LMO_ROT(4,III,IFRG)=CMIN(IMN+3)
               DYNDD_LMO_ROT(5,III,IFRG)=CMIN(IMN+4)
               DYNDD_LMO_ROT(6,III,IFRG)=CMIN(IMN+5)
               DYNDD_LMO_ROT(7,III,IFRG)=CMIN(IMN+6)
               DYNDD_LMO_ROT(8,III,IFRG)=CMIN(IMN+7)
               DYNDD_LMO_ROT(9,III,IFRG)=CMIN(IMN+8)
               IMN=IMN+9
                  DYNDQ_LMO_NEW(1,NDPST)=CMIN(IMN)
                  DYNDQ_LMO_NEW(2,NDPST)=CMIN(IMN+1)
                  DYNDQ_LMO_NEW(3,NDPST)=CMIN(IMN+2)
                  DYNDQ_LMO_NEW(4,NDPST)=CMIN(IMN+3)
                  DYNDQ_LMO_NEW(5,NDPST)=CMIN(IMN+4)
                  DYNDQ_LMO_NEW(6,NDPST)=CMIN(IMN+5)
                  DYNDQ_LMO_NEW(7,NDPST)=CMIN(IMN+6)
                  DYNDQ_LMO_NEW(8,NDPST)=CMIN(IMN+7)
                  DYNDQ_LMO_NEW(9,NDPST)=CMIN(IMN+8)
                  DYNDQ_LMO_NEW(10,NDPST)=CMIN(IMN+9)
                  DYNDQ_LMO_NEW(11,NDPST)=CMIN(IMN+10)
                  DYNDQ_LMO_NEW(12,NDPST)=CMIN(IMN+11)
                  DYNDQ_LMO_NEW(13,NDPST)=CMIN(IMN+12)
                  DYNDQ_LMO_NEW(14,NDPST)=CMIN(IMN+13)
                  DYNDQ_LMO_NEW(15,NDPST)=CMIN(IMN+14)
                  DYNDQ_LMO_NEW(16,NDPST)=CMIN(IMN+15)
                  DYNDQ_LMO_NEW(17,NDPST)=CMIN(IMN+16)
                  DYNDQ_LMO_NEW(18,NDPST)=CMIN(IMN+17)
                  DYNDQ_LMO_NEW(19,NDPST)=CMIN(IMN+18)
                  DYNDQ_LMO_NEW(20,NDPST)=CMIN(IMN+19)
                  DYNDQ_LMO_NEW(21,NDPST)=CMIN(IMN+20)
                  DYNDQ_LMO_NEW(22,NDPST)=CMIN(IMN+21)
                  DYNDQ_LMO_NEW(23,NDPST)=CMIN(IMN+22)
                  DYNDQ_LMO_NEW(24,NDPST)=CMIN(IMN+23)
                  DYNDQ_LMO_NEW(25,NDPST)=CMIN(IMN+24)
                  DYNDQ_LMO_NEW(26,NDPST)=CMIN(IMN+25)
                  DYNDQ_LMO_NEW(27,NDPST)=CMIN(IMN+26)
                 IMN=IMN+27
                  DYNDQ_LMO_ROT(1,III,IFRG)=CMIN(IMN)
                  DYNDQ_LMO_ROT(2,III,IFRG)=CMIN(IMN+1)
                  DYNDQ_LMO_ROT(3,III,IFRG)=CMIN(IMN+2)
                  DYNDQ_LMO_ROT(4,III,IFRG)=CMIN(IMN+3)
                  DYNDQ_LMO_ROT(5,III,IFRG)=CMIN(IMN+4)
                  DYNDQ_LMO_ROT(6,III,IFRG)=CMIN(IMN+5)
                  DYNDQ_LMO_ROT(7,III,IFRG)=CMIN(IMN+6)
                  DYNDQ_LMO_ROT(8,III,IFRG)=CMIN(IMN+7)
                  DYNDQ_LMO_ROT(9,III,IFRG)=CMIN(IMN+8)
                  DYNDQ_LMO_ROT(10,III,IFRG)=CMIN(IMN+9)
                  DYNDQ_LMO_ROT(11,III,IFRG)=CMIN(IMN+10)
                  DYNDQ_LMO_ROT(12,III,IFRG)=CMIN(IMN+11)
                  DYNDQ_LMO_ROT(13,III,IFRG)=CMIN(IMN+12)
                  DYNDQ_LMO_ROT(14,III,IFRG)=CMIN(IMN+13)
                  DYNDQ_LMO_ROT(15,III,IFRG)=CMIN(IMN+14)
                  DYNDQ_LMO_ROT(16,III,IFRG)=CMIN(IMN+15)
                  DYNDQ_LMO_ROT(17,III,IFRG)=CMIN(IMN+16)
                  DYNDQ_LMO_ROT(18,III,IFRG)=CMIN(IMN+17)
                  DYNDQ_LMO_ROT(19,III,IFRG)=CMIN(IMN+18)
                  DYNDQ_LMO_ROT(20,III,IFRG)=CMIN(IMN+19)
                  DYNDQ_LMO_ROT(21,III,IFRG)=CMIN(IMN+20)
                  DYNDQ_LMO_ROT(22,III,IFRG)=CMIN(IMN+21)
                  DYNDQ_LMO_ROT(23,III,IFRG)=CMIN(IMN+22)
                  DYNDQ_LMO_ROT(24,III,IFRG)=CMIN(IMN+23)
                  DYNDQ_LMO_ROT(25,III,IFRG)=CMIN(IMN+24)
                  DYNDQ_LMO_ROT(26,III,IFRG)=CMIN(IMN+25)
                  DYNDQ_LMO_ROT(27,III,IFRG)=CMIN(IMN+26)
                 IMN=IMN+27
  116       CONTINUE
C
C RECOVER DISPERSION COEFFICIENTS FOR EFP1-MP2
C
            DO 117 III=1,NDPTS(IFRG)
                NDST=NDST+1
                CDIS(1,NDST) = CMIN(IMN  )
                CDIS(2,NDST) = CMIN(IMN+1)
                CDIS(3,NDST) = CMIN(IMN+2)
                IMN=IMN+3
  117       CONTINUE
C
  121    CONTINUE
      END IF
C
      CALL EFCM
C
      RETURN
      END
C*MODULE GLOBOP  *DECK PRMNC
C> @brief prints current set of minimum energy coordinates
C>
C> @param CMIN allows for specifying the stored coordinates to print
C>
      SUBROUTINE PRMNC(CMIN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXPT=2000, MXFRG=1050, MXAO=8192,
     *           MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*6 FRGNAM
      CHARACTER*8 FRGNME,PTNAM
C
      DIMENSION CMIN(*)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
C
      PARAMETER (ZERO=0.0D+00,UNITS = 0.52917724924D+00)
C
C     PRINT MINIMUM ENERGY COORDINATES
C
      IF(MASWRK) WRITE(IW,9010)
C
      IMN=1
      IF(ICOORD.NE.4) THEN
         DO I = 1,NAT
            IF(MASWRK) WRITE(IW,9028) I,ANAM(I),BNAM(I),
     *             CMIN(IMN)*UNITS,CMIN(IMN+1)*UNITS,CMIN(IMN+2)*UNITS
         IMN=IMN+3
         ENDDO
      END IF
C
      IF(NFRG.GT.0) THEN
         IF(MASWRK) WRITE(IW,9011)
         IF(MASWRK) WRITE(IW,9021)
         IAT=0
         KMASS=0
         DO 120 IFRG=1,NFRG
            IF(MASWRK) WRITE(IW,9022) FRGNAM(IFRG)
            DO 110 III=1,NMPTS(IFRG)
               IAT=IAT+1
               IF(FMASS(III+KMASS).GT.ZERO) THEN
                  XF =  CMIN(IMN)*UNITS
                  YF =  CMIN(IMN+1)*UNITS
                  ZF =  CMIN(IMN+2)*UNITS
                  IF(MASWRK) WRITE(IW,9031) FRGNME(IAT),XF,YF,ZF
               END IF
               IMN=IMN+3
  110      CONTINUE
           KMASS=KMASS+NMPTS(IFRG)
  120   CONTINUE
      END IF
C
      RETURN
C
 9010 FORMAT(/2X,'COORDINATES OF MINIMUM ENERGY GEOMETRY (ANGS):'/)
 9011 FORMAT(1X,'COORDINATES OF FRAGMENT MULTIPOLE CENTERS (ANGS)')
 9021 FORMAT(1X,'MULTIPOLE NAME',9X,'X',18X,'Y',18X,'Z'/
     *       1X,60(1H-))
 9022 FORMAT(1X,'FRAGNAME=',A6)
 9028 FORMAT(1X,I3,2X,A8,A2,3F18.13)
 9031 FORMAT(1X,A8,7X,3F18.13)
C
      END
C*MODULE GLOBOP  *DECK PRFC
C> @brief prints current set of EFP and C coordinates
C>
      SUBROUTINE PRFC
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      PARAMETER (MXATM=2000, MXAO=8192, MXPT=2000, MXFRG=1050,
     *           MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*6 FRGNAM
      CHARACTER*8 FRGNME,PTNAM
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /FRAGMT/ XCRD(50,MXFRG),YCRD(50,MXFRG),ZCRD(50,MXFRG),
     *                PTNAM(50,MXFRG),FRGNAM(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
C
      PARAMETER (ZERO=0.0D+00,UNITS = 0.52917724924D+00)
C
C     PRINT MINIMUM ENERGY COORDINATES
C
      IF(MASWRK) WRITE(IW,9010)
C
      IF(ICOORD.NE.4) THEN
         DO I = 1,NAT
            IF(MASWRK) WRITE (IW,9028) I,ANAM(I),BNAM(I),
     *               C(1,I)*UNITS,C(2,I)*UNITS,C(3,I)*UNITS
         ENDDO
      END IF
C
      IF(NFRG.GT.0) THEN
         IF(MASWRK) WRITE(IW,9011)
         IF(MASWRK) WRITE(IW,9021)
         IAT=0
         KMASS=0
         DO 120 IFRG=1,NFRG
            IF(MASWRK) WRITE(IW,9022) FRGNAM(IFRG)
            DO 110 III=1,NMPTS(IFRG)
               IAT=IAT+1
               IF(FMASS(III+KMASS).GT.ZERO) THEN
                  XF = EFC(1,IAT)*UNITS
                  YF = EFC(2,IAT)*UNITS
                  ZF = EFC(3,IAT)*UNITS
                  IF(MASWRK) WRITE(IW,9031) FRGNME(IAT),XF,YF,ZF
               END IF
  110      CONTINUE
           KMASS=KMASS+NMPTS(IFRG)
  120   CONTINUE
      END IF
C
      RETURN
C
 9010 FORMAT(2X,'COORDINATES OF FINAL GEOMETRY (ANGS):'/)
 9011 FORMAT(1X,'COORDINATES OF FRAGMENT MULTIPOLE CENTERS (ANGS)')
 9021 FORMAT(1X,'MULTIPOLE NAME',9X,'X',18X,'Y',18X,'Z'/
     *       1X,60(1H-))
 9022 FORMAT(1X,'FRAGNAME=',A6)
 9028 FORMAT(1X,I3,2X,A8,A2,3F18.13)
 9031 FORMAT(1X,A8,7X,3F18.13)
C
      END
C*MODULE GLOBOP  *DECK RNGEN
C> @brief random number generator driver
C>
C> @details calculates the seed value and calls the random
C>          number generator chosen in the input, if init=1
C>          then the seed is changed as a permutation of 
C>          the previous seed.
C>
C> @param RANNUM array of random numbers
C> @param NRN integer size of RANNUM
C> @param IRTP determines which number generation to use
C> @param INIT sets whether to initialize seed
C>
      SUBROUTINE RNGEN(RANNUM,NRN,IRTP,INIT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION :: RANNUM(NRN)
      DIMENSION ITIMST(6)
      SAVE IDUM
C
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
C
C        THE SEED -IX- IS EITHER A CONSTANT FOR DEBUGGING PURPOSES,
C        OR IS BASED ON THE TIME STRING.  ALL VALUES IN THE TIME
C        STRING ARE SUMMED SINCE DIFFERENT O/S RETURN THE SECONDS
C        FIELD IN DIFFERENT POSITIONS.  WE WANT TO BE SURE TO PICK
C        UP THE SECONDS PART OF THE STRING TO BE MORE RANDOMIZED.
C
      IF(INIT.EQ.0) THEN
         IA = 1345
         IC = 0
         M = 2**19 - 1
         IF(IRTP.EQ.0) THEN
            IX = 64097
         ELSE
            CALL TMDATE(ITIMST)
            IX=0
            LENTIM=6
            IF(NWDVAR.EQ.1) LENTIM=3
            DO I=1,LENTIM
               IX=IX+ITIMST(I)
            ENDDO
         END IF
         IX  = IABS(IX)
         IDUM= -IX
      ELSE
C The new Monte Carlo needs to call for random numbers
C more than once so this addition changes the seed
C based on a simple interation from the previous seed.
         K=IDUM/127773
         IDUM=16807*(IDUM-k*127773)-2836*k
         IF (IDUM.lt.0) IDUM=IDUM+2147483647
      END IF
C
      IF(IRTP.EQ.3) THEN
         DO I=1,NRN
            CALL RAND3(IDUM,RANNUM(I))
         ENDDO
      ELSE
         DO I=1,NRN
            ITEMP = IA*IX + IC
            IX = MOD(ITEMP,M)
            RANNUM(I)=IX
            RANNUM(I)=RANNUM(I)/(M-1)
         ENDDO
      END IF
      RETURN
      END
C*MODULE GLOBOP  *DECK RAND3
C> @brief random number generator from numerical recipe
C>
C> @param IDUM the seed vlue for the random number
C> @param RAN3 position in array of random numbers
C>
      SUBROUTINE RAND3(IDUM,RAN3)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  ON FIRST CALL IDUM SHOULD BE LESS THAN ZERO
C  (C) COPR. 1986-92 NUMERICAL RECIPES SOFTWARE
C
      INTEGER IDUM
      INTEGER MBIG,MSEED,MZ
      PARAMETER (MBIG=1000000000,MSEED=161803398,MZ=0,FAC=1.0D+00/MBIG)
      DIMENSION MA(55)
      SAVE IFF,INEXT,INEXTP,MA
      DATA IFF /0/
C
      IF(IDUM.LT.0.OR.IFF.EQ.0) THEN
        IFF=1
        MJ=IABS(MSEED-IABS(IDUM))
        MJ=MOD(MJ,MBIG)
        MA(55)=MJ
        MK=1
        DO 11 I=1,54
          II=MOD(21*I,55)
          MA(II)=MK
          MK=MJ-MK
          IF(MK.LT.MZ) MK=MK+MBIG
          MJ=MA(II)
11      CONTINUE
        DO 13 K=1,4
          DO 12 I=1,55
            MA(I)=MA(I)-MA(1+MOD(I+30,55))
            IF(MA(I).LT.MZ) MA(I)=MA(I)+MBIG
12        CONTINUE
13      CONTINUE
        INEXT=0
        INEXTP=31
        IDUM=1
      END IF
C
      INEXT=INEXT+1
      IF(INEXT.EQ.56) INEXT=1
      INEXTP=INEXTP+1
      IF(INEXTP.EQ.56) INEXTP=1
C
      MJ=MA(INEXT)-MA(INEXTP)
      IF(MJ.LT.MZ) MJ=MJ+MBIG
      MA(INEXT)=MJ
      RAN3=MJ*FAC
      RETURN
      END
C
C*MODULE GLOBOP   *DECK PXALRT
C> @brief tests coordinate proximity
C>
C> @details Either runs through all of the EFP groups and
C>          determines the distance to all other coordinates
C>          or starts with a fragment and does the same.
C>          For FMO/AI, IFMOID makes sure atoms in the same group
C>          are not compared.
C>
C> @param alert intent out, tracks whether there is a
C>              proximity issue
C> @param flag determines whether EFP or FMO is being looked at
C>        (1=EFP,0=FMO/AI)
C>
      SUBROUTINE PXALRT(ALERT,FLAG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C INDENTING NEEDS TO BE FIXED 
C NAT is set by FMO so it works
C FLAG determines whether to test FMO/AB INIT or EFP
C
      INTEGER FLAG
      LOGICAL ALERT,GOPARR,MASWRK,DSKWRK,MCMIN
C
      PARAMETER (MXATM=2000,
     *           MXPT=2000, MXFRG=1050, MXDFG=5, MXFGPT=12000,
     *           MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 FRGNME
C
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GLOFMO/ MCMIN,IFMOID(MXATM)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC,IPTRAJ
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
C     CHECK THE DISPLACEMENT FOR NUCLEI TOO CLOSE TOGETHER
C     IF ANY ARE, REGISTER A PROXIMITY ALERT!
C
      ALERT=.FALSE.
      IF(FLAG.EQ.1) THEN
      IF(NFRG.GT.0) THEN
        IAT=0
        KMASS=0
        DO 220 IFRG=1,NFRG
         DO 210 III=1,NMPTS(IFRG)
          IAT=IAT+1
          IF(FMASS(III+KMASS).GT.0.0D+00) THEN
           XF = EFC(1,IAT)
           YF = EFC(2,IAT)
           ZF = EFC(3,IAT)
           IF(NAT.gt.0) THEN
            DO 400 I = 1,NAT
              SEP2 = (XF-C(1,I))**2+(YF-C(2,I))**2+(ZF-C(3,I))**2
              SEP = SQRT(SEP2)
              IF(SEP.LT.SEPTOL) THEN
                ALERT = .TRUE.
                IF (MASWRK) then
                WRITE(IW,*)'Proximity alert between EFP'
     *        ,IFRG,'and atom', I
                CALL FLSHBF(IW)
                END IF
                RETURN
              END IF
  400       END DO
           END IF
           IAT2=0
           KMASS2=0
           DO 202 IFRG2=1,NFRG
             DO 201 III2=1,NMPTS(IFRG2)
               IAT2=IAT2+1
               IF(IFRG2.LE.IFRG) GO TO 201
               IF(FMASS(III2+KMASS2).GT.0.0D+00) THEN
                 SEP2 = (XF-EFC(1,IAT2))**2+(YF-EFC(2,IAT2))**2
     *            +(ZF-EFC(3,IAT2))**2
                 SEP = SQRT(SEP2)
                 IF(SEP.LT.SEPTOL) THEN
                   ALERT = .TRUE.
                   IF (MASWRK) THEN
                WRITE(IW,*)'Proximity alert between EFP'
     *          ,IFRG,'and EFP',IFRG2
                   CALL FLSHBF(IW)
                   END IF
                   RETURN
                 END IF
               END IF
  201        END DO
             KMASS2=KMASS2+NMPTS(IFRG2)
  202      END DO
          END IF
  210    END DO
         KMASS=KMASS+NMPTS(IFRG)
  220   END DO
      END IF
      ELSE
      IF (NAT.NE.0) THEN
        IAT=0
        DO 310 IFRG=1,NAT
          IAT=IAT+1
          XF = C(1,IAT)
          YF = C(2,IAT)
          ZF = C(3,IAT)
          IF(NFRG.GT.0) THEN
            IAT2=0
            KMASS2=0
            DO 302 JFRAG=1,NFRG
              DO 301 III=1,NMPTS(JFRAG)
               IAT2=IAT2+1
               IF(JFRAG.LE.IFRG) GO TO 301
               IF(FMASS(III+KMASS2).GT.0.0D+00) THEN
                 SEP2 = (XF-EFC(1,IAT2))**2+(YF-EFC(2,IAT2))**2
     *              +(ZF-EFC(3,IAT2))**2
                 SEP = SQRT(SEP2)
                 IF(SEP.LT.SEPTOL) THEN
                   ALERT = .TRUE.
                   IF (MASWRK) THEN
                WRITE(IW,*)'Proximity alert between atom'
     *          ,IAT,'and EFP',JFRAG
                   CALL FLSHBF(IW)
                   END IF
                   RETURN
                 END IF
               END IF
  301         END DO
             KMASS2=KMASS2+NMPTS(JFRAG)
  302       END DO
          END IF
          DO I=1,NAT
C-------Use IFMOID to make sure that atoms in the same fragment
C-------are ignored by PXALRT
            IF(IFMOID(IAT).NE.IFMOID(I))THEN
            SEP2 = (XF-C(1,I))**2+(YF-C(2,I))**2+(ZF-C(3,I))**2
            SEP = SQRT(SEP2)
            IF(SEP.LT.SEPTOL.AND.SEP.NE.0) THEN
              ALERT = .TRUE.
                   IF (MASWRK) THEN
                WRITE(IW,*)'Proximity alert between atom'
     *          ,IAT,'and atom',I
                   CALL FLSHBF(IW)
                   END IF
              RETURN
            END IF
            END IF
          END DO
  310   END DO
      END IF
      END IF
      CALL FLSHBF(6)
C
      RETURN
      END SUBROUTINE
C*MODULE GLOBOP  *DECK MC_FMO_RAND
C> @brief randomizes the initial coordinates of FMO groups
C>
C> @details Starts moving fragments from the origin and randomly
C>          moves them outward until no proximity alerts are found
C>
C> @author Caleb Carlin
C>
C> @param IMXRAN max random numbers stored
C> @param RND array of random numbers
C> @param IRN current position in RND
C> @param IRTP stores which number generator to use
C> @param NMCFRG number of FMO frags or AI groups
C> @param IFXFMO array of fragments to not move
C> @param AVEXYZ array of positional averages for each group
C>
      SUBROUTINE MC_FMO_rand(IMXRAN,RND,IRN,IRTP,NMCFRG,IFXFMO,
     *         AVEXYZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C     routine to randomly distribute FMO fragments if RNDINI=true
C     EFP groups are taken into account for proximity alerts, but are
C     moved elsewhere
      LOGICAL GOPARR,MASWRK,DSKWRK
      PARAMETER (MXATM=2000,MXFRG=1050,ZERO=0.0D+00,MXDPPT=63000
     *            ,UNITS = 0.52917724924D+00)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)

      DIMENSION AVEXYZ(3,*)
      DOUBLE PRECISION :: RND(IMXRAN)
      LOGICAL ALERT
      DIMENSION IFXFMO(*)
      INTEGER MOVED
C
      If (MASWRK) THEN
        WRITE(IW,*) ' '
        WRITE(IW,*) 'BEGINNING RANDOMIZING FMO CLUSTER FRAGMENTS'
      END IF
C     IFIRST ensures that first movements are from the origin
      IFIRST=1
      ISTOVR=IMXRAN-10
C     Random numbers
      INIT=1
      IF(MASWRK) THEN
         CALL RNGEN(RND,IMXRAN,IRTP,INIT)
         CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
      ELSE
         CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
      END IF
      IRN=1
C
C     This should be changed to a do while loop
C
   30 CONTINUE
      ALERT=.FALSE.
      IF(IRN.GE.ISTOVR) THEN
         INIT=1
         IF(MASWRK) THEN
            CALL RNGEN(RND,IMXRAN,IRTP,INIT)
            CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
         ELSE
            CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
         END IF
         IRN=1
      END IF
C
        MFRGID=NFRG
        DO INF=1,NMCFRG
         IF(IRN.GE.ISTOVR) THEN
            INIT=1
            IF(MASWRK) THEN
               CALL RNGEN(RND,IMXRAN,IRTP,INIT)
               CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
            ELSE
               CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
            END IF
            IRN=1
         END IF
        MFRGID=MFRGID+1
        IF (IFXFMO(INF).NE.1) THEN
          IF(IFIRST==1) THEN
             DX=2.0D+00*(2.0D+00*RND(IRN  )-1.0D+00)-AVEXYZ(1,INF)
             DY=2.0D+00*(2.0D+00*RND(IRN+1)-1.0D+00)-AVEXYZ(2,INF)
             DZ=2.0D+00*(2.0D+00*RND(IRN+2)-1.0D+00)-AVEXYZ(3,INF)
          ELSE
             DX=2.0D+00*(2.0D+00*RND(IRN  )-1.0D+00)
             DY=2.0D+00*(2.0D+00*RND(IRN+1)-1.0D+00)
             DZ=2.0D+00*(2.0D+00*RND(IRN+2)-1.0D+00)
          END IF
          DA=3.1415D+00*(2.0D+00*RND(IRN+3)-1.0D+00)
          DB=3.1415D+00*(2.0D+00*RND(IRN+4)-1.0D+00)
          DG=3.1415D+00*(2.0D+00*RND(IRN+5)-1.0D+00)
          CALL MC_TRANSLATE(DX,DY,DZ,INF,MOVED,AVEXYZ,MFRGID)
          CALL MC_CHANGE_AVEXYZ(AVEXYZ,DX,DY,DZ,ZERO,ZERO,ZERO
     *       ,INF,ZERO,ZERO,ZERO)
          CALL MC_ROTATE(DA,DB,DG,INF,
     *    AVEXYZ(1,MFRGID),AVEXYZ(2,MFRGID),AVEXYZ(3,MFRGID))
          CALL MC_CHANGE_AVEXYZ(AVEXYZ,ZERO,ZERO,ZERO,DA,DB,DG,
     *    INF,AVEXYZ(1,MFRGID),AVEXYZ(2,MFRGID),AVEXYZ(3,MFRGID))
          IRN=IRN+6
        END IF
        END DO
        IFIRST=0
        CALL PXALRT(ALERT,0)
      IF (ALERT) GOTO 30
      RETURN
C
      END SUBROUTINE
C*MODULE GLOBOP  *DECK MC_EFP_BLOCK
C> @brief moves NFRMOV EFP fragments
C>
C> @details Completes either a translation or rotation step
C>          based on TorR by determining random movement
C>          and calling EFDSPL
C>
C> @param DELC array for storing translation movements
C> @param DELMXC array of maximum translation movements
C> @param DELA array for storing angle changes
C> @param DELMXA array of maximum angle changes
C> @param NFRMOV number of EFP frags to move each step
C> @param PROVEC array of EFP values
C> @param CTVEC array of EFP values
C> @param RND array of random numbers
C> @param IRN place holder in RND
C> @param IFXFRG array of EFP frags that have frozen coordinates
C> @param TorR logical true=translations false=rotations
C> @param NSTMIN number of steps to go between printing to trj file
C> @param MCTYP bitwise additive for type of groups in use
C> @param BETA temperature dependent value for MC step
C> @param COLD array of accept coordinates of previous step
C> @param IGLO the number of the current step
C> @param MXBF determines the size of LENCV/LENPV
C> @param CMIN array of coordinates of current lowest energy
C> @param AIMOVE MCTYP=4 only, max displacement of AI atoms
C> @param AVEXYZ array of coordinate averages
C> @param BAVEXYZ backup array of coordinate averages
C> @param IMXRAN size of array of random doubles
C> @param IRTP determines how to calculate random numbers
C> 
C> @author Caleb Carlin
C>
      subroutine MC_EFP_BLOCK(DELC,DELMXC,DELA,DELMXA,NFRMOV,
     *            PROVEC,CTVEC,RND,IRN,IFXFRG,TorR,NSTMIN,MCTYP,
     *            BETA,COLD,IGLO,MXBF,CMIN,AIMOVE,AVEXYZ,BAVEXYZ,
     *            IMXRAN,IRTP)

      use DYNPOL_DIST
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C      
      DOUBLE PRECISION :: DELC(*),DELMXC(*),DELA(*),DELMXA(*),RND(*)
C
      PARAMETER (MXAO=8192,MXFRG=1050, MXDFG=5, MXFGPT=12000,
     *           MXDPPT=63000,ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00,
     *           MXPT=2000,MXSHEF=1000,MXGEFP=4000,MXATM=2000,
     *      UNITS = 0.52917724924D+00)
C     
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFMULT/ EFC(3,MXFGPT),EFCHG(2,MXFGPT),EFATRM(MXFGPT),
     *                EFBTRM(MXFGPT),EFATRM2(MXFGPT),EFBTRM2(MXFGPT),
     *                EFDIP(3,MXFGPT),EFQAD(6,MXFGPT),
     *                EFOCT(10,MXFGPT),FRGNME(MXFGPT)
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),JNLPR(4*MXPT),
     *                JKFR(MXPT),JKLR(MXPT),NDPTS(MXFRG),NDTTPT
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC,IPTRAJ

      DOUBLE PRECISION EFC
      DIMENSION CMIN(*),COLD(*),AVEXYZ(3,*),BAVEXYZ(3,*)
      DIMENSION PROVEC(MXBF,*),CTVEC(MXBF,*)
      LOGICAL TorR, ALERT,MASWRK,ACCEPT,GOPARR,DSKWRK
      INTEGER :: IFXFRG(*)
      INTEGER, ALLOCATABLE :: IFRMOV(:)
      CHARACTER*8 LJNAME,ELJNAM,FRGNME
C
            ALLOCATE(IFRMOV(NFRG))
            II=0
            DO INF=1,NFRG
               IFRMOV(INF)=0
            ENDDO
            IFRAG=INT(DBLE(NFRG)*RND(IRN))
            IRN=IRN+1
C
  115       CONTINUE
            IF(IFRAG.EQ.NFRG) IFRAG=0
            IFRAG=IFRAG+1
            IF(IFXFRG(IFRAG).GT.0) THEN
               GO TO 115
            ELSE
               IFRMOV(IFRAG)=1
               II=II+1
               IF(II.LT.NFRMOV) GO TO 115
            END IF
C
        INIT=1
        IF(MASWRK)THEN
            CALL RNGEN(RND,IMXRAN,IRTP,INIT)
            CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
        ELSE
            CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
        END IF
        IRN=1
C
         IF(TorR) THEN
C
C   DETERMINE NEW TEST COORDINATES
C
            IDC=1
            DO 110 INF=1,NFRG
               IF(IFXFRG(INF).EQ.0.AND.IFRMOV(INF).EQ.1) THEN
                  DELC(IDC  ) = DELMXC(IDC  )*(TWO*RND(IRN  )-ONE)
                  DELC(IDC+1) = DELMXC(IDC+1)*(TWO*RND(IRN+1)-ONE)
                  DELC(IDC+2) = DELMXC(IDC+2)*(TWO*RND(IRN+2)-ONE)
                  IRN=IRN+3
               ELSE
                  DELC(IDC  ) = ZERO
                  DELC(IDC+1) = ZERO
                  DELC(IDC+2) = ZERO
               END IF
               IDC=IDC+3
  110       CONTINUE
            XRAN = RND(IRN)
            IRN=IRN+1
C
C
C SAVE CURRENT COORDINATES
C
         LENPV=MXBF*NTMO
         LENCV=MXBF*NTCTMO
         IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
            CALL DAREAD(IDAF,IODA,PROVEC,LENPV,267,0)
         END IF
         IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
            CALL DAREAD(IDAF,IODA,CTVEC,LENCV,269,0)
         END IF
         CALL STCOR(COLD,PROVEC,CTVEC,MXBF)
C
C           MOVE AB INITIO ATOMS
C
         IF(AIMOVE.GT.0.0D+00) THEN
            DO IAB=1,NAT
               AINUM=NFRG+IAB
               AIDX=AIMOVE*(2.0D+00*RND(IRN)-ONE)
               AIDY=AIMOVE*(2.0D+00*RND(IRN+1)-ONE)
               AIDZ=AIMOVE*(2.0D+00*RND(IRN+2)-ONE)
               C(1,IAB)=C(1,IAB)+AIDX
               C(2,IAB)=C(2,IAB)+AIDY
               C(3,IAB)=C(3,IAB)+AIDZ
               CALL MC_CHANGE_AVEXYZ(AVEXYZ,AIDX,AIDY,AIDZ
     *         ,ZERO,ZERO,ZERO,AINUM,ZERO,ZERO,ZERO)
               IRN=IRN+3
            ENDDO
         END IF
C
         NMST=0
         NPST=0
         NLJST=0
         NDPST=0
         NRST=0
         NDST=0
         NATST=0
         NORST=0
         NCTMOST=0
         IFRC=1
         DAVE=ZERO
C
C           MOVE FRAGMENT LOCATIONS
C
         DO 400 INF=1,NFRG
            IF(IFRMOV(INF).NE.0) THEN
C  Make sure step is inside box
            MOVED=1
C  ensure backup average is correct
            BAVEXYZ(1,INF)=AVEXYZ(1,INF)
            BAVEXYZ(2,INF)=AVEXYZ(2,INF)
            BAVEXYZ(3,INF)=AVEXYZ(3,INF)
              CALL MC_PBC(AVEXYZ,DELC(IFRC),
     *          DELC(IFRC+1),DELC(IFRC+2),MOVED,INF)
C
               DAVE=DAVE+ABS(DELC(IFRC  ))+ABS(DELC(IFRC+1))
     *                  +ABS(DELC(IFRC+2))+ABS(DELA(IFRC  ))
     *                  +ABS(DELA(IFRC+1))+ABS(DELA(IFRC+2))
C
C                 THIS MOVES THE FRAGMENT IN QUESTION.
C
               CALL EFDSPL(INF,
     *               DELC(IFRC),DELC(IFRC+1),DELC(IFRC+2),
     *               DELA(IFRC),DELA(IFRC+1),DELA(IFRC+2),
     *               NMST,NPST,NLJST,NDPST,NRST,NDST,NATST,NORST,
     *               PROVEC,NCTMOST,CTVEC,MXBF)
               CALL MC_CHANGE_AVEXYZ(AVEXYZ,DELC(IFRC),DELC(IFRC+1),
     *               DELC(IFRC+2),ZERO,ZERO,ZERO
     *               ,INF,ZERO,ZERO,ZERO)
            END IF
            NMST  = NMST  + NMPTS(INF)
            NPST  = NPST  + NPPTS(INF)
            NLJST = NLJST + NLJPTS(INF)
            NDPST = NDPST + NDPPTS(INF)
            NRST  = NRST  + NRPTS(INF)
            NDST  = NDST  + NDPTS(INF)
            NATST = NATST + NATEF(ISET(INF))
            NORST = NORST + NORB(INF)
            NCTMOST = NCTMOST + NCTMO(ISET(INF))
            IFRC=IFRC+3
  400    CONTINUE
C
         IF (NFRG.GT.0.AND.NTMO.GT.0)
     *       CALL DAWRIT(IDAF,IODA,PROVEC,LENPV,267,0)
         IF (NFRG.GT.0.AND.NTCTMO.GT.0)
     *       CALL DAWRIT(IDAF,IODA,CTVEC,LENCV,269,0)
         DAVE=DAVE/(6*NFRG)
         CALL PXALRT(ALERT,1)
         IF(ALERT) THEN
C        Restore old coordinates and return
            DO KNR=1,NFRG
               IF (IFRMOV(KNR).NE.0) THEN
                  AVEXYZ(1,KNR)=BAVEXYZ(1,KNR)
                  AVEXYZ(2,KNR)=BAVEXYZ(2,KNR)
                  AVEXYZ(3,KNR)=BAVEXYZ(3,KNR)
               END IF
            END DO
            IF (AIMOVE.GT.0.0D+00) THEN
               MAIPLACE=NFRG+1
               DO IKF=1,NAT
                 AVEXYZ(1,MAIPLACE)=BAVEXYZ(1,MAIPLACE)
                 AVEXYZ(2,MAIPLACE)=BAVEXYZ(2,MAIPLACE)
                 AVEXYZ(3,MAIPLACE)=BAVEXYZ(3,MAIPLACE)
                 MAIPLACE=MAIPLACE+1
               END DO
            END IF
            CALL RSTCOR(COLD,PROVEC,CTVEC,MXBF)
            IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
               CALL DAWRIT(IDAF,IODA,PROVEC,LENPV,267,0)
            END IF
            IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
              CALL DAWRIT(IDAF,IODA,CTVEC,LENCV,269,0)
            END IF
            NRPA=NRPA+1
            NRPAT=NRPAT+1
            IF(MASWRK.AND.NPRTGO.NE.2) WRITE(IW,*)
     *           'REJECTED DUE TO PROXIMITY ALERT'
C
C CLEAR TRANSLATIONAL DISPLACEMENTS
C
            IDC=1
            DO INF=1,NFRG
               DELC(IDC  ) = ZERO
               DELC(IDC+1) = ZERO
               DELC(IDC+2) = ZERO
               IDC=IDC+3
            ENDDO
            IF(ALLOCATED(IFRMOV)) DEALLOCATE (IFRMOV)
            RETURN
         END IF
         ACCEPT=.false.
         CALL MC_ENERGY(IGLO,CMIN,PROVEC,CTVEC,ACCEPT,XRAN,BETA,
     *      NSTMIN,MCTYP,COLD,MXBF)
C  If accepted, we update DELMX* before wiping DEL*
      IF(ACCEPT.AND.ALPHA.NE.ZERO) THEN
         II=1
         IF(MASWRK) WRITE(IW,9009) ALPHA
         DO INF=1,NFRG
           DELMXC(II) = DELMXC(II)*(ONE-ALPHA) + ALPHA*ABS(DELC(II))
           DELMXC(II+1) = DELMXC(II+1)*(ONE-ALPHA)+ALPHA*ABS(DELC(II+1))
           DELMXC(II+2) = DELMXC(II+2)*(ONE-ALPHA)+ALPHA*ABS(DELC(II+2))
          II=II+3
         END DO
      END IF
      IF (.NOT.ACCEPT) THEN
c   coordinates restored in MC_ENERGY
         DO KNS=1,NFRG
            IF (IFRMOV(KNS).NE.0) THEN
               AVEXYZ(1,KNS)=BAVEXYZ(1,KNS)
               AVEXYZ(2,KNS)=BAVEXYZ(2,KNS)
               AVEXYZ(3,KNS)=BAVEXYZ(3,KNS)
            END IF
         END DO
         IF (AIMOVE.GT.0.0D+00) THEN
            MAIPLACE=NFRG+1
            DO IKG=1,NAT
              AVEXYZ(1,MAIPLACE)=BAVEXYZ(1,MAIPLACE)
              AVEXYZ(2,MAIPLACE)=BAVEXYZ(2,MAIPLACE)
              AVEXYZ(3,MAIPLACE)=BAVEXYZ(3,MAIPLACE)
              MAIPLACE=MAIPLACE+1
            END DO
         END IF
      END IF        
C
C CLEAR TRANSLATIONAL DISPLACEMENTS
C
         IDC=1
         DO INF=1,NFRG
            DELC(IDC  ) = ZERO
            DELC(IDC+1) = ZERO
            DELC(IDC+2) = ZERO
            IDC=IDC+3
         ENDDO
C
C  BELOW IS FOR ROTATIONS
C
      ELSE
C
C   DETERMINE NEW TEST COORDINATES
C
            IDA=1
            DO 120 INF=1,NFRG
               IF(IFXFRG(INF).EQ.0.AND.IFRMOV(INF).EQ.1) THEN
                  DELA(IDA  ) = DELMXA(IDA  )*(TWO*RND(IRN  )-ONE)
                  DELA(IDA+1) = DELMXA(IDA+1)*(TWO*RND(IRN+1)-ONE)
                  DELA(IDA+2) = DELMXA(IDA+2)*(TWO*RND(IRN+2)-ONE)
                  IRN=IRN+3
               ELSE
                  DELA(IDA  ) = ZERO
                  DELA(IDA+1) = ZERO
                  DELA(IDA+2) = ZERO
               END IF
               IDA =IDA +3
  120       CONTINUE
            XRAN = RND(IRN)
            IRN=IRN+1
C
C SAVE CURRENT COORDINATES
C
         IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
            CALL DAREAD(IDAF,IODA,PROVEC,LENPV,267,0)
         END IF
         IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
            CALL DAREAD(IDAF,IODA,CTVEC,LENCV,269,0)
         END IF
         CALL STCOR(COLD,PROVEC,CTVEC,MXBF)
C
         NMST=0
         NPST=0
         NLJST=0
         NDPST=0
         NRST=0
         NDST=0
         NATST=0
         NORST=0
         NCTMOST=0
         IFRC=1
         DAVE=ZERO
C
C           MOVE FRAGMENT LOCATIONS
C
         DO INF=1,NFRG
            IF(IFRMOV(INF).NE.0) THEN
C
               DAVE=DAVE+ABS(DELC(IFRC  ))+ABS(DELC(IFRC+1))
     *                  +ABS(DELC(IFRC+2))+ABS(DELA(IFRC  ))
     *                  +ABS(DELA(IFRC+1))+ABS(DELA(IFRC+2))
C
C                 THIS MOVES THE FRAGMENT IN QUESTION.
C
               CALL EFDSPL(INF,
     *               DELC(IFRC),DELC(IFRC+1),DELC(IFRC+2),
     *               DELA(IFRC),DELA(IFRC+1),DELA(IFRC+2),
     *               NMST,NPST,NLJST,NDPST,NRST,NDST,NATST,NORST,
     *               PROVEC,NCTMOST,CTVEC,MXBF)
               CALL MC_CHANGE_AVEXYZ(AVEXYZ,ZERO,ZERO,ZERO,DELA(IFRC)
     *               ,DELA(IFRC+1),DELA(IFRC+2),INF,
     *               EFC(1,INF),EFC(2,INF),EFC(3,INF))
            END IF
            NMST  = NMST  + NMPTS(INF)
            NPST  = NPST  + NPPTS(INF)
            NLJST = NLJST + NLJPTS(INF)
            NDPST = NDPST + NDPPTS(INF)
            NRST  = NRST  + NRPTS(INF)
            NDST  = NDST  + NDPTS(INF)
            NATST = NATST + NATEF(ISET(INF))
            NORST = NORST + NORB(INF)
            NCTMOST = NCTMOST + NCTMO(ISET(INF))
            IFRC=IFRC+3
         END DO
C
         IF (NFRG.GT.0.AND.NTMO.GT.0)
     *       CALL DAWRIT(IDAF,IODA,PROVEC,LENPV,267,0)
         IF (NFRG.GT.0.AND.NTCTMO.GT.0)
     *       CALL DAWRIT(IDAF,IODA,CTVEC,LENCV,269,0)
         DAVE=DAVE/(6*NFRG)
        CALL PXALRT(ALERT,1)
        IF(ALERT) THEN
C        Restore old coordinates and return
         DO KNt=1,NFRG
            IF (IFRMOV(KNt).NE.0) THEN
               AVEXYZ(1,KNt)=BAVEXYZ(1,KNt)
               AVEXYZ(2,KNt)=BAVEXYZ(2,KNt)
               AVEXYZ(3,KNt)=BAVEXYZ(3,KNt)
            END IF
         END DO
            CALL RSTCOR(COLD,PROVEC,CTVEC,MXBF)
            IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
               CALL DAWRIT(IDAF,IODA,PROVEC,LENPV,267,0)
            END IF
            IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
              CALL DAWRIT(IDAF,IODA,CTVEC,LENCV,269,0)
            END IF
            NRPA=NRPA+1
            NRPAT=NRPAT+1
            IF(MASWRK.AND.NPRTGO.NE.2) WRITE(IW,*)
     *           'REJECTED DUE TO PROXIMITY ALERT'
            KK=1
            DO KKC=1,NFRG
              DELA(KK)=0.0d0
              DELA(KK+1)=0.0d0
              DELA(KK+2)=0.0d0
              KK=KK+3
            END DO
            IF(ALLOCATED(IFRMOV)) DEALLOCATE (IFRMOV)            
            RETURN
        END IF
        CALL MC_ENERGY(IGLO,CMIN,PROVEC,CTVEC,ACCEPT,XRAN,BETA,
     *                NSTMIN,MCTYP,COLD,MXBF)
C  If accepted, we update DELMX* before wiping DEL*
      IF(ACCEPT.AND.ALPHA.NE.ZERO) THEN
         II=1
         IF(MASWRK) WRITE(IW,9009) ALPHA
         DO INF=1,NFRG
           DELMXA(II) = DELMXA(II)*(ONE-ALPHA) + ALPHA*ABS(DELA(II))
           DELMXA(II+1) = DELMXA(II+1)*(ONE-ALPHA)+ALPHA*ABS(DELA(II+1))
           DELMXA(II+2) = DELMXA(II+2)*(ONE-ALPHA)+ALPHA*ABS(DELA(II+2))
           II=II+3
         END DO
      END IF
      IF (.NOT.ACCEPT) THEN
c   coordinates restored in MC_ENERGY
         DO KNU=1,NFRG
            IF (IFRMOV(KNU).NE.0) THEN
               AVEXYZ(1,KNU)=BAVEXYZ(1,KNU)
               AVEXYZ(2,KNU)=BAVEXYZ(2,KNU)
               AVEXYZ(3,KNU)=BAVEXYZ(3,KNU)
            END IF
         END DO
      END IF
C
      KK=1
      DO KKC=1,NFRG
        DELA(KK)=0.0d0
        DELA(KK+1)=0.0d0
        DELA(KK+2)=0.0d0
        KK=KK+3
      END DO
      END IF
      IF(ALLOCATED(IFRMOV)) DEALLOCATE (IFRMOV)
        RETURN
 9009 FORMAT(3X,'USING ALPHA=',F5.4,1X,'TO UPDATE DMAT.')
C
      end subroutine MC_EFP_BLOCK
C*MODULE GLOBOP  *DECK MC_FMO_BLOCK
C> @brief driver for FMO/AI MC step
C>
C> @details Sets up the translation or rotation of NFMOMOV number
C>          of FMO or AI groups. FMOR frags and AI groups are
C>          treated the same since they are both stored in C
C>
C> @param RND array of random numbers
C> @param IRN current position in RND
C> @param NFMOMOV controls number of fragments moved
C> @param DELC array for storing translation movements
C> @param DELMXC array of maximum translation movements
C> @param DELA array for storing angle changes
C> @param DELMXA array of maximum angle changes
C> @param TorR logical true=translation false=rotation
C> @param IFXFMO array of fragments with frozen coordinates
C> @param NSTMIN number of steps to go between printing to trj file
C> @param MCTYP bitwise additive for type of groups in use
C> @param BETA temperature dependent value for MC step
C> @param COLD array of accept coordinates of previous step
C> @param IGLO the number of the current step
C> @param MXBF determines the size of LENCV/LENPV
C> @param CMIN array of coordinates of current lowest energy
C> @param NMCFRG number of FMO or AI groups
C> @param TEMP current temperature
C> @param IRTP method for generating random numbers
C> @param NSMSTP number of steps in secondary MC step
C> @param SMTEMP secondary MC starts when TEMPER<SMTEMP
C> @param IMXRAN size of the random number array
C> @param PRSEP max seperation between paired atoms
C> @param INDEP sets whether to propogate translations
C> @param AVEXYZ array of coordinate averages
C> @param BAVEXYZ backup array of coordinate averages
C>
C> @author Caleb Carlin
C>
      subroutine MC_FMO_BLOCK(RND,IRN,DELA,DELC,
     *            DELMXC,DELMXA,TorR,NFMOMOV,IFXFMO,NSTMIN,MCTYP,
     *            BETA,PROVEC,CTVEC,COLD,IGLO,MXBF,CMIN,NMCFRG,
     *            NPRBND,IPRBNDA,TEMP,IRTP,NSMSTP,SMTEMP,IMXRAN,
     *            PRSEP,INDEP,AVEXYZ,BAVEXYZ)
C
      use connglob
      use DYNPOL_DIST
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION :: DELC(*),DELMXC(*),DELA(*),DELMXA(*),RND(*)
C
      PARAMETER (MXATM=2000,MXFRG=1050,ONE=1.0D+00,ZERO=0.0D+00,
     *          MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      COMMON /GLOFMO/ MCMIN,IFMOID(MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC,IPTRAJ
      DIMENSION AVEXYZ(3,*),CMIN(*),COLD(*)
      DIMENSION IFXFMO(*),BAVEXYZ(3,*)
      DIMENSION PROVEC(MXBF,*),CTVEC(MXBF,*)
      INTEGER, allocatable :: IFMOMOV(:)
      DIMENSION IPRBNDA(NAT),PRSEP(*)
C     routine to setup the moving of fmo groups during the
C     loop over temperature
C
      LOGICAL ALERT,TorR,ACCEPT,MASWRK,GOPARR,DSKWRK,MCMIN
      INTEGER :: MOVED=0
C     STORE CURRENT COORDINATES
      CALL STCOR(COLD,PROVEC,CTVEC,MXBF)
      ALLOCATE(IFMOMOV(NMCFRG))
C
      DO ICC=1,NMCFRG
         IFMOMOV(ICC)=0
      END DO
C     Pick NFMOMOV fragments to move
C     Single fragment runs may occur when MCTYP=1
      JJ=0
      JFRG=INT(DBLE(NMCFRG)*RND(IRN))
      IRN=IRN+1
      IF(NMCFRG.NE.1) THEN
  115   CONTINUE
          IF(JFRG.EQ.NMCFRG) JFRG=0
          JFRG=JFRG+1
          IF(IFXFMO(JFRG).GT.0) THEN
            GO TO 115
          ELSE
            IFMOMOV(JFRG)=1
            JJ=JJ+1
            IF(JJ.LT.NFMOMOV) GO TO 115
          END IF
      ELSE
        IFMOMOV(1)=1
      END IF
C 
      ALERT=.FALSE.
      IDC=NFRG*3+1
      CALL FLSHBF(6)
      DO 180 IGM=1,NMCFRG
        MFRGPOS=NFRG+IGM
C
      IF (IRN.GE.IMXRAN) THEN
      init=1
      IF(MASWRK) THEN
          CALL RNGEN(RND,IMXRAN,IRTP,INIT)
          CALL DDI_BCAST(2666,'F',RND,IMXRAN,MASTER)
      ELSE
          CALL DDI_BCAST(2666,'F',RND,IMXRAN,MASTER)
      END IF
      IRN=1
      END IF
      IF(IFMOMOV(IGM)==1) THEN
C-----Set up the displacement variables
        IF(TorR) THEN
           DELC(IDC)=DELMXC(IDC  )*(2.0D+00*RND(IRN  )-1.0D+00)
           DELC(IDC+1)=DELMXC(IDC+1)*(2.0D+00*RND(IRN+1)-1.0D+00)
           DELC(IDC+2)=DELMXC(IDC+2)*(2.0D+00*RND(IRN+2)-1.0D+00)
           DELA(IDC)=0.0D+00
           DELA(IDC+1)=0.0D+00
           DELA(IDC+2)=0.0D+00
C           IDC=IDC+3
        ELSE
           DELA(IDC)=DELMXA(IDC  )*(3.1415D+00*RND(IRN  )-1.5708D+00)
           DELA(IDC+1)=DELMXA(IDC+1)*(3.1415D+00*RND(IRN+1)-1.5708D+00)
           DELA(IDC+2)=DELMXA(IDC+2)*(3.1415D+00*RND(IRN+2)-1.5708D+00)
           DELC(IDC)=0.0D+00
           DELC(IDC+1)=0.0D+00
           DELC(IDC+2)=0.0D+00
C           IDC=IDC+3
        END IF
        IRN=IRN+3
C
C   Here we handle the movement of paired or unpaired runs

        CALL FLSHBF(6)
        RNDTRAN=RND(IRN)
        IRN=IRN+1
        IF (TorR.AND.NPRBND.EQ.0) THEN
        CALL MC_TRANSLATE(DELC(IDC),DELC(IDC+1),DELC(IDC+2),IGM,MOVED
     *  ,AVEXYZ,MFRGPOS)
        CALL MC_CHANGE_AVEXYZ(AVEXYZ,DELC(IDC),DELC(IDC+1),DELC(+2),
     *   ZERO,ZERO,ZERO,MFRGPOS,ZERO,ZERO,ZERO)
        END IF
C
        IF (TorR.AND.NPRBND.NE.0) THEN
        CALL MC_CON_TRANSLATE(DELC(IDC),DELC(IDC+1),DELC(IDC+2),
     *   RNDTRAN,IGM,ALERT,INDEP,PRSEP,AVEXYZ,MFRGPOS)
        END IF
C
        IF (.NOT.TorR.AND.NPRBND.EQ.0) THEN
          CALL MC_ROTATE(DELA(IDC),DELA(IDC+1),DELA(IDC+2),IGM,
     *    AVEXYZ(1,MFRGPOS),AVEXYZ(2,MFRGPOS),AVEXYZ(3,MFRGPOS))
          CALL MC_CHANGE_AVEXYZ(AVEXYZ,zero,zero,zero,DELA(IDC),
     *    DELA(IDC+1),DELA(IDC+2),MFRGPOS,
     *    AVEXYZ(1,MFRGPOS),AVEXYZ(2,MFRGPOS),AVEXYZ(3,MFRGPOS))
        END IF
C
        IF (.NOT.TorR.AND.NPRBND.NE.0) THEN
        CALL MC_CON_ROTATE(DELA(IDC),DELA(IDC+1),DELA(IDC+2),
     *       RNDTRAN,IGM,ALERT,AVEXYZ,MFRGPOS)
         END IF
C   perform secondary mc here
        IF ((NSMSTP.GT.0).AND.(TEMP.LT.SMTEMP)) THEN
            CALL MC_FMO_SUBMC(IGM,NSMSTP,IRTP,BETA)
        END IF
C
      END IF
      IDC=IDC+3
 180  END DO
      IF (.not.ALERT) CALL PXALRT(ALERT,0)
      IF (ALERT) THEN
         IF (NPRBND.EQ.0) THEN
            MFGPOS=NFRG+1
            DO KLW=1,NMCFRG
               IF(IFMOMOV(KLW).NE.0) THEN
                   AVEXYZ(1,MFGPOS)=BAVEXYZ(1,MFGPOS)
                   AVEXYZ(2,MFGPOS)=BAVEXYZ(2,MFGPOS)
                   AVEXYZ(3,MFGPOS)=BAVEXYZ(3,MFGPOS)
                   MFGPOS=MFGPOS+1
               END IF
            END DO
         ELSE
            MFGPOS=NFRG+1
            DO KRN=1,NMCFRG
               AVEXYZ(1,MFGPOS)=BAVEXYZ(1,MFGPOS)
               AVEXYZ(2,MFGPOS)=BAVEXYZ(2,MFGPOS)
               AVEXYZ(3,MFGPOS)=BAVEXYZ(3,MFGPOS)
               MFGPOS=MFGPOS+1
            END DO
         END IF
         CALL RSTCOR(COLD,PROVEC,CTVEC,MXBF)
         NRPA=NRPA+1
         NRPAT=NRPAT+1
C
         KK=NFRG*3+1
         DO KKC=1,NMCFRG
           DELC(KK)=0.0d+00
           DELC(KK+1)=0.0d+00
           DELC(KK+2)=0.0d+00
           DELA(KK)=0.0d+00
           DELA(KK+1)=0.0d+00
           DELA(KK+2)=0.0d+00
           KK=KK+3
         END DO
         IF(ALLOCATED(IFMOMOV)) DEALLOCATE(IFMOMOV)
         RETURN
      END IF
      XRAN = RND(IRN)
      IRN=IRN+1
      CALL MC_ENERGY(IGLO,CMIN,PROVEC,CTVEC,ACCEPT,XRAN,BETA,
     *              NSTMIN,MCTYP,COLD,MXBF)
C  If accepted, we update DELMX* before wiping DEL*
      IF(ACCEPT.AND.ALPHA.NE.ZERO) THEN
         II=NFRG*3+1
         IF(MASWRK) WRITE(IW,9009) ALPHA
         DO 445 INF=1,NMCFRG
           DELMXC(II) = DELMXC(II)*(ONE-ALPHA) + ALPHA*ABS(DELC(II))
           DELMXC(II+1) = DELMXC(II+1)*(ONE-ALPHA)+ALPHA*ABS(DELC(II+1))
           DELMXC(II+2) = DELMXC(II+2)*(ONE-ALPHA)+ALPHA*ABS(DELC(II+2))
           DELMXA(II) = DELMXA(II)*(ONE-ALPHA) + ALPHA*ABS(DELA(II))
           DELMXA(II+1) = DELMXA(II+1)*(ONE-ALPHA)+ALPHA*ABS(DELA(II+1))
           DELMXA(II+2) = DELMXA(II+2)*(ONE-ALPHA)+ALPHA*ABS(DELA(II+2))
          II=II+3
 445     CONTINUE
      END IF
      IF (.NOT.ACCEPT) THEN
         IF (NPRBND.EQ.0) THEN
            MFGPOS=NFRG+1
            DO KLX=1,NMCFRG
               IF(IFMOMOV(KLX).NE.0) THEN
                   AVEXYZ(1,MFGPOS)=BAVEXYZ(1,MFGPOS)
                   AVEXYZ(2,MFGPOS)=BAVEXYZ(2,MFGPOS)
                   AVEXYZ(3,MFGPOS)=BAVEXYZ(3,MFGPOS)
                   MFGPOS=MFGPOS+1
               END IF
            END DO
         ELSE
            MFGPOS=NFRG+1
            DO KRN=1,NMCFRG
               AVEXYZ(1,MFGPOS)=BAVEXYZ(1,MFGPOS)
               AVEXYZ(2,MFGPOS)=BAVEXYZ(2,MFGPOS)
               AVEXYZ(3,MFGPOS)=BAVEXYZ(3,MFGPOS)
               MFGPOS=MFGPOS+1
            END DO
         END IF
      END IF
C
      KK=NFRG*3+1
      DO KKC=1,NMCFRG
        DELC(KK)=0.0d+00
        DELC(KK+1)=0.0d+00
        DELC(KK+2)=0.0d+00
        DELA(KK)=0.0d+00
        DELA(KK+1)=0.0d+00
        DELA(KK+2)=0.0d+00
        KK=KK+3
      END DO
C
      IF (ALLOCATED(IFMOMOV)) DEALLOCATE(IFMOMOV)
      RETURN
 9009 FORMAT(3X,'USING ALPHA=',F5.4,1X,'TO UPDATE DMAT.')
      end subroutine MC_FMO_BLOCK
C*MODULE GLOBOP  *DECK MC_PBC
C> @brief periodic boundary conditions check
C>
C> @details checks to see if any translations would move an atom
C>          outside the boundaries, and changes the translation to
C>          be within boundaries.
C>
C> @param AVEXYZ array of positional averages
C> @param DX change in x-coordinate
C> @param DY change in y-coordinate
C> @param DZ change in z-coordinate
C> @param moved returns whether any displacements were changed
C> @param MCFRGPO position in AVEXYZ of fragment
C>
C> @author Caleb Carlin
C>
      subroutine MC_PBC(AVEXYZ,DX,DY,DZ,MOVED,MCFRGPO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC,IPTRAJ
      DOUBLE PRECISION DX,DY,DZ
      DIMENSION AVEXYZ(3,*)
      MOVED=0
C     Moved keeps track of if any of the displacements have changed
C
               XTEMP=AVEXYZ(1,MCFRGPO)+DX
               YTEMP=AVEXYZ(2,MCFRGPO)+DY
               ZTEMP=AVEXYZ(3,MCFRGPO)+DZ
C
               IF(XTEMP.GT.XMAX) THEN
                  DX=DX - XRANGE
                  MOVED=1
               ELSE IF(XTEMP.LT.XMIN) THEN
                  DX=DX + XRANGE
                  MOVED=1
               END IF
               IF(YTEMP.GT.YMAX) THEN
                  DY=DY - YRANGE
                  MOVED=1
               ELSE IF(YTEMP.LT.YMIN) THEN
                  DY=DY + YRANGE
                  MOVED=1
               END IF
               IF(ZTEMP.GT.ZMAX) THEN
                  DZ=DZ - ZRANGE
                  MOVED=1
               ELSE IF(ZTEMP.LT.ZMIN) THEN
                  DZ=DZ + ZRANGE
                  MOVED=1
               END IF
      RETURN
      end subroutine MC_PBC
C*MODULE GLOBOP  *DECK MC_ENERGY
C> @brief energy driver for Monte Carlo
C>
C> @details If called on the zeroeth step, calls an energy calculation
C>          and automatically saves the coordinates and energy.
C>          Every other time, it calls an energy calculation and then
C>          compares the energy to see if it should be kept or rejected.
C>          If MCMIN is true, can be used to optimize the configuration
C>          every NSTMIN steps.
C>          Energy calls are made to ENERGX,SIGX, or FMOX depending on
C>          which tyes of atoms are present (i.e. MCTYP)
C>
C> @param IGLO tracks which overall step in the MC search
C> @param CMIN array that stores coordinates of minimum energy
C> @param PROVEC stores information of minimum energy configuration
C> @param CTVEC stores information of minimum energy configuration
C> @param ACCEPT intent out: whether the configuration is accepted or not
C> @param XRAN single random number
C> @param BETA Boltzmann constant times temperature
C> @param NSTMIN number of steps between optimizing geometry
C> @param MCTYP bitwise variable for which atoms are present
C>              (i.e. EFP and/or FMO)
C> @param COLD array of previous accepted coordinates
C> @param MXBF determines length of LENPV/LENCV
C>
C> @author Caleb Carlin
C>
C> @date January 2016, E.Guidez, write E6 and E7 dispersion energy
C>    Ccontributions to trj file
      subroutine MC_ENERGY(IGLO,CMIN,PROVEC,CTVEC,ACCEPT,XRAN,
     *           BETA,NSTMIN,MCTYP,COLD,MXBF)

      use DYNPOL_DIST
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXFRG=1050,MXDPPT=63000,ZERO=0.0D+00,
     *           MXAO=8192,MXDFG=5,MXFGPT=12000)
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CANFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GLOFMO/ MCMIN,IFMOID(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM,IHET
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /SIMEN / EPREV,EMIN,ALPHA,DAVE,XMIN,XMAX,YMIN,YMAX
     *               ,ZMIN,ZMAX,XRANGE,YRANGE,ZRANGE,SEPTOL
     *               ,DACRAT,UPDFAC,IPTRAJ
      COMMON /FRGNRG/ CCNRG,CDNRG,CQNRG,CONRG,DDNRG,DQNRG,QQNRG,
     *                ESNRG,REPNRG,POLNRG,DISNRG,DISNRG8,
     *                EDISD,CHTNRG,EDISP7,EDISD6

      DATA OPT/8HOPTIMIZE/,ENERGY/8HENERGY  /,CHECK/8HCHECK   /
      DIMENSION CMIN(*),COLD(*)
      DIMENSION PROVEC(MXBF,*),CTVEC(MXBF,*)
      DOUBLE PRECISION CMIN,PROVEC,CTVEC,COLD
      LOGICAL GOPARR,DSKWRK,ACCEPT,MASWRK,MCMIN

      TRUNTP=RUNTYP
      MXBF=0
      DO I = 1, NFRG
         MXBF=MAX(MXBF,NPBF(I))
      END DO
      LENPV=MXBF*NTMO
      LENCV=MXBF*NTCTMO
      CALL FLSHBF(6)
      
      IF (IGLO.EQ.0) THEN
        E=ZERO
        IF (MCMIN) THEN
           RUNTYP=OPT
           CALL SIGX(.FALSE.)
           RUNTYP=TRUNTP
        ELSE IF (iand(MCTYP,2).NE.0) THEN
          RUNTYP=ENERGY
C          RUNTYP=OPT 
          CALL FMOX(1)
          RUNTYP=TRUNTP
        ELSE
          CALL ENERGX
        ENDIF
C
C        IF(IEFPFMO.EQ.0.AND.ICOORD.NE.4) CALL FFSVMO(0,WRK)
C
C           SAVE, INITIALIZING THE "BEST POINT SO FAR" INFORMATION
C
        EPREV=E
        EMIN=E
        CALL FLSHBF(6)
C
        IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
           CALL DAREAD(IDAF,IODA,PROVEC,LENPV,267,0)
        END IF
        IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
           CALL DAREAD(IDAF,IODA,CTVEC,LENCV,269,0)
        END IF
        CALL STCOR(CMIN,PROVEC,CTVEC,MXBF)
C
        CALL FLSHBF(6)
        IGOMIN = IGLO
        IF(MASWRK) WRITE(IW,9290) IGLO,E
        CALL FLSHBF(6)
C
      ELSE
C
C-----IF-IGLO.GT.0
        E=ZERO
C---FOR THE EFP+PCM PART
        IF(IP_F.EQ.1) CALL MAKCVM
C---    IF(MASWRK) WRITE(IW,*)'IP_F-VALUE',IP_F,IPCM,IEFP
        IF(MCMIN.AND.(NSTMIN.EQ.1.OR.(MOD(IGLO,NSTMIN).EQ.0)))
     *    THEN
           TRUNTP=RUNTYP
           RUNTYP=OPT
           CALL SIGX(.FALSE.)
           RUNTYP=TRUNTP
           IF(IDPUNC.EQ.1) GOTO 450
        ELSE
C------PRADIPTA
C           IF((ICOORD.EQ.4).OR.(IP_F.EQ.1).OR.(NSTMIN.EQ.1)) THEN
             IF (iand(MCTYP,2).NE.0) THEN
               RUNTYP=ENERGY
               CALL FLSHBF(IW)
               CALL FMOX(1)
               RUNTYP=TRUNTP
             ELSE
               CALL ENERGX
             END IF
C  This portion added by Pradipta but had a bug that was never fixed
C  Likely related to PCM
C           ELSE
C             IF (iand(MCTYP,2).NE.0) THEN
C               RUNTYP=ENERGY
C               CALL FLSHBF(IW)
C               CALL FMOX(1)
C               RUNTYP=TRUNTP
C             ELSE
C               CALL ENERGX
C             END IF
C             CALL ONEEI
C             CALL WFN
C             CALL FFSVMO(1,WRK)
C            END IF
        END IF
C
         ACCEPT=.FALSE.
         IF(MASWRK.AND.NPRTGO.NE.2) WRITE(IW,*)'EPREV,E',EPREV,E,' '
C---------actual Monte Carlo step.
         IF(E.LT.EPREV) THEN
          ACCEPT=.TRUE.
         ELSE
          APROP = EXP(-(E-EPREV)*BETA)
          IF(MASWRK.AND.NPRTGO.NE.2) WRITE(IW,*)'APROP,XRAN',
     *              APROP,XRAN
          IF(APROP.GT.XRAN) THEN
            ACCEPT=.TRUE.
          END IF
         END IF
C
C           STORE (AND PRINT INFO ABOUT) THIS ENERGY/GEOMETRY/EFP DATA,
C           IF ITS THE BEST ENERGY FOUND SO FAR
C
         IF(E.LT.EMIN) THEN
           EMIN=E
           IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
             CALL DAREAD(IDAF,IODA,PROVEC,LENPV,267,0)
           END IF
           IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
             CALL DAREAD(IDAF,IODA,CTVEC,LENCV,269,0)
           END IF
           CALL STCOR(CMIN,PROVEC,CTVEC,MXBF)

           CALL PRMNC(CMIN)
           IGOMIN = IGLO
         END IF
      END IF
C
       CALL FLSHBF(6)
      IF(E.EQ.ZERO .AND. IGLO.EQ.0 .AND. EXETYP.NE.CHECK) THEN
         IF (MASWRK .AND. NPRTGO.NE.2) WRITE(IW,9100)
         CALL ABRT
      END IF
C
C                   ******
      IF(IGLO.EQ.0) RETURN
C                   ******
C
 450  CONTINUE
        IF(ACCEPT) THEN
C  USE THIS GEOMETRY AS STARTING POINT FOR NEXT STEP
C  AND KEEP THIS ENERGY AS REFERENCE ENERGY FOR NEXT GEOMETRY
C  AND REFINE DMAT TO GIVE A BETTER STEP
         NACC=NACC+1
         NACCT=NACCT+1
         EPREV=E
         IF(MASWRK .AND. NPRTGO.NE.2) WRITE(IW,9290) IGLO,E
         IGOFLG=1
C
         IF(MASWRK) THEN
            WRITE(IPTRAJ,9291) E,IGLO
            WRITE(IPTRAJ,9292) EDISD6,EDISP7

            CALL PRATM(IPTRAJ,1)
         END IF
C
         GO TO 500
C
        ELSE
C  RESTORE OLD COORDINATES
          IF(MASWRK.AND.NPRTGO.NE.2) WRITE(IW,*)
     *       'WE SHOULD BE HERE ONLY IF IT WAS REJECTED'

         CALL RSTCOR(COLD,PROVEC,CTVEC,MXBF)
         IF (NFRG.GT.0.AND.NTMO.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,PROVEC,LENPV,267,0)
         END IF
         IF (NFRG.GT.0.AND.NTCTMO.GT.0) THEN
            CALL DAWRIT(IDAF,IODA,CTVEC,LENCV,269,0)
         END IF

         NREJ = NREJ + 1
         NREJT = NREJT + 1

C    WRITES-THE-ENERGY-AND-COORDINATES-OF-THE-PREVIOUS-STEP
        END IF
C
 500  CONTINUE
      RETURN
 9100 FORMAT(1X,' ***  SCF DID NOT CONVERGE AT INITIAL GEOMETRY')
 9290 FORMAT(/3X,'ENERGY ACCEPTED AT GLOBAL SEARCH POINT',I6,
     *           ' IS ',F20.10)
 9291 FORMAT('ENERGY = ',F20.8,' ACCEPTED AT GLOBAL SEARCH POINT',I8)
 9292 FORMAT(1X,'E6 DISPERSION ENERGY',F16.10/
     *       1X,'E7 DISPERSION ENERGY',F16.10,//)
      end subroutine MC_ENERGY
C*MODULE GLOBOP *DECK MC_EFP_RAND
C> @brief randomize initial EFP configuration
C>
C> @details Move EFP groups away from the origin in a large cluster
C>          and then moves individual fragments away from the origin
C>          in small steps until there is no proximity alert
C>
C> @param RND array of random numbers
C> @param IMXRAN size of RND
C> @param PROVEC array holds information about minimum energy coord.
C> @param CTVEC array holds information about minimum energy coord.
C> @param IRN current position in RND
C> @param MXBF calculated in GLOPDR, ensures size of LENCV/LENPV
C> @param RIORD whether to choose frags to move randomly
C> @param IRTP method for generating random numbers
C> @param IFXFRG array of EFP fragments that are frozen
C> @param AVEXYZ array of coordinate averages
C>
C> @author Caleb Carlin
C> 
      Subroutine MC_EFP_rand(RND,
     *    PROVEC,CTVEC,IRN,MXBF,RIORD,IMXRAN,IRTP,IFXFRG
     *    ,AVEXYZ)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL MASWRK,ALERT,GOPARR,DSKWRK
      DIMENSION PROVEC(MXBF,*),CTVEC(MXBF,*),IFXFRG(*)
      DOUBLE PRECISION :: RND(*)
      INTEGER, ALLOCATABLE :: JMOVED(:)
      DIMENSION AVEXYZ(3,*)
C
      PARAMETER (MXAO=8192,ONE=1.0D+00,TWO=2.0D+00,
     *           MXPT=2000, MXFRG=1050, MXDFG=5, MXFGPT=12000,
     *           MXDPPT=63000,ZERO=0.0D+00,MXSHEF=1000,MXGEFP=4000)
C
      COMMON /EFPBAS/ EX(MXGEFP,MXDFG),CS(MXGEFP,MXDFG),
     *                CP(MXGEFP,MXDFG),CD(MXGEFP,MXDFG),
     *                CF(MXGEFP,MXDFG),CG(MXGEFP,MXDFG),
     *                PRNAME(MXFGPT),PRCORD(3,MXFGPT),EFZNUC(MXFGPT),
     *                KSTART(MXSHEF,MXDFG),KATOM(MXSHEF,MXDFG),
     *                KTYPE(MXSHEF,MXDFG),KNG(MXSHEF,MXDFG),
     *                KLOC(MXSHEF,MXDFG),KMIN(MXSHEF,MXDFG),
     *                KMAX(MXSHEF,MXDFG),NSHELL(MXDFG),NGAUSS(MXDFG),
     *                NATEF(MXDFG),NUMEF(MXDFG),NTPATM
      COMMON /EFPCT / NOCC(MXDFG),NVIR(MXDFG),NAO(MXDFG),NTAO,
     *                CTFOK(MXAO,MXDFG),NCTMO(MXDFG),NTCTMO
      COMMON /FRGLJP/ CORDLJ(3,MXPT),ELJCRD(3,MXFGPT),
     *                POTLJ(2,MXPT),ELJPOT(2,MXFGPT),
     *                LJNAME(MXPT),ELJNAM(MXFGPT),
     *                NLJPTS(MXFRG),NLJTTPT,ILJP,NMLJ(2)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGTYP/ NDFRG,ISET(MXFRG),NAMIDX(MXDFG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PAULMO/ CENTNM(MXFGPT),CENTCD(3,MXFGPT),NORB(MXFRG),
     *                NPBF(MXFRG),NTMO
      COMMON /POLTMP/ TCLPD(4*MXPT),TZLPD(4*MXPT),JNLPR(4*MXPT),
     *                JKFR(MXPT),JKLR(MXPT),NDPTS(MXFRG),NDTTPT
      CHARACTER*8 LJNAME,ELJNAM
      DATA RAND /8HRAND    /
C
      IF(MASWRK) THEN
           WRITE(6,*) ' '
           WRITE(6,*) 'RANDOMIZED CLUSTER CONSTRUCTION BEGINNING...'
           CALL FLSHBF(IW)
      END IF
C
         LENPV=MXBF*NTMO
         LENCV=MXBF*NTCTMO

         INIT=1
         IF(MASWRK) THEN
            CALL RNGEN(RND,IMXRAN,IRTP,INIT)
            CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
         ELSE
            CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
         END IF
         IRN=1
C
C SPREAD MOLECULES FAR APART IN ORDER TO PREVENT PROXIMITY ALERTS
C
         ISTOVR=IMXRAN-10
  441    CONTINUE
         IF(IRN.GE.ISTOVR) THEN
            INIT=1
            IF(MASWRK) THEN
               CALL RNGEN(RND,IMXRAN,IRTP,INIT)
               CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
            ELSE
               CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
            END IF
            IRN=1
         END IF
C
C  Spread out all atoms in a large cluster (max radius 300)
C  to avoid proximity alerts due to overlapping atoms
         NMST=0
         NPST=0
         NLJST=0
         NDPST=0
         NRST=0
         NDST=0
         NATST=0
         NORST=0
         NCTMOST=0
         DO 867 INF=1,NFRG
            IF(IRN.GE.ISTOVR) THEN
               INIT=1
               IF(MASWRK) THEN
                  CALL RNGEN(RND,IMXRAN,IRTP,INIT)
                  CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
               ELSE
                  CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
               END IF
               IRN=1
            END IF
            DX = 3.0D+02*(TWO*RND(IRN  )-ONE)-AVEXYZ(1,INF)
            DY = 3.0D+02*(TWO*RND(IRN+1)-ONE)-AVEXYZ(2,INF)
            DZ = 3.0D+02*(TWO*RND(IRN+2)-ONE)-AVEXYZ(3,INF)
            IRN=IRN+3
            IF(IFXFRG(INF).EQ.0) THEN
            CALL EFDSPL(INF,DX,DY,DZ,ZERO,ZERO,ZERO,
     *                  NMST,NPST,NLJST,NDPST,NRST,NDST,NATST,NORST,
     *                  PROVEC,NCTMOST,CTVEC,MXBF)
            CALL MC_CHANGE_AVEXYZ(AVEXYZ,DX,DY,DZ,ZERO,ZERO,ZERO
     *      ,INF,ZERO,ZERO,ZERO)
            END IF
            NMST  = NMST  + NMPTS(INF)
            NPST  = NPST  + NPPTS(INF)
            NLJST = NLJST + NLJPTS(INF)
            NDPST = NDPST + NDPPTS(INF)
            NRST  = NRST  + NRPTS(INF)
            NDST  = NDST  + NDPTS(INF)
            NATST = NATST + NATEF(ISET(INF))
            NORST = NORST + NORB(INF)
            NCTMOST = NCTMOST + NCTMO(ISET(INF))
  867    CONTINUE
         CALL PXALRT(ALERT,1)
         IF(ALERT) GO TO 441
C
C KEEPS TRACK OF WHICH FRAGMENTS HAVE ALREADY BEEN PLACED IN CLUSTER
C
         ALLOCATE(JMOVED(NFRG))
         IF(RIORD.EQ.RAND) THEN
            DO INF=1,NFRG
               JMOVED(INF)=0
            ENDDO
         END IF
C
         DO 111 IMF=1,NFRG
C
C       This is to be safe
         IF(IRN.GE.ISTOVR) THEN
            INIT=1
            IF(MASWRK) THEN
               CALL RNGEN(RND,IMXRAN,IRTP,INIT)
               CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
            ELSE
               CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
            END IF
            IRN=1
         END IF
C
C CHOOSE A FRAGMENT WE HAVE NOT YET MOVED
C
         IF(RIORD.EQ.RAND) THEN
            IRN=1
  770       CONTINUE
            INF=INT(NFRG*RND(IRN))+1
            IRN=IRN+1
C            IF(IRN.GT.ISTOVR) IRN=1
            IF(INF.GT.NFRG) GO TO 770
            IF(JMOVED(INF).EQ.1) GO TO 770
            JMOVED(INF)=1
         ELSE
            INF=IMF
         END IF
C
         NMST=0
         NPST=0
         NLJST=0
         NDPST=0
         NRST=0
         NDST=0
         NATST=0
         NORST=0
         NCTMOST=0
         DO 238 IJK=1,INF-1
            NMST  = NMST  + NMPTS(IJK)
            NPST  = NPST  + NPPTS(IJK)
            NLJST = NLJST + NLJPTS(IJK)
            NDPST = NDPST + NDPPTS(IJK)
            NRST  = NRST  + NRPTS(IJK)
            NDST  = NDST  + NDPTS(IJK)
            NATST = NATST + NATEF(ISET(IJK))
            NORST = NORST + NORB(IJK)
            NCTMOST = NCTMOST + NCTMO(ISET(IJK))
  238    CONTINUE
         IFIRST=1
C
C WE RETURN HERE EACH TIME WE GET A PROXIMITY ALERT
C FOR THE CURRENT FRAGMENT
C
  729    CONTINUE
C         IF(IRN.GE.ISTOVR) THEN
            INIT=1
            IF(MASWRK) THEN
               CALL RNGEN(RND,IMXRAN,IRTP,INIT)
               CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
            ELSE
               CALL DDI_BCAST(2600,'F',RND,IMXRAN,MASTER)
            END IF
            IRN=1
C         END IF
C
C FIRST TIME WE MOVE FRAGMENT, START AT ORIGIN
C
         IF(IFIRST.EQ.1) THEN
            DX = 3.0D+00*(TWO*RND(IRN  )-ONE)-AVEXYZ(1,INF)
            DY = 3.0D+00*(TWO*RND(IRN+1)-ONE)-AVEXYZ(2,INF)
            DZ = 3.0D+00*(TWO*RND(IRN+2)-ONE)-AVEXYZ(3,INF)
            DA = 3.141592654D+00*(TWO*RND(IRN+3)-ONE)
            DB = 3.141592654D+00*(TWO*RND(IRN+4)-ONE)
            DC = 3.141592654D+00*(TWO*RND(IRN+5)-ONE)
         ELSE
            DX = 3.0D+00*(TWO*RND(IRN  )-ONE)
            DY = 3.0D+00*(TWO*RND(IRN+1)-ONE)
            DZ = 3.0D+00*(TWO*RND(IRN+2)-ONE)
            DA = 3.141592654D+00*(TWO*RND(IRN+3)-ONE)
            DB = 3.141592654D+00*(TWO*RND(IRN+4)-ONE)
            DC = 3.141592654D+00*(TWO*RND(IRN+5)-ONE)
         END IF
         IRN=IRN+6
C
C  Ensure boundary conditions are met
C 
         MOVED=1
         DO WHILE (MOVED==1)
            CALL MC_PBC(AVEXYZ,DX,DY,DZ,MOVED,INF)
         END DO
         IF(IFXFRG(INF).EQ.0) THEN
            CALL EFDSPL(INF,DX,DY,DZ,DA,DB,DC,
     *        NMST,NPST,NLJST,NDPST,NRST,NDST,NATST,NORST,
     *        PROVEC,NCTMOST,CTVEC,MXBF)
            CALL PXALRT(ALERT,1)
            CALL MC_CHANGE_AVEXYZ(AVEXYZ,DX,DY,DZ,ZERO,ZERO,
     *       ZERO,INF,ZERO,ZERO,ZERO)
            CALL MC_CHANGE_AVEXYZ(AVEXYZ,ZERO,ZERO,ZERO,DA,
     *       DB,DC,INF,AVEXYZ(1,INF),AVEXYZ(2,INF),
     *       AVEXYZ(3,INF))
         IF(ALERT) THEN
            IFIRST=0
            GO TO 729
         END IF
         END IF
  111    CONTINUE
         IF (NFRG.GT.0.AND.NTMO.GT.0)
     *       CALL DAWRIT(IDAF,IODA,PROVEC,LENPV,267,0)
         IF (NFRG.GT.0.AND.NTCTMO.GT.0)
     *       CALL DAWRIT(IDAF,IODA,CTVEC,LENCV,269,0)
C
      DEALLOCATE(JMOVED)
      RETURN
      END SUBROUTINE MC_EFP_RAND
C*MODULE GLOBOP  *DECK MC_FMO_SUBMC
C> @brief performs MC search on a single fragment
C>
C> @details works with FMO and ab initio groups
C>          Randomly translates single atoms and then
C>          calculates the energy of the entire system.
C>          At present, only a minimum separation is checked
C>          so a large number of steps could lead to bond
C>          breaking.  The lowest energy coordinates are 
C>          returned.
C>
C> @author Caleb Carlin
C>
C> @param IFG number of fragment used
C> @param NSMSTP number of steps to perform
C> @param IRTP method for calculation of random numbers
C> @param BETA temperature dependent, determines chance of
C>             accepting a higher energy coordinate
C>
      subroutine MC_FMO_SUBMC(IFG,NSMSTP,IRTP,BETA) 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000)
      COMMON /FUNCT / E,EG(3*MXATM)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /GLOFMO/ MCMIN,IFMOID(MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DATA ENERGY/8HENERGY  /
      LOGICAL :: MASWRK,GOPARR,DSKWRK,ACCEPT,ALERT,MCMIN
      INTEGER :: NIFG,II,JJ,ITR,KTR,IRTP,NSMSTP,IFG
      DOUBLE PRECISION, allocatable :: CSMOLD(:,:,:),CSMMIN(:,:),
     *            SMRND(:)
      INTEGER :: ISMRN,ISMXRAN,NSMACPT,NSMRJT
      INTEGER :: NSMPRX, IPICK
      DOUBLE PRECISION :: EPREV,EMIN,DX,DY,DZ,SMSEP,APROP,BETA,
     *           RUNTYP,TRUNTP
C
      NIFG=0
      DO ITR=1,NAT
         IF (IFMOID(ITR).EQ.IFG) THEN
             NIFG=NIFG+1
         END IF
      END DO
      IF(MASWRK) THEN
          WRITE(IW,*) 'Number of atoms in fragment is',NIFG
      END IF
      ISMXRAN=5*NSMSTP*1000
      CALL FLSHBF(6)
C
C  for CSMOLD, (1,X,2) is the atom number in C
      Allocate (CSMOLD(3,NIFG,2),CSMMIN(3,NIFG))
      Allocate (SMRND(ISMXRAN))
C
      INIT=1
      IF(MASWRK)THEN
          CALL RNGEN(SMRND,ISMXRAN,IRTP,INIT)
          CALL DDI_BCAST(2600,'F',SMRND,ISMXRAN,MASTER)
      ELSE
          CALL DDI_BCAST(2600,'F',SMRND,ISMXRAN,MASTER)
      END IF
C
C  Initialize local arrays
      ISMRN=1
      II=1
      DO JTR=1,NAT
         IF (IFMOID(ITR).EQ.IFG) THEN
             CSMOLD(1,II,1)=C(1,JTR)
             CSMOLD(2,II,1)=C(2,JTR)
             CSMOLD(3,II,1)=C(3,JTR)
             CSMMIN(1,II)=C(1,JTR)
             CSMMIN(2,II)=C(2,JTR)
             CSMMIN(3,II)=C(3,JTR)
             CSMOLD(1,II,2)=DBLE(JTR)
             II=II+1
         END IF
      END DO
C  these values are local
      EPREV=E
      EMIN=E
      SMSEP=0.6D+00
      NSMPRX=0
      NSMACPT=0
      NSMRJT=0
C
      DO LTR=1,NSMSTP
C  loop over the number of small MC steps
C
          IPICK=INT(SMRND(ISMRN)*DBLE(NIFG))+1
          ISMRN=ISMRN+1
C
          NATOM=INT(CSMOLD(1,IPICK,2))
          C(1,NATOM)=C(1,NATOM)+SMSEP*(SMRND(ISMRN)*2.0D+00-1.0D+00)
          C(2,NATOM)=C(2,NATOM)+SMSEP*(SMRND(ISMRN+1)*2.0D+00-1.0D+00)
          C(3,NATOM)=C(3,NATOM)+SMSEP*(SMRND(ISMRN+2)*2.0D+00-1.0D+00)
          ISMRN=ISMRN+3
C
C  Proximity test
          ALERT=.FALSE.
          DO KTR=1,NIFG
              IF (KTR.NE.IPICK) THEN
                  DX=C(1,NATOM)-CSMOLD(1,KTR,1)
                  DY=C(2,NATOM)-CSMOLD(2,KTR,1)
                  DZ=C(3,NATOM)-CSMOLD(3,KTR,1)
                  DX=SQRT(DX**2+DY**2+DZ**2)
                  IF (DX.LT.SMSEP) THEN
                     ALERT=.TRUE.
                     EXIT
                  END IF
              END IF
          END DO
          call DDI_BCAST(666,'I',ALERT,1,MASTER)
C
          IF (ALERT) THEN
              NSMPRX=NSMPRX+1
              ACCEPT=.FALSE.
          ELSE
C  We set RUNTYP=ENERGY before calling the routine
              IF (NFG.GT.0) THEN
                  TRUNTP=RUNTYP
                  RUNTYP=ENERGY
                  CALL FLSHBF(6)
                  CALL FMOX(1)
                  RUNTYP=TRUNTP
              ELSE
                  CALL ENERGX
              END IF

C  MC comparison of energies
              ACCEPT=.FALSE.
              IF (E.LT.EPREV) THEN
                  ACCEPT=.TRUE.
              ELSE
                  APROP = EXP(-(E-EPREV)*BETA)
                  IF(APROP.GT.SMRND(ISMRN)) THEN
                      ACCEPT=.TRUE.
                  END IF
                  ISMRN=ISMRN+1
              END IF
          END IF
C          
          IF (ACCEPT) THEN
              NSMACPT=NSMACPT+1
              CSMOLD(1,IPICK,1) = C(1,NATOM)
              CSMOLD(2,IPICK,1) = C(2,NATOM)
              CSMOLD(3,IPICK,1) = C(3,NATOM)
              EPREV=E
C
              If (E.LT.EMIN) THEN
                  CSMMIN(1,IPICK) = C(1,NATOM)
                  CSMMIN(2,IPICK) = C(2,NATOM)
                  CSMMIN(3,IPICK) = C(3,NATOM)
                  EMIN=E
              END IF
          ELSE
              IF(.NOT.ALERT) NSMRJT=NSMRJT+1
              C(1,NATOM) = CSMOLD(1,IPICK,1)
              C(2,NATOM) = CSMOLD(2,IPICK,1)
              C(3,NATOM) = CSMOLD(3,IPICK,1)
              E=EPREV
          END IF
      END DO
C
      JJ=1
      DO MTR=1,NAT
         IF (IFMOID(ITR).EQ.IFG) THEN
             C(1,MTR)=CSMMIN(1,JJ)
             C(2,MTR)=CSMMIN(2,JJ)
             C(3,MTR)=CSMMIN(3,JJ)
             JJ=JJ+1
         END IF
      END DO
C
      IF(MASWRK) THEN
           WRITE(IW,*)'-------Sub MC results----------'
           WRITE(IW,*) 'NUMBER OF ENERGY EVALUATIONS =',
     *       NSMRJT+NSMACPT
           WRITE(IW,*) 'NUMBER OF PROXIMITY ALERTS =',NSMPRX
           WRITE(IW,*) 'NUMBER OF REJECTED ENERGIES =',NSMRJT
           WRITE(IW,*) 'NUMBER OF ACCEPTED ENERGIES =',NSMACPT
           WRITE(IW,*) 'FINAL MINIMUM ENERGY IS =',EMIN
           WRITE(IW,*)'-------------------------------'
      END IF
C
      DEALLOCATE(CSMOLD,CSMMIN,SMRND)
      RETURN
      END SUBROUTINE
C*MODULE GLOBOP  *DECK MC_AI_FRGCONV
C> @brief converts shorthand aifrg to full array
C>
C> @details for aifrg that uses 0,N,-M,0 style input
C>    where N is the first atom in a group and M is the last
C>    Reads through the array, creates a new array with the
C>    traditional format and then copies it back onto aifrg
C>
C> @author Caleb Carlin
C>
C> @param NAIFG number of ab initio groups
C> @param AIFRG integer array that records which group each
C>              atom is in
C>        
      subroutine mc_ai_frgconv(NAIFG,AIFRG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension AIFRG(*)
      integer :: aifrg
      integer, allocatable :: aifrgg(:)
      PARAMETER (MXATM=2000)
      logical GOPARR,DSKWRK,MASWRK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c
c     process Gaussian-like AIFRG, indicated by AIFRG(1)=0 (therefore, skip
c     AIFRG(1)).  Based on subroutine fmogind in fmolib.src
c
      ALLOCATE(aifrgg(NAT))
      ifg=1
      nifg=0
      natot=0
      i=1
  100 continue
        i=i+1
        if(i.ge.nat) goto 200
        now=aifrg(i)
        if(now.eq.0) then
          if(ifg.eq.naifg) goto 200
          if(nifg.eq.0) then
            if(maswrk) write(iw,*) 'No atoms in fragment',ifg
            DEALLOCATE(AIFRGG)
            call abrt
          endif
          ifg=ifg+1
          natot=natot+nifg
          nifg=0
          goto 100
        endif
        if(aifrg(i+1).lt.0) then
          i=i+1
          next=abs(aifrg(i))
        else
          next=now
        endif
        do j=now,next
          if(j.gt.nat) then
            if(maswrk) write(iw,9010) i,ifg,j
            DEALLOCATE(AIFRGG)
            call abrt
          endif
          nifg=nifg+1
          aifrgg(j)=ifg
        enddo
      goto 100
  200 continue
      natot=natot+nifg
      if(ifg.ne.naifg.or.natot.ne.nat) then
        if(maswrk) write(iw,9000) ifg,naifg,natot,nat
        DEALLOCATE(AIFRGG)
        call abrt
      endif
      call icopy(nat,aifrgg,1,aifrg,1)
      DEALLOCATE(AIFRGG)
      return
 9000 format(/1x,'Bad aifrg: naifg(aifrg,naifg)=',2I6,
     *           ' nat(naifg,glbfrg)=',2I7,
     * /1x,'Perhaps you forgot to add the final 0 at the end of aifrg?')
 9010 format(/1x,'Bad aifrg, check element',I6,', frg',i5,
     *           ' too many atoms:',I6)
      end
C
C*MODULE GLOBOP  *DECK MC_TRANSLATE
C>  @brief  performs translation of non-EFP MC group
C>
C>  @details checks if the translation will violate the
C>           boundary conditions and then performs the
C>           trasnlation of an FMO fragment or
C>           ab initio group
C>
C>  @author Caleb Carlin
C>
C>  @param DX translation along x-axis
C>  @param DY translation along y-axis
C>  @param DZ translation along z-axis
C>  @param IFRG number of the fragment to be moved
C>  @param MOVED flag that tracks if the boundary condition is broken
C>  @param AVEXYZ array of coordinate averages
C>  @param MCFGPOS position of IFRG in AVEXYZ
C
      Subroutine mc_translate(DX,DY,DZ,IFRG,MOVED,AVEXYZ,MCFGPOS)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (MXATM=2000)
      LOGICAL MCMIN
      COMMON /GLOFMO/ MCMIN,IFMOID(MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      DIMENSION AVEXYZ(3,*)

      CALL MC_PBC(AVEXYZ,DX,
     *      DY,DZ,MOVED,MCFGPOS)

      DO IIJ=1,NAT
         IF (IFMOID(IIJ).EQ.IFRG) THEN
            C(1,IIJ)=C(1,IIJ)+DX
            C(2,IIJ)=C(2,IIJ)+DY
            C(3,IIJ)=C(3,IIJ)+DZ
         END IF
      END DO

      END subroutine mc_translate
C
C*MODULE GLOBOP  *DECK MC_ROTATE
C>  @brief performs rotation of non-EFP MC group
C>
C>  @details rotates a fragment around a given anchor
C>           point.  The default anchor is the origin.
C>  @author Caleb Carlin
C>
C>  @param DA rotation angle alpha
C>  @param DB rotation angle beta
C>  @param DG rotation angle gamma
C>  @param IFRG number of the fragment to be moved
C>  @param AA x coordinate of anchor point
C>  @param AB y coordinate of anchor point
C>  @param AG z coordinate of anchor point
C
      Subroutine mc_rotate(DA,DB,DG,IFRG,AA,AB,AG)

      implicit double precision (A-H,O-Z)

      PARAMETER (MXATM=2000)
      LOGICAL MCMIN
      COMMON /GLOFMO/ MCMIN,IFMOID(MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *               ZAN(MXATM),C(3,MXATM),IAN(MXATM)

C       Double Precision :: AVEXYZ(3)
       DO IIJ=1,NAT
          IF (IFMOID(IIJ).EQ.IFRG) THEN
             XOLD=C(1,IIJ)-AA
             YOLD=C(2,IIJ)-AB
             ZOLD=C(3,IIJ)-AG
          C(1,IIJ)=XOLD*COS(DB)*COS(DG)-YOLD*(COS(DA)*SIN(DG)-
     *     SIN(DA)*SIN(DB)*COS(DG))+ZOLD*(SIN(DA)*SIN(DG)
     *     +COS(DA)*SIN(DB)*COS(DG))
          C(2,IIJ)=XOLD*COS(DB)*SIN(DG)+YOLD*(COS(DA)*COS(DG)+
     *     SIN(DA)*SIN(DB)*SIN(DG))-ZOLD*(SIN(DA)*COS(DG)-
     *     COS(DA)*SIN(DB)*SIN(DG))
          C(3,IIJ)=YOLD*SIN(DA)*COS(DB)-XOLD*SIN(DB)+
     *     ZOLD*COS(DA)*COS(DB)
              C(1,IIJ)=C(1,IIJ)+AA
              C(2,IIJ)=C(2,IIJ)+AB
              C(3,IIJ)=C(3,IIJ)+AG
          END IF
       END DO

       RETURN

       End subroutine mc_rotate
C
C*MODULE GLOBOP  *DECK MC_CHANGE_AVEXYZ
C>  @brief updates array of position averages
C>
C>  @details each group (EFP/FMO/AI) has an average
C>           stored in avexyz.  Any change to the groups must
C>           be matched with a call to this subroutine except
C>           in the case where the array is reverted to a
C>           saved state, which is handled elsewhere.  To
C>           avoid errors, translations and rotations should
C>           be called separately.
C>           
C>  @author Caleb Carlin
C>
C>  @param AVEXYZ array of positional averages
C>  @param DX change in x choordinate
C>  @param DY change in y choordinate
C>  @param DZ change in z choordinate
C>  @param DA rotation angle alpha
C>  @param DB rotation angle beta
C>  @param DG rotation angle gamma
C>  @param FRAG number of the fragment to be moved
C>  @param AA x coordinate of anchor point
C>  @param AB y coordinate of anchor point
C>  @param AG z coordinate of anchor point
C
       Subroutine MC_CHANGE_AVEXYZ(AVEXYZ,DX,DY,DZ,DA,DB,DG,FRAG,
     *      AA,AB,AG)

       IMPLICIT NONE

       DOUBLE PRECISION :: AVEXYZ,DX,DY,DZ,DA,DB,DG,AA,AB,AG
       DIMENSION AVEXYZ(3,*)
       DOUBLE PRECISION :: TRANSUM,ROTSUM
       DOUBLE PRECISION :: XOLD,YOLD,ZOLD
       INTEGER :: FRAG

       TRANSUM=DX+DY+DZ
       ROTSUM= DA+DB+DG

       IF (TRANSUM.NE.0.0d+00) THEN
          AVEXYZ(1,FRAG)=AVEXYZ(1,FRAG)+DX
          AVEXYZ(2,FRAG)=AVEXYZ(2,FRAG)+DY
          AVEXYZ(3,FRAG)=AVEXYZ(3,FRAG)+DZ
       ELSE IF (ROTSUM.NE.0) THEN
          XOLD=AVEXYZ(1,FRAG)-AA
          YOLD=AVEXYZ(2,FRAG)-AB
          ZOLD=AVEXYZ(3,FRAG)-AG
          AVEXYZ(1,FRAG)=XOLD*COS(DB)*COS(DG)-YOLD*(COS(DA)*SIN(DG)-
     *    SIN(DA)*SIN(DB)*COS(DG))+ZOLD*(SIN(DA)*SIN(DG)
     *     +COS(DA)*SIN(DB)*COS(DG))+AA
          AVEXYZ(2,FRAG)=XOLD*COS(DB)*SIN(DG)+YOLD*(COS(DA)*COS(DG)+
     *     SIN(DA)*SIN(DB)*SIN(DG))-ZOLD*(SIN(DA)*COS(DG)-
     *     COS(DA)*SIN(DB)*SIN(DG))+AB
          AVEXYZ(3,FRAG)=YOLD*SIN(DA)*COS(DB)-XOLD*SIN(DB)+
     *     ZOLD*COS(DA)*COS(DB)+AG
       ELSE
          WRITE(6,*)'Warning: something is wrong with the average
     *    coordinate array update.'
       END IF

       RETURN
       END SUBROUTINE
