C 22 Oct 14 - DGF - pad common blocks
C
C
C*MODULE LOCAL   *DECK LOCAL_LMOSVD
c> @brief      Local_lmosvd calls local_ppasvd routines.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c> @details    Local_lmosvd grabs memory and calls svd routines.
c>             For VVOS, IORBF1 can only be DAF file 15 right now.
c>             Otherwise, we need to re-visit some file definitions.
c>
c> @date December 13, 2012-Aaron West
c> -Added ORMAS svd localization.
c>
c> @date December 20, 2012-Aaron West
c> -Stripped out the use of LVNACT.   We do not need to do all
c>  confusing sorting in LOCAL_PPASVDCORE and LOCAL_PPASVD.
c>  We can just grab out the orbital transformation and use its
c>  block-diagonal form to get the LMOs at the end in one matvec.
c>  We still keep core and valence manipulations separate.
C>
C> @date January 16, 2013-Aaron West
C> -Added VVOS option.
C>
C> @date January 30, 2013-Aaron West
C> -Added ISVDOP to ORNTMO common block.
C> This run gives special option for SVD runs.
C>
C> @date February 23, 2013-Aaron West
C> -Enable MO overlaps with MOs from VVOS i.e. ISVDOP=10
C> This run gives special option for SVD runs.
C>
C> @date March 13, 2013-Aaron West
C> -Allowed for RHF wave functions.
C>
C> @date April 01, 2013-Aaron West
C> -Adapt for extloc runs.
C>
C> @date April 01, 2013-Aaron West
C> -Adapt for spherical harmonics.
C>
C> @date May 17, 2013-Aaron West
C> -For extloc=atmnos, force out the valence density matrix.
C>  Some new dimensioning is required.
C>  I forced the extloc option through the routine.
C>  Results were re-checked for this difficult option.
C>
C> @date May 18, 2013-Aaron West
C> -For MCSCF-type runs and externalizing runs,
C>  the MCSCF SVD orbitals are now requested.
C>  Right now, MCSCF+extloc=atmnos result in
C>  ER localized orbitals and ext. nos.
C>  that preserve the waveFxN invariance.
C>  However, MCSCF+extloc=atmnos runs mix
C>  all orbitals in the MBS valence for the SVD orbitals.
C>
C> @date July 12, 2013-Aaron West
C> -Small correction for EXTLOC runs with MCSCF.
C>  Density matrix is now handled with care.
C>  This fix does not affect:
C>  non-EXTLOC runs or Hartree-Fock EXTLOC runs.
C>
C> @date August 12, 2013-Aaron West
C> -Create new degeneracy sorting routine for external orbitals.
C>
C> @date November 20, 2013-Aaron West
C> -Preserve nspace for extloc runs that are of the rmc persuasion.
C>
C> @date December 2, 2013-Aaron West
C> -Clean up vvos redimensioning routines.
C>
C> @date February 27, 2014-Aaron West
C> -Added CCTYP for SVD for internal valence only.
C>
C> @param IORBF1 indicates daf dict file with starting orbitals
C>               from which the localized orbitals are formed.
      SUBROUTINE LOCAL_LMOSVD(IORBF1)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C
C     VARS
      LOGICAL KEEPER,COMBO,SWITCH_ORBS,SVDEXTOPT,
     *        SVDAOS,SVD_INVAR,SVD_AOSCF
      INTEGER NGOTMX,LAST,LOADFM,NDAWN0,NDAWN1,
     *        LEIG1,LIWRK,LS,LS2,LSAOMO,LSV,LSVMBS,LNATLAB,LUVEC,LVOLD,
     *        LVSAV,LEIGSAV,LEIGTMP,LVTVECSAV,LIGRPLAB,LIATLAB,
     *        LIORDBIG,LIORDBIG2,
     *        LIPOSMBS,LILENMBS,LIPOSCOR,LILENCOR,
     *        LVTMP,LVTVEC,LWRKSVD,LWSPHER,LDENOSAV,
     *        IEXTSPACE,LIATEXT,NATEXT
      INTEGER ISIZE_FCCWFN
      INTEGER NERR,I,ITMP,IORBF1,ISIZSVD,ISIZSVD2,
     *        L0,L1,L2,L3,IMBS,IMBS2,L0MBS,L2MBS,
     *        NCORTOT,NCORSV,NACTBS,NAOTOT,NAOTRI,LDSVD,
     *        NSKIP,NSKIP2,NSKIP_SING,NVIR2,
     *        NACTSV,NACT,NACTSV_OCC,NACT_OCC
      INTEGER IDENFIL,IDENSIZ,IOPTNON
C-----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       CHECK,EOMCC,ORMAS,RHF,RMC,ROHF,RNONE
C-----------------------------------------------------------------------
C     NEW CODING STANDARDS VARS
C
      DOUBLE PRECISION :: C
      DOUBLE PRECISION :: ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER LIMLOW,LIMSUP,LIATMSTA,LIATMSTA2
C
      DOUBLE PRECISION :: QMTTOL
      INTEGER ISPHER
C
      DOUBLE PRECISION ::
     *       CVGCI,CVGEOM,GRPEOM
      INTEGER NSTEOM,NOACT,NUACT,
     *        MOACTCC,MTHTRIP,MTHCI,MTHEOM,MTHINIT,
     *        MAXCI,MAXEOM,MICCI,MICEOM,IROOTCC,
     *        IPROPCC,IPROPCCE
C
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      LOGICAL FDIRCT,QCORR
      DOUBLE PRECISION ::
     *       C0SQ
      INTEGER LMSTA_SAV,NSPACE_SAV,NSPACE,
     *        MSTA,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,IBMA,
     *        IDIMFCC,LBST,NREF0
C
      DOUBLE PRECISION :: X
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION ::
     *       FINALCI,METHOD,CISTEP,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT
C
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
      INTEGER ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      LOGICAL SOME
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      INTEGER MXATM,MXAO,MXNORO
      PARAMETER (MXATM=2000, MXAO=8192, MXNORO=250)
C-----------------------------------------------------------------------
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /EOMPAR/ CVGCI,CVGEOM,GRPEOM,NSTEOM(8),NOACT,NUACT,
     *                MOACTCC(MXAO),MTHTRIP,MTHCI,MTHEOM,MTHINIT,
     *                MAXCI,MAXEOM,MICCI,MICEOM,IROOTCC(2),
     *                IPROPCC,IPROPCCE
C                            SPECIAL NOTE:
C                            IF CHANGE SIZE OF MSTA ARRAY HERE,
C                            ALSO CHANGE ISIZE_FCCWFN VARIABLE BELOW
C                            IN A SINGLE PLACE.
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
C
C     DATA STUFF
      DATA CHECK/8HCHECK   /
      DATA EOMCC/8HEOM-CCSD/
      DATA ORMAS/8HORMAS   /
      DATA RHF/8HRHF     /
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
      DATA RNONE/8HNONE    /
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     PRINT STUFF
      IF(SOME) WRITE(IW,9000)
C
C     SET UP SOME ORBITAL DIMENSIONS
      ISIZE_FCCWFN=51
      CALL LOCAL_SVDORB_VARS(
     *     L0,L1,L2,L3,
     *     NCORTOT,IMBS,IMBS2,L0MBS,L2MBS,
     *     NAOTOT,NAOTRI)
C
C
C----------------------------------------------------
C----------------------------------------------------
C     MAKE SOME ERROR OUTS
      NERR=0
      COMBO=CISTEP.EQ.ORMAS.OR.SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF
      IF(.NOT.COMBO.AND.IVVOS.NE.0) THEN
        IF(MASWRK) WRITE(IW,9050)
        NERR=NERR+1
      ENDIF
      IF(IVVOS.NE.0.AND.IORBF1.NE.15) THEN
        IF(MASWRK) WRITE(IW,9052)
        NERR=NERR+1
      ENDIF
      IF(EXTLOC.NE.RNONE.AND.IVVOS.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9053)
        NERR=NERR+1
      ENDIF
      IF(EXTLOC.NE.RNONE.AND.ILOCAL.EQ.4) THEN
        IF(MASWRK) WRITE(IW,9054)
        NERR=NERR+1
      ENDIF
      IF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
        IF(IVVOS.EQ.0) THEN
          IF(MASWRK) WRITE(IW,9055)
          NERR=NERR+1
        ENDIF
      ENDIF
      IF(ORMFUL.AND.EXTLOC.NE.RNONE) THEN
        IF(MASWRK) WRITE(IW,9056)
        NERR=NERR+1
      ENDIF
      COMBO=SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF
      IF(ORMFUL.AND.COMBO) THEN
        IF(MASWRK) WRITE(IW,9057)
        NERR=NERR+1
      ENDIF
      IF(CCTYP.NE.RNONE) THEN
        IF(CCTYP.NE.EOMCC) THEN
          IF(MASWRK) WRITE(IW,9058)
          NERR=NERR+1
        ENDIF
        IF(IPROPCC.NE.1.AND.IPROPCCE.NE.1) THEN
          IF(MASWRK) WRITE(IW,9058)
          NERR=NERR+1
        ENDIF
        IF(SCFTYP.NE.RHF) THEN
          IF(MASWRK) WRITE(IW,9058)
          NERR=NERR+1
        ENDIF
        IF(EXTLOC.NE.RNONE) THEN
          IF(MASWRK) WRITE(IW,9058)
          NERR=NERR+1
        ENDIF
        IF(IORBF1.NE.15) THEN
          IF(MASWRK) WRITE(IW,9059)
          NERR=NERR+1
        ENDIF
      ENDIF
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C----------------------------------------------------
C----------------------------------------------------
C
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C     SETUP ANY VARIABLES THAT USE ISDVOP.
C     NOTE: THE DEFAULT COMES FROM LMOINP ROUTINE.
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C--------------------------------------------------------------------
      SVDEXTOPT=.FALSE.
      SVDAOS=.FALSE.
      SVD_INVAR=.FALSE.
      SVD_AOSCF=.FALSE.
      IF(SOME) WRITE(IW,9070)
      CALL FLSHBF(IW)
C
      IF(SCFTYP.EQ.RMC) THEN
        IF(ISVDOP.EQ.0) THEN
        ELSEIF(ISVDOP.EQ.4) THEN
          SVD_INVAR=.TRUE.
        ELSEIF(ISVDOP.EQ.10) THEN
C         USE THE TRUE AOS THAT MIKE HAS STORED UP FOR VVOS.
          SVD_AOSCF=.TRUE.
        ELSE
          IF(MASWRK) WRITE(IW,9090)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
      ELSEIF(SCFTYP.EQ.RHF.AND.ISVDOP.EQ.0) THEN
        SVD_AOSCF=.TRUE.
      ELSEIF(SCFTYP.EQ.ROHF.AND.ISVDOP.EQ.0) THEN
        SVD_AOSCF=.TRUE.
      ELSE
        IF(MASWRK) WRITE(IW,9090)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C     PUT SOME RESTRICTIONS ON EXTLOC.
      IF(EXTLOC.NE.RNONE.AND.SCFTYP.EQ.RMC) THEN
        SVDAOS=.FALSE.
        SVD_INVAR=.FALSE.
        SVD_AOSCF=.TRUE.
      ENDIF
C
C---------------------------------------------------
C     PRINT ANY OTHER POSSIBLE OPTIONS HERE.
C---------------------------------------------------
      IF(SOME) THEN
        IF(ISVDOP.EQ.0.AND..NOT.SVD_AOSCF) WRITE(IW,9071)
        IF(SVDAOS) WRITE(IW,9073)
        IF(SVD_INVAR) WRITE(IW,9077)
        IF(SVD_AOSCF) WRITE(IW,9080)
      ENDIF
      CALL FLSHBF(IW)
C---------------------------------------------------
C     END OF PRINT ANY OTHER POSSIBLE OPTIONS HERE.
C---------------------------------------------------
C
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C     END OF SETUP ANY VARIABLES THAT USE ISDVOP.
C--------------------------------------------------------------------
C--------------------------------------------------------------------




C
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     SVD-VVOS OVERHAUL:  STEP 1
C     RESET DIMENSIONS
C     SVD-VVOS LENGTHS OF BLOCKS
C     ACTUAL CORE BLOCK:  NCORTOT
C     FILLED CORE BLOCK:  NSKIP
C     NEW EMPTY BLOCK:    NSKIP2
C     OLD ACTIVE BLOCK:   NACTSV
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C     GRAB MEMORY FOR SAVING ORIGINAL MSTA ARRAY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LMSTA_SAV = LOADFM + 1
      LAST      = LMSTA_SAV + ISIZE_FCCWFN
      NDAWN0    = LAST - LOADFM - 1
      CALL GETFM(NDAWN0)
C
C     SETUP SVD CORE AND ACTIVE.
      CALL LOCAL_SVDVVOS_REDIM_STEP0(
     *           L0,NCORTOT,NCORSV,NACTSV,
     *           EXTLOC,
     *           MASWRK,IW)
      CALL LOCAL_SVDVVOS_REDIM_STEP1(
     *     NAT,NCORSV,NACTSV,L0,
     *     NSPACE,NSPACE_SAV,
     *     ISIZE_FCCWFN,MSTA,X(LMSTA_SAV),
     *     NCORTOT,NSKIP,NACT,NSKIP2,NVIR2,
     *     NA,NB,IVVOS,CISTEP,
     *     SOME,MASWRK,IW)
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     END OF SVD-VVOS OVERHAUL:  STEP 1
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C
C     CALCULATE NACTBS FOR LATER ON...
      IF(NACT.EQ.L0-NCORTOT) THEN
        NACTBS=NAOTOT-NCORTOT
      ELSE
        NACTBS=NACT
      ENDIF
C
C     CALCULATE LDSVD.
      LDSVD=NACTBS*NAT
      LDSVD=MAX(LDSVD,L1)
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C
C
C     BEFOREHAND, DETERMINE SIZES OF ANY EXTRA WORK ARRAYS
C     NOTE:  EXPLICITLY DETERMINE LARGEST WORKSPACE
C            AND
C            FORCE INTO 1 VARIABLE.
      ISIZSVD  = MAX(3*MIN(L1,L0)+MAX(L1,L0),5*MIN(L1,L0))
      ISIZSVD2 = 5*L0
C     NEXT LINE GIVES SVD
      ISIZSVD  = MAX(ISIZSVD,ISIZSVD2)
      ISIZSVD2 = 8*L1
C     NEXT LINE GIVES GLDIAG
      ISIZSVD  = MAX(ISIZSVD,ISIZSVD2)
C     NEXT LINE GIVES A BIT MORE WORKSPACE
      ISIZSVD  = 40*ISIZSVD
C
C     CHECK ON NSPACE.
      IF(NSPACE.LE.0.OR.NSPACE.GT.ISIZE_FCCWFN) THEN
        IF(MASWRK) WRITE(IW,9074)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     GET ALL MEMORY FOR LOCAL_PPASVD.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LS       = LOADFM + 1
C     A BUNCH OF ORBITAL MEMORY.
      LUVEC    = LS        + L2
      LEIG1    = LUVEC     + L3
      LVTVEC   = LEIG1     + L1
      LWRKSVD  = LVTVEC    + L3
      LSV      = LWRKSVD   + ISIZSVD
      LVOLD    = LSV       + L3
      LVTMP    = LVOLD     + L3
      LVSAV    = LVTMP     + L3
      LSAOMO   = LVSAV     + MAX(L3,L1*LDSVD)
      LS2      = LSAOMO    + L3
      LIWRK    = LS2       + L2
      LSVMBS   = LIWRK     + L3
      LNATLAB  = LSVMBS    + L1*L0MBS
      LIPOSMBS = LNATLAB   + L1
C     MORE MEMORY FOR INDEXING.
      LILENMBS  = LIPOSMBS + (NAT+1)
      LIPOSCOR  = LILENMBS + NAT
      LILENCOR  = LIPOSCOR + (NAT+1)
      LIATMSTA2 = LILENCOR + NAT
C     MORE MEMORY FOR ATOM ASSIGNMENTS.
      LIATMSTA  = LIATMSTA2 + NSPACE*NAT
      LEIGSAV   = LIATMSTA  + NSPACE*NAT
C     MORE MEMORY SVD EVALUE SELECTION.
      LEIGTMP   = LEIGSAV    + LDSVD
      LVTVECSAV = LEIGTMP    + LDSVD
      LIGRPLAB  = LVTVECSAV  + NACT*LDSVD
      LIATLAB   = LIGRPLAB   + LDSVD
      LIORDBIG  = LIATLAB    + LDSVD
      LIORDBIG2 = LIORDBIG   + LDSVD
      LWSPHER   = LIORDBIG2  + LDSVD
C     MORE MEORY FOR SPHERICAL TRNASFORM.
      LDENOSAV  = LWSPHER    + L3
C     MORE MEMORY FOR ORTHOG.
      LAST      = LDENOSAV   + L3
C---------------
C     INTEGER ARRAY MEMORY FOR VIRTUAL DEGENERACY SORTING.
      NATEXT=4
      LIATEXT=LAST
      LAST=LIATEXT+NAT*NATEXT
C---------------
      NDAWN1 = LAST - LOADFM - 1
      CALL GETFM(NDAWN1)
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C
C     OBTAIN ANTI-BONDING-TYPE ORBITALS FOR COUPLE CLUSTER.
      IF(CCTYP.NE.RNONE) THEN
        CALL LOCAL_NOS_CC(
     *       IORBF1,
     *       NE,NCORTOT,L0,L1,L2,L3,ISIZSVD,
     *       X(LIWRK),
     *       X(LS),X(LS2),
     *       X(LVTMP),X(LVSAV),X(LEIG1),X(LWRKSVD),
     *       SOME,MASWRK)
        CALL DAWRIT(IDAF,IODA,X(LS2),L2,554,0)
      ENDIF
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     SVD-VVOS OVERHAUL:  STEP 2
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C     FOREVER RESET IORBF1 ORDERINGS.
      SWITCH_ORBS=.FALSE.
      IF(IVVOS.NE.0) THEN
C       NOTE:  THE ORDER ASSIGNING NEXT COMBO MATTERS BIG TIME.
        COMBO=.TRUE.
        IF(SCFTYP.EQ.RHF) COMBO=.FALSE.
        IF(EXTLOC.NE.RNONE) COMBO=.FALSE.
        IF(SCFTYP.EQ.ROHF) COMBO=.TRUE.
        IF(CCTYP.NE.RNONE) COMBO=.FALSE.
        IF(COMBO) THEN
          CALL VICLR(X(LIWRK),1,L2)
          CALL LOCAL_SVDVVOS_MOS(
     *         SWITCH_ORBS,X(LIWRK),SCFTYP,
     *         L0,NCORSV,NCORTOT,NACTSV,NSKIP,NSKIP2,NA,NB,
     *         MASWRK,IW)
          CALL DAREAD(IDAF,IODA,X(LVTMP),L3,15,0)
          CALL REORDR(X(LVTMP),X(LIWRK),L0,L1)
          CALL DAWRIT(IDAF,IODA,X(LVTMP),L3,15,0)
        ENDIF
      ENDIF
      IF(SWITCH_ORBS) THEN
        IF(NSKIP2.EQ.0) THEN
          IF(MASWRK) WRITE(IW,9400)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
      ELSE
        IF(NSKIP2.NE.0) THEN
          IF(MASWRK) WRITE(IW,9410)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
      ENDIF
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     END OF SVD-VVOS OVERHAUL:  STEP 2
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
CKEEPIVVOSC
CKEEPIVVOSC     IF NEEDED, PRINT OUT CANONICAL MCSCF OCCUPIEDS + VVOS
CKEEPIVVOS      IF(IVVOS.NE.0) THEN
CKEEPIVVOS        CALL DAREAD(IDAF,IODA,X(LVTMP),L3,15,0)
CKEEPIVVOS        IF(MASWRK) WRITE(IW,9060)
CKEEPIVVOS        CALL PRSQL(X(LVTMP),L0,L1,L1)
CKEEPIVVOS      ENDIF
C
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C     SETUP THE 'KEEPER' VAR
      CALL LOCAL_KEEPER_SETUP(KEEPER,0,L1,X(LIWRK))
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C     SETUP THE SVDEXTOPT VARIABLE.
C     NOTE:  VAR ALREADY INITIALIZED TO FALSE EARLY ON.
      IF(KEEPER.AND..NOT.SVDCOPT) THEN
        IEXTSPACE=0
        DO I=1,NSPACE
          IF(MSTA(I).GT.L0MBS) IEXTSPACE=IEXTSPACE+1
        ENDDO
        IF(IEXTSPACE.EQ.1) SVDEXTOPT=.TRUE.
      ENDIF
      IF(SVDEXTOPT) THEN
        IF(SOME) WRITE(IW,9072)
      ENDIF
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C     SETUP LIMLOW AND LIMSUP ARRAYS BY CALLING AOLIM.
C     LIMLOW CONTAINS INITIAL BASIS FXN INDEX FOR EACH ATOM.
C     LIMSUP CONTAINS FINAL BASIS FXN INDEX FOR EACH ATOM.
C     E.G. TRIATOMIC
C     LIMLOW LIMSUP
C     1      33
C     34     57
C     58     93 = NUM IN INFOA BLOCK
      CALL AOLIM
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C     SETUP AAMBS SV OVERLAP MATRIX.
      IF(SVD_AOSCF.OR.IVVOS.NE.0) THEN
        IF(SOME) WRITE(IW,9200)
        CALL FLSHBF(IW)
        IF(EXETYP.NE.CHECK)
     *    CALL DAREAD(IDAF,IODA,X(LSVMBS),L1*L0MBS,533,0)
      ENDIF
CKEEPAAMBS      ITMP=4
CKEEPAAMBS      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
CKEEPAAMBS      CALL LOCAL_WEIGHTED_SYM_ORTHOG(
CKEEPAAMBS     *     ITMP,L1,X(LS),X(LVTVEC),
CKEEPAAMBS     *     X(LUVEC),X(LSV),X(LWSPHER),X(LEIG1),
CKEEPAAMBS     *              X(LIWRK),X(LWRKSVD),
CKEEPAAMBS     *     L1,L3,L2,.FALSE.,
CKEEPAAMBS     *     IW,MASWRK)
CKEEPAAMBS      CALL DAREAD(IDAF,IODA,X(LWSPHER),L1*L0MBS,533,0)
CKEEPAAMBS      CALL MRARBR(X(LUVEC),L1,L1,L1,
CKEEPAAMBS     *            X(LWSPHER),L1,L0MBS,
CKEEPAAMBS     *            X(LVTMP),L1)
CKEEPAAMBS      IF(SOME) WRITE(IW,9210)
CKEEPAAMBS      CALL PRSQL(X(LVTMP),L0MBS,L1,L1)
C------------------------------------------------------
C------------------------------------------------------
C------------------------------------------------------
C
C     CHECK FOR ERROR OUTS.
      CALL LOCAL_PPAERR(
     *     KEEPER,SVDEXTOPT,
     *     ISVDOP,
     *     NSPACE,NAT,NCORTOT,NACT,L0MBS,
     *     IAN,
     *     ZAN,
     *     MASWRK,IW)
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     ENSURE THAT ORBITALS ARE ORTHONORMAL
C            BEFORE THE SVD IS PERFORMED.
      CALL DAREAD(IDAF,IODA,X(LVTMP),L3,IORBF1,0)
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     L0,L1,L2,
     *     X(LS2),X(LS),X(LVTMP),X(LWRKSVD),
     *     MASWRK,IW)
C
C     MAKE THE CALLS FOR SVD-BASED ORBITALS.
      CALL LOCAL_PPASVDCORE(
     *     NCORTOT,IORBF1,X(LS2),
     *     X(LS),X(LUVEC),X(LEIG1),X(LVTVEC),
     *     X(LWRKSVD),X(LIWRK),
     *     X(LVOLD),X(LVTMP),X(LVSAV),
     *     X(LSV),X(LSAOMO),
     *     ISIZSVD,L0,L1,L2,L3,
     *     LIMLOW,LIMSUP,NAT,SVDAOS,
     *     ISPHER,
     *     L0MBS,SVD_AOSCF,X(LIPOSCOR),X(LILENCOR),X(LSVMBS),
     *     X(LNATLAB),
     *     QMTTOL,NAOTOT,
     *     SOME,MASWRK)
C------
CKEEP      SOME_SAV=SOME
CKEEP      SOME=.FALSE.
CKEEP      NACTSV_OCC=NACTSV
CKEEP      NACT_OCC=NACT
CKEEP      CALL LOCAL_SETUP_PPADEN(
CKEEP     *     IORBF1,NSKIP,NSKIP2,NSKIP_SING,NACT_OCC,NACTSV_OCC,
CKEEP     *     NCORTOT,NA,NB,IMBS,L1,IDENFIL,IDENSIZ,
CKEEP     *     EXTLOC,
CKEEP     *     SWITCH_ORBS,SOME,MASWRK,IW)
CKEEP      CALL LOCAL_PPADEN1(
CKEEP     *     NCORSV,NACTSV_OCC,NACT_OCC,L1,L2,
CKEEP     *     NSKIP,NSKIP2,NSKIP_SING,
CKEEP     *     IVVOS,IORBF1,IDENFIL,IDENSIZ,
CKEEP     *     X(LDENOSAV),X(LUVEC),X(LVTVEC),
CKEEP     *     SOME,MASWRK)
CKEEP      SOME=SOME_SAV
C------
      CALL LOCAL_PPASVD(
     *     NCORTOT,IORBF1,
     *     X(LS2),X(LS),X(LUVEC),X(LEIG1),X(LVTVEC),
     *     X(LWRKSVD),X(LIWRK),
     *     X(LVOLD),X(LVTMP),X(LVSAV),
     *     X(LSV),X(LSAOMO),
     *     ISIZSVD,NACT,NACTBS,LDSVD,L0,L1,L2,L3,
     *     MSTA,ISIZE_FCCWFN,NSPACE,
     *     LIMLOW,LIMSUP,NAT,X(LIATMSTA),X(LIATMSTA2),KEEPER,
     *     X(LEIGSAV),X(LEIGTMP),X(LVTVECSAV),X(LIGRPLAB),
     *     X(LIATLAB),X(LIORDBIG),X(LIORDBIG2),ISVMOR,
     *     X(LIPOSMBS),X(LILENMBS),X(LIPOSCOR),X(LILENCOR),
     *     X(LSVMBS),L0MBS,
     *     SVDEXTOPT,SVDAOS,SVD_INVAR,
     *     SVD_AOSCF,SCFTYP,EXTLOC,
     *     ISPHER,
     *     IEXTSPACE,NATEXT,X(LIATEXT),X(LNATLAB),
     *     QMTTOL,NAOTOT,L0DEP0,SVDCOPT,
     *     MASWRK,SOME)
C
C     1. FINAL CORE ATOM ORDER   ==> FILE 568
C     2. FINAL  VAL ATOM ORDER   ==> FILE 528
C     3. FINAL GROUP LABEL       ==> FILE 546
      CALL DAWRIT(IDAF,IODA,X(LNATLAB),NCORTOT,580,1)
      CALL VICLR(X(LIWRK),1,L1)
      CALL ICOPY(NACT,X(LNATLAB+NCORTOT),1,X(LIWRK),1)
      CALL DAWRIT(IDAF,IODA,X(LIWRK),L1,528,1)
      CALL DAWRIT(IDAF,IODA,X(LIGRPLAB),L1,546,1)
C
C     OBTAIN SVD DENSITY.
C     --ONLY ORTHOGONAL ORBITALS AT THIS POINT FOR DENSITY.
C     --EXTLOC STATEMENTS ARE IMPORTANT
C       AND ELIMINATE FILE CONFLICTS EVERYWHERE.
C     --NSKIP VARS ARE MODIFIED.
C       SO, CANNOT USE THIS UNTIL DONE WITH ORIGINAL NSKIP VARS.
      NACTSV_OCC=NACTSV
      NACT_OCC=NACT
      CALL LOCAL_SETUP_PPADEN(
     *     IORBF1,NSKIP,NSKIP2,NSKIP_SING,NACT_OCC,NACTSV_OCC,
     *     NCORTOT,NA,NB,IMBS,L1,IDENFIL,IDENSIZ,
     *     EXTLOC,
     *     SWITCH_ORBS,SOME,MASWRK,IW)
      CALL LOCAL_PPADEN1(
     *     NCORSV,NACTSV_OCC,NACT_OCC,L1,L2,
     *     NSKIP,NSKIP2,NSKIP_SING,
     *     IVVOS,IORBF1,IDENFIL,IDENSIZ,
     *     X(LDENOSAV),X(LUVEC),X(LVTVEC),
     *     SOME,MASWRK)
      IOPTNON=1
      CALL LOCAL_PPADEN2(
     *     IOPTNON,
     *     NCORTOT,NACT_OCC,L0DEP0,L1,L3,
     *     NAT,
     *     X(LDENOSAV),X(LUVEC),X(LVTMP),X(LVTVEC),X(LIWRK),
     *     EXTLOC,
     *     SOME,MASWRK)
      ITMP=(NACT*NACT+NACT)/2
      CALL LOCAL_CHECK_DENS(
     *     X(LUVEC),ITMP,NACT,NCORTOT,NE,
     *     MASWRK,IW)
C
C     FOR ORIENTATION DILRMO ROUTINE:
C     LOCAL_PPADEN PUTS DENSITY ON DAF FILE 285.
C     PUT ORTHOGONAL SVD-ORBITALS INTO FILE 71.
C     ----THE EXTLOC STATEMENTS ARE IMPORTANT
C         AND ELIMINATE FILE CONFLICTS EVERYWHERE...
      IF(EXTLOC.EQ.RNONE) THEN
        CALL DAREAD(IDAF,IODA,X(LVTMP),L3,521,0)
        CALL DAWRIT(IDAF,IODA,X(LVTMP),L3,71,0)
      ENDIF
C
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     SVD-VVOS OVERHAUL:  STEP LAST
C     RESET DIMENSIONS
C     RESET THE MSTA ARRAY
C----------------------------------------------------------------------
C----------------------------------------------------------------------
      CALL LOCAL_SVDVVOS_REDIM_STEPLAST(
     *     NACT,NACTSV,NSPACE,NSPACE_SAV,ISIZE_FCCWFN,
     *     MSTA,X(LMSTA_SAV),MASWRK,SOME,IW)
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C     END OF SVD-VVOS OVERHAUL:  STEP LAST
C----------------------------------------------------------------------
C----------------------------------------------------------------------
C
C     RELEASE ALL MEMORY FOR ATOMIC-LIKE ORBITALS.
 8999 CONTINUE
      CALL RETFM(NDAWN1)
      CALL RETFM(NDAWN0)
C
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LMOSVD NOW LOCALIZES ATOMIC BASIS ONTO MO SPACE.'/
     *   5X,60(1H-))
 9050 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'VVOS MCSCF CAN ONLY RUN THROUGH LOCAL_LMOSVD',
     *        1X,'WITH THE ORMAS CISTEP.')
 9052 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'RIGHT NOW, VVOS ARE FORMED FROM THE OPERATOR',
     *        1X,'IN THE AO BASIS EARLIER IN THE CODE.',
     *       /1X,'SO, NATURAL ORBITALS CANNOT BE USED.')
 9053 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'EXTLOC RUNS MUST RUN WITH VVOS=.T.',
     *       /1X,'SET VVOS TO TRUE IN SCF OR MCSCF GROUP.')
 9054 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'LOCAL=SVD AND EXTLOC DO NOT WORK TOGETHER.')
 9055 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'RHF AND ROHF ALWAYS NEED VVOS=TRUE.')
 9056 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *        1X,'ORMFUL IS NOT COMPATIBLE WITH EXTLOC.')
 9057 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'RHF,ROHF INCLUDE EXTLOC,',
     *        1X,'WHICH IS NOT COMPATIBLE WITH ORMFUL.')
 9058 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'THIS CCTYP IS NOT ALLOWED.',
     *       /1X,'ONLY SCFTYP=RHF IS ALLOWED RIGHT NOW.',
     *       /1X,'FOR CCSD, IPROPCC MUST EQUAL 1.',
     *       /1X,'FOR EOM-CCSD, BOTH IPROPCC,IPROPCCE MUST EQUAL 1.')
 9059 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'CCTYP REQUIRES USE OF DAF15.')
CKEEPIVVOS 9060 FORMAT(//10X,'MCSCF OCCUPIEDS+VVOS LOCALIZED ORBITALS')
 9070 FORMAT(/1X,'CHECKING OUT ISVDOP OPTIONS.')
 9071 FORMAT(1X,'USING REGULAR SVD OPTION.')
 9072 FORMAT(1X,'USING SVDEXTOPT OPTION:',
     *      /1X,'RIGHT NOW, SVDEXTOPT IS POSSIBLE WHEN THE',
     *       1X,'NSPACE GROUP IS',
     *       1X,'THE ENTIRE EXTERNAL SPACE.')
 9073 FORMAT(1X,'USING SVDAOS OPTION:  NONORTHOGONAL AOS IN SVD.')
 9074 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'MEMORY HAS ISSUE WITH NSPACE VALUE.')
 9077 FORMAT(1X,'USING SVD_INVAR OPTION:  ',
     *      /1X,'ATOMIC MO OVERLAPS ON ATOM A WITH SVD BASIS.')
 9080 FORMAT(1X,'USING SVD_AOSCF OPTION:  ',
     *      /1X,'FOR MBS ORBITALS, USE THE TRUE AOS FROM VVOS.',
     *      /1X,'FOR MORE THAN MBS ORBITALS,',
     *       1X,'USE SVD TO AO BASIS SET FOR THE EXTRA ORBITALS.')
 9090 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'THIS OPTION DOES NOT EXIST IN THE CODE.')
 9200 FORMAT(/1X,'READING L1,L0MBS SV MATRIX FOR AOS',
     *        1X,'FROM THE VVOS RUN.',
     *       /1X,'NOTES FOR SCFTYP=MCSCF:',
     *       /1X,'1. IF VVOS IN MCSCF IS FALSE,',
     *       /1X,'DO NOT INSERT',
     *        1X,'VVOS INTO CANONICAL MCSCF ORBITALS.',
     *       /1X,'2. IF RUN BOMBS, CHECK FOR DIMENSION ISSUE',
     *        1x,'WITH DAF FILE 533.')
CKEEPAAMBS 9210 FORMAT(//10X,'AAMBS LOCALIZED ORBITALS')
 9300 FORMAT(1X,'... DONE WITH SVD LOCALIZATION ...')
 9400 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'THIS RUN MOVED THE VVOS ORBITAL GROUP.',
     *        1X,'HOWEVER, NSKIP2 EQUALS 0.',
     *       /1X,'THIS COMBINATION IS PROBABLY NOT POSSIBLE.')
 9410 FORMAT(/1X,'LOCAL_LMOSVD ERROR:',
     *       /1X,'THIS RUN DID NOT MOVE THE VVOS ORBITAL GROUP.',
     *        1X,'HOWEVER, NSKIP2 IS GREATER THAN 0.',
     *       /1X,'THIS COMBINATION IS PROBABLY NOT POSSIBLE.')
      END
C*MODULE LOCAL   *DECK LOCAL_PPAERR
c> @brief      Routine checks basis set for SVD-localization.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
C> @param KEEPER       is a logical that equals true when
C>                     cistep=ormas and nspace>1 and ormful=false.
C> @param SVDEXTOPT    preserves degenerate external orbitals
C>                     in the external orbital space by
C>                     discarding only orbitals with non-degenerate
C>                     SVD values on each atom.
C>                     However, this option must not allow any more
C>                     sperical externals than are allowed on a given
C>                     atom.
C>                     So, one should not loop over and look for
C>                     the smallest eigenvalues across atoms here.
C> @param ISVDOP       is a switch for various extra options.
C>                     I made this item so that I do not have to keep
C>                     taking up space to the nameio call for
C>                     local group.
c> @param NSPACE       is the number ORMAS groups.
c> @param NAT          is the number of atoms.
c> @param NCORTOT      is number of core orbitals.
c> @param NACT         is the number of active orbitals.
C> @param L0MBS        is the dimension of the minimal basis set number of
C>                     orbitals.
c> @param IAN          is from INFOA common.
c> @param ZAN          is from INFOA common.
c> @param MASWRK       indicates the master process.
c> @param IW           indicates write out to the log file.
      SUBROUTINE LOCAL_PPAERR(
     *           KEEPER,SVDEXTOPT,
     *           ISVDOP,
     *           NSPACE,NAT,NCORTOT,NACT,L0MBS,
     *           IAN,
     *           ZAN,
     *           MASWRK,IW)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK,KEEPER,SVDEXTOPT
      INTEGER IW,ISVDOP,
     *        NSPACE,NAT,NCORTOT,NACT,L0MBS
      INTEGER IAN(NAT)
      DOUBLE PRECISION :: ZAN(NAT)
C----------------------------------------------------------------------
      INTEGER I,NERR,ILAST,NUCZ
C-----------------------------------------------------------------------
C
C     INITIALIZE NERR
      NERR=0
C
C     MAKE SOME MAIN ERROR OUTS FIRST.
C     --FOR NOW, ABORT IF BASIS IS NOT ALL ELECTRON BASIS.
      ILAST=55
      DO I=1,NAT
        NUCZ = INT(ZAN(I) + 1.0D-03)
        IF(NUCZ.NE.IAN(I).OR.IAN(I).GE.ILAST) NERR=NERR+1
      ENDDO
      IF(MASWRK) WRITE(IW,9001)
      IF(MASWRK.AND.NERR.GT.0) WRITE(IW,9002)
C
C     SOME ERROR OUTS FOR ISVDOP=10.
C     IF THE FOLLOWING IS NOT MET,
C     MORE CHECKING IS REQUIRED BEFORE PROCEEDING...
      IF(ISVDOP.EQ.10) THEN
        IF(MASWRK
     *    .AND.NSPACE.EQ.2
     *    .AND.NACT.GT.L0MBS-NCORTOT) WRITE(IW,9031)
        IF(NACT.GT.L0MBS-NCORTOT.AND.NSPACE.NE.2) THEN
          IF(MASWRK) WRITE(IW,9032)
          NERR=NERR+1
        ENDIF
      ENDIF
C
C     MAKE ANY EXCLUSIONS FOR SVDEXTOPT
      IF(SVDEXTOPT) THEN
        IF(NSPACE.EQ.1) THEN
          IF(MASWRK) WRITE(IW,9034)
          NERR=NERR+1
        ENDIF
        IF(.NOT.KEEPER) THEN
          IF(MASWRK) WRITE(IW,9035)
          NERR=NERR+1
        ENDIF
      ENDIF
C
C     ACTUALLY ERROR OUT.
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(/1X,'BASIS SET CHECK IS DONE.')
 9002 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.'/
     *       1X,'ERROR OCCURS FOR USING BASIS SET.')
 9031 FORMAT(1X,'ISVDOP=10 + NSPACE=2 RUNS MUST HAVE',
     *       1X,'MBS NUMBER OF ORBITALS IN GROUP 1.')
 9032 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'ISVDOP=10 CANNOT BE USED WHEN',
     *        1X,'NACT>L0MBS-NCORTOT AND NSPACE NE 2.')
 9034 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'SVDEXTOPT OPTION MUST HAVE NSPACE>1.')
 9035 FORMAT(/1X,'*** ERROR IN LOCAL_PPAERR ROUTINE.',
     *        1X,'SVDEXTOPT OPTION MUST HAVE KEEPER VAR TRUE.')
      END
C*MODULE LOCAL   *DECK LOCAL_NUMVAL
C> @brief      Routine returns number of valences orbitals.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -November 4, 2012
C>
C> @date January 12, 2013-Aaron West
C> -This routine has now moved beyond the minimal basis set.
C>
C> @date January 30, 2013-Aaron West
C> -Added ISVDOP to ORNTMO common block.
C> This run gives special option for SVD runs.
C>
C> @date March 20, 2013-Aaron West
C> -Added ISWMBS to integer function.
C>
C> @param ITMP2 is the atom number.
C> @param ISWMBS allows for the output of MBS numbers of orbitals.
C>
      INTEGER FUNCTION LOCAL_NUMVAL(ITMP2,ISWMBS)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      INTEGER IWX,ITEST,I,ITMP,ITMP2,NVALAT,ISWMBS,NERR
C---------------------------------------------------
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
      DOUBLE PRECISION :: ZAN,C,BNDDEN
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      INTEGER NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,IAN
      INTEGER ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
      INTEGER IVVOS,NVVOS
C---------------------------------------------------
      INTEGER MXATM
      PARAMETER (MXATM=2000)
C---------------------------------------------------
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
C-----------------------------------------------------------------------
C
C     RETURN THE NUMBER OF VALENCE ORBITALS ON A GIVEN ATOM.
C     ALSO SEE NUMCOR,NVVOS_NUMCOR,AND VVOS ROUTINES.
C     STILL NEED TO ADDRESS ECPs,ETC.
C     STILL NEED TO ADDRESS SEMI-CORE ORBS.
C
      NERR=0
      ITEST=0
      DO I=1,NAT
        IF(ISVMOR(I).NE.0) ITEST=1
      ENDDO
C
C     HERE, WE WILL ENFORCE MBS NUMBERS OF ORBITALS FOR CERTAIN OPTIONS.
      IF(IVVOS.NE.0) ITEST=0
C
C     GRAB ATOM NUMBER
      I=ITMP2
C
C     ASSIGN NUMBER OF VALENCE ORBITALS
      IF(ITEST.EQ.0.OR.ISWMBS.EQ.1) THEN
        ITMP=IAN(I)
        IF(ITMP.LT.1.OR.ITMP.GT.54) THEN
          NERR=NERR+1
          IF(MASWRK) WRITE(IW,9000)
        ENDIF
        IF(               ITMP.LE. 2) NVALAT=1
        IF(ITMP.GE. 3.AND.ITMP.LE. 4) NVALAT=1
        IF(ITMP.GE. 5.AND.ITMP.LE.10) NVALAT=4
        IF(ITMP.GE.11.AND.ITMP.LE.12) NVALAT=1
        IF(ITMP.GE.13.AND.ITMP.LE.18) NVALAT=4
        IF(ITMP.GE.19.AND.ITMP.LE.20) NVALAT=1
        IF(ITMP.GE.21.AND.ITMP.LE.30) NVALAT=6
        IF(ITMP.GE.31.AND.ITMP.LE.36) NVALAT=4
        IF(ITMP.GE.37.AND.ITMP.LE.38) NVALAT=1
        IF(ITMP.GE.39.AND.ITMP.LE.48) NVALAT=6
        IF(ITMP.GE.49.AND.ITMP.LE.54) NVALAT=4
      ELSE
        NVALAT=ISVMOR(I)
      ENDIF
C
      IF(NERR.GT.0) THEN
        IWX=IW
        CALL FLSHBF(IWX)
        CALL ABRT
        STOP
      ENDIF
C
      LOCAL_NUMVAL=NVALAT
C
      RETURN
 9000 FORMAT(1X,'LOCAL_NUMVAL ERROR:',
     *      /1X,'THERE IS A PROBLEM WITH THE INTEGER ARRAY IAN.')
      END
C*MODULE LOCAL   *DECK LOCAL_ATM_CH
C> @brief      This routine return integer value of nuclear charge.
C>
C> @author     Aaron West
C>             -November 15, 2012
C>
C> @details    Using function avoids any conflict of variables very
C>             easily.  e.g. in Davidson routines for Malmqvist items
C>
C> @param IAT is the atom number.
      INTEGER FUNCTION LOCAL_ATM_CH(IAT)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      INTEGER IAT
C     NEW CODING STANDARDS VARS
      DOUBLE PRECISION :: ZAN,C
      INTEGER MXATM,NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,IAN
      PARAMETER (MXATM=2000)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C-----------------------------------------------------------------------
C
      LOCAL_ATM_CH=INT(ZAN(IAT))
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_PPASVDCORE
c> @brief      Routine makes SVD-localized core orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @details    LOCAL_PPASVD contains equivalent and
c>             better comments in the routine itself.
c>
c> @date November 16, 2012-Aaron West
c> -Removed some error outs for vtvec.  Symmetric molecules
c>  can have zeros here even in C1 point group.
c>  This error out was mainly for debugging bad code.
c>
c> @param NCORTOT is total number of MCSCF core orbitals.
c>        For VVOS run, it is adjusted.
c> @param IORBF1 is the dat dict file for initial orbitals.
c> @param S2 stores AO basis overlaps on each atom.
c> @param S stores all the AO basis overlaps.
c> @param UVEC is the u matrix in SVD.
c> @param EIG holds eigenvalues from SVD.
c> @param VTVEC is the V-transpose matrix in SVD.
c> @param WRKSVD is the work array designed for gldiag and svd calls.
c> @param IWRK is the integer work array used
c>                    -- for symmetric matrix indices
c>                    -- for gldiag calls
c> @param VOLD contains the AO coefficients from IORBF1 daf dict file.
c> @param VTMP is temporary storage.
c> @param VSAV is temporary storage.
c> @param SV holds the AO basis overlap times AO coefficients matvec.
c> @param SAOMO is often S_IATM1**(-1/2) * SV on each IATM1 atom.
c> @param ISIZSVD is the workspace size for WRKSVD array.
c> @param L0 is the length of the MO variational space.
c> @param L1 is the length of the AO coefficients.
c> @param L2 is the triangular length of L1.
c> @param L3 is the square of L1.
c> @param LIMLOW array contains the lower basis function on an atom.
c> @param LIMSUP array contains the upper basis function on an atom.
c> @param NAT is the number of atoms.
c> @param SVDAOS is a toggle option for orthogonalizing the input AOs.
C> @param ISPHER       indicates treatment of basis functions
C>                     in terms of spherical or Cartesians.
C> @param L0MBS        is the dimension of the minimal basis set number of
C>                     orbitals.
C>                     L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
C> @param SVD_AOSCF    is an option to use the AOs from VVOS
C>                     with high basis set quality.
C> @param IPOSCOR      denotes the integer array that holds the starting
C>                     position for the 1st CORE AO on a given atom.
C> @param ILENCOR      denotes the integer array that holds the
C>                     number of CORE orbitals on a given atom.
C> @param SVMBS        is an array that holds the overlap to the true AOs
C>                     from the VVOS run.
C>                     This overlap has a dimension of L1xL0MBS.
C> @param NATLAB       is array for atom-orbital correspondence.
C> @param QMTTOL is the linear dependence threshold.
C> @param NAOTOT is the true number of sphericals.
C> @param SOME   is true for master process with nprint not equal -5.
c> @param MASWRK indicates the master process.
c> @see   LOCAL_PPASVD
      SUBROUTINE LOCAL_PPASVDCORE(
     *           NCORTOT,IORBF1,S2,
     *           S,UVEC,EIG,VTVEC,WRKSVD,IWRK,
     *           VOLD,VTMP,VSAV,
     *           SV,SAOMO,
     *           ISIZSVD,L0,L1,L2,L3,
     *           LIMLOW,LIMSUP,NAT,SVDAOS,
     *           ISPHER,
     *           L0MBS,SVD_AOSCF,IPOSCOR,ILENCOR,SVMBS,
     *           NATLAB,
     *           QMTTOL,NAOTOT,
     *           SOME,MASWRK)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK,SVDAOS,SVD_AOSCF,COMBOSPHER
      INTEGER MXATM
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: ONE,TOL,QMTTOL
      INTEGER NAT,LIMLOW(MXATM),LIMSUP(MXATM),
     *        NVVOS_NUMCOR
      PARAMETER (ONE=1.0D+00)
      INTEGER I,IATM1,IBAS1,IBAS2,IBASSPH1,IBASSPH2,IBASPOS,
     *        IERR2,IERR3,IHACT,
     *        ILTH_FIX,ILTH_FIX_SAV,ILTH_SAV,ILTH,ILTHSPH,
     *        ILTH_FOR_SV,
     *        IMO,IORBF1,ISIZSVD,J,L0,L1,L2,L3,
     *        L0MBS,NCORTOT,NUMCOR1,IJ2,ITMP,IPOS,
     *        INFO,IKIND
      INTEGER NAOTOT
C---------SPHERICAL HARMONIC STUFF---------------------
      LOGICAL IGNORE_SPHER
      INTEGER ISPHER
C------------------------------------------------------
C     NEW CODING STANDARDS VARS
      INTEGER IDAF,IODA,IP,IPK,IR,IS,IW,NAV
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C-----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       S2(L2),S(L2),
     *       UVEC(L1,L1),EIG(L1),VTVEC(L1,L1),
     *       WRKSVD(ISIZSVD),
     *       VOLD(L1,L1),VTMP(L1,L1),VSAV(L1,L1),
     *       SV(L1,L1),SAOMO(L1,L1),SVMBS(L1,L0MBS)
      INTEGER IPOSCOR(NAT+1),ILENCOR(NAT),IWRK(L2),NATLAB(L1)
C
C     -------------------------------------------------------
C     SEE LOCAL_PPASVD ROUTINE FOR ANALOGOUS COMMENTS.
C     -------------------------------------------------------
C
C
C     SET UP TOL=QMTTOL
      TOL=ABS(QMTTOL)
C
C     SET UP THE IPOSCOR AND ILENCOR ARRAYS.
      CALL LOCAL_VVOS_ORB_RANGE_CORE(IPOSCOR,ILENCOR,NAT)
C
C     READ IN THE DESIRED ORBITALS.
      CALL DAREAD(IDAF,IODA,VOLD,L3,IORBF1,0)
C
C     SV=S*V=AO BASIS OVERLAP*AO COEFFS
C               WITH INNER CONTRACTION OVER ALL ATOMS.
C     GET AND SAVE SV FOR ALL ATOMS
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,VOLD,L0,SV,L1,1)
C
C     CONVERT S AND SV OVER TO SPHERICALS IF NEEDED.
      IGNORE_SPHER=.FALSE.
      COMBOSPHER=ISPHER.GE.0
     *           .AND..NOT.SVDAOS
     *           .AND..NOT.IGNORE_SPHER
      IF(COMBOSPHER) THEN
        CALL SPHBCKU(UVEC,L1,L1,ITMP)
        IF(ITMP.NE.NAOTOT) THEN
          IF(MASWRK) WRITE(IW,*)
          IF(MASWRK) WRITE(IW,*) "LOCSVD ERROR FOR SPHBCKU"
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
        CALL VCLR(S2,1,L2)
        CALL TFTRI(S2,S,UVEC,WRKSVD,NAOTOT,L1,L1)
        CALL DCOPY(L2,S2,1,S,1)
        CALL VCLR(VTMP,1,L3)
        CALL MRTRBR(UVEC,L1,L1,NAOTOT,SV,L1,L0,VTMP,L1)
        CALL DCOPY(L3,VTMP,1,SV,1)
      ENDIF
C
C     VCLR (CORE) NONROTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL VCLR(VSAV,1,L3)
C
C     INIT. NATLAB.
      CALL VICLR(NATLAB,1,L1)
C
C     LOOP OVER ALL ATOMS
      DO 100 IATM1=1,NAT
C
C       SKIP IF NUMCOR1=0.
        NUMCOR1=NVVOS_NUMCOR(IATM1,1)
        IF(NUMCOR1.EQ.0) GO TO 100
C
C       SET UP BASIS DIMENSIONS AND OVERLAP.
        CALL LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *       LIMLOW,LIMSUP,IATM1,NAT,L2,
     *       S2,S,
     *       IBAS1,IBAS2,ILTH,
     *       IBASSPH1,IBASSPH2,ILTHSPH,
     *       COMBOSPHER)
        ILTH_SAV=ILTH
        ILTH_FIX=ILTH
        IBASPOS=IBAS1
        IF(COMBOSPHER) THEN
          ILTH_FIX=ILTHSPH
          IBASPOS=IBASSPH1
        ENDIF
        ILTH_FIX_SAV=ILTH_FIX
        ILTH_FOR_SV=ILTH_FIX
C
C       PERFORM S**(-1/2) ORTHOG.
C       NOTE:  SAOMO,VTVEC,UVEC,WRKSVD,IWRK ARE ALL SCRATCH.
        IKIND=3
        CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *       IKIND,ILTH_FIX,S2,WRKSVD,
     *       VTMP,VTVEC,UVEC,EIG,IWRK,WRKSVD,
     *       L1,L3,L2,.TRUE.,
     *       IW,MASWRK)
C
C       SAOMO= OVERLAP MATRIX B/T CORE MO AND AOS ON IATM1.
        CALL VCLR(SAOMO,1,L3)
C
C---------------------------------------------------------------
C       IMPLEMENT SAOMO OPTIONS.
C---------------------------------------------------------------
        IF(SVD_AOSCF) THEN
          IPOS=IPOSCOR(IATM1)
          ITMP=ILENCOR(IATM1)
          CALL MRTRBR(SVMBS(1,IPOS),L1,L1,ITMP,
     *                VOLD(1,1),L1,NCORTOT,SAOMO,L1)
          ILTH_FIX=ITMP
C
          IF(SOME) WRITE(IW,9002) ILTH_FIX,IATM1
        ELSEIF(SVDAOS) THEN
          DO IMO=1,NCORTOT
            CALL DCOPY(ILTH_FOR_SV,SV(IBASPOS,IMO),1,SAOMO(1,IMO),1)
          ENDDO
        ELSE
          CALL VCLR(UVEC,1,L3)
          DO IMO=1,NCORTOT
            CALL DCOPY(ILTH_FOR_SV,SV(IBASPOS,IMO),1,UVEC(1,IMO),1)
          ENDDO
          CALL VCLR(SAOMO,1,L3)
          CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH_FOR_SV,
     *                UVEC,L1,NCORTOT,SAOMO,L1)
        ENDIF
C---------------------------------------------------------------
C       END OF IMPLEMENT SAOMO OPTIONS.
C---------------------------------------------------------------
C
C       PERFORM SVD FOR IATM1
        CALL VCLR(UVEC,1,L3)
        CALL VCLR(VTVEC,1,L3)
        CALL VCLR(EIG,1,L1)
        CALL DGESVD('A','A',
     *              ILTH_FIX,NCORTOT,SAOMO,L1,EIG,
     *              UVEC,L1,VTVEC,L1,
     *              WRKSVD,ISIZSVD,INFO)
C
C       IMMEDIATELY RESET ILTH_FIX
        ILTH=ILTH_SAV
        ILTH_FIX=ILTH_FIX_SAV
C
C       FORM TRANSFORMATION MATRIX VTVEC-TRANS
C            FOR THE NEWLY PROJECTED MOS.
        CALL TRPOSQ(VTVEC,L1)
C
C       DEFINE THE NUMBER OF CORE ORBITALS TO SAVE.
        NUMCOR1=NVVOS_NUMCOR(IATM1,1)
C
C       GRAB OUT THE (CORE) NONORTHOGONAL
C                QUASI-ATOMIC ORBITAL TRANSFORMATION.
        IHACT=0
        DO I=1,IATM1-1
          IHACT=IHACT+NVVOS_NUMCOR(I,1)
        ENDDO
        DO I=1,NUMCOR1
          IHACT=IHACT+1
          CALL DCOPY(NCORTOT,VTVEC(1,I),1,VSAV(1,IHACT),1)
          NATLAB(IHACT)=IATM1
        ENDDO
C
C     END LOOP OVER ALL ATOMS
  100 CONTINUE
C
C
C
C     SAVE THE (CORE) NONORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION.
      CALL DAWRIT(IDAF,IODA,VSAV,L3,523,0)
C
C     HAVE THE NONORTHOGONAL ORBITAL TRANSFORMATION.
C     ---CONSTRUCT NONORTHOG. CORE ORBITALS IN DIRECT FASHION
      CALL VCLR(UVEC,1,L3)
      CALL MRARBR(VOLD,L1,L1,NCORTOT,VSAV,L1,NCORTOT,UVEC,L1)
      CALL DAWRIT(IDAF,IODA,UVEC,L3,522,0)
C
C     FORM SV=NEW OVERLAP B/T NEW MO ORBITALS.
C     --UVEC CONTAINS THE NONORTHOG. CORE ORBITALS.
      CALL VCLR(SV,1,L3)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,UVEC,NCORTOT,SV,L1,1)
      CALL MRTRBR(UVEC,L1,L1,NCORTOT,SV,L1,NCORTOT,VTMP,L1)
C
C     FORM VTMP=[ NEW SMO**(-1/2) ] VIA SYM. ORTHOGONALIZATION.
C     HERE INITIAL VTMP=NEW MO OVERLAPS.
      CALL VCLR(S2,1,L2)
      IJ2=1
      DO I=1,NCORTOT
        DO J=1,I
          S2(IJ2)=VTMP(I,J)
          IJ2=IJ2+1
        ENDDO
      ENDDO
      IERR2=0
      CALL VCLR(VTMP,1,L3)
ccccccc
      IF(NCORTOT.NE.0)
     * CALL GLDIAG(L1,NCORTOT,NCORTOT,S2,WRKSVD,EIG,VTMP,IERR2,IWRK)
ccccccc
      IF(IERR2.GT.0) GO TO 8999
      IERR3=0
      DO I=1,NCORTOT
        IF(EIG(I).LT.TOL) IERR3=IERR3+1
        EIG(I)=ONE/SQRT(EIG(I))
C       WRITE(IW,*) "IATM1,I,EIG=",IATM1,I,EIG(I)
      ENDDO
      IF(IERR3.GT.0) GO TO 8999
      DO I=1,NCORTOT
        DO J=1,NCORTOT
          SV(I,J)=VTMP(J,I)
          SV(J,I)=VTMP(I,J)
        ENDDO
      ENDDO
      DO I=1,NCORTOT
        CALL DSCAL(NCORTOT,EIG(I),VTMP(1,I),1)
      ENDDO
C     DO MATVEC TO S_IATM1**(-1/2)
      CALL VCLR(SAOMO,1,L3)
      CALL MRARBR(VTMP,L1,NCORTOT,NCORTOT,SV,L1,NCORTOT,SAOMO,L1)
      CALL DCOPY(L3,SAOMO,1,VTMP,1)
C
C     FORM UVEC * [VTMP = NEW SMO**(-1/2)] MATVEC
C     THIS NEXT PIECE ORTHOGONALIZES THE ALREADY PROJECTED MOS.
      CALL VCLR(SV,1,L3)
      CALL MRARBR(UVEC,L1,L1,NCORTOT,VTMP,L1,NCORTOT,SV,L1)
C     SAVE THE ORTHOGONAL QUASI-ATOMIC ORBITAL TRANSFORMATION NOW.
      CALL DAWRIT(IDAF,IODA,VTMP,L3,524,0)
      CALL DAREAD(IDAF,IODA,VTMP,L3,IORBF1,0)
      DO I=1,NCORTOT
        CALL DCOPY(L1,SV(1,I),1,VTMP(1,I),1)
      ENDDO
C     SAVE THE (CORE) ORTHOGONAL QUASI-ATOMIC ORBITALS.
      CALL DAWRIT(IDAF,IODA,VTMP,L3,521,0)
C
C
C
C
C     PERFORM FINAL ERROR OUTS.
 8999 CONTINUE
      IF(MASWRK) THEN
        IF(IERR2.GT.0) THEN
          WRITE(IW,9003)
        ELSEIF(IERR3.GT.0) THEN
          WRITE(IW,9004) IERR3
        ENDIF
      ENDIF
      IF(IERR2.GT.0
     *  .OR.IERR3.GT.0
     *  ) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9002 FORMAT(1X,'SVD_AOSCF OPTION FINDS',I4,' CORE ORBITALS',
     *       1X,'FOR ATOM NUMBER=',I4)
 9003 FORMAT(1X,'*** ERROR IN LOCAL_PPASVDCORE ROUTINE.'/
     *       1X,'ERROR OCCURS FOR GLDIAG CALL.')
 9004 FORMAT(1X,'*** ERROR IN LOCAL_PPASVDCORE ROUTINE.'/
     *       1X,'IN SYMMETRIC ORTHOG.,'/
     *       1X,I4,' EIGENVALUES ARE BELOW TOL.')
      END
C*MODULE LOCAL   *DECK LOCAL_PPASVD
c> @brief      Routine makes SVD-localized valence orbitals.
c>
c> @author     Aaron West and Klaus Ruedenberg
c>             -November 4, 2012
c>
c> @details    Please see note about VTMP array within
c>             the 100 do loop if you plan to muck.
c>
c> @date November 16, 2012-Aaron West
c> -Removed some error outs for vtvec.  Symmetric molecules
c>  can have zeros here even in C1 point group.
c>  This error out was mainly for debugging bad code.
c>
c> @date December 20, 2012-Aaron West
c> -Add ormas check on orbital transformation
c>  to sort out issues earlier than MALMQ_CIDRIV.
C>
C> @date December 28, 2012-Aaron West
C> -Re-work orbital extraction to use only the orbital transformation
C>  to define the final orbital sets by transforming the orbitals
C>  in the IORBF1 file.
C>
C> @date January 09, 2013-Aaron West
C> -Re-work scheme for the number of orbitals to take from each SVD.
C>  Use ALL maximum SVD values from ALL atoms.
C>
C> @date January 12, 2013-Aaron West
C> -Re-worked large section of this routine.
C>  ORMAS runs should be able to auto-assign orbitals to atoms now.
C>
C> @date August 16, 2013-Aaron West
C> -Turned evalue sorting into a totally different beast.
C>  This effort began from trying to deal with dropped MOs
C>  in larger basis sets.
C>  From this change, future modifications should be easier.
C>
c> @param NCORTOT is total number of MCSCF core orbitals.
c>        For VVOS run, it is adjusted.
c> @param IORBF1 is the dat dict file for initial orbitals.
c> @param S2 stores AO basis overlaps on each atom.
c> @param S stores all the AO basis overlaps.
c> @param UVEC is the u matrix in SVD.
c> @param EIG holds eigenvalues from SVD.
c> @param VTVEC is the V-transpose matrix in SVD.
c> @param WRKSVD is the work array designed for gldiag and svd calls.
c> @param IWRK is the integer work array used
c>                    -- for symmetric matrix indices
c>                    -- for gldiag calls
c> @param VOLD contains the AO coefficients from IORBF1 daf dict file.
c> @param VTMP is temporary storage.
c> @param VSAV is temporary storage.
c> @param SV holds the AO basis overlap times AO coefficients matvec.
c> @param SAOMO is often S_IATM1**(-1/2) * SV on each IATM1 atom.
c> @param ISIZSVD is the workspace size for WRKSVD array.
c> @param NACT is the total number of active orbitals.
c> @param NACTBS is the total number of active orbitals and ignores
c>               any orbitals that are dropped for linear dependence.
c> @param LDSVD  is the memory given to IATLAB,IGRPLAB,etc.
c> @param L0 is the length of the MO variational space.
c> @param L1 is the length of the AO coefficients.
c> @param L2 is the triangular length of L1.
c> @param L3 is the square of L1.
c> @param MSTA         contains the starting orbitals for each
c>                     ORMAS group, or subspace.
c> @param ISIZE_FCCWFN is current size of fccwfn integer arrays.
c> @param NSPACE       is the number ORMAS groups.
c> @param LIMLOW array contains the lower basis function on an atom.
c> @param LIMSUP array contains the upper basis function on an atom.
c> @param NAT is the number of atoms.
c> @param IATMSTA      is an array that defines atoms for orbitals.
c> @param IATMSTA2     is an integer scratch array.
C> @param KEEPER       is a logical that equals true when
C>                     cistep=ormas and nspace>1 and ormful=false.
C> @param EIGSAV       saves the SVD evalues from ALL SVDs.
C>                     For each atom, an SVD is done.
C> @param EIGTMP       is scratch space to save EIGSAV array.
C> @param VTVECSAV     temporarily saves orbital transformations
C>                     for ALL SVDs from which transform elements
C>                     are selected.
C> @param IGRPLAB      is for ORMAS group labels with length of
C>                     LDSVD.
C> @param IATLAB       is for atom labels with length of
C>                     LDSVD.
C> @param IORDBIG      is integer scratch with length of
C>                     LDSVD.
C> @param IORDBIG2     is integer scratch with length of
C>                     LDSVD.
C> @param ISVMOR       is ISVMOR from ORNTMO common block.
C> @param IPOSMBS      denotes the integer array that holds the starting
C>                     position for the 1st MBS AO on a given atom.
C>                     These are in atomic order from the input
C>                     as usual.
C>                     I emphasize the CORE+VALENCE part.
C> @param ILENMBS      gives the number of VALANEC MBS orbitals.
C> @param IPOSCOR      denotes the integer array that holds the starting
C>                     position for the 1st CORE AO on a given atom.
C> @param ILENCOR      denotes the integer array that holds the number of
C>                     CORE orbitals on a given atom.
C> @param SVMBS        is an array that holds the overlap to the true AOs
C>                     from the VVOS run.
C>                     This overlap has a dimension of L1xL0MBS.
C> @param L0MBS        is the dimension of the minimal basis set
C>                     number of orbitals.
C>                     L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
C> @param SVDEXTOPT    preserves degenerate external orbitals
C>                     in the external orbital space by
C>                     discarding only orbitals with non-degenerate
C>                     SVD values on each atom.
C>                     However, this option must not allow any more
C>                     sperical externals than are allowed on a given
C>                     atom.
C> @param SVDAOS       is a toggle option for orthogonalizing
C>                     the input AOs.
C> @param SVD_INVAR    is a possible trial for invariant option.
C> @param SVD_AOSCF    is an option to use the AOs from VVOS
C>                     with high basis set quality.
C> @param SCFTYP       is the scftyp from common.
C> @param EXTLOC       defines the external orbital procedure (if any).
C> @param ISPHER       indicates treatment of basis functions
C>                     in terms of spherical or Cartesians.
C> @param IEXTSPACE    indicates the number of ORMAS groups that
C>                     begin above the L0MBS number of orbitals.
C> @param NATEXT       is an integer of chosen length.
C>                     Error outs are given for the length.
C> @param IATEXT       is integer scratch of length NAT*NATEXT.
C> @param NATLAB       is array for atom-orbital correspondence.
C> @param QMTTOL       is the threshold for linear dependence.
C> @param NAOTOT       is the true number of sphericals.
C> @param L0DEP0       is the current number of final spherical MOs.
C> @param SVDCOPT      is an option for setting up SVD runs where
C>                     cityp options differ from what SVD needs.
C>                     This option is specialized.
C> @param MASWRK       indicates the master process.
C> @param SOME         is true for master process with nprint
C>                     not equal -5.
C>
      SUBROUTINE LOCAL_PPASVD(
     *     NCORTOT,IORBF1,
     *     S2,S,UVEC,EIG,VTVEC,
     *     WRKSVD,IWRK,
     *     VOLD,VTMP,VSAV,
     *     SV,SAOMO,
     *     ISIZSVD,NACT,NACTBS,LDSVD,L0,L1,L2,L3,
     *     MSTA,ISIZE_FCCWFN,NSPACE,
     *     LIMLOW,LIMSUP,NAT,IATMSTA,IATMSTA2,KEEPER,
     *     EIGSAV,EIGTMP,VTVECSAV,IGRPLAB,
     *     IATLAB,IORDBIG,IORDBIG2,ISVMOR,
     *     IPOSMBS,ILENMBS,IPOSCOR,ILENCOR,SVMBS,L0MBS,
     *     SVDEXTOPT,SVDAOS,SVD_INVAR,
     *     SVD_AOSCF,SCFTYP,EXTLOC,
     *     ISPHER,
     *     IEXTSPACE,NATEXT,IATEXT,NATLAB,
     *     QMTTOL,NAOTOT,L0DEP0,SVDCOPT,
     *     MASWRK,SOME)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C-----------------------------------------------------------------------
      LOGICAL SOME,MASWRK,KEEPER,SVDEXTOPT,SVDAOS,
     *        SVD_INVAR,SVD_AOSCF,COMBO,COMBO2,COMBOSPHER,SVDCOPT,
     *        MODELORB
      INTEGER MXATM
      PARAMETER (MXATM=2000)
      DOUBLE PRECISION :: TMP,TOL,QMTTOL,
     *                    SCFTYP,EXTLOC,
     *                    RMC,RHF,RNONE,ROHF
      INTEGER NAT,LIMLOW(MXATM),LIMSUP(MXATM)
      INTEGER I,IATM1,IBAS1,IBAS2,IBASSPH1,IBASSPH2,IBASPOS,
     *        ILTH,ILTHSPH,ILTH_FIX,ILTH_SAV,ILTH_FIX_SAV,
     *        ILTH_FOR_SV,
     *        IORBF1,ISIZSVD,J,LDSVD,L0,L0BS,L0MBS,L1,L2,L3,
     *        NACT,NACTBS,NCORTOT,NUMVAL1,
     *        IERR5,IERR6,IERR7,IERR9,IERR10,IERR11,IERR
      INTEGER IPOS,IPOSMBS(NAT+1),ILENMBS(NAT),
     *             IPOSCOR(NAT+1),ILENCOR(NAT)
      INTEGER LOCAL_NUMVAL
      INTEGER IROW,JORB1,JORB2,JORBLEN,
     *        IDUM,ITMP,III,JJJ
      INTEGER NSPACE,ISPACE,NACTFIN,ISIZE_FCCWFN
      INTEGER NAOCART,NAOSPH,NAOTOT
      INTEGER ITMPNACT,ICT_ORB,NERR,IST,IEND,IEXTORB,IEXTORBF,
     *        NACTTMP,NACTDEP,L0DEP0
      INTEGER INFO,IKIND
C---------SPHERICAL HARMONIC STUFF---------------------
      LOGICAL IGNORE_SPHER
      INTEGER ISPHER
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: GROUP,COMPLX
      INTEGER IGROUP,NAXIS,ILABMO
      LOGICAL ABEL
C
      INTEGER IDAF,IODA,IP,IPK,IR,IS,IW,NAV
C-----------------------------------------------------------------------
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /SYMMOL/ GROUP,COMPLX,IGROUP,NAXIS,ILABMO,ABEL
C-----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       S2(L2),S(L2),
     *       WRKSVD(ISIZSVD),
     *       UVEC(L1,L1),EIG(L1),VTVEC(L1,L1),
     *       VOLD(L1,L1),VTMP(L1,L1),VSAV(L1,L1),
     *       SV(L1,L1),SAOMO(L1,L1),SVMBS(L1,L0MBS)
      DOUBLE PRECISION ::
     *       EIGSAV(LDSVD),EIGTMP(LDSVD),
     *       VTVECSAV(NACT,LDSVD)
      INTEGER NATLAB(L1),IWRK(L1,L1),
     *        IGRPLAB(LDSVD),IATLAB(LDSVD),
     *        IORDBIG(LDSVD),IORDBIG2(LDSVD),ISVMOR(NAT),
     *        IATMSTA2(NSPACE,NAT),IATMSTA(NSPACE,NAT),
     *        MSTA(ISIZE_FCCWFN)
      INTEGER LD_EXTOPT,IEXTSPACE,NATEXT,IATEXT(NAT,NATEXT)
C----------------------------------------------------------------------
      DOUBLE PRECISION :: SMALL
      PARAMETER (SMALL=1.0D-13)
C----------------------------------------------------------------------
C
C     DEFINE SOME DATA STUFF
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA RNONE/8HNONE    /
      DATA ROHF/8HROHF    /
C
C     SET UP TOL=QMTTOL
      TOL=ABS(QMTTOL)
C
C     INITIALIZE ALL POSSIBLE IERR VARS.
      IERR5=0
      IERR6=0
      IERR7=0
      IERR9=0
      IERR10=0
      IERR11=0
C
C     SETUP THE MBS ORBITAL POSITION AND LENGTH ARRAYS.
      CALL LOCAL_VVOS_ORB_RANGE_CORE(IPOSCOR,ILENCOR,NAT)
      CALL LOCAL_VVOS_ORB_RANGE(IPOSMBS,ILENMBS,NAT)
C
C------------------------------------------------------------
C     CONTINUE WITH CHUNKS OF ORIGINALLY INTENDED ROUTINE...
C------------------------------------------------------------
C
C
C     READ IN THE DESIRED ORBITALS.
      CALL DAREAD(IDAF,IODA,VOLD,L3,IORBF1,0)
C
C     SETUP SV=S*V=AO BASIS OVERLAP*AO COEFFS
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL MTARBR(S,L1,VOLD,L0,SV,L1,1)
C
C     CONVERT S AND SV OVER TO SPHERICALS IF NEEDED.
      IGNORE_SPHER=.FALSE.
      COMBOSPHER=ISPHER.GE.0
     *           .AND..NOT.SVDAOS
     *           .AND..NOT.IGNORE_SPHER
      IF(COMBOSPHER) THEN
        CALL SPHBCKU(UVEC,L1,L1,ITMP)
        IF(ITMP.NE.NAOTOT) THEN
          IF(MASWRK) WRITE(IW,*)
          IF(MASWRK) WRITE(IW,*) "LOCSVD ERROR FOR SPHBCKU"
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
        CALL VCLR(S2,1,L2)
        CALL TFTRI(S2,S,UVEC,WRKSVD,NAOTOT,L1,L1)
        CALL DCOPY(L2,S2,1,S,1)
        CALL VCLR(VTMP,1,L3)
        CALL MRTRBR(UVEC,L1,L1,NAOTOT,SV,L1,L0,VTMP,L1)
        CALL DCOPY(L3,VTMP,1,SV,1)
      ENDIF
C------------------------------------------------------------
C------------------------------------------------------------
C------------------------------------------------------------
C     LOOP OVER ALL ATOMS
C     NOTE:  SEPARATE CASES WITH 1 DIM.
      DO 100 IATM1=1,NAT
C------------------------------------------------------------
C------------------------------------------------------------
C------------------------------------------------------------
C
C       SET UP ATOMIC BASIS SET AND ITS DIMENSIONS.
        CALL LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *       LIMLOW,LIMSUP,IATM1,NAT,L2,
     *       S2,S,
     *       IBAS1,IBAS2,ILTH,
     *       IBASSPH1,IBASSPH2,ILTHSPH,
     *       COMBOSPHER)
        ILTH_SAV=ILTH
        ILTH_FIX=ILTH
        IBASPOS=IBAS1
        IF(COMBOSPHER) THEN
          ILTH_FIX=ILTHSPH
          IBASPOS=IBASSPH1
        ENDIF
        ILTH_FIX_SAV=ILTH_FIX
        ILTH_FOR_SV=ILTH_FIX
C
C       CHECK THAT AO LENGTHS FROM LOCAL_COUNTAOS MATCH.
        ITMP=IATM1
        CALL LOCAL_COUNTAOS(ITMP,NAOCART,NAOSPH)
        IERR10=0
        IF(NAOCART.NE.ILTH) IERR10=1
        IF(IERR10.GT.0) GO TO 8999
C
C       PERFORM S**(-1/2) ORTHOG.
C       NOTE:  SAOMO,VTVEC,UVEC,WRKSVD,IWRK ARE ALL SCRATCH.
        IKIND=3
        CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *       IKIND,ILTH_FIX,S2,WRKSVD,
     *       VTMP,VTVEC,UVEC,EIG,IWRK,WRKSVD,
     *       L1,L3,L2,.TRUE.,
     *       IW,MASWRK)
C
C
C       *****************************************************
C       *****************************************************
C       FOR EACH ROUND OF 100 LOOP, VTMP CANNOT BE DISTURBED.
C       NOTES:
C       VTMP=S**(-1/2) ON ATOM IATM1.
C       FOR SPHERICALS...
C       VTMP=[W*S**(-1/2)]-TRANS
C       VTMP HAS DIMENSION OF (ILTH_FIX,ILTH) AS NEEDED FOR
C       THE SVDS BELOW.  THIS PIECE IS CORRECT.
C       *****************************************************
C       *****************************************************
C
C------------------------------------------------------------
C       INITIALIZE NSPACE FOR ALDET TO AVOID COMPLAINTS
C       NOTE: EVEN THOUGH THE DIM WAS ALREADY DEFINED TO BE 1.
C       THE ORMAS LOOP
        DO 90 ISPACE=1,NSPACE
C         NO KEEPER LINE HERE BECAUSE WE WANT TO LOOK (NOT USE)
C         ALL POSSIBLE SVD VALUES.
C------------------------------------------------------------
C         DEFINE NACTFIN
C         DEFINE ITEMS NEEDED FOR UVEC COPY
C         RESET ILTH HERE FOR FIRST PART OF THE LOOP.
          IF(KEEPER) THEN
            NACTFIN=MSTA(ISPACE+1)-MSTA(ISPACE)
            JORB1=MSTA(ISPACE)
            JORB2=MSTA(ISPACE+1)-1
          ELSE
            NACTFIN=NACT
            JORB1=NCORTOT+1
            JORB2=NCORTOT+NACT
          ENDIF
          ILTH=ILTH_SAV
          ILTH_FIX=ILTH_FIX_SAV
C
C---------------------------------------------------------------
C---------------------------------------------------------------
C         FINISH FORMING THE SAOMO OVERLAP MATRIX.
C---------------------------------------------------------------
C---------------------------------------------------------------
          CALL VCLR(SAOMO,1,L3)
          CALL VCLR(UVEC,1,L3)
          IF(SVDAOS) THEN
            III=1
            DO JJJ=JORB1,JORB2
              CALL DCOPY(ILTH_FOR_SV,SV(IBASPOS,JJJ),1,SAOMO(1,III),1)
              III=III+1
            ENDDO
          ELSEIF(SVD_INVAR) THEN
            IF(ILTH_FOR_SV.NE.ILTH) THEN
              IF(MASWRK) WRITE(IW,*)
              IF(MASWRK) WRITE(IW,*) "SVD_INVAR ILTH_FOR_SV PROBLEM."
              CALL FLSHBF(IW)
              CALL ABRT
              STOP
            ENDIF
C           MAKE P_INVAR = (V)-TRANS * SV
            CALL MRTRBR(VOLD(IBASPOS,JORB1),L1,ILTH,NACTFIN,
     *                    SV(IBASPOS,JORB1),L1,NACTFIN,SAOMO,L1)
C
C           NOTE:  THE USE OF ILTH_SAV ABOVE.
            ILTH=NACTFIN
            ILTH_FIX=NACTFIN
          ELSEIF(SVD_AOSCF) THEN
            COMBO =NACT.EQ.L0-NCORTOT.AND.ISPACE.EQ.1
            COMBO =COMBO.OR.NACT.EQ.L0MBS-NCORTOT
            COMBO2=NACT.EQ.L0-NCORTOT.AND.ISPACE.EQ.2
C------------
            IF(SVDCOPT) THEN
              COMBO =ISPACE.EQ.1
              COMBO2=ISPACE.EQ.2
            ENDIF
C------------
            IF(COMBO) THEN
              IF(SOME.AND.IATM1.EQ.1) WRITE(IW,9038) ISPACE
C
C             E.G. FOR CARBON... FORM (4,L1)*(L1,NACTFIN) MATRIX.
C             THE INNER CONTRACTION IS NOW ACROSS ALL AO FXNS.
C             EARLIER, WE STOLE OUT S_BAS1*S_BAS2*V OF THE ATOMIC MOS
C                      FROM THE VVOS RUN INTO DAF FILE 533.
C             IN THIS EXAMPLE, OUR NULL SPACE IS NACTFIN-4.
C             SO, WE SHOULD SEE ONLY 4 NON-ZERO EIGENVALUES...
C
              IPOS=IPOSMBS(IATM1)
              ITMP=ILENMBS(IATM1)
              CALL MRTRBR(SVMBS(1,IPOS),L1,L1,ITMP,
     *                    VOLD(1,JORB1),L1,NACTFIN,SAOMO,L1)
C             NOTE:  THE USE OF ILTH_SAV ABOVE.
              ILTH=ITMP
              ILTH_FIX=ITMP
            ELSEIF(COMBO2) THEN
              IF(SOME.AND.IATM1.EQ.1) WRITE(IW,9039) ISPACE
              III=1
              DO JJJ=JORB1,JORB2
                CALL DCOPY(ILTH_FOR_SV,SV(IBASPOS,JJJ),1,UVEC(1,III),1)
                III=III+1
              ENDDO
              CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH_FOR_SV,
     *                    UVEC,L1,NACTFIN,SAOMO,L1)
            ELSE
              IF(MASWRK) WRITE(IW,9040)
              CALL FLSHBF(IW)
              CALL ABRT
              STOP
            ENDIF
C
          ELSE
C           PROCEED WITH SVD WITH ORTHOG. AOS.
            III=1
            DO JJJ=JORB1,JORB2
              CALL DCOPY(ILTH_FOR_SV,SV(IBASPOS,JJJ),1,UVEC(1,III),1)
              III=III+1
            ENDDO
            CALL MRARBR(VTMP,L1,ILTH_FIX,ILTH_FOR_SV,
     *                  UVEC,L1,NACTFIN,SAOMO,L1)
          ENDIF
C---------------------------------------------------------------
C---------------------------------------------------------------
C         END OF FINISH FORMING THE SAOMO OVERLAP MATRIX.
C---------------------------------------------------------------
C---------------------------------------------------------------
C
C
C---------------------------------------------------------------
C---------------------------------------------------------------
C         PERFORM SVD FOR IATM1, AND SAVE VARIOUS ITEMS
C---------------------------------------------------------------
C---------------------------------------------------------------
C
C         PERFORM THE SVD.
          CALL VCLR(UVEC,1,L3)
          CALL VCLR(VTVEC,1,L3)
          CALL VCLR(EIG,1,L1)
          CALL DGESVD('A','A',
     *                ILTH_FIX,NACTFIN,SAOMO,L1,EIG,
     *                UVEC,L1,VTVEC,L1,
     *                WRKSVD,ISIZSVD,INFO)
C
C         DEFINE THE NUMBER OF NON-ZERO VALUES.
C         PRINT OFF INITIAL EVALUES.
          ITMPNACT=MIN(ILTH_FIX,NACTFIN)
          IF(SOME) THEN
            IF(ISPACE.EQ.1) WRITE(IW,9045) IATM1
            DO I=1,ITMPNACT
              WRITE(IW,9050) ISPACE,I,EIG(I)
            ENDDO
          ENDIF
C
C         FORM(NACTFIN,ITMPNACT) VTVEC-TRANS MATRIX.
          CALL TRPOSQ(VTVEC,L1)
C
C         TEMPORARILY SAVE COLLECTIVE ITEMS E.G. EVALUES.
          IF(IATM1.EQ.1.AND.ISPACE.EQ.1) THEN
            ICT_ORB=0
            CALL VICLR(IGRPLAB,1,LDSVD)
            CALL VICLR(IATLAB,1,LDSVD)
            CALL VCLR(EIGSAV,1,LDSVD)
            CALL VCLR(VTVECSAV,1,NACT*LDSVD)
          ENDIF
          IF(KEEPER) THEN
            IROW=MSTA(ISPACE)-NCORTOT
          ELSE
            IROW=1
          ENDIF
          DO I=1,ITMPNACT
            ICT_ORB=ICT_ORB+1
            IGRPLAB(ICT_ORB)=ISPACE
            IATLAB(ICT_ORB)=IATM1
C           --NEXT LINE ALLOWS IDAMAX TO FUNCTION WHEN IGROUP NE 1.
            IF(IGROUP.NE.1.AND.EIG(I).LT.SMALL) EIG(I)=SMALL
            EIGSAV(ICT_ORB)=EIG(I)
            CALL DCOPY(NACTFIN,VTVEC(1,I),1,
     *                         VTVECSAV(IROW,ICT_ORB),1)
          ENDDO
C---------------------------------------------------------------
C---------------------------------------------------------------
C     END OF PERFORM SVD FOR IATM1, AND SAVE VARIOUS ITEMS
C---------------------------------------------------------------
C---------------------------------------------------------------
C
C------------------------------------------------------------
C------------------------------------------------------------
C------------------------------------------------------------
C       END LOOP OVER ORMAS GROUPS
   90   CONTINUE
C     END LOOP OVER ALL ATOMS
  100 CONTINUE
C
C     CHECK ON ICT_ORB NOW.
      IF(ICT_ORB.GT.LDSVD) THEN
        IF(MASWRK) WRITE(IW,9052)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C------------------------------------------------------------
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     SORTING PASSAGE TO OBTAIN ORBITALS.
C     NOTES:
C     --EACH STEP ORDERS A GIVEN NUMBER OF OBJECTS.
C     --HOW MANY OBJECTS REQUIRES SOME THOUGHT.
C------------------------------------------------------------
C------------------------------------------------------------
C
C     0.  SET THE NACTTMP VAR.
      NACTTMP=NACTBS
C
C     1.  MAKE A CHECK FOR BOGUS EIGENVALUES FOR C1 SYM. RUN.
      IERR11=0
      DO I=1,ICT_ORB
        IF(EIGSAV(I).LE.0.0D+00.AND.IGROUP.EQ.1) IERR11=IERR11+1
      ENDDO
      IF(IERR11.NE.0) GO TO 8999
C
C     2.  AMONG ICT_ORB ORBITALS, SORT BY:
C         --ORMAS GROUP.
C         --SVD VALUE.
      CALL LOCAL_SORT_SVDALL(
     *     0,
     *     NACT,ICT_ORB,LDSVD,
     *     IORDBIG,IORDBIG2,IGRPLAB,IATLAB,
     *     EIGSAV,VTVECSAV)
C
C     3.  CREATE IATMSTA ARRAY.
C         NOTES:
C         --ARRAYS ARE ORDERED BY ORMAS GROUPS,SVD VALUES.
C         --NUMBER OF ALLOWED ORBITALS PER ORMAS GROUP IS KNOWN.
C         --FIND THE ALLOWED ATOM LABELS.
C         --THEN, REORDER BY ALLOWED ATOM LABELS.
      CALL VICLR(IORDBIG,1,ICT_ORB)
      CALL VICLR(IATMSTA,1,NSPACE*NAT)
      CALL VICLR(ISVMOR,1,NAT)
      CALL VICLR(IATMSTA2,1,NSPACE*NAT)
      IST=0
      IEND=ICT_ORB+1
      DO I=1,ICT_ORB
C---------------------
        ISPACE=IGRPLAB(I)
        IATM1=IATLAB(I)
        IATMSTA2(ISPACE,1)=IATMSTA2(ISPACE,1)+1
C---------------------
C       NOTE:  JORBLEN DOES NOT DEPEND ON ACTIVE INDICES.
        IF(KEEPER) THEN
          JORB1=MSTA(ISPACE)
          JORB2=MSTA(ISPACE+1)-1
          IF(JORB2.EQ.L0) JORB2=L0+(NACTTMP-NACT)
          JORBLEN=JORB2-JORB1+1
        ELSE
          JORB1=NCORTOT+1
          JORB2=NCORTOT+NACTTMP
          JORBLEN=JORB2-JORB1+1
        ENDIF
C---------------------
        IF(IATMSTA2(ISPACE,1).LE.JORBLEN) THEN
          IST=IST+1
          IORDBIG(IST)=I
          IATMSTA(ISPACE,IATM1)=IATMSTA(ISPACE,IATM1)+1
          ISVMOR(IATM1)=ISVMOR(IATM1)+1
        ELSE
          IEND=IEND-1
          IORDBIG(IEND)=I
        ENDIF
C---------------------
      ENDDO
      CALL LOCAL_SORT_SVDEIG(
     *     NACT,ICT_ORB,
     *     LDSVD,EIGSAV,VTVECSAV,
     *     IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
C
C     4.  IF AN EXTERNAL SPACE IS PRESENT,
C         SORT DEGENERACY AMONG EXTERNAL ORBITALS.
C         NOTES:
C         --USER INPUT OF EXTERNAL ATOM LABELS IS CURRENTLY HOPELESS.
C         --IATMSTA IS NOW POSSIBLY LOST.
C           I ACCOUNT FOR THIS LOSS LATER.
C         --IN LOCAL_SVDEXTOPT_ACROSSATOMS,
C           SEE HOW LIMORB IS DEFINED.
      IF(SVDEXTOPT) THEN
        IF(NACT.NE.L0-L0MBS.AND.SOME) WRITE(IW,9800)
        ITMP=ICT_ORB
        LD_EXTOPT=LDSVD
        CALL LOCAL_SVDEXTOPT_ACROSSATOMS(
     *       ITMP,IGRPLAB,IATLAB,IORDBIG,
     *       IEXTSPACE,L1,L0,L0MBS,NCORTOT,NATEXT,
     *       IATEXT(1,1),IATEXT(1,2),IATEXT(1,3),IATEXT(1,4),
     *       NAT,LD_EXTOPT,NACT,NSPACE,MSTA,
     *       EIGSAV,EIGTMP,
     *       ILENCOR,ILENMBS,
     *       SOME,MASWRK,IW)
        CALL LOCAL_SORT_SVDEIG(
     *       NACT,ICT_ORB,
     *       LDSVD,EIGSAV,VTVECSAV,
     *       IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
        IERR=0
        DO I=1,L0MBS-NCORTOT
          IF(IORDBIG(I).NE.I) IERR=IERR+1
        ENDDO
        DO I=L0MBS-NCORTOT+1,NACTTMP
          IF(IGRPLAB(I).NE.NSPACE) IERR=IERR+1
        ENDDO
        IF(IERR.NE.0) THEN
          IF(MASWRK) WRITE(IW,9805)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ENDIF
C
C     5.  AMONG NACTTMP ORBITALS, SORT BY:
C         --ORMAS GROUP.
C         --SVD VALUE.
C         --ATOM LABEL.
      CALL LOCAL_SORT_SVDALL(
     *     1,
     *     NACT,NACTTMP,LDSVD,
     *     IORDBIG,IORDBIG2,IGRPLAB,IATLAB,
     *     EIGSAV,VTVECSAV)
C
C     6.  FINAL CHECK ON THE ORMAS GROUP LABELS.
      NERR=0
      DO ISPACE=1,NSPACE
        IF(KEEPER) THEN
          JORB1=MSTA(ISPACE)
          JORB2=MSTA(ISPACE+1)-1
          IF(JORB2.EQ.L0) JORB2=L0+(NACTTMP-NACT)
          JORB1=JORB1-MSTA(1)+1
          JORB2=JORB2-MSTA(1)+1
        ELSE
          JORB1=1
          JORB2=NACTTMP
        ENDIF
        DO I=JORB1,JORB2
          IF(IGRPLAB(I).NE.ISPACE) NERR=NERR+1
        ENDDO
      ENDDO
      IF(NERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9059)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF SORTING PASSAGE TO OBTAIN ORBITALS.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     SAVE NONORTHOG. INFO.
C------------------------------------------------------------
C------------------------------------------------------------
C
      L0BS=L0+NACTBS-NACT
      CALL DAREAD(IDAF,IODA,VSAV,L3,523,0)
      DO I=1,NACTBS
        CALL DCOPY(NACT,VTVECSAV(1,I),1,
     *                  VSAV(NCORTOT+1,NCORTOT+I),1)
      ENDDO
      DO I=NCORTOT+NACTBS+1,L0BS
        VSAV(I,I)=1.0D+00
      ENDDO
      IF(KEEPER) THEN
        CALL LOCAL_BLOCK_ORMAS(
     *       L1,NSPACE,MSTA,VSAV,
     *       MASWRK,IW)
      ENDIF
C
C     SAVE SOME INFORMATION NOW
      CALL VCLR(VTMP,1,L3)
      CALL MRARBR(VOLD,L1,L1,L0,VSAV,L1,L0BS,VTMP,L1)
      CALL DAWRIT(IDAF,IODA,VTMP,L3,539,0)
      CALL VICLR(IWRK,1,L3) ! increased for this routine.
      CALL DCOPY(NACTBS,IATLAB,1,IWRK,1)
      CALL DAWRIT(IDAF,IODA,IWRK,L1,540,1)
C
C     SAVE OTHER INFORMATION NOW
      CALL DAWRIT(IDAF,IODA,VTMP,L3,522,0)
      CALL DAWRIT(IDAF,IODA,VSAV,L3,523,0)
C
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF SAVE NONORTHOG. INFO.
C------------------------------------------------------------
C------------------------------------------------------------
C
C------------------------------------------------------------
C------------------------------------------------------------
CLINDEP      LINEAR DEPENDENCE PASSAGE TO OBTAIN ORBITALS.
C------------------------------------------------------------
C------------------------------------------------------------
C     SHRINK ORBITAL TRANSFORMATION:  PART 1
C     ---INITIALIZE IEXTORBF.
C     ---ENTER FOR NACTBS DIFFERENT THAN NACT.
      IF(NCORTOT+NACT.EQ.L0) THEN
        IEXTORBF=L0-L0MBS
      ELSE
        IEXTORBF=0
      ENDIF
      IF(NACTBS.EQ.NACT) GO TO 911
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 2
C     ---COPY OUT THE EXTERNAL ORBITALS ONLY.
C     ---COPY OUT SVD VALUES FOR THE EXTERNAL ORBITALS.
C     ---COPY OUT ATOM LABELS FOR THE EXTERNAL ORBITALS.
      CALL DAREAD(IDAF,IODA,VTMP,L3,522,0)
      CALL VCLR(VTVEC,1,L3)
      CALL VCLR(EIGTMP,1,LDSVD)
      CALL VICLR(IORDBIG,1,LDSVD)
      IEXTORB=0
      DO 555 I=1,L0BS-NCORTOT
        IF(IGRPLAB(I).NE.NSPACE) GO TO 555
        IEXTORB=IEXTORB+1
C     -----------------------TRICKY TRICKY SAID THE INDEXY.
        CALL DCOPY(L1,VTMP(1,NCORTOT+I),1,VTVEC(1,IEXTORB),1)
        EIGTMP(IEXTORB)=EIGSAV(I)
        IORDBIG(IEXTORB)=IATLAB(I)
  555 CONTINUE
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 3
C     ---PERFORM KR'S CRITERION WITH THE DISJUNCT SUMMATION.
C     ---IF CRITERION FAILS, ALSO PERFORM REMOVAL OF SMALL SVD EVALUES.
      CALL VCLR(VTMP,1,L3)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      IEXTORBF=0
      CALL LOCAL_CLINDEP(
     *     IEXTORB,IEXTORBF,NAOTOT,L0MBS,L0,L1,L2,L3,
     *     IORDBIG,IWRK(1,1),IWRK(1,2),
     *     VTVEC,EIGTMP,TOL,
     *     S,S2,VTMP,WRKSVD,EIG,
     *     SOME,MASWRK,IW)
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 4
C     ---PREPARE FOR CLINDEP REORDERING.
C        I.E. SETUP EVERYTHING IN TERMS OF NACTBS.
      IPOS=L0MBS-NCORTOT
      CALL VCLR(UVEC,1,L3)
      CALL DCOPY(L1*(NAOTOT-L0MBS),VTVEC,1,UVEC(1,IPOS+1),1)
      CALL DCOPY(L3,UVEC,1,VTVEC,1)
      CALL DAREAD(IDAF,IODA,UVEC,L3,539,0)
      CALL DCOPY(L1*IPOS,UVEC(1,NCORTOT+1),1,VTVEC,1)
      CALL VCLR(VTMP,1,L3)
      CALL DCOPY(L1*NACTBS,UVEC(1,NCORTOT+1),1,VTMP,1)
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 5
C     ---PERFORM CLINDEP REORDERING.
      IDUM=0
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL OVLSEL(VTMP,EIG,VTVEC,S,
     *            UVEC,IORDBIG,WRKSVD,IORDBIG,
     *            IDUM,IDUM,L0,L1,L2,.FALSE.,NACTBS)
      CALL VCLR(VTMP,1,L3)
      CALL VCLR(VTVEC,1,L3)
      CALL LOCAL_SORT_SVDEIG(
     *     NACT,NACTBS,
     *     LDSVD,EIGSAV,VTVECSAV,
     *     IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
C
C------------------------------------------------------------
C------------------------------------------------------------
CLINDEP       END OF LINEAR DEPENDENCE PASSAGE TO OBTAIN ORBITALS.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C     FORM NONORTHOG. TRANSFORM AND ORBITALS.
C     --SET UP THE NACTDEP VAR.
C     --GET AT NONORTHOG. TRANSFORM AS IT IS CURRENTLY ORDERED.
C     --CHECK ORMAS BLOCK-DIAGONAL FORM.
  911 CONTINUE
CLINDEP       NACTDEP VAR.
      NACTDEP=L0MBS-NCORTOT+IEXTORBF
      IF(SVDCOPT) NACTDEP=NACT
CLINDEP     L0DEP0
      IF(NCORTOT+NACT.EQ.L0) THEN
        L0DEP0=NCORTOT+NACTDEP
      ELSE
        L0DEP0=L0
      ENDIF
C
      IF(KEEPER.AND.SOME) WRITE(IW,9060)
      CALL DAREAD(IDAF,IODA,VSAV,L3,523,0)
      DO I=1,NACTDEP
C     -----------------------TRICKY TRICKY SAID THE INDEXY.
        CALL DCOPY(NACT,VTVECSAV(1,I),1,
     *                  VSAV(NCORTOT+1,NCORTOT+I),1)
      ENDDO
      DO I=NCORTOT+NACTDEP+1,L0DEP0
        VSAV(I,I)=1.0D+00
      ENDDO
      IF(KEEPER) THEN
        CALL LOCAL_BLOCK_ORMAS(
     *       L1,NSPACE,MSTA,VSAV,
     *       MASWRK,IW)
      ENDIF
      CALL DAWRIT(IDAF,IODA,VSAV,L3,523,0)
      CALL VCLR(VTMP,1,L3)
C     -----------------------TRICKY TRICKY SAID THE INDEXY.
      CALL MRARBR(VOLD,L1,L1,L0,VSAV,L1,L0DEP0,VTMP,L1)
      CALL DAWRIT(IDAF,IODA,VTMP,L3,522,0)
C
C     PERFORM (POSSIBLY) SYMMETRIC ORTHOGONALIZATION
C     NOTE:  VTMP MUST BE SAVED FOR A BIT...
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL DAREAD(IDAF,IODA,VTMP,L3,522,0)
      CALL VCLR(S2,1,L2)
      CALL TFTRI(S2,S,VTMP(1,NCORTOT+1),WRKSVD,NACTDEP,L1,L1)
      IKIND=3
      CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *     IKIND,NACTDEP,S2,UVEC,
     *     VTMP,VTVEC,SAOMO,EIG,IWRK,WRKSVD,
     *     L1,L3,L2,.TRUE.,
     *     IW,MASWRK)
      MODELORB=.TRUE.
      IF(MODELORB) THEN
        CALL LOCAL_MODELORB_DRIV(
     *       KEEPER,IORBF1,L1,NACTDEP,L0DEP0,
     *       IATLAB,VTMP)
      ENDIF
C
C     FORM ORTHOGONAL TRANSFORM AND ORBITALS.
      CALL DAREAD(IDAF,IODA,VSAV,L3,524,0)
      DO I=1,NACTDEP
C     -----------------------TRICKY TRICKY SAID THE INDEXY.
        CALL DCOPY(NACT,VTMP(1,I),1,
     *                  VSAV(NCORTOT+1,NCORTOT+I),1)
      ENDDO
      DO I=NCORTOT+NACTDEP+1,L0DEP0
        VSAV(I,I)=1.0D+00
      ENDDO
      IF(KEEPER) THEN
        CALL LOCAL_BLOCK_ORMAS(
     *       L1,NSPACE,MSTA,VSAV,
     *       MASWRK,IW)
      ENDIF
      CALL DAWRIT(IDAF,IODA,VSAV,L3,524,0)
      CALL DAREAD(IDAF,IODA,SV,L3,522,0)
      CALL VCLR(VTMP,1,L3)
      CALL MRARBR(SV,L1,L1,L0,VSAV,L1,L0DEP0,VTMP,L1)
      CALL DAWRIT(IDAF,IODA,VTMP,L3,521,0)
C
C     CONSTRUCT AND SAVE OVERALL TRANSFORM.
      CALL VCLR(SV,1,L3)
      CALL DAREAD(IDAF,IODA,VTMP,L3,523,0)
      CALL DAREAD(IDAF,IODA,VSAV,L3,524,0)
      CALL MRARBR(VTMP,L1,L0DEP0,L0DEP0,VSAV,L1,L0DEP0,SV,L1)
      CALL DAWRIT(IDAF,IODA,SV,L3,525,0)
      IF(KEEPER) THEN
        CALL LOCAL_BLOCK_ORMAS(
     *       L1,NSPACE,MSTA,SV,
     *       MASWRK,IW)
      ENDIF
C
C     DETERMINE GOODNESS OF MO OVERLAP.
      IDUM=0
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL DAREAD(IDAF,IODA,SV,L3,522,0)
      CALL DAREAD(IDAF,IODA,VTMP,L3,521,0)
      CALL OVLSEL(VTMP,EIG,SV,S,
     *            UVEC,IWRK,WRKSVD,IWRK,
     *            IDUM,IDUM,L0,L1,L2,.FALSE.,L0DEP0)
C     REORDER THE NONORTHOGONAL ORBITAL OVERLAPS.
      CALL REORDR(UVEC,IWRK,L0DEP0,L1)
C     NEVER TAKE THE REORDERED ORTHOGONAL ORBITALS.
      CALL VCLR(VTMP,1,L3)
C     PRINT OFF THE ABS. VALUE OF THE DIAGONAL OVERLAPS.
      IF(SOME) THEN
        WRITE(IW,9830)
        DO I=1,NCORTOT+NACTDEP
          TMP=ABS(UVEC(I,I))
          WRITE(IW,9831) I,TMP
        ENDDO
      ENDIF
C
C     ENSURE THAT ORBITALS ARE ORTHONORMAL NOW.
      CALL DAREAD(IDAF,IODA,VTMP,L3,521,0)
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     L0DEP0,L1,L2,
     *     S2,S,VTMP,WRKSVD,
     *     MASWRK,IW)
C
C------------------------------------------------------------
C------------------------------------------------------------
C     FINAL RESET OF ATOMIC-BASED INDEXING FOR TRUTH.
C------------------------------------------------------------
C------------------------------------------------------------
      CALL VICLR(IATMSTA,1,NSPACE*NAT)
      CALL VICLR(ISVMOR,1,NAT)
      DO I=1,NACTDEP
        IATM1=IATLAB(I)
        ISPACE=IGRPLAB(I)
        IATMSTA(ISPACE,IATM1)=IATMSTA(ISPACE,IATM1)+1
        ISVMOR(IATM1)=ISVMOR(IATM1)+1
        NATLAB(NCORTOT+I)=IATM1
      ENDDO
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF FINAL RESET OF ATOMIC-BASED INDEXING FOR TRUTH.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     NICE ERROR CHECKING SECTION.
C------------------------------------------------------------
C------------------------------------------------------------
C
C     RECHECK THAT ISVMOR HAS NACT LENGTH.
      ITMP=0
      DO I=1,NAT
        ITMP = ITMP + ISVMOR(I)
      ENDDO
      IERR5=0
      IF(ITMP.NE.NACTDEP) IERR5=1
      IF(IERR5.GT.0) GO TO 8999
C
C     RECHECK ISVMOR THROUGH LOCAL_NUMVAL INTEGER FUNCTION.
      IERR9=0
      IF(EXTLOC.EQ.RNONE) THEN
        IF(SCFTYP.EQ.RMC) THEN
          ITMP=0
          DO I=1,NAT
            NUMVAL1=LOCAL_NUMVAL(I,0)
            ITMP=ITMP+NUMVAL1
          ENDDO
          IERR5=0
          IF(ITMP.NE.NACTDEP) IERR5=1
          IF(IERR5.GT.0) GO TO 8999
        ELSEIF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
C         NO CHECK HERE.
C         IF CHECK IS DESIRED, ADD NEW ARGUMENTS TO LOCAL_NUMVAL.
        ELSE
          IERR9=1
          GO TO 8999
        ENDIF
      ELSE
C       NO CURRENT CHECK HERE.
      ENDIF
C
C     CHECK THAT ISVMOR AND NATLAB 'JIVE'.
      IF(KEEPER) THEN
        IERR6=0
        DO J=1,NAT
          ITMP=0
          DO I=NCORTOT+1,NCORTOT+NACTDEP
            IF(NATLAB(I).EQ.J) ITMP=ITMP+1
          ENDDO
          IF(ITMP.NE.ISVMOR(J)) IERR6=IERR6+1
        ENDDO
        IF(IERR6.GT.0) GO TO 8999
      ENDIF
C
C     CHECK THAT ALL ENTRIES IN ISVMOR ARE GREATER THAN 0.
      IERR7=0
      DO J=1,NAT
        IF(ISVMOR(J).LE.0) IERR7=IERR7+1
      ENDDO
      IF(IERR7.GT.0) GO TO 8999
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF NICE ERROR CHECKING SECTION.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     FINAL PRINT SECTION FOR TRUTH.
C------------------------------------------------------------
C------------------------------------------------------------
C
C     PRINT FINAL ORGANIZATION OF SVD VALUES.
      IF(SOME) THEN
        WRITE(IW,9810)
        DO I=1,NACTDEP
          WRITE(IW,9820) I,IGRPLAB(I),IATLAB(I),EIGSAV(I)
        ENDDO
      ENDIF
C
C     PRINT OFF NEW ORBITAL NUMBERS ON EACH ATOM.
      IF(SOME) THEN
        WRITE(IW,9054)
        DO IATM1=1,NAT
          WRITE(IW,9056) IATM1,ISVMOR(IATM1)
        ENDDO
      ENDIF
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF FINAL PRINT SECTION FOR TRUTH.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C------------------------------------------------------------
C------------------------------------------------------------
C     PRINT OFF ORBITAL SETS LAST.
C------------------------------------------------------------
C------------------------------------------------------------
C     PRINT NONOROTHOG. ORBITALS INTO .LOG FILE.
      CALL DAREAD(IDAF,IODA,VTMP,L3,522,0)
      IF(SOME) THEN
        WRITE(IW,9069)
        WRITE(IW,9071) NCORTOT+NACTDEP
        CALL PRSQL(VTMP,NCORTOT+NACTDEP,L1,L1)
      ENDIF
C     PRINT ORTHOG. ORBITALS INTO .LOG FILE.
      CALL DAREAD(IDAF,IODA,VTMP,L3,521,0)
      IF(SOME) THEN
        WRITE(IW,9070)
        WRITE(IW,9071) NCORTOT+NACTDEP
        CALL PRSQL(VTMP,NCORTOT+NACTDEP,L1,L1)
      ENDIF
C     PRINT ORTHOG. ORBITALS INTO .DAT FILE.
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(VTMP,NCORTOT+NACTDEP,L1,L1)
        WRITE(IP,9085)
      ENDIF
C------------------------------------------------------------
C------------------------------------------------------------
C     END OF PRINT OFF ORBITAL SETS LAST.
C------------------------------------------------------------
C------------------------------------------------------------
C
C
C
C
C     PERFORM FINAL ERROR OUTS.
 8999 CONTINUE
      IF(MASWRK) THEN
        IF(IERR5.GT.0) THEN
          WRITE(IW,9006)
        ELSEIF(IERR6.GT.0) THEN
          WRITE(IW,9007)
        ELSEIF(IERR7.GT.0) THEN
          WRITE(IW,9008)
        ELSEIF(IERR9.GT.0) THEN
          WRITE(IW,9010)
        ELSEIF(IERR10.GT.0) THEN
          WRITE(IW,9011)
        ELSEIF(IERR11.GT.0) THEN
          WRITE(IW,9012)
        ENDIF
      ENDIF
      IF(IERR5.GT.0
     *  .OR.IERR6.GT.0
     *  .OR.IERR7.GT.0
     *  .OR.IERR9.GT.0
     *  .OR.IERR10.GT.0
     *  .OR.IERR11.GT.0
     *  ) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9006 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'
     *       /1X,'ISVMOR WAS RESET AND NO LONGER EQUALS NACT.',
     *       /1X,'CHECK IF MOS WERE DROPPED FOR LINEAR DEPENDENCE..')
 9007 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ISVMOR AND NATLAB DO NOT AGREE.')
 9008 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'ISVMOR HAS VALUES LESS THAN 1.',
     *      /1X,'YOU MIGHT WANT TO CHECK OUT THE SVD EVALUES,',
     *       1X,'AND USE THE ISVMOR ARRAYS FOR INPUT.')
 9010 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'PLEASE CODE IN LOCAL_NUMVAL CHECK FOR',
     *       1X,'A NEW SCFTYP OPTION.')
 9011 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'LENGTHS FROM LOCAL_COUNTAOS VS. LIMLOW AND LIMSUP',
     *       1X,'DO MATCH UP.')
 9012 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *       1X,'SVD EVALUES CANNOT BE LESS THAN OR EQUAL TO ZERO.',
     *       1X,'ALSO, THEN IDAMAX SORTING DOES NOT WORK.')
 9038 FORMAT(/1X,'---CHECKING SVD--- AAMBS ARE USED FOR GROUP=',I4)
 9039 FORMAT(/1X,'---CHECKING SVD--- ORTHOGONALIZED SV',
     *       1X,'IS USED FOR GROUP=',I4)
 9040 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *      /1X,'ISVDOP=10 IS NOT SACTIONED FOR USE OF',
     *       1X,' NSPACE>2 AND MORE THAN MBS ORBITALS.',
     *      /1X,'YOU ARE LOST.  TURN BACK NOW.')
 9045 FORMAT(/1X,'SVD EIGENVALUES NOW FOLLOW FOR ATOM NUMBER=',I4)
 9050 FORMAT(1X,'GROUP=',I4,
     *       5X,'ACTIVE ORBITAL=',I4,5X,'SVD EIGENVALUE=',F12.7)
 9052 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *      /1X,'ICT_ORB EXCEEDS ALLOWED MEMORY.')
 9054 FORMAT(/1X,'FINAL ATOM NUMBERS:')
 9056 FORMAT( 1X,'ATOM =',I4,5X,'ACTIVE ORBITALS NUMBER=',I4)
 9059 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *      /1X,'IN ATOM LABELS SORTING,',
     *       1X,'IGRPLAB DOES NOT MAKE ANY SENSE.')
 9060 FORMAT(/1X,'LOCAL_PPASVD KEEPS ORBITALS WITHIN',
     *        1X,'ORMAS SUBSPACES.')
 9069 FORMAT(//10X,'NONORTHOGONAL PPA SVD LOCALIZED ORBITALS')
 9070 FORMAT(//10X,'PPA SVD LOCALIZED ORBITALS')
 9071 FORMAT(10X,I5,1X,'ORBITALS ARE LOCALIZED BY',
     *        1X,'SINGULAR VALUE DECOMPOSITION',
     *      /16X,'INTO PURE PROJECTED ATOMIC ORBITALS.')
 9080 FORMAT('PPA SVD LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9800 FORMAT(//1X,'DEALING WITH QMTTOL ISSUES FOR SVD.')
 9805 FORMAT(1X,'*** ERROR IN LOCAL_PPASVD ROUTINE.'/
     *      /1X,'SVDEXTOPT HAS ISSUES WITH REORDERING ARRAY.')
 9810 FORMAT(/1X,'FINAL SVD ORDERING SCHEME:')
 9820 FORMAT(1X,'COUNT,ORMAS GROUP,ATOM,SVD VALUE=',
     *       1X,5X,I4,2X,I4,2X,I4,2X,F12.7)
 9830 FORMAT(/1X,'MO OVERLAP COMPARISON:',
     *       /1X,'COMPARE NONORTHOGONAL AND ORTHOGONAL ORBITAL',
     *        1X,'OVERLAPS')
 9831 FORMAT(1X,'ORBITAL,MO OVERLAP=',I4,F12.7)
      END
C*MODULE LOCAL   *DECK LOCAL_SETUP_PPADEN
C> @brief      Sets up SVD densities for different runs.
C>
C> @author     Aaron West
C>             -July 13, 2013
C>
C> @details    The set up depends on many options:
C>             VVOs,orbital swappings,scftyp,extloc,etc.
C>
C> @date October 18, 2013-Aaron West
C> -Reset some density sizes.
C>  Checked all other parts of log files by script.
C>  Checked density matrices for examples by hand.
C>
C> @param IORBF1        denotes the initial orbital file.
C> @param NSKIP         denotes number of valence doubly occupieds.
C> @param NSKIP2        denotes number of orbitals to skip over
C>                      (if any) when the VVOs were shifted.
C> @param NSKIP_SING    denotes number of singly occupied orbitals
C>                      (if any).
C> @param NACT_OCC      denotes number of localized valence orbitals.
C>                      This variable controls resultant file sizes
C>                      for different kinds of runs.
C> @param NACTSV_OCC    is the total number of MCSCF active orbitals
C>                      before VVOS dimensional changes.
C> @param NCORTOT       denotes total number of chemical core orbitals.
C> @param NA            denotes core+valence occupieds for some runs.
C>                      e.g. RHF,ROHF
C> @param NB            denotes total core+valence doubly occupieds.
C> @param IMBS          is the total number of MBS valence orbitals.
C> @param L1            is the total number of AOs for the molecule.
C> @param IDENFIL       indicates the DAF file that holds the density.
C> @param IDENSIZ       indicates the size of the file read.
C> @param EXTLOC        defines the external orbital procedure (if any).
C> @param SWITCH_ORBS   indicates if the VVOs orbital group was moved.
C> @param SOME          is true for master process with
C>                      nprint not equal -5.
C> @param MASWRK        indicates the master process.
C> @param IW            indicates write out to the log file.
      SUBROUTINE LOCAL_SETUP_PPADEN(
     *           IORBF1,NSKIP,NSKIP2,NSKIP_SING,NACT_OCC,NACTSV_OCC,
     *           NCORTOT,NA,NB,IMBS,L1,IDENFIL,IDENSIZ,
     *           EXTLOC,
     *           SWITCH_ORBS,SOME,MASWRK,IW)
      IMPLICIT NONE
      LOGICAL SWITCH_ORBS,SOME,MASWRK
      INTEGER IW,
     *        IORBF1,NSKIP,NSKIP2,NSKIP_SING,NACT_OCC,NACTSV_OCC,
     *        NCORTOT,NA,NB,IMBS,L1,IDENFIL,IDENSIZ
      DOUBLE PRECISION :: EXTLOC
C-------------------------------------------------------------------
      LOGICAL OK
      INTEGER ITMP,ITMP2,NACTSV_OCC2
C-------------------------------------------------------------------
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-------------------------------------------------------------------
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-------------------------------------------------------------------
      DOUBLE PRECISION :: RHF,RMC,ROHF,RNONE
C-------------------------------------------------------------------
C
C     DATA STUFF
      DATA RHF/8HRHF     /
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
      DATA RNONE/8HNONE    /
C
C     INITIALIZE IDENSIZ AND IDENFIL
      IDENFIL=0
      IDENSIZ=0
C
C     INITIALIZE NSKIP_SING.
      NSKIP_SING=0
C
C     LONG PASSAGE TO SET UP DENSITY,ETC, FOR DIFFERENT KIND OF RUNS.
C---------------------------------------------------
      IF(EXTLOC.EQ.RNONE) THEN
C---------------------------------------------------
        IF(SCFTYP.EQ.RMC) THEN
C         DO NOTHING FOR NSKIP STUFF.
          IF(IORBF1.EQ.15) THEN
            IF(SOME) WRITE(IW,9010)
C           ALWAYS PUT FILE DEFS LAST.
            IDENFIL=320
            NACTSV_OCC2=(NACTSV_OCC*NACTSV_OCC+NACTSV_OCC)/2
            IDENSIZ=NACTSV_OCC2
          ELSEIF(IORBF1.EQ.19) THEN
            IF(SOME) WRITE(IW,9020)
C           ALWAYS PUT FILE DEFS LAST.
            IDENFIL=19
            IDENSIZ=L1
          ELSE
            IF(MASWRK) WRITE(IW,9030)
            IF(MASWRK) WRITE(IW,9500)
            CALL FLSHBF(IW)
           CALL ABRT
          ENDIF
        ELSEIF(SCFTYP.EQ.RHF
     *         .AND.CCTYP.EQ.RNONE.AND.IORBF1.EQ.15) THEN
          IF(SOME) WRITE(IW,9040)
C         WORKS FOR RHF AND ISVDOP=0.
          NSKIP =NA-NCORTOT
          NSKIP2=0
          NACT_OCC=IMBS
        ELSEIF(SCFTYP.EQ.RHF
     *         .AND.CCTYP.NE.RNONE.AND.IORBF1.EQ.15) THEN
          IF(SOME) WRITE(IW,9041)
          NSKIP =0
          NSKIP2=0
          NACT_OCC=IMBS
          ITMP=(NACT_OCC*NACT_OCC+NACT_OCC)/2
          IDENSIZ=ITMP
          IDENFIL=554
        ELSEIF(SCFTYP.EQ.ROHF
     *         .AND.CCTYP.EQ.RNONE.AND.IORBF1.EQ.15) THEN
          IF(SOME) WRITE(IW,9060)
          NSKIP=NB-NCORTOT
          NSKIP2 =IMBS-(NA-NCORTOT)
          NSKIP_SING=NA-NB ! accounts for closed-shell ROHF.
          NACT_OCC=IMBS
        ELSE
          IF(MASWRK) WRITE(IW,9500)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
C---------------------------------------------------
      ELSE  ! EXTLOC.NE.RNONE
C---------------------------------------------------
        IF(SCFTYP.EQ.RHF
     *     .AND.CCTYP.EQ.RNONE.AND.IORBF1.EQ.15) THEN
          IF(SOME) WRITE(IW,9040)
          NSKIP=NA-NCORTOT
          NSKIP2=0
          NACT_OCC=IMBS
        ELSEIF(SCFTYP.EQ.RMC
     *         .AND.CCTYP.EQ.RNONE.AND.IORBF1.EQ.15) THEN
          IF(SOME) WRITE(IW,9050)
          CALL LOCAL_SVDVVOS_RMC_SETUP1(ITMP,ITMP2)
          NSKIP=ITMP-NCORTOT
          NACTSV_OCC=ITMP2
          NSKIP2=0
          IF(NACTSV_OCC.LE.IMBS) NACT_OCC=IMBS
C         ALWAYS PUT FILE DEFS LAST.
          IDENFIL=320
          NACTSV_OCC2=(NACTSV_OCC*NACTSV_OCC+NACTSV_OCC)/2
          IDENSIZ=NACTSV_OCC2
        ELSEIF(SCFTYP.EQ.ROHF
     *         .AND.CCTYP.EQ.RNONE.AND.IORBF1.EQ.15) THEN
          IF(SOME) WRITE(IW,9060)
          NSKIP=NB-NCORTOT
          NSKIP2 =IMBS-(NA-NCORTOT)
          NSKIP_SING=NA-NB ! accounts for closed-shell ROHF.
          NACT_OCC=IMBS
        ELSE
          IF(MASWRK) WRITE(IW,9500)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
      ENDIF
C     END OF LONG PASSAGE TO SET UP DENSITY FOR DIFFERENT KINDS OF RUNS.
C
C
C
C     ERROR OUT FOR SWITCH_ORBS
C     --IF SWITCH_ORBS IS TRUE,
C       THE THE VVOS ORBITALS WERE RE-POSITIONED.
      OK=EXTLOC.NE.RNONE.AND.SCFTYP.NE.RMC
      OK=OK.OR.EXTLOC.EQ.RNONE
      IF(OK) THEN
        IF(SWITCH_ORBS) THEN
          IF(NSKIP2.EQ.0) THEN
            IF(MASWRK) WRITE(IW,9200)
            CALL FLSHBF(IW)
            CALL ABRT
          ENDIF
        ELSE
          IF(NSKIP2.NE.0) THEN
            IF(MASWRK) WRITE(IW,9210)
            CALL FLSHBF(IW)
            CALL ABRT
          ENDIF
        ENDIF
      ENDIF
C
      RETURN
 9010 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  STARTING WITH CANONICAL ORBITAL',
     *        1X,'DENSITY FROM DAF FILE 320.')
 9020 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  STARTING WITH NATURAL ORBITAL',
     *        1X,'DENSITY FROM DAF FILE 21.')
 9030 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  IORBF1 ORBITAL CHOICE HAS NO',
     *        1X,'DENSITY FILE PROGRAMED.  PLEASE ADD ONE.')
 9040 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  STARTING WITH RHF DENSITY.')
 9041 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  STARTING WITH CC DENSITY.')
 9050 FORMAT(/1X,'LOCAL_SETUP_PPADEN:',
     *       /1X,'THIS RHF EXTLOC RUN STARTED WITH MCSCF.',
     *       /1X,'SO, A DENSITY MATRIX MUST BE PICKED UP.')
 9060 FORMAT(/1X,'LOCAL_SETUP_PPADEN:  STARTING WITH ROHF DENSITY.')
 9200 FORMAT(/1X,'LOCAL_SETUP_PPADEN ERROR:',
     *       /1X,'THIS RUN MOVED THE VVOS ORBITAL GROUP.',
     *        1X,'HOWEVER, NSKIP2 EQUALS 0.',
     *       /1X,'THIS COMBINATION IS PROBABLY NOT POSSIBLE.')
 9210 FORMAT(/1X,'LOCAL_SETUP_PPADEN ERROR:',
     *       /1X,'THIS RUN DID NOT MOVE THE VVOS ORBITAL GROUP.',
     *        1X,'HOWEVER, NSKIP2 IS GREATER THAN 0.',
     *       /1X,'THIS COMBINATION IS PROBABLY NOT POSSIBLE.')
 9500 FORMAT(/1X,'LOCAL_SETUP_PPADEN ERROR:',
     *       /1X,'THIS OPTION DOES NOT EXIST IN THE CODE.')
      END
C*MODULE LOCAL   *DECK LOCAL_PPADEN1
C> @brief      Extracts initial density for quasi-atomic orbital run.
C>
C> @author     Aaron West
C>             -January 11, 2014
C>
C> @param NCORSV        equals saved number of core orbitals.
C> @param NACTSV_OCC    equals saved number of active orbitals.
C> @param NACT_OCC      equals number of active orbitals.
C> @param L1            is the length of the AO coefficients.
C> @param L2            equals triangular length of L1.
C> @param NSKIP         gives how many doubly-occupieds to skip
C>                      over for VVOS run.
C> @param NSKIP2        gives how many virtuals to re-assign
C>                      to active orbitals for VVOS run.
C> @param NSKIP_SING    gives singly occupieds e.g. ROHF.
C> @param IVVOS         equals 1 indicates a VVOS run.
C> @param IORBF1        gives daf dict file with starting orbitals.
C> @param IDENFIL       gives the DAF file that holds the density.
C> @param IDENSIZ       gives the size of IDENFIL.
C> @param DEN           is original density in the MO basis.
C> @param DEN2          will hold the transformed density.
C> @param WRK           is L1 workspace.
C> @param SOME          is true for master process with
C>                      nprint not equal -5.
C> @param MASWRK        indicates master process.
      SUBROUTINE LOCAL_PPADEN1(
     *           NCORSV,NACTSV_OCC,NACT_OCC,L1,L2,
     *           NSKIP,NSKIP2,NSKIP_SING,
     *           IVVOS,IORBF1,IDENFIL,IDENSIZ,
     *           DEN,DEN2,WRK,
     *           SOME,MASWRK)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK
      INTEGER NCORSV,NACT_OCC,NACTSV_OCC,L1,L2,
     *        NSKIP,NSKIP2,NSKIP_SING,
     *        IVVOS,IORBF1,IDENFIL,IDENSIZ
      DOUBLE PRECISION ::
     *       DEN(L2),DEN2(L2),WRK(L1)
C-----------------------------------------------------------------------
      INTEGER NACTSV_OCC2,IPOS,IJ,IJ2,I,J,I2,J2
C-----------------------------------------------------------------------
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C----------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       ONE,TWO,
     *       RMC,RNONE
      PARAMETER (ONE=1.0D+00,TWO=2.0D+00)
      DATA RMC/8HMCSCF   /
      DATA RNONE/8HNONE    /
C----------------------------------------------------------------------
C
C     DEFINE SOME NEEDED DIMENSIONS.
      NACTSV_OCC2=(NACTSV_OCC*NACTSV_OCC+NACTSV_OCC)/2
C
C     CLEAR OUT SOME ARRAYS
      CALL VCLR(DEN,1,L2)
      CALL VCLR(DEN2,1,L2)
      CALL VCLR(WRK,1,L1)
C
C     READ IN THE DENSITY
      IF(IDENSIZ.NE.0.AND.IDENFIL.NE.0) THEN
        CALL DAREAD(IDAF,IODA,DEN,IDENSIZ,IDENFIL,0)
      ENDIF
C
C     PERFORM ANY NON-VVOS EXTRA OPERATIONS TO REORDER DENSITY
      IF(SCFTYP.EQ.RMC.AND.IORBF1.EQ.19) THEN
        IF(SOME) WRITE(IW,9010)
        IF(IDENSIZ.EQ.0.OR.IDENFIL.EQ.0) THEN
          IF(MASWRK) WRITE(IW,9020)
          CALL FLSHBF(IW)
          CALL ABRT
        ENDIF
        CALL DCOPY(L1,DEN,1,WRK,1)
        CALL VCLR(DEN,1,L2)
        DO I=1,NACTSV_OCC
          WRK(I)=WRK(I+NCORSV)
        ENDDO
        DO I=1,NACTSV_OCC
          IJ=(I*I-I)/2 + I
          DEN(IJ)=WRK(I)
        ENDDO
      ENDIF
C
C     DEAL OUT ANY OCCUPATIONS FROM THE VVOS STUFF.
      IF(IVVOS.NE.0.AND.CCTYP.EQ.RNONE) THEN
        CALL VCLR(DEN2,1,L2)
        CALL DCOPY(NACTSV_OCC2,DEN,1,DEN2,1)
        CALL VCLR(DEN,1,L2)
        DO I=1,NSKIP
          IJ=(I*I-I)/2 + I
          DEN(IJ)=TWO
        ENDDO
C
        DO I=NSKIP+NSKIP2+1,NSKIP+NSKIP2+NSKIP_SING
          IJ=(I*I-I)/2 + I
          DEN(IJ)=ONE
        ENDDO
C
        IPOS=NSKIP+NSKIP_SING+NSKIP2
        DO I=1,NACTSV_OCC
          DO J=1,I
            IJ =(I*I-I)/2 + J
            I2=I+IPOS
            J2=J+IPOS
            IJ2=(I2*I2-I2)/2 + J2
            DEN(IJ2)=DEN2(IJ)
          ENDDO
        ENDDO
C
        IF(SCFTYP.EQ.RMC) THEN
          IF(SOME) WRITE(IW,9030)
        ENDIF
C
        IF(SOME) THEN
          WRITE(IW,9040)
          CALL PRTRI(DEN,NACT_OCC)
        ENDIF
      ENDIF
C
C     FINAL CHECK ON CORRECT FILES.
      IF(IVVOS.NE.0.AND.IORBF1.NE.15) THEN
        IF(MASWRK) WRITE(IW,9050)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9010 FORMAT(/1X,'LOCAL_PPADEN1:  STARTING WITH NATURAL ORBITAL',
     *        1X,'DENSITY FROM DAF FILE 19.')
 9020 FORMAT(/1X,'LOCAL_PPADEN1 ERROR:',
     *       /1X,'DAF FILE 19 REQUIRES NON-ZERO VALUES FOR',
     *        1X,'IDENFIL,IDENSIZE.')
 9030 FORMAT(/1X,'NOTE:  PREVIOUS PRINT OFF FOR DENSITY DOES NOT',
     *       /1X,'       MATCH HERE BECAUSE IT IS',
     *        1X,'NOT CANONICAL DENSITY.')
 9040 FORMAT(/1X,'DENSITY MATRIX FOR VVOS BEFORE ORTHORGONAL',
     *       /1X,'QUASI-ATOMIC SVD MO ORBITAL TRANSFORMATION.')
 9050 FORMAT(/1X,'LOCAL_PPADEN1:  YOUR DENSITY IS PROBABLY WRONG!',
     *       /1X,'VVOS WAS PROGRAMMED TO WORK WITH DAF FILE 15.',
     *        1X,'RE-RERUN OR RE-PROGRAM WITH FAO FOR NOS',
     *        1X,'AND REMOVE ERROR.')
      END
C*MODULE LOCAL   *DECK LOCAL_PPADEN2
C> @brief      Forms densities for quasi-atomic orbitals.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -November 4, 2012
C>
C> @date January 19, 2013-Aaron West
C> -Re-worked for VVOS runs.
C>
C> @date July 13, 2013-Aaron West
C> -Re-worked with the addition of setup_ppaden.
C>  Also, made some simplifications after more experience.
C>
C> @date January 11, 2013-Aaron West
C> -Added nonorthogonal densities.
C> -Ripped apart routine into two pieces for new option.
C>
C> @param IOPTNON    =0 exits early with nonorthogonal density.
C>                   =1 exits later with orthogonal density.
C> @param NCORTOT    is the total number of MCSCF core orbitals.
C>                   For VVOS run, it is adjusted.
C> @param NACT_OCC   is the total number of MCSCF active oribtals.
C> @param L0DEP0     beholden the allmighty L0DEP0.
C> @param L1         is the length of the AO coefficients.
C> @param L3         is the square of L1.
C> @param NAT        is the number of atoms.
C> @param DEN        contains the original density in the
C>                   canonical MO basis.
C> @param DEN2       will hold the transformed density.
C> @param VTMP       holds the overall orthogonal
C>                   orbital transformation.
C> @param SCR        is workspace for the transformation.
C> @param IWRK       is integer scratch space.
C> @param EXTLOC     defines the external orbital procedure (if any).
C> @param SOME       is true for master process with
C>                   nprint not equal -5.
C> @param MASWRK     indicates master process.
      SUBROUTINE LOCAL_PPADEN2(
     *           IOPTNON,
     *           NCORTOT,NACT_OCC,L0DEP0,L1,L3,
     *           NAT,
     *           DEN,DEN2,VTMP,SCR,IWRK,
     *           EXTLOC,
     *           SOME,MASWRK)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK
      INTEGER IOPTNON,
     *        NCORTOT,NACT_OCC,L0DEP0,L1,L3,
     *        NAT
      DOUBLE PRECISION ::
     *       EXTLOC
C-----------------------------------------------------------------------
      INTEGER IWRK(L1)
      DOUBLE PRECISION ::
     *       DEN(L3),DEN2(L3),VTMP(L1,L1),SCR(L3)
C-----------------------------------------------------------------------
      INTEGER NACT_OCC2,
     *        IJ,IJ2,I,J,
     *        LTPOS
      DOUBLE PRECISION ::
     *       ATSUM,ATSUM2,TMP,
     *       RNONE,
     *       TOLDEN
      PARAMETER (TOLDEN=0.1D+00)
C-----------------------------------------------------------------------
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C----------------------------------------------------------------------
      DATA RNONE/8HNONE    /
C----------------------------------------------------------------------
C
C     DEFINE SOME NEEDED DIMENSIONS.
      NACT_OCC2=(NACT_OCC*NACT_OCC+NACT_OCC)/2
C
C     FIND NONORTHOGONAL DENSITY MATRIX.
C     --FORM T-INV * DEN * [T-INV]-DAGGER.
      CALL DAREAD(IDAF,IODA,VTMP,L3,523,0)
      CALL LOCAL_SQMAT_INV(
     *     VTMP,DEN2,SCR,L1,L0DEP0,
     *     MASWRK,IW)
      CALL TRPOSQ(VTMP,L1)
      CALL VCLR(DEN2,1,L3)
      CALL TFTRI(DEN2,DEN,VTMP(NCORTOT+1,NCORTOT+1),SCR,
     *           NACT_OCC,NACT_OCC,L1)
      IF(SOME) THEN
        WRITE(IW,9500)
        CALL PRTRI(DEN2,NACT_OCC)
      ENDIF
C
C     FIND NONORTHOGONAL OVERLAP MATRIX.
      CALL VCLR(SCR,1,L3)
      CALL DAREAD(IDAF,IODA,VTMP,L3,523,0)
      CALL MRTRBR(VTMP(NCORTOT+1,NCORTOT+1),L1,NACT_OCC,NACT_OCC,
     *            VTMP(NCORTOT+1,NCORTOT+1),L1,NACT_OCC,
     *            SCR,L1)
C
C     FIND MULLIKEN POPUATIONS.
      CALL VCLR(VTMP,1,L3)
      DO I=1,NACT_OCC
        DO J=1,NACT_OCC
          IJ =LTPOS(I,J)
          IJ2=I+L1*(J-1) ! square symmetric matrix
          VTMP(I,I)=VTMP(I,I)+DEN2(IJ)*SCR(IJ2)
        ENDDO
      ENDDO
      DO I=1,NACT_OCC
        IF(SOME) WRITE(IW,9510) I,VTMP(I,I)
      ENDDO
C
C     EXIT EARLY WITHOUT REPLACING NONORTHOGONAL DENSITY.
      IF(IOPTNON.EQ.0) RETURN
C---------------------------------------------------------------------
C---------------------------------------------------------------------
C---------------------------------------------------------------------
C
C     READ IN THE OVERALL ORTHOGONALIZING QUAO TRANSFORMATION.
      CALL DAREAD(IDAF,IODA,VTMP,L3,525,0)
C
C     TRANSFORM THE DENSITY BY BLOCK-DIAGONAL TRANFORMATION:
C     NEW ORBS = ORIG ORBS * VTMP
C     NEW DENSITY = VTMP-TRANS * DEN * VTMP
C     --SAVE DENSITY MATRIX
C     ----FILE 526 FOR KEEPS
C     ----FILE 285 FOR ORIENTATION
      CALL TFTRI(DEN2,DEN,VTMP(NCORTOT+1,NCORTOT+1),SCR,
     *           NACT_OCC,NACT_OCC,L1)
      IF(EXTLOC.EQ.RNONE) THEN
        CALL DAWRIT(IDAF,IODA,DEN2,NACT_OCC2,526,0)
        CALL DAWRIT(IDAF,IODA,DEN2,NACT_OCC2,285,0)
      ELSE
        CALL DAWRIT(IDAF,IODA,DEN2,NACT_OCC2,536,0)
      ENDIF
C
C     PRINT OUT THE DENSITY.
      IF(SOME) THEN
        WRITE(IW,9000)
        CALL PRTRI(DEN2,NACT_OCC)
      ENDIF
C
C     GRAB ATOM-ORBITAL CORRESPONDENCE.
      CALL VCLR(IWRK,1,L1)
      CALL DAREAD(IDAF,IODA,IWRK,L1,528,1)
C
C     PRINT OUT ATOMIC POPULATIONS.
      DO J=1,NAT
        ATSUM =0.0D+00
        ATSUM2=0.0D+00
        DO I=1,NACT_OCC
          IF(IWRK(I).EQ.J) THEN
            IJ=(I*I-I)/2 + I
            TMP=DEN2(IJ)
            ATSUM=ATSUM+TMP
            IF(TMP.GT.TOLDEN) ATSUM2=ATSUM2+TMP
          ENDIF
        ENDDO
        IF(SOME) WRITE(IW,9020) J,ATSUM,TOLDEN,ATSUM2
      ENDDO
C
      RETURN
 9000 FORMAT(/1X,'DENSITY MATRIX IN THE',
     *        1X,'ORTHOGONAL QUASI-ATOMIC SVD MO BASIS',
     *       /1X,'OVER ACTIVE ORBITALS IS')
 9020 FORMAT(/1X,'ATOM',I5,3X,'SVD POPULATION =',F5.3,
     *        3X,'GREATER THAN ',F5.3,' CONTRIBUTIONS=',F5.3)
 9500 FORMAT(/1X,'DENSITY MATRIX IN THE',
     *        1X,'NONORTHOGONAL SVD QUAO BASIS',
     *       /1X,'OVER ACTIVE ORBITALS IS')
 9510 FORMAT(/1X,'ACTIVE ORBITAL=',I5,3X,'MULLIKEN POPULATION= ',F5.3)
      END
C*MODULE LOCAL   *DECK LOCAL_KEEPER_SETUP
C> @brief      Set up variables for ilocal=4 runs.
C>
C> @author     Aaron West
C>             -January 12, 2013
C>
C> @date January 30, 2013-Aaron West
C> -Added ISVDOP to ORNTMO common block.
C> This run gives special option for SVD runs.
C>
C> @param KEEPER     is a logical and is true when
C>                   CISTEP=ORMAS + NSPACE>1 + ORMFUL=.FALSE.
C>                   SCFTYP=RHF
C> @param IMODE      resets part of the MSTA array.
C> @param L1         is the length of LCAO coefficients.
C> @param IGRP       is integer array of length L1.
C>
      SUBROUTINE LOCAL_KEEPER_SETUP(KEEPER,IMODE,L1,IGRP)
      IMPLICIT NONE
      LOGICAL KEEPER
      DOUBLE PRECISION :: ORMAS,RMC,RHF,ROHF
      INTEGER I,ISPACE,IMODE,L1,IGRP(L1)
      INTEGER NCORSV,NACTSV
C----------------------------------------------------------------
      INTEGER MXNORO
      PARAMETER (MXNORO=250)
      INTEGER MXATM
      PARAMETER (MXATM=2000)
C----------------------------------------------------------------
      LOGICAL FDIRCT,QCORR
      INTEGER NSPACE,MSTA,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,IBMA,IDIMFCC,
     *        LBST,NREF0
      DOUBLE PRECISION ::
     *       C0SQ
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION ::
     *       FINALCI,METHOD,CISTEP,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT
C
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
      INTEGER ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C----------------------------------------------------------------
C
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C----------------------------------------------------------------
C
C     DATA STUFF
      DATA ORMAS/8HORMAS   /
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA ROHF/8HROHF    /
C
C     SETUP THE 'KEEPER' VAR
      IF(SCFTYP.EQ.RMC) THEN
        KEEPER=CISTEP.EQ.ORMAS.AND.NSPACE.GT.1.AND..NOT.ORMFUL
      ELSEIF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
        KEEPER=.TRUE.
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SETUP WAVEFXN ORMAS GROUP LABELS.
      CALL LOCAL_SVDVVOS_RMC_SETUP1(NCORSV,NACTSV)
      CALL VICLR(IGRP,1,L1)
      DO I=NCORSV+1,NCORSV+NACTSV
        IGRP(I)=1
      ENDDO
      IF(CISTEP.EQ.ORMAS) THEN
        DO ISPACE=1,NSPACE
          IF(IMODE.EQ.1) MSTA(NSPACE+1)=NCORSV+NACTSV+1
          DO I=MSTA(ISPACE),MSTA(ISPACE+1)-1
            IGRP(I)=ISPACE
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_KEEPER_SETUP ERROR:',
     *        1X,'PLEASE CODE A NEW KEEPER VAR OPTION.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_MOS
C> @brief      Routine moves around orbital file for VVOS-SVD.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param SWITCH_ORBS is an array that determines if any orbital
C>                    switchings actually occur.
C> @param IWRK    is scratch array for integers that will
C>                reorder MOs.
C> @param SCFTYP  gives the wave function type e.g. mcscf,rhf,etc.
C> @param L0      is the length of the MO variational space.
C> @param NCORSV  denotes the original MCSCF run doubly occupied size.
C> @param NCORTOT denotes the chemical cores as defined by NVVOS_NUMCOR.
C> @param NACTSV  denotes the original MCSCF run active space size.
C> @param NSKIP   denotes the number of filled doubly occupieds
C>                i.e. MDOC.
C> @param NSKIP2  denotes the now filled but previously empty virutals.
C> @param NA      is total occupieds for RHF,ROHF.
C> @param NB      is total doubly occupieds for ROHF.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to the log file.
      SUBROUTINE LOCAL_SVDVVOS_MOS(
     *           SWITCH_ORBS,IWRK,SCFTYP,
     *           L0,NCORSV,NCORTOT,NACTSV,NSKIP,NSKIP2,NA,NB,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK,SWITCH_ORBS
      INTEGER L0,NCORSV,NCORTOT,NACTSV,NSKIP,NSKIP2,NA,NB,IW
      INTEGER IWRK(L0)
      INTEGER I,NERR,ISING,ITOT
      DOUBLE PRECISION :: SCFTYP,RMC,ROHF
C
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
C
C
      NERR=0
      CALL VICLR(IWRK,1,L0)
C
      IF(SCFTYP.EQ.RMC) THEN
      ITOT=0
      DO I=1,NCORTOT+NSKIP
        ITOT=ITOT+1
        IWRK(ITOT)=I
      ENDDO
      DO I=1,NSKIP2
        ITOT=ITOT+1
        IWRK(ITOT)=NCORSV+NACTSV+I
      ENDDO
      DO I=1,NACTSV
        ITOT=ITOT+1
        IWRK(ITOT)=NCORSV+I
      ENDDO
      DO I=NCORSV+NACTSV+NSKIP2+1,L0
        ITOT=ITOT+1
        IWRK(I)=I
      ENDDO
C
      ELSEIF(SCFTYP.EQ.ROHF) THEN
      ISING=NA-NB
      ITOT=0
      DO I=1,NCORTOT+NSKIP
        ITOT=ITOT+1
        IWRK(ITOT)=I
      ENDDO
      DO I=1,NSKIP2
        ITOT=ITOT+1
        IWRK(ITOT)=NCORTOT+NSKIP+ISING+I
      ENDDO
      DO I=1,ISING
        ITOT=ITOT+1
        IWRK(ITOT)=NCORTOT+NSKIP+I
      ENDDO
      DO I=NCORTOT+NSKIP+NSKIP2+ISING+1,L0
        ITOT=ITOT+1
        IWRK(I)=I
      ENDDO
C
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        NERR=NERR+1
      ENDIF
C
C     POSSIBLY SET SWITCH_ORBS TO TRUE.
      DO I=1,L0
        IF(IWRK(I).NE.I) SWITCH_ORBS=.TRUE.
      ENDDO
      IF(SCFTYP.EQ.ROHF.AND.ISING.EQ.0) SWITCH_ORBS=.TRUE.
C
C     CHECK NUMBER OF ORBITALS COPIED OVER MAKES SENSE.
      IF(ITOT.NE.L0) THEN
        IF(MASWRK) WRITE(IW,9001)
        NERR=NERR+1
      ENDIF
C
      IF(NERR.NE.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_SVDVVOS_MOS ERROR:',
     *        1X,'SCFTYP WAS NOT PROGRAMED FOR ORBITAL REORDERING.')
 9001 FORMAT(/1X,'LOCAL_SVDVVOS_MOS ERROR:',
     *        1X,'VVOS DIMENSIONS MUST BE WRONG.',
     *        1X,'ORBITALS COPIED DOES NOT TOTAL UP TO L0 MOS.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_REDIM_STEP0
C> @brief      Initializes ncorsv and nactsv for SVD runs.
C>
C> @author     Aaron West
C>             -March 21, 2014
C>
C> @param L0       is the number of variational molecular orbitals.
C> @param NCORTOT  is the total number of chemical core orbitals.
C> @param NCORSV   is the total number of core orbitals.
C> @param NACTSV   is the total number of active SVD orbitals.
C> @param EXTLOC   indicates an external orbitals run.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to the log file.
      SUBROUTINE LOCAL_SVDVVOS_REDIM_STEP0(
     *           L0,NCORTOT,NCORSV,NACTSV,
     *           EXTLOC,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IW,
     *        L0,NCORTOT,NCORSV,NACTSV
      DOUBLE PRECISION :: EXTLOC
C---------------------------------------------------------------------
      DOUBLE PRECISION :: RHF,RMC,ROHF,RNONE
C---------------------------------------------------------------------
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C---------------------------------------------------------------------
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C---------------------------------------------------------------------

C
C     DATA STUFF
      DATA RHF/8HRHF     /
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
      DATA RNONE/8HNONE    /
C
C     ASSIGN NCORSV AND NACTSV.
      NCORSV=NCORTOT
      NACTSV=L0-NCORTOT
      IF(EXTLOC.EQ.RNONE) THEN
        IF(SCFTYP.EQ.RMC) THEN
          CALL LOCAL_SVDVVOS_RMC_SETUP1(NCORSV,NACTSV)
        ELSEIF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
        ELSE
          IF(MASWRK) WRITE(IW,9050)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ELSE
        IF(SCFTYP.EQ.RMC) THEN
        ELSEIF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
        ELSE
          IF(MASWRK) WRITE(IW,9050)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ENDIF
C
      RETURN
 9050 FORMAT(/1X,'LOCAL_SVDVVOS_REDIM_STEP0 ERROR:',
     *       /1X,'SCFTYP DOES NOT EXIST YET.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_REDIM_STEP1
C> @brief      Routine sets up VVOS ormas nspace and orbital sizes.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @details    This routine is a bit convoluted.
C>             I have wasted many months condensing options
C>             for many runtyps into this current routine.
C>             Modification of this redimensioning system
C>             is an ongoing experience for many options.
C>             The following might occur in the future:
C>             --more un-complications.
C>             --re-visit CLINDEP issues.
C>             --possible creation of LSPACE,LSTA arrays.
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param NAT          is the number of atoms.
C> @param NCORSV       is the original MCSCF doubly occupied space.
C> @param NACTDT       is the original MCSCF active space size.
C> @param L0           is the size of the MO variational space.
C> @param NSPACE       indicates the number of ORMAS groups.
C> @param NSPACE_SAV   saves the original ORMAS group size.
C> @param ISIZE_FCCWFN is set to length of msta common var.
C> @param MSTA         contains the ORMAS orbital ranges.
C> @param MSTA_SAV     saves the original MCSCF orbital ranges.
C> @param NCORTOT      is the chemical cores as defined
C>                     by NVVOS_NUMCOR.
C> @param NSKIP        denotes the number of filled doubly occupieds
C>                     i.e. MDOC.
C> @param NACT         denotes the number of VVOS active space orbitals.
C> @param NSKIP2       denotes the now filled but
C>                     previously empty virutals.
C> @param NVIR2        denotes the number of VVOS virtual orbitals.
C> @param NA           is total occupieds for RHF,ROHF.
C>                     Here, it is only used for ROHF.
C> @param NB           is total doubly occupieds for ROHF.
C> @param IVVOS        equals 1 indicates a VVOS run.
C> @param CISTEP       indicates the CI converger.
C>                     At this point, running VVOS orbitals through SVD.
C> @param SOME         is true for master process
C>                             with nprint not equal -5.
C> @param MASWRK       indicates the master process.
C> @param IW           indicates write out to the log file.
C>
      SUBROUTINE LOCAL_SVDVVOS_REDIM_STEP1(
     *           NAT,NCORSV,NACTDT,L0,
     *           NSPACE,NSPACE_SAV,
     *           ISIZE_FCCWFN,MSTA,MSTA_SAV,
     *           NCORTOT,NSKIP,NACT,NSKIP2,NVIR2,
     *           NA,NB,IVVOS,CISTEP,
     *           SOME,MASWRK,IW)
C
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER NAT,NCORSV,NACTDT,L0,
     *        NSPACE,NSPACE_SAV,ISIZE_FCCWFN,
     *        NCORTOT,NSKIP,NACT,NSKIP2,NVIR2,
     *        NA,NB,IVVOS,
     *        MSTA(ISIZE_FCCWFN),MSTA_SAV(ISIZE_FCCWFN),
     *        IW,I,ITMP,ITMPMBS,ISWMBS,
     *        LOCAL_NUMVAL
      DOUBLE PRECISION :: CISTEP
C
      DOUBLE PRECISION :: ORMAS,RMC,RHF,RNONE,ROHF,SPLITQ2
C---------------------------------------------------------------------
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
      INTEGER ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C---------------------------------------------------------------------
      INTEGER MXATM
      PARAMETER (MXATM=2000)
C---------------------------------------------------------------------
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
C
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C---------------------------------------------------------------------
C
C     DATA STUFF.
      DATA ORMAS/8HORMAS   /
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA RNONE/8HNONE    /
      DATA ROHF/8HROHF    /
      DATA SPLITQ2/8HSPLITQ2 /
C
C     SAVE THE NSPACE ALWAYS.
C     PRESERVE THE MSTA ARRAY.
      NSPACE_SAV=NSPACE
      CALL ICOPY(ISIZE_FCCWFN,MSTA,1,MSTA_SAV,1)
C
C     INITIALIZE NSPACE TO 1.
      IF(CISTEP.NE.ORMAS) NSPACE=1
      IF(SCFTYP.EQ.RMC) THEN
      ELSEIF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
        NSPACE=1
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C     CHECK ON NSPACE NOW.
      ITMP=ISIZE_FCCWFN
      IF(IVVOS.NE.0) ITMP=ISIZE_FCCWFN-2
      IF(NSPACE.GT.ITMP) THEN
        IF(MASWRK) WRITE(IW,9005)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     CREATE SOME MBS DIMS.
      ISWMBS=1
      ITMPMBS=0
      DO I=1,NAT
        ITMPMBS=ITMPMBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
C
C     INITIALIZE NSKIP,NSKIP2,NACT,NVIR2
      NSKIP=0
      NSKIP2=0
      NACT=NACTDT
      NVIR2=L0-NCORTOT-NSKIP-NSKIP2-NACTDT
C
C     SET UP CASE FOR FULL-VALENCE ORBITAL SPACE.
      IF(SCFTYP.EQ.RMC.AND.NACTDT.EQ.ITMPMBS) THEN
        IF(NSPACE.EQ.1) THEN
          MSTA(1)=NCORTOT+1
          MSTA(2)=NCORTOT+ITMPMBS+1
        ENDIF
        GO TO 8000
      ENDIF
C
C     SKIP OVER FOR NO VVOS CASE.
      IF(IVVOS.EQ.0) GO TO 8000
C
C     ASSIGN DIMS FOR DIFFERENT WAVEFXNS.
      IF(SCFTYP.EQ.RMC.AND.EXTLOC.EQ.RNONE) THEN
        NSPACE=NSPACE_SAV+1
        ITMP=0
        DO I=1,NAT
          ITMP=ITMP+LOCAL_NUMVAL(I,0)
        ENDDO
C       NOTES:  SEE VVOS ROUTINE FOR SIMILAR VARS.
        NSKIP  =NCORSV-NCORTOT
        NSKIP2 =ITMP-NSKIP-NACTDT
        NACT   =NACTDT+NSKIP+NSKIP2
        NVIR2  =L0-NCORTOT-NSKIP-NSKIP2-NACTDT
        IF(NACT.EQ.NACTDT.AND.NSPACE_SAV.EQ.1) NSPACE=1
C---------------------------------
        DO I=NSPACE,1,-1
          MSTA(I+1)=MSTA(I)+NSKIP2
        ENDDO
        MSTA(1)=NCORTOT+1
C---------------------------------
      ELSEIF(SCFTYP.EQ.RMC.AND.EXTLOC.NE.RNONE) THEN
        NSPACE=2
        IF(EXTLOC.EQ.SPLITQ2) NSPACE=1
        NSKIP  =NA-NCORTOT
        NSKIP2 =0
        NACT   =NACTDT
        IF(EXTLOC.EQ.SPLITQ2) NACT=ITMPMBS
        NVIR2  =L0-NCORTOT-NSKIP-NSKIP2-NACTDT
        MSTA(1)=NCORTOT+1
        MSTA(2)=NCORTOT+ITMPMBS+1
        MSTA(3)=L0+1
      ELSEIF(SCFTYP.EQ.RHF) THEN
        NSPACE=2
        IF(EXTLOC.EQ.SPLITQ2) NSPACE=1
        NSKIP  =NA-NCORTOT
        NSKIP2 =0
        NACT   =NACTDT
        IF(EXTLOC.EQ.SPLITQ2) NACT=ITMPMBS
        NVIR2  =L0-NCORTOT-NSKIP-NSKIP2-NACTDT
        MSTA(1)=NCORTOT+1
        MSTA(2)=NCORTOT+ITMPMBS+1
        MSTA(3)=L0+1
      ELSEIF(SCFTYP.EQ.ROHF) THEN
        NSPACE=2
        IF(EXTLOC.EQ.SPLITQ2) NSPACE=1
        NSKIP  =NB-NCORTOT
        NSKIP2 =ITMPMBS-(NA-NCORTOT)
        NACT   =NACTDT
        IF(EXTLOC.EQ.SPLITQ2) NACT=ITMPMBS
        NVIR2  =L0-NCORTOT-NACTDT
        MSTA(1)=NCORTOT+1
        MSTA(2)=NCORTOT+ITMPMBS+1
        MSTA(3)=L0+1
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     OVERIDE ASSIGNMENTS FOR ORMFUL.
C     NOTE:  IF ONE CREATES LSTA,LSPACE, THEN NEED ANOTHER OVERIDE.
 8000 CONTINUE
      IF(ORMFUL.AND.ORMRESET) THEN
        IF(EXTLOC.EQ.RNONE) THEN
          NSPACE=1
          MSTA(1)=NCORTOT+1
          MSTA(2)=NCORTOT+ITMPMBS+1
C         PERMANENTLY RESET ORMAS DIMS.
          NSPACE_SAV=NSPACE
          CALL ICOPY(ISIZE_FCCWFN,MSTA,1,MSTA_SAV,1)
        ELSE
          IF(MASWRK) WRITE(IW,9010)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ENDIF
C
C     OVERIDE ASSIGNMENTS FOR SVDCOPT.
      IF(SVDCOPT) THEN
C       ERROR OUT.
        IF(ORMFUL) THEN
          IF(MASWRK) WRITE(IW,9020)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C       RE-DEFINE DIMS.
        NSPACE=2
        MSTA(1)=NCORTOT+1
        MSTA(2)=NCORTOT+ITMPMBS+1
        MSTA(3)=NCORTOT+NACTDT+1
      ENDIF
C
C     PRINT OUT ASSIGNMENTS FOR VVOS CASES.
      IF(IVVOS.NE.0.OR.ORMFUL.OR.SVDCOPT) THEN
        IF(SOME) WRITE(IW,9090) NSPACE,(MSTA(I),I=1,NSPACE)
        IF(SOME) WRITE(IW,9100) NCORTOT,NSKIP,NACTDT,NSKIP2,NVIR2
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_SVDVVOS_REDIM_STEP1 ERROR:',
     *        /1X,'THIS DIMENSIONING DOES NOT EXIST.')
 9005 FORMAT(/1X,'LOCAL_SVDVVOS_REDIM_STEP1 ERROR:',
     *       /1X,'VVOS-SVD MCSCF RUNS MUST BE ALLOWED TO USE MORE',
     *        1X,'OF THE MSTA ARRAY.',
     *       /1X,'MSTA IS IN A COMMON WITH FIXED DIMENSION.',
     *        1X,'YOU NEED TO INCREASE FIXED DIMENSION OF MSTA',
     *        1X,'EVERYWHERE.')
 9010 FORMAT(//1X,'LOCAL_SVDVVOS_REDIM_STEP1 ERROR:',
     *        /1X,'ORMFUL IS NOT COMPATIBLE WITH EXTLOC.')
 9020 FORMAT(//1X,'LOCAL_SVDVVOS_REDIM_STEP1 ERROR:',
     *        /1X,'ORMFUL IS NOT COMPATIBLE WITH SVDCOPT.')
 9090 FORMAT(//1X,'SVDVVOS ORMAS GROUPS.',
     *        /1X,'THE NUMBER OF SPACES             =',I4,
     *        /1X,'EACH SPACE STARTS AT ORBITAL     =',50I4//)
 9100 FORMAT(/1X,'DEFINING ORBITAL SIZES FOR VVOS RUN...'/
     *       /1X,'CHEMICAL     CORE    ORBTIALS =',I5,
     *       /1X,'ORIG. FILLED VALENCE ORBITALS =',I5,
     *       /1X,'ORIG. ACTIVE VALENCE ORBITALS =',I5,
     *       /1X,'ORIG. EMPTY  VALENCE ORIBTALS =',I5,
     *       /1X,'NEW   VIRTUAL        ORBITALS =',I5)
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_REDIM_STEPLAST
C> @brief      Routine resets MSTA,NSPACE,orbitals for VVOS-ORMAS.
C>
C> @author     Aaron West and Mike Schmidt
C>             -January 21, 2013
C>
C> @see LOCAL_SVDVVOS_REDIM_STEP1
C>      LOCAL_SVDVVOS_REDIM_STEP2
C>      LOCAL_SVDVVOS_REDIM_STEPLAST
C>      LOCAL_SVDVVOS_MOS
C>
C> @param NACT         is the current number of active orbitals.
C> @param NACTDT       is the original number of active orbitals.
C> @param NSPACE       is the current number of ORMAS groups.
C> @param NSPACE_SAV   is the original number of ORMAS groups.
C> @param ISIZE_FCCWFN is the common block size of MSTA.
C> @param MSTA         holds the orbital ranges for ORMAS groups.
C> @param MSTA_SAV     is the original orbital ORMAS group ranges.
C> @param MASWRK       indicates the master process.
C> @param SOME          is true for master process with nprint not equal -5.
C> @param IW           indicates write out to the log file.
C>
      SUBROUTINE LOCAL_SVDVVOS_REDIM_STEPLAST(
     *           NACT,NACTDT,NSPACE,NSPACE_SAV,ISIZE_FCCWFN,
     *           MSTA,MSTA_SAV,MASWRK,SOME,IW)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION :: RMC,RHF,ROHF
C
      LOGICAL MASWRK,SOME,OK
      INTEGER I,IW,NACT,NACTDT,NSPACE,NSPACE_SAV,ISIZE_FCCWFN
      INTEGER MSTA(ISIZE_FCCWFN),MSTA_SAV(ISIZE_FCCWFN)
C-----------------------------------------------------------------
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------
C
C     DATA STUFF
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA ROHF/8HROHF    /
C
C     BEGIN RESET.
      OK=.FALSE.
      IF(SCFTYP.EQ.RMC) OK=.TRUE.
      IF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) OK=.TRUE.
C
      IF(OK) THEN
        NACT=NACTDT
        NSPACE=NSPACE_SAV
        CALL ICOPY(ISIZE_FCCWFN,MSTA_SAV,1,MSTA,1)
        IF(SOME) WRITE(IW,9001) NSPACE,(MSTA(I),I=1,NSPACE)
      ELSE
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_SVDVVOS_REDIM_STEPLAST ERROR:',
     *        /1X,'THIS SCFTYP,ISVDOP OPTION DOES NOT EXIST.')
 9001 FORMAT(//1X,'VVOS RESETS BACK TO ORIGINAL ORMAS GROUPS.',
     *        /1X,'THE NUMBER OF SPACES             =',I4,
     *        /1X,'EACH SPACE STARTS AT ORBITAL     =',50I4//)
      END
C*MODULE LOCAL   *DECK LOCAL_SVDVVOS_RMC_SETUP1
C> @brief      Returns MCSCF core and active orbital numbers.
C>
C> @author     Aaron West
C>             -March 16, 2013
C>
C> @details    This is a wrapper to avoid variable conflicts
C>             since I introduced new wave function types,etc.
C>             It will get used again.
C>
C> @param NCOR_GET denotes the number of MCSCF core orbitals.
C> @param NACT_GET denotes the number of MCSCF active orbitals.
C>
      SUBROUTINE LOCAL_SVDVVOS_RMC_SETUP1(NCOR_GET,NACT_GET)
      IMPLICIT NONE
C
      INTEGER NCOR_GET,NACT_GET
C
      DOUBLE PRECISION ::
     *       CRIT,DWPARM,GLIST,GRPDET,PRTTOL,SDET,SPINS,SZDET,
     *       WSTATE,STSYM,FSTATE
      INTEGER MXRT,IDWEIGH,IGPDET,IPURES,IROOT,IWTS,KDET,KSTDET,
     *        KSTSYM,MAXP,MAXW1,NACTDT,NADET,NBDET,NCI,NCOR,NCORSV,
     *        NFLGDM,NFTGCI,NITDET,NORBDT,IFTS
C
      PARAMETER( MXRT=100 )
C
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACTDT,NORBDT,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCI,IGPDET,KSTSYM,NFTGCI,IDWEIGH,
     *                fstate(mxrt),ifts(mxrt)
C
C
      NCOR_GET=NCORSV
      NACT_GET=NACTDT
C
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_LMOEXT
C> @brief      This sub. combines LMOs.
C>
C> @author     Aaron West
C>             -March 16, 2013
C>
C> @details    This sub. involves the use of several
C>             localized orbitals.
C>             It then combines two sets of localized orbitals
C>             and outputs the VEC group into .log and .dat files.
C>
C> @param IMODE =1 runs through the entire routine.
C>              =2 just creates a new DAF534 file.
      SUBROUTINE LOCAL_LMOEXT(IMODE)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,COMBO
      INTEGER IMODE,ISVDOP_SV,
     *        IORBF1,IORBF52x,NERR,I,ITMP,LOCAL_NUMVAL
      INTEGER L0,L1,L2,L3,NAOTOT,NAOTRI,
     *        NCORTOT,IMBS,IMBS2,L0MBS,L2MBS
      INTEGER NGOTMX,LOADFM,LAST,NEED_EXTLOC,LDEN,LVEC1,LVEC2,LVEC3
      DOUBLE PRECISION :: SVD,ATMNOS,SPLITQA,SPLITQ2,SPLITQ3
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C
      DOUBLE PRECISION :: ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
      INTEGER ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C
C-----------------------------------------------------------------------
      INTEGER MXATM
      PARAMETER (MXATM=2000)
C-----------------------------------------------------------------------
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA ATMNOS/8HATMNOS  /
      DATA CHECK/8HCHECK   /
      DATA SPLITQA/8HSPLITQA /
      DATA SPLITQ2/8HSPLITQ2 /
      DATA SPLITQ3/8HSPLITQ3 /
      DATA SVD/8HSVD     /
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.SVD) COMBO=.TRUE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQA) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQ2) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQ3) COMBO=.TRUE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME.AND.IMODE.EQ.1) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C     SET UP SOME ORBITAL DIMENSIONS
      CALL LOCAL_SVDORB_VARS(
     *     L0,L1,L2,L3,
     *     NCORTOT,IMBS,IMBS2,L0MBS,L2MBS,
     *     NAOTOT,NAOTRI)
C
C     ERROR OUTS
      NERR=0
      ITMP=NCORTOT
      DO I=1,NAT
        ITMP=ITMP+LOCAL_NUMVAL(I,0)
      ENDDO
      IF(ITMP.NE.L0MBS.AND.IVVOS.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9002)
        NERR=NERR+1
      ENDIF
      IF(ILOCAL.EQ.4) THEN
        IF(MASWRK) WRITE(IW,9004)
        NERR=NERR+1
      ENDIF
C
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     SKIP FOR IMODE=2
      IF(IMODE.EQ.2) GO TO 7999
C
C     FORM EXTERNAL LOCALIZED ORBITALS.
C     NOTE1:  THE NEXT CALL REPLACES DAF FILE 71
C             ONLY IF NOT EXTLOC=RNONE.
C     NOTE2:  SPLITQA WAS THE VERY LAST ADDITION TO POSSIBILITIES.
C             AS SUCH, THINGS GOT MORE COMPLICATED.
C             THE PREVIOUS EXTLOC EXAMPLE RESULTS WERE PRESERVED
C             VIA OLD TEST CASES.
      IORBF1=15 ! ,15,
      ISVDOP_SV=ISVDOP
      ISVDOP=0
      CALL LOCAL_LMOSVD(IORBF1)
      ISVDOP=ISVDOP_SV
C
C     PRINT OFF SECOND BANNER
 7999 CONTINUE
      IF(SOME) WRITE(IW,9001)
      CALL FLSHBF(IW)
C
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L3 = L1*L1
C
C     ALLOCATE MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LDEN  = LOADFM + 1
      LVEC1 = LDEN   + IMBS2
      LVEC2 = LVEC1  + L3
      LVEC3 = LVEC2  + L3
      LAST  = LVEC3  + L3
      NEED_EXTLOC = LAST - LOADFM - 1
      CALL GETFM(NEED_EXTLOC)
C
C     PREPARE SOME SUPER-SPECIAL PIECES FOR SPLITQA RUNS.
C     NOTE1:  CHANGING THE EXTLOC GUTS OF LOCAL_LMOSVD IS MADNESS.
C     NOTE2:  DIRLMO REQUIRES ORTHOGONAL VALENCE-INTERNAL ORBITALS.
C             I.E. DAF521
      COMBO=EXTLOC.EQ.SPLITQA.OR.
     *      EXTLOC.EQ.SPLITQ2.OR.
     *      EXTLOC.EQ.SPLITQ3
      IF(COMBO.AND.IMODE.EQ.1) THEN
        CALL DAREAD(IDAF,IODA,X(LVEC1),L3,521,0)
        CALL DAWRIT(IDAF,IODA,X(LVEC1),L3,71,0)
        CALL VCLR(X(LVEC1),1,L3)
        CALL DAREAD(IDAF,IODA,X(LDEN),IMBS2,536,0)
        CALL DAWRIT(IDAF,IODA,X(LDEN),IMBS2,285,0)
      ENDIF
C
C     COMBINE ORBITAL PIECES FROM 2 ORBITAL SETS
C     NOTE:  EXTERNALS MUST BE ORTHOGONAL TO INTERNALS AT THIS POINT.
C     DAF FILE 71  --> CONTAINS MBS LOCALIZED ORBITALS
C     DAF FILE 522 --> CONTAINS THE NEEDED EXTERNAL VIRTUALS.
C                  --> WANT THE NON-ORTHOGONAL VERSION
C                      WHERE THE MOS ARE ORTHOGONAL ONLY
C                      ON EACH ATOM.
C     ORBITAL PIECE 1 = CORE + OCCUPIEDS + VVOS
C     ORBITAL PIECE 2 = EXTERNALS
      CALL DAREAD(IDAF,IODA,X(LVEC1),L3,71,0)
      IORBF52x=522 ! ,522,
      CALL DAREAD(IDAF,IODA,X(LVEC2),L3,IORBF52x,0) ! ,522,521,
      CALL VCLR(X(LVEC3),1,L3)
C
C
      IF(IORBF52x.EQ.522) THEN
        IF(SOME) WRITE(IW,9020)
      ELSEIF(IORBF52x.EQ.521) THEN
        IF(SOME) WRITE(IW,9021)
      ELSE
        IF(SOME) WRITE(IW,9022)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      CALL FLSHBF(IW)
C
C     ADD INTERNALS TO 'SVD' EXTERNALS.
      CALL DCOPY(L1*L0,X(LVEC2),1,X(LVEC3),1)
      CALL DCOPY(L1*L0MBS,X(LVEC1),1,X(LVEC3),1)
      CALL VCLR(X(LVEC1),1,L3)
      CALL VCLR(X(LVEC2),1,L3)
C
C     SAVE ORBITALS OFF TO DAF FILE 534
      CALL DAWRIT(IDAF,IODA,X(LVEC3),L3,534,0)
C
C     PRINT OUT FINAL INTERNAL+EXT ORBITALS TO GAMESS .LOG FILE.
      IF(SOME.AND.IMODE.EQ.1) THEN
        WRITE(IW,9070)
        WRITE(IW,9071) L0
        CALL PRSQL(X(LVEC3),L0,L1,L1)
      ENDIF
C
C     PRINT OUT ER+EXT ORBITALS TO .DAT FILE.
      IF(MASWRK.AND.IMODE.EQ.1) THEN
        WRITE(IP,9080)
        CALL PUSQL(X(LVEC3),L0,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_EXTLOC)
C
C
 8999 CONTINUE
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LMOEXT NOW FORMS LOCALIZED EXTERNAL ORBITALS.'/
     *   5X,'LOCAL_LMOEXT CALLS UPON LOCAL_LMOSVD.'/
     *   5X,60(1H-))
 9001 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LMOEXT COMBINES TWO ORBITAL SETS.'/
     *   5X,60(1H-))
 9002 FORMAT(//1X,'LOCAL_LMOEXT ERROR:',
     *        /1X,'EXT=SVD OPTION REQUIRES EITHER:',
     *        /1X,'1. FULL VALENCE ORBITAL SPACE',
     *        /1X,'2. VVOS RUN.')
 9004 FORMAT(//1X,'LOCAL_LMOEXT ERROR:',
     *        /1X,'ILOCAL=4 HAS FILE CONFLICTS FOR',
     *         1X,'EXTLMO=SVD OPTION.')
 9020 FORMAT(1X,'USING NONORTHOGONAL ORBITALS FROM FILE 522...')
 9021 FORMAT(1X,'USING ORTHOGONAL ORBITALS FROM FILE 521...')
 9022 FORMAT(//1X,'LOCAL_LMOEXT ERROR:',
     *        /1X,'IORBF52x FILE IS NOT APPROPRIATE.')
 9070 FORMAT(//10X,'OCCUPIED + SVD EXTERNAL LOCALIZED ORBITALS')
 9071 FORMAT(10X,I5,1X,'ORBITALS ARE SHOWN.')
 9080 FORMAT('OCCUPIED + SVD EXTERNAL LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9300 FORMAT(1X,'... DONE WITH LOCAL_LMOEXT ...')
      END
C
C*MODULE LOCAL   *DECK LOCAL_COUNTAOS
C> @brief      return no. Cartesian and spherical AOs on atom IAT
C>
C> @author     Mike Schmidt
C>             -March 16, 2013
C>
C> @param IAT      is the atom number from the input file.
C> @param NAOCART  is the number of Cartesian AOs on atom IAT.
C> @param NAOSPH   is the number of spherical AOs on atom IAT.
C>
      SUBROUTINE LOCAL_COUNTAOS(IAT,NAOCART,NAOSPH)
      IMPLICIT NONE
C
      INTEGER NUMCART(8),NUMSPH(8)
      INTEGER I,IAT,ISH,KT,NAOCART,NAOSPH
C--------------------------------------------------------------------------
      DOUBLE PRECISION :: QMTTOL
      INTEGER ISPHER
C
      DOUBLE PRECISION :: EX,CS,CP,CD,CF,CG,CH,CI
      INTEGER KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL
C--------------------------------------------------------------------------
      INTEGER MXSH,MXGTOT
      PARAMETER (MXSH=5000, MXGTOT=20000)
C--------------------------------------------------------------------------
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C--------------------------------------------------------------------------
C
C         s,p,d,f,g,h,i corresponds to KTYPE=1,2,3,4,5,6,7.
C
      NUMCART(1)=1
      DO I=2,7
        NUMCART(I) = NUMCART(I-1) + I
      ENDDO
      IF(ISPHER.EQ.1) THEN
        DO I=1,7
           NUMSPH(I)=2*I-1
        ENDDO
      ELSE
        DO I=1,7
           NUMSPH(I)=NUMCART(I)
        ENDDO
      END IF
C
C           L=SP shell is arbitrarily numbered 8.
C
      NUMCART(8)=4
      NUMSPH(8) =4
C
      NAOCART = 0
      NAOSPH  = 0
C
      DO 100 ISH=1,NSHELL
         IF(KATOM(ISH).LT.IAT) GO TO 100
         IF(KATOM(ISH).GT.IAT) RETURN
         KT = KTYPE(ISH)
         IF(KMIN(ISH).EQ.1  .AND.  KMAX(ISH).EQ.4) KT=8
         NAOCART = NAOCART + NUMCART(KT)
         NAOSPH  = NAOSPH  + NUMSPH(KT)
  100 CONTINUE
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_LCAO_WGHTS
C> @brief      Driver for lcao weight squared.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 16, 2013
C>
C> @details    These weightings identify atom-orbital correspondence.
C>             For atom identification, one should use nonorthogonal
C>             orbitals as the reference orbitals.
C>             However, many options can be modified as needed.
C>
C> @date September 26, 2013-Aaron West
C> -For linear dependence cases,
C>  one should just use the reordered nonorthogonal orbitals.
C>  So, any extloc runs are now modified to do so here.
C>  Previous results are easily recovered by changing IORBF52x.
C>  Please keep this item in mind when trying to reproduce results.
C>
C>
      SUBROUTINE LOCAL_LCAO_WGHTS
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,COMBO,OK
      INTEGER IORBF1,IORBF52x,IFILAT,NUML0,ITMPORB,I
      INTEGER L0,L1,L2,L3
      INTEGER NGOTMX,LOADFM,LAST,NEED_LCAO,
     *        LVEC1,LWGT,LWGT2,LWGTDUP,LIATORB,LIATORB2,LSUMORB,
     *        LIATSCR,LWGTSCR
      INTEGER NVVOS_NUMCOR
      INTEGER LOCAL_NUMVAL
      DOUBLE PRECISION :: CUTOFF_IATORB
      DOUBLE PRECISION :: ATMNOS,SVD,SPLITQA,SPLITQ2,SPLITQ3,RNONE
      INTEGER NERR
C
      INTEGER IKIND
      INTEGER LVEC2,LVTORB,LVMAT,LS,LIATSVD
C-----------------------------------------------------------------------
C
      INTEGER LIMLOW,LIMSUP
C
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C
      DOUBLE PRECISION :: ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
      INTEGER ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      DOUBLE PRECISION ::
     *       RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
C-----------------------------------------------------------------------
      INTEGER MXATM
      PARAMETER (MXATM=2000)
C-----------------------------------------------------------------------
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C-----------------------------------------------------------------------
      PARAMETER (CUTOFF_IATORB=0.9D+00)
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA ATMNOS/8HATMNOS  /
      DATA CHECK/8HCHECK   /
      DATA RNONE/8HNONE    /
      DATA SPLITQA/8HSPLITQA /
      DATA SPLITQ2/8HSPLITQ2 /
      DATA SPLITQ3/8HSPLITQ3 /
      DATA SVD/8HSVD     /
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.SVD) COMBO=.TRUE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQA) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQ2) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQ3) COMBO=.TRUE.
      IF(ILOCAL.EQ.4) COMBO=.TRUE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME) WRITE(IW,9001)
      CALL FLSHBF(IW)
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     SET UP SOME DIMENSIONS
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
C     JUST IN CASE, QUICK SETUP OF LIMLOW AND LIMSUP
      CALL AOLIM
C
C     CALCULATE A COMMON ORBITAL NUMBER
C     FOR POSSIBLE USE BELOW.
      ITMPORB=NVVOS_NUMCOR(0,0)
      DO I=1,NAT
        ITMPORB=ITMPORB+LOCAL_NUMVAL(I,0)
      ENDDO
C
C     FOR EACH CASE:
C     --SET SOME VARS.
C     --OBTAIN ORBITALS
C     NOTE:  DAF 521 SERVES TO DEFINE THE ATOM-ORBITAL CORRESPONDENCE.
C            OTHER ORBITALS SETS ARE RELATED TO DAF 521.
      NUML0=0
      IORBF1=0
      IORBF52x=0
      IFILAT=0
      IORBF52x=521 ! ,521,
      IF(EXTLOC.EQ.SPLITQ2.OR.EXTLOC.EQ.SPLITQ3) THEN
        NUML0=ITMPORB
        IORBF1=534   ! ,521,
        IORBF52x=521 ! ,521,
        IFILAT=528   ! ,528,
      ELSEIF(EXTLOC.NE.RNONE) THEN
        NUML0=L0
        IORBF1=534   ! ,534,
        IORBF52x=539 ! ,539,
        IFILAT=540   ! ,540,
      ELSEIF(ILOCAL.EQ.4) THEN
        NUML0=ITMPORB
        IORBF1=521   ! ,521,
        IF(ORIENT) IORBF1=286 ! ,286,
        IORBF52x=521 ! ,521,
        IFILAT=528   ! ,528,
      ELSE
        IF(MASWRK) WRITE(IW,9002)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     CHECK ON ALL-MIGHTY L0DEP0 VAR.
      IF(L0DEP0.NE.L0) THEN
        OK=.FALSE.
        OK=EXTLOC.EQ.ATMNOS.OR.EXTLOC.EQ.SPLITQA  ! splitq2 is ok.
        IF(.NOT.OK) THEN
          IF(MASWRK) WRITE(IW,9200)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C       IN THIS CASE, ALWAYS SEVERELY RESTRICT THE FILES.
C       NOTE:  NOT NECCESSARILY A REPEAT FROM ABOVE.
        NUML0=L0DEP0
        IORBF1=534   ! ,534,
        IORBF52x=539 ! ,539,
        IFILAT=540   ! ,540,
      ENDIF
C
C     ERROR OUT FOR IORBF1=0
      NERR=0
      IF(IORBF1.EQ.0) THEN
        IF(MASWRK) WRITE(IW,9110)
        NERR=NERR+1
      ENDIF
      IF(EXTLOC.NE.SPLITQA.AND.
     *   EXTLOC.NE.SPLITQ2.AND.EXTLOC.NE.SPLITQ3) THEN
        IF(ORIENT.AND.EXTLOC.NE.RNONE) THEN
          IF(MASWRK) WRITE(IW,9111)
          NERR=NERR+1
        ENDIF
      ENDIF
      IF(EXTLOC.NE.RNONE.AND.ILOCAL.EQ.4) THEN
        IF(MASWRK) WRITE(IW,9112)
        NERR=NERR+1
      ENDIF
      IF(NERR.NE.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     ALLOCATE MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LVEC1     = LOADFM + 1
C     MEMORY FOR LACO WEIGHTS STUFF.
      LWGT      = LVEC1 + L3
      LWGT2     = LWGT  + NAT*NUML0
      LWGTDUP   = LWGT2 + NUML0
C     MEMORY FOR GETTING ATOM-ORBITAL CORRESPONDENCE
C            FOR LCAO STUFF.
      LIATORB   = LWGTDUP + NAT*NUML0
      LSUMORB   = LIATORB + NAT*NUML0
      LIATORB2  = LSUMORB + NUML0
C     MEMORY FOR GETTING ATOM-ORBITAL CORRESPONDENCE
C            FOR MO OVERLAP B/T QUASI-ATOMIC AND ER LOC. ORBITALS.
      LVEC2     = LIATORB2 + NAT*NUML0
C     MEMORY FOR OBTAINING ORBITAL TRANSFORMATION.
      LVTORB    = LVEC2   + L3
      LVMAT     = LVTORB  + L3
      LS        = LVMAT   + L3
      LIATSVD   = LS      + L2
      LIATSCR   = LIATSVD + NUML0
C     MEMORY FOR INTEGER SCRATCH ARRAY FOR PRINT OFF.
      LWGTSCR   = LIATSCR + NAT
      LAST      = LWGTSCR + NAT
      NEED_LCAO = LAST - LOADFM - 1
      CALL GETFM(NEED_LCAO)
C
C
      CALL VCLR(X(LVEC1),1,L3)
      CALL VCLR(X(LWGT),1,NAT*NUML0)
      CALL VCLR(X(LWGT2),1,NUML0)
      CALL VICLR(X(LIATSVD),1,NUML0)
C
C     READ IN CHOSEN ORBITALS
      CALL DAREAD(IDAF,IODA,X(LVEC1),L3,IORBF1,0)
C
C----------LCAO SECTION----------------------------
C
C     OBTAIN THE RELATIVE LCAO WEIGHTINGS PER ATOM.
C     NOTE:  IKIND=0 --> LIATSVD IS NOT USED IN NEXT CALL.
      IKIND=0
      CALL LOCAL_LCAO_WGHTS2(
     *     X(LWGT),X(LWGT2),X(LVEC1),X(LIATSVD),
     *     LIMSUP,LIMLOW,
     *     NAT,NUML0,L1,MXATM,IKIND,IW,MASWRK)
C
C     PRINT ORBITAL ATOMIC WEIGHTS OFF TO THE LOG FILE.
      IF(SOME) THEN
        WRITE(IW,9005)
        WRITE(IW,9003) IORBF1,IFILAT,NAT,NUML0
        CALL PRSQ(X(LWGT),NUML0,NAT,NAT)
      ENDIF
C
C     OBTAIN THE ATOM LABEL(S) FOR EACH MO.
C     PRINT OFF THESE LABELS.
      CALL DCOPY(NAT*NUML0,X(LWGT),1,X(LWGTDUP),1)
      IF(SOME) WRITE(IW,9005)
      CALL LOCAL_LCAO_ATOM_LABELS(
     *     X(LWGT),X(LWGTDUP),X(LIATORB),X(LSUMORB),X(LIATSCR),
     *     X(LWGTSCR),CUTOFF_IATORB,NAT,NUML0,IW,SOME,MASWRK)
C
C----------MO OVERLAP SECTION------------------------
C
C     READ IN THE ORBITALS.
      CALL DAREAD(IDAF,IODA,X(LVEC1),L3,IORBF1,0)
      CALL DAREAD(IDAF,IODA,X(LVEC2),L3,IORBF52x,0)
C
C
      IF(SOME) WRITE(IW,9099)
      IF(SOME) WRITE(IW,9100) IORBF52x
      OK=.FALSE.
      IF(IORBF52x.EQ.522) OK=.TRUE.
      IF(IORBF52x.EQ.521) OK=.TRUE.
      IF(IORBF52x.EQ.539) OK=.TRUE.
      IF(.NOT.OK) THEN
        IF(SOME) WRITE(IW,9105)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      CALL FLSHBF(IW)
C
C     READ IN ATOM LABELS FOR ALL ORBITALS.
C     ---NOTE:  WE DO NOT WANT TO DISTURB HOW FILE 528 WORKS.
C               THAT WOULD BE IDIOTIC AND A LOT OF WORK.
C     ---NOTE:  IFILAT IS CREATED DUE TO CLINDEP ISSUES.
      CALL LOCAL_READ_FILE528_WITH_CORES(IFILAT,
     *                                   X(LIATSVD),NAT,NUML0,MASWRK)
C
C     CONSTRUCT THE MO OVERLAP BETWEEN
C     COLUMNS FROM QUASI-ATOMIC ORBITAL ON DAF FILE 521
C     AND
C     ROWS FROM ...
C     E.G.  ER SEP. LOC. 'OCCUPIED' ON DAF FILE 534
C     E.G.  DAF FILE 521 AGAIN
      CALL VCLR(X(LVTORB),1,L3)
      CALL VCLR(X(LVMAT),1,L3)
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL MTARBR(X(LS),L1,X(LVEC1),NUML0,X(LVMAT),L1,1)
      CALL MRTRBR(X(LVEC2),L1,L1,NUML0,X(LVMAT),L1,NUML0,X(LVTORB),L1)
CKEEP
CKEEP      another clindep issue...
CKEEPC     NOTE:  VEC1,VEC2 ==> (VEC2,VEC1) DIMS.
CKEEPC     NOTE:  NEXT CALL GIVES PRISTINE MATRIX.
CKEEPC            I.E. NO GARBAGE OUTSIDE THE L0XL0 BLOCK.
CKEEP      CALL MALMQ_TORB
C
C     PERFORM WEIGHTS ANALYSIS NOW ON MO OVERLAP RATHER THAN LCAO.
      IKIND=1
      CALL LOCAL_LCAO_WGHTS2(
     *     X(LWGT),X(LWGT2),X(LVTORB),X(LIATSVD),
     *     LIMSUP,LIMLOW,
     *     NAT,NUML0,L1,MXATM,IKIND,IW,MASWRK)
      IF(SOME) THEN
        WRITE(IW,9006)
        WRITE(IW,9003) IORBF1,IFILAT,NAT,NUML0
        CALL PRSQ(X(LWGT),NUML0,NAT,NAT)
      ENDIF
      CALL DCOPY(NAT*NUML0,X(LWGT),1,X(LWGTDUP),1)
      IF(SOME) WRITE(IW,9006)
      CALL LOCAL_LCAO_ATOM_LABELS(
     *     X(LWGT),X(LWGTDUP),X(LIATORB2),X(LSUMORB),X(LIATSCR),
     *     X(LWGTSCR),CUTOFF_IATORB,NAT,NUML0,IW,SOME,MASWRK)
C
C
C------------------------------------------------------
C----------END OF MO OVERLAP SECTION-------------------
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_LCAO)
C
C
 8999 CONTINUE
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
C 9000 FORMAT(/1X,'SKIPPING LOCAL_LCAO_WGHTS:',
C     *       /1X,'LOCAL_LCAO_WGHTS CANNOT DETERMINE',
C     *        1X,'ORBITAL DAF FILE.')
 9001 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_LCAO_WGHTS NOW ANALYZES',
     *   1X,'ATOMIC WEIGHTS SQUARED'/
     *   5X,'OF LCAO AND MO OVERLAP OF ORBITAL SET DEFINED BELOW.'/
     *   5X,60(1H-))
 9002 FORMAT(/1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *       /1X,'LOCAL_LCAO_WGHTS CANNOT DETERMINE',
     *        1X,'ORBITAL DAF FILE.')
 9003 FORMAT(/1X,'THE RELATIVE WEIGHTS SQUARED NOW FOLLOW.',
     *       /1X,'ORBITAL DAF FILE =',I5,
     *       /1X,'ATOM DAF FILE    =',I5,
     *       /1X,'ROWS=ATOMS,COLUMNS=MOS',
     *       /1X,'INCLUDES CORE ORBITALS ON UP...',
     *       /1X,'NUMBER OF ATOMS =',I5,
     *       /1X,'NUMBER OF MOS   =',I5)
 9005 FORMAT(/1X,'NOW USING LCAO COEFFICIENTS',
     *        1X,'IN THE ANALYSIS... ')
 9006 FORMAT(/1X,'NOW USING MO OVERLAP COEFFICIENTS',
     *        1X,'IN THE ANALYSIS... ')
 9099 FORMAT(/1X,'A SET OF ATOMIC-LIKE MOLECULAR ORBITALS MUST',
     *        1X,'BE CHOSEN FOR A RELATIVE COMPARISON...')
 9100 FORMAT( 1X,'USING NONORTHOGONAL ORBITALS FROM DAF FILE=',I4)
 9105 FORMAT(//1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *        /1X,'IORBF52x FILE IS NOT APPROPRIATE.')
 9110 FORMAT(/1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *       /1X,'IORBF1 DAF FILE EQUALS 0.  NO FILE SELECTED.')
 9111 FORMAT(/1X,'ERROR IN LOCAL_LCAO_WGHTS:',
     *       /1X,'NO NO. THIS WILL BE A SEPARATE RUN.',
     *       /1X,'THE LOCAL INPUT SHOULD HAVE PREVENTED US',
     *        1X,'US FROM REACHING HERE. PLEASE RE-THINK.')
 9112 FORMAT(/1X,'LOCAL_LCAO_WGHTS ERROR:',
     *       /1X,'ANY GIVEN EXTLOC OPTION CANNOT HAVE',
     *        1X,'ILOCAL=4.')
 9200 FORMAT(/1X,'LOCAL_LCAO_WGHTS ERROR:',
     *       /1X,'L0DEP0 DIFFERS FROM L0.',
     *       /1X,'IN THIS CASE, ATMNOS AND SPLITQA ARE ALLOWED.',
     *        1X,'OTHER EXTLOC KINDS ARE NOT ALLOWED.',
     *       /1X,'FURTHERMORE, OTHER KINDS ARE NOT AS GOOD.')
 9300 FORMAT(1X,'... DONE WITH LCAO RELATIVE',
     *       1X,'ATOMIC WEIGHTS SQUARED ...')
      END
C*MODULE LOCAL   *DECK LOCAL_LCAO_WGHTS2
C> @brief      FORMS RELATIVE LCAO WEIGHTS SQUARED
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 16, 2013
C>
C> @details    1.  LCAO COEFFICIENTS ARE SQUARED.
C>             2.  FOR EACH MO FOR EACH ATOM A,
C>                 THE LCAO**2 VALUES ARE SUMMED.
C>             3.  FOR EACH MO,
C>                 THESE VALUES ARE THEN NORMALIZED.
C>
C>
C> @param WGT    will contain the LCAO summed over one atom
C>               for each MO.
C>               i.e. NATxNUML0 array
C> @param WGT2   will contain the LCAO summed over all atoms
C>               per MO.
C>               i.e. NUML0 array
C> @param VEC    contains the LCAO for the MOs of interest.
C> @param IATSVD is an array from the SVD run itself
C>               that contains atom-orbital correspondences.
C> @param LIMSUP array contains the upper basis function on an atom.
C> @param LIMLOW array contains the lower basis function on an atom.
C> @param NAT    denotes number of atoms.
C> @param NUML0  denotes number of orbitals to be used in
C>               the LCAO weights squared analysis.
C> @param L1     is length of the AO basis.
C> @param MXATM  is max. number of atoms.
C> @param IKIND  is an integer to switch between using
C>               LCAO and MO OVERLAP.
C>               IKIND=0 --> USE LCAO ATOMS LIMITS
C>               IKIND=1 --> CONVERT SVD MO TO ATOMS
C> @param IW     indicates write out to the log file.
C> @param MASWRK is true for master process.
      SUBROUTINE LOCAL_LCAO_WGHTS2(
     *     WGT,WGT2,VEC,IATSVD,
     *     LIMSUP,LIMLOW,
     *     NAT,NUML0,L1,MXATM,IKIND,IW,MASWRK)
C
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK
      INTEGER L1,NUML0,NAT,MXATM,IKIND,IW
      INTEGER IATM1,IBAS1,IBAS2,I,K
      INTEGER LIMLOW(MXATM)
      INTEGER LIMSUP(MXATM)
      INTEGER IATSVD(NUML0)
      DOUBLE PRECISION :: SUM,TOTSUM,TMP
      DOUBLE PRECISION :: WGT(NAT,NUML0),WGT2(NUML0),VEC(L1,L1)
C
      CALL VCLR(WGT,1,NAT*NUML0)
      CALL VCLR(WGT2,1,NUML0)
C
C     SUM UP THE RELATIVE LCAO WEIGHTS ON EACH ATOM FOR EACH ORBITAL.
      IF(IKIND.EQ.0) THEN
        DO I=1,NUML0
          TOTSUM=0.0D+00
          DO IATM1=1,NAT
            IBAS1=LIMLOW(IATM1)
            IBAS2=LIMSUP(IATM1)
            SUM=0.0D+00
            DO K=IBAS1,IBAS2
              SUM=SUM+VEC(K,I)**2
            ENDDO
            WGT(IATM1,I)=SUM
            TOTSUM=TOTSUM+SUM
          ENDDO
          WGT2(I)=TOTSUM
        ENDDO
      ELSEIF(IKIND.EQ.1) THEN
        DO I=1,NUML0
          TOTSUM=0.0D+00
          DO K=1,NUML0
            IATM1=IATSVD(K)
            TMP=VEC(K,I)**2
            WGT(IATM1,I)=WGT(IATM1,I)+TMP
            WGT2(I)=WGT2(I)+TMP
          ENDDO
        ENDDO
      ENDIF
C
C     NORMALIZE ALL WEIGHTS ON EACH ORBITAL.
      DO I=1,NUML0
        DO IATM1=1,NAT
          WGT(IATM1,I)=WGT(IATM1,I)/WGT2(I)
        ENDDO
      ENDDO
C
C
      IF(IKIND.NE.0.AND.IKIND.NE.1) THEN
        IF(MASWRK) WRITE(IW,9001)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(//1X,'LOCAL_LCAO_WGHTS2 ERROR:',
     *        /1X,'IKIND=0 OR IKIND=1 ARE ONLY OPTIONS.')
      END
C*MODULE LOCAL   *DECK LOCAL_LCAO_ATOM_LABELS
C> @brief      Determines atom-orbital correspondence for LOCAL_LCAO.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 19, 2013
C>
C> @details    The atom-orbital correspondence is determined
C>             based on summing the largest overlap coefficients
C>             up to a specified cutoff.
C>             These overlap coefficients might be
C>             LCAO coefficients or MO overlap for a particular
C>             reference set of orbitals.
C>
C> @date December 1, 2013-Aaron West
C> -Account for cases of degeneracy.
C>  I noticed this item in version changes.
C>
C> @param WGT           is the the relative weights squared array.
C>                      Dimensions are NATxNUML0.
C>                      i.e. number of atoms x some MOs.
C> @param WGTDUP        is a copy of the relative weights squared array.
C>                      Dimensions are NATxNUML0.
C>                      i.e. number of atoms x some MOs.
C> @param IATORB        is the integer array that will hold the
C>                      atom or atoms for a particular orbital.
C> @param SUMORB        is an integer array used to sum up the coefficients
C>                      from WGTDUP.
C> @param IATSCR        is an scratch integer array that is used for printing.
C> @param WGTSCR        is a scratch array that is used for printing.
C> @param CUTOFF_IATORB is the tolerance cut-off for assigning
C>                      the atoms to MOs.
C> @param NAT           is the total number of atoms.
C> @param NUML0         is the number of molecular orbital used.
C>                      It is based on the kind of localization.
C> @param IW            indicates write out to the log file.
C> @param SOME          is true for master process with nprint not equal -5.
C> @param MASWRK        indicates the master process.
      SUBROUTINE LOCAL_LCAO_ATOM_LABELS(
     *           WGT,WGTDUP,IATORB,SUMORB,IATSCR,
     *           WGTSCR,CUTOFF_IATORB,NAT,NUML0,IW,SOME,MASWRK)
C
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,MASWRK
      INTEGER NAT,NUML0,JPOS,I,J,II,IW,IERR
      INTEGER IDAMAX,IXAMAX
      DOUBLE PRECISION :: TMP,CUTOFF_IATORB
C
      INTEGER IATORB(NAT,NUML0)
      INTEGER IATSCR(NAT)
      DOUBLE PRECISION :: WGT(NAT,NUML0),WGTDUP(NAT,NUML0),
     *                    SUMORB(NUML0),WGTSCR(NAT)
C
      LOGICAL SKIP
      INTEGER ITMP
      DOUBLE PRECISION :: TMP2,TOLDEG
      PARAMETER (TOLDEG=1.0D-06)
C
C     INITIALIZE
      CALL VCLR(SUMORB,1,NUML0)
      CALL VICLR(IATORB,1,NAT*NUML0)
      SKIP=.TRUE.
C
C     GET THE ATOM LABELS.
      IERR=0
      DO 100 I=1,NUML0
        DO J=1,NAT
          IF(SUMORB(I).GT.CUTOFF_IATORB.AND.SKIP) GO TO 100
          JPOS=IDAMAX(NAT,WGTDUP(1,I),1)
          TMP=WGTDUP(JPOS,I)
          IF(TMP.LT.0.0D+00) IERR=IERR+1
          WGTDUP(JPOS,I)=0.0D+00
          SUMORB(I)=SUMORB(I)+TMP
          IATORB(JPOS,I)=1
C----------
C         FIX UP DEGENERACY SO THAT
C         LABELS DO NOT ALTERNATE BETWEEN PROGRAM VERSIONS.
          SKIP=.TRUE.
          ITMP=IDAMAX(NAT,WGTDUP(1,I),1)
          TMP2=WGTDUP(ITMP,I)
          TMP2=ABS(TMP2-TMP)
          IF(TMP2.LT.TOLDEG) SKIP=.FALSE.
C----------
        ENDDO
  100 CONTINUE
C
C     PRINT THE ATOM LABELS.
      IF(SOME) WRITE(IW,9000) CUTOFF_IATORB
      DO I=1,NUML0
        CALL VICLR(IATSCR,1,NAT)
        CALL VCLR(WGTSCR,1,NAT)
        II=0
        DO J=1,NAT
          IF(IATORB(J,I).EQ.1) THEN
            II=II+1
            IATSCR(II)=J
            WGTSCR(II)=WGT(J,I)
          ENDIF
        ENDDO
        IF(SOME) THEN
          WRITE(IW,9001) I,(IATSCR(J),J=1,II)
          WRITE(IW,9002) (WGTSCR(J),J=1,II)
        ENDIF
      ENDDO
C
C     ERROR OUT
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9003)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'FOR EACH MOLECULAR ORBITAL,',
     *      /1X,'1. THE MAXIMUM RELATIVE COEFFICIENT',
     *       1X,'SQUARES ARE LOCATED.',
     *      /1X,'2. THESE MAXIMUM COEFFICIENTS ARE SUMMED UP.',
     *      /1X,'3. WHEN THE SUM IN POINT 2 REACHES THE CUTOFF',
     *      /1X,'   WITHOUT ANY DEGENERACY IN THE COEFFICIENTS,',
     *      /1X,'   THE ATOM LABELS ARE NO LONGER ASSIGNED.',
     *      /1X,'   CUTOFF=',1P,E10.2,
     *      /1X,'4. FOR MO OVERLAPS,',
     *      /1X,'   VALUES OF 1 DO NOT NECCESARILY INDICATE',
     *      /1X,'   ORBITAL OVERLAPS OF 1... QUITE THE CONTRARY.',
     *      /1X,'5. THE DISPLAYED ATOM LABELS ARE READ FROM',
     *      /1X,'   THE SVD ITSELF.  FOR DAF534, THE MO OVERLAPS',
     *      /1X,'   ARE STILL FORMED WITH SVD ORBITALS.',
     *      /1X,'   SO SVD ATOM LABELS ARE SUFFICIENT FOR NOW.',
     *      /1X,'6. DO NOT APPLY TO MALMQ_CIDRIV RESULTS.')

 9001 FORMAT(1X,'MO=',I5,1X,'HAS ATOM(S)=',100I5//)
 9002 FORMAT(10X,'WITH WEIGHT(S)=',100F5.2//)
 9003 FORMAT(/1X,'LOCAL_LCAO_ATOM_LABELS ERROR:',
     *       /1X,'IDAMAX SORTING DOES NOT WORK',
     *        1X,'WITH NEGATIVE VALUES.')
      END
C*MODULE LOCAL   *DECK LOCAL_READ_FILE528_WITH_CORES
C> @brief      Reads DAF file 528 or 540 and adds cores to it.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    Reads DAF file 528 or 540 and adds cores to it.
C>             File 528 was designed to deal with general
C>             atom-orbital correspondence.
C>             Chemical core orbital atom-orbital correspondence
C>             is calculated from NVVOS_NUMCOR.
C>             Testing for 0s in the read out was very useful
C>             in the long run.
C>
C> @param IFILE  is currently either 528 or 540.
C> @param IATSVD is the integer array that will hold the
C>               SVD-based atoms labels.
C> @param NAT    is the number of atoms.
C> @param NUML0  is the length of the 'active' orbitals.
C>               This is a bit varied based on the run.
C> @param MASWRK indicates the master process.
      SUBROUTINE LOCAL_READ_FILE528_WITH_CORES(
     *           IFILE,IATSVD,NAT,NUML0,MASWRK)
C
      LOGICAL MASWRK
      INTEGER IFILE,ITOT,IDUM,NAT,ITMP
      INTEGER IATSVD(NUML0)
      INTEGER NVVOS_NUMCOR
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      CALL VICLR(IATSVD,1,NUML0)
C
      ITOT=0
      IDUM=1
      DO I=1,NAT
        ITMP=NVVOS_NUMCOR(I,1)
        ITOT=ITOT+ITMP
        IF(ITMP.NE.0) THEN
          DO J=IDUM,ITOT
            IATSVD(J)=I
          ENDDO
        ENDIF
        IDUM=ITOT+1
      ENDDO
      IDUM=IDUM-1
      ITMP=NUML0-IDUM
C
C     READ IN NON-CORES FROM FILE 528.
      CALL DAREAD(IDAF,IODA,IATSVD(IDUM+1),ITMP,IFILE,1) ! ,528, ,540,
C
C     THE ARRAY SHOULD NOT HAVE ANY 0S.  TEST FOR THIS.
C     THIS IS MY INANIMATE SAVIOR.
      ITMP=0
      DO I=1,NUML0
        IF(IATSVD(I).EQ.0) ITMP=1
      ENDDO
      IF(ITMP.GT.0) THEN
        IF(MASWRK) WRITE(IW,9001)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(//1X,'LOCAL_READ_FILE528_WITH_CORES ERROR:',
     *        /1X,'IATSVD ARRAY HAS 0S.  WRONG...')
      END
C*MODULE LOCAL   *DECK LOCAL_VVOS_ORB_RANGE
C> @brief      Automatically finds atom numbers for VVOS orbitals.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    Finds atom numbers for VVOS orbitals.
C>             This is handy for determining which atoms
C>             are on which orbital and how many.
C>             In VVOS, the chemical core orbitals
C>             start at the beginning of each atom...
C>             i.e. all chem. cores are not at the beginning...
C>             This sub. deals with it.
C>
C> @param IPOSMBS takes an atom number and returns the
C>                very first VALENCE MBS-type orbital number.
C> @param ILENMBS gives the number of VALANEC MBS orbitals.
C> @param NAT     is the number of atoms.
      SUBROUTINE LOCAL_VVOS_ORB_RANGE(IPOSMBS,ILENMBS,NAT)
      IMPLICIT NONE
C
      INTEGER I,ITYPE,NCOR_NEVER,ITMP,NVAL,ISWMBS
      INTEGER LOCAL_NUMVAL
      INTEGER NVVOS_NUMCOR
      INTEGER NAT
      INTEGER IPOSMBS(NAT+1)
      INTEGER ILENMBS(NAT)
C
C     NOTES:
C     1.  GO BACK TO THE BASIC NVVOS_NUMCOR INFO HERE
C         SINCE VVOS IS IN MBS NUMBERS.
C     2.  GO BACK TO NVVOS_NUMCOR ATOM-BY-ATOM.
C         THIS PART TOOK ME A BIT TO REALIZE... AND DANCE.
C
      ITMP=1
      DO I=1,NAT
C
        ITYPE=1
        NCOR_NEVER=NVVOS_NUMCOR(I,ITYPE)
        ISWMBS=1
        NVAL=LOCAL_NUMVAL(I,ISWMBS)
C
        ILENMBS(I)=NVAL
C
        ITMP=ITMP+NCOR_NEVER
        IPOSMBS(I)=ITMP
        ITMP=ITMP+NVAL
C
      ENDDO
      IPOSMBS(NAT+1)=ITMP
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_EXT
C> @brief      Driver for atomic external NOs.
C>
C> @author     Aaron West
C>             -March 21, 2013
C>
C> @details    This driver forms external canonical
C>             quasi-atomic orbitals from the
C>             current basis set and Whitten exchange integrals.
C>
      SUBROUTINE LOCAL_NOS_EXT
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL SOME,COMBO,REDO_INT
      DOUBLE PRECISION :: ATMNOS,SPLITQA,SPLITQ2,SPLITQ3,RMC,RNONE
      INTEGER L0,L1,L2,L3,NAOTOT,NAOTRI,
     *        NCORTOT,IMBS,IMBS2,L0MBS,L2MBS
      INTEGER L0FIN
      INTEGER LOADFM,NGOTMX,NEED_NOS_EXT,LAST,
     *        LS,LS2,LSWRK,LSVMBS,
     *        LIPOSCOR,LILENCOR,LIPOSMBS,LILENMBS,LIATSVD,
     *        LIPOSEXT,LOCCIMO,LVECCOL,LVEC539,LVEC,
     *        LVWRK1,LVWRK2,LVWRK3,LVWRK4,LBUFFX,LBUFFI,
     *        LWRK,LIWRK,LEIG,LSAVWGT,LSAVWGT2,LIWRKP,LIWRK3
      INTEGER IDUM,NERR,ITMP,ITMP2,IFILE
      DOUBLE PRECISION :: DUMMY
C
C-----------------------------------------------------------------------
      INTEGER MXATM,MXSH
      PARAMETER (MXATM=2000, MXSH=5000)
C-----------------------------------------------------------------------
C
      INTEGER LIMLOW,LIMSUP
C
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C,ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER NINTMX,NHEX,NTUPL,INTTYP,IGRDTYP
      LOGICAL PACK2E
C
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
      INTEGER ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      DOUBLE PRECISION :: RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      DOUBLE PRECISION :: T
      INTEGER MAPSHL,MAPCTR,INVT,NT
C
      LOGICAL DIRTRF
      DOUBLE PRECISION :: CUTTRF
      INTEGER NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      COMMON /ATLIM / LIMLOW(MXATM),LIMSUP(MXATM)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME  = NPRINT.NE.-5 .AND. MASWRK
C
C     DATA STUFF
      DATA ATMNOS/8HATMNOS  /
      DATA CHECK/8HCHECK   /
      DATA RMC/8HMCSCF   /
      DATA RNONE/8HNONE    /
      DATA SPLITQA/8HSPLITQA /
      DATA SPLITQ2/8HSPLITQ2 /
      DATA SPLITQ3/8HSPLITQ3 /
C
C     DETERMINE IF ANALYSIS IS POSSIBLE.
C     IF NOT, EXIT OUT.
      COMBO=.FALSE.
      IF(EXTLOC.EQ.ATMNOS) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQA) COMBO=.TRUE.
      IF(EXTLOC.EQ.SPLITQ2) COMBO=.FALSE.
      IF(EXTLOC.EQ.SPLITQ3) COMBO=.FALSE.
      IF(.NOT.COMBO) RETURN
C
C     PRINT BANNER
      IF(SOME) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C     SET UP SOME ORBITAL DIMENSIONS
      CALL LOCAL_SVDORB_VARS(
     *     L0,L1,L2,L3,
     *     NCORTOT,IMBS,IMBS2,L0MBS,L2MBS,
     *     NAOTOT,NAOTRI)
C
C     PERFORM SOME MORE EXITS.
      IF(SCFTYP.EQ.RMC) THEN
        CALL LOCAL_SVDVVOS_RMC_SETUP1(ITMP,ITMP2)
        ITMP=ITMP+ITMP2
        IF(ITMP.EQ.L0) RETURN
      ENDIF
C
C     ERROR OUTS
      NERR=0
      IF(IVVOS.EQ.0.AND.ISVDOP.NE.10) THEN
        IF(MASWRK) WRITE(IW,9003)
        NERR=NERR+1
      ENDIF
      IF(L0.EQ.L0MBS) THEN
        IF(MASWRK) WRITE(IW,9004)
        NERR=NERR+1
      ENDIF
      IF(EXTLOC.NE.RNONE.AND.ILOCAL.EQ.4) THEN
        IF(MASWRK) WRITE(IW,9005)
        NERR=NERR+1
      ENDIF
      IF(DIRTRF) THEN
        IF(MASWRK) WRITE(IW,9006)
        NERR=NERR+1
      ENDIF
C
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     REMOVE MOLECULAR SYMMETRY FOR ENTIRE ROUTINE.
      REDO_INT=.FALSE.
      IF(NT.NE.1) REDO_INT=.TRUE.
      CALL SYMOFF
C
C     RE-DO INTEGRALS
      IF(REDO_INT) THEN
        CALL SEQREW(IS)
        CALL JANDK
      ENDIF
      CALL SEQREW(IS)
C
C     ALLOCATE MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LS           = LOADFM     + 1
      LS2          = LS         + L2
      LSWRK        = LS2        + L2
      LSVMBS       = LSWRK      + L2
      LIPOSCOR     = LSVMBS     + L1*L0MBS
      LILENCOR     = LIPOSCOR   + (NAT+1)
      LIPOSMBS     = LILENCOR   + NAT
      LILENMBS     = LIPOSMBS   + (NAT+1)
      LIATSVD      = LILENMBS   + NAT
      LIPOSEXT     = LIATSVD    + L1
      LOCCIMO      = LIPOSEXT   + (NAT+1)
      LVECCOL      = LOCCIMO    + L0MBS
      LVEC539      = LVECCOL    + L3
      LVEC         = LVEC539    + L3
      LVWRK1       = LVEC       + L3
      LVWRK2       = LVWRK1     + L3
      LVWRK3       = LVWRK2     + L3
      LVWRK4       = LVWRK3     + L3
      LBUFFX       = LVWRK4     + L3
      LBUFFI       = LBUFFX     + NINTMX
      LWRK         = LBUFFI     + NINTMX
      LIWRK        = LWRK       + L1*8
      LEIG         = LIWRK      + L1
      LSAVWGT      = LEIG       + L1
      LSAVWGT2     = LSAVWGT    + NAOTOT
      LIWRKP       = LSAVWGT2   + NAOTOT
      LIWRK3       = LIWRKP     + L1
      LAST         = LIWRK3     + L3
      NEED_NOS_EXT = LAST - LOADFM - 1
      CALL GETFM(NEED_NOS_EXT)
C
C     NEED TO KEEP THE ROUTINES FOR LATER.
C     FAKE SOME CALLS.
      IF(IW.NE.6) THEN
        IDUM=1
        DUMMY=0.0D+00
        CALL LOCAL_ATOMIC_HSANDT(X(LS),L2,IDUM,IDUM,DUMMY)
        CALL LOCAL_RESIZE_DEN(
     *       X(LBUFFX),X(LBUFFI),X(LIWRK),IDUM,IDUM,DUMMY)
      ENDIF
C
C     SETUP SOME ATOM INTEGER ARRAYS.
      CALL VCLR(X(LWRK),1,L1*8)
      CALL LOCAL_AAMBS_ATLAB(
     *     NAT,L0MBS,
     *     X(LIPOSCOR),X(LILENCOR),X(LIPOSMBS),X(LILENMBS),
     *     X(LWRK+L1),X(LWRK+2*L1),
     *     MASWRK,IW)
      IFILE=540
      CALL LOCAL_READ_FILE528_WITH_CORES(IFILE,
     *                                   X(LIATSVD),NAT,NAOTOT,MASWRK)
C
C     PUT ALL THE WAVE FXN ORBITALS IN THE ORDER OF
C     THE SCF FREE-ATOM ORBITALS.
C     --ONLY CURRENT OUTPUT:  LOCCIMO
      IF(SOME) WRITE(IW,9055)
      CALL DAREAD(IDAF,IODA,X(LSWRK),IMBS2,536,0)
      CALL DAREAD(IDAF,IODA,X(LSVMBS),L1*L0MBS,533,0)
      CALL DAREAD(IDAF,IODA,X(LVWRK1),L3,539,0) ! clindep 522 before
      CALL LOCAL_NOS_EXTSVD1(
     *     NAT,L1,L0MBS,NCORTOT,IMBS,IMBS2,
     *     X(LIPOSMBS),X(LILENMBS),
     *     X(LWRK+L1),X(LWRK+2*L1),
     *     X(LIATSVD),X(LWRK),X(LIWRK),
     *     X(LVWRK1),X(LVEC),X(LSVMBS),X(LVWRK2),
     *     X(LSWRK),X(LOCCIMO))
C
C     FORM "ORDERED" EXTERNAL QUAOS
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL DAREAD(IDAF,IODA,X(LSVMBS),L1*L0MBS,533,0)
      CALL DAREAD(IDAF,IODA,X(LVEC539),L3,539,0) ! clindep 522 before
      L0FIN=0
      CALL LOCAL_NOS_EXTSVD2(
     *     NAOTOT,L0,L0FIN,L1,L2,L3,L0MBS,NAT,NINTMX,
     *     X(LIPOSMBS),X(LILENMBS),X(LIATSVD),X(LIPOSEXT),
     *     LIMSUP,LIMLOW,
     *     X(LOCCIMO),
     *     X(LS),X(LS2),X(LSWRK),X(LSVMBS),
     *     X(LVEC539),X(LVECCOL),X(LVEC),
     *     X(LEIG),X(LSAVWGT),X(LSAVWGT2),
     *     X(LIWRK),X(LWRK),X(LVWRK1),X(LVWRK2),X(LVWRK3),X(LVWRK4),
     *     NOPK,X(LBUFFX),X(LBUFFI),
     *     X(LIWRKP),
     *     X(LIWRK3),
     *     SOME,IW)
CLINDEP
C     ENJOY... SUFFER... ENDURE... PERISH...
      CALL DAWRIT(IDAF,IODA,X(LVEC539),L3,539,0)
      CALL VICLR(X(LIWRK3),1,L3)
      CALL ICOPY(L1-NCORTOT,X(LIATSVD+NCORTOT),1,X(LIWRK3),1)
      CALL DAWRIT(IDAF,IODA,X(LIWRK3),L1,540,1)
CLINDEP
C
C     ADD THE INTERNAL ORBITALS FOR THE LVECCOL.
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,534,0)
      CALL DCOPY(L1*L0MBS,X(LVEC),1,X(LVECCOL),1)
C
C     FINISH EXTERNAL ORBITAL FILES.
C     --NOTE1:  NEVER-EVER-EVER OVER-WRITE DAF 528.
C               528 IS FOR THE "INTERNALS" PROJECT.
C     --NOTE2:  FILE 535 WILL CONTAIN ONLY EXTERNAL ATOM LABELS.
C               WE MUST THROW OUT THE MBS SVD ATOM LABELS.
C               LATER, WE LEARN THE ATOM LABELS FOR ER,BOYS,ETC...
      IF(ISVDOP.EQ.100) THEN
        IFILE=540
        CALL LOCAL_READ_FILE528_WITH_CORES(IFILE,
     *                                     X(LIATSVD),NAT,NAOTOT,MASWRK)
        CALL VICLR(X(LIWRKP),1,L1)
        CALL ICOPY(L0FIN,X(LIATSVD),1,X(LIWRKP),1)
        GO TO 789
      ENDIF
      CALL VICLR(X(LIWRK),1,L1)
      CALL ICOPY(L0FIN,X(LIWRKP),1,X(LIWRK),1)
      CALL REORDR(X(LVECCOL),X(LIWRK),L0FIN,L1)
      IFILE=540
      CALL LOCAL_READ_FILE528_WITH_CORES(IFILE,
     *                                   X(LIATSVD),NAT,NAOTOT,MASWRK)
      CALL ICOPY(L0FIN,X(LIWRKP),1,X(LIWRK),1)
      CALL IREORDR(X(LIATSVD),X(LIWRK),L0FIN,1)
      CALL ICOPY(L0FIN,X(LIWRKP),1,X(LIWRK),1)
      CALL REORDR(X(LSAVWGT2),X(LIWRK),L0FIN,1)
      CALL VICLR(X(LIWRKP),1,L1)
      CALL ICOPY(L0FIN,X(LIATSVD),1,X(LIWRKP),1)
  789 CONTINUE
      CALL DAWRIT(IDAF,IODA,X(LVECCOL),L3,534,0)
      CALL DAWRIT(IDAF,IODA,X(LIWRKP),L1,535,1)
C
C     CHECK FOR ORTHONORMAL FINAL ORBITALS.
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     L0FIN,L1,L2,
     *     X(LS2),X(LS),X(LVECCOL),X(LWRK),
     *     MASWRK,IW)
C
C     WRITE ATOM LABELS OFF TO .DAT FILE.
      CALL DAREAD(IDAF,IODA,X(LIWRKP),L1,535,1)
      CALL LOCAL_DAT_ATOMS(
     *     L1,L0FIN,L0MBS+1,X(LIWRKP),IP,MASWRK,IW)
C
C     SAVE THE ALL-MIGHTY L0DEP0.
      L0DEP0=L0FIN
C
C     WRITE ORBITALS OUT TO EVERYWHERE.
      IF(SOME) THEN
        WRITE(IW,9070)
        WRITE(IW,9071) L0FIN
        CALL PRSQL(X(LVECCOL),L0FIN,L1,L1)
      ENDIF
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(X(LVECCOL),L0FIN,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED_NOS_EXT)
C
C     RESTORE MOLECULAR SYMMETRY NOW.
      CALL SYMON
C
C     FINISH UP.
 8999 CONTINUE
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_NOS_EXT NOW FORMS EXTERNAL LOCALIZED NOS.'/
     *   5X,60(1H-))
 9003 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *        /1X,'DID NOT RUN THROUGH VVOS ROUTINE.',
     *        /1X,'NEED ISVDOP=10 OR IVVOS.NE.0 OR BOTH.')
 9004 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *      /1X,'EXTLOC=ATMNOS REQUIRES EXTERNAL ORBITALS.')
 9005 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *       /1X,'ANY GIVEN EXTLOC OPTION CANNOT HAVE ILOCAL=4.')
 9006 FORMAT(//1X,'LOCAL_NOS_EXT ERROR:',
     *       /1X,'FOR THE MOMENT',
     *        1X,'DIRTRF MUST BE FALSE TO FORM THE EXCHANGE.')
 9055 FORMAT(/1X,'LOCAL_NOS_EXTSVD1:',
     *        1X,'LOCATES ALL VALENCE SVD ORBITALS.',
     *       /1X,'LOCAL_NOS_EXTSVD1:',
     *        1X,'ORDERS SVD ORBITALS AND DENSITIES INTO',
     *      /20X,'THE ORDER OF THE HIGH QUALITY VVOS AOS.')
 9070 FORMAT(//10X,'ORDERED EXTERNAL LOCALIZED ORBITALS')
 9071 FORMAT(10X,I5,1X,'ORBITALS ARE SHOWN.')
 9080 FORMAT('ORDERED EXTERNAL LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9300 FORMAT(1X,'... DONE WITH LOCAL_NOS_EXT ...')
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_EXTSVD1
C> @brief      Prepares occs. for 2 el. exch. integrals.
C>
C> @author     Aaron West
C>             -May 19, 2013
C>
C> @date May 23, 2015-Aaron West
C> -Simplify this piece.
C>
C> @param NAT      is the number of atoms.
C> @param L1       is the length of the AO coefficients.
C> @param L0MBS    is the dimension of the minimal basis set number of
C>                 orbitals.
C> @param NCORTOT      is the chemical cores as defined
C>                     by NVVOS_NUMCOR.
C> @param IMBS          is the total number of MBS valence orbitals.
C> @param IMBS2    is the triangular size of IMBS.
C> @param IPOSMBS  denotes the integer array that holds the starting
C>                 position for the 1st VALENCE MBS AO on a given atom.
C>                 These are in atomic order from the input
C>                 as usual.
C>                 I emphasize the CORE+VALENCE part.
C> @param ILENMBS  gives the number of VALANEC MBS orbitals.
C> @param MAPAA    holds the atom labels for the AAMBS orbitals.
C> @param IVALAA   is an integer array of size L0MBS.
C>                 It holds 1 for the core AAMBS orbitals.
C>                 It holds 2 for the valence AAMBS orbitals.
C> @param IATSVD   is an array from the SVD run itself
C>                 that contains atom-orbital correspondences.
C> @param IORDTOT  is an integer scratch of length L0MBS.
C> @param IWRK     is an integer scratch of length L0MBS.
C> @param VCOPY    holds the copy of wave function orbitals
C>                 for this routine and should not change
C>                 for this routine.
C> @param VEC      is scratch space of size L1xL0MBS.
C> @param SVMBS    holds the SV product of the MBS orbitals
C>                 from the VVOS but in the current basis set.
C> @param SMO      is scratch space of size L0MBSxL0MBS.
C> @param DEN      holds the density matrix for the SVD orbitals
C>                 on entry.
C> @param OCCIMO   will hold reorder SVD densities
C>                 in the order of the VVOS.
      SUBROUTINE LOCAL_NOS_EXTSVD1(
     *           NAT,L1,L0MBS,NCORTOT,IMBS,IMBS2,
     *           IPOSMBS,ILENMBS,
     *           MAPAA,IVALAA,
     *           IATSVD,IORDTOT,IWRK,
     *           VCOPY,VEC,SVMBS,SMO,
     *           DEN,OCCIMO)
      IMPLICIT NONE
      INTEGER NAT,L1,L0MBS,NCORTOT,IMBS,IMBS2
      INTEGER IPOSMBS(NAT+1),ILENMBS(NAT),
     *        MAPAA(L0MBS),IVALAA(L0MBS),
     *        IATSVD(L0MBS),IORDTOT(L0MBS),IWRK(L0MBS)
      DOUBLE PRECISION ::
     *       VCOPY(L1,L0MBS),VEC(L1,L0MBS),
     *       SVMBS(L1,L0MBS),SMO(L0MBS,L0MBS),
     *       DEN(IMBS2),OCCIMO(L0MBS)
C---------------------------------------------------------------------
      INTEGER I,J,IATM1,IPOS,ILEN,
     *        LTPOS
C---------------------------------------------------------------------
C
C     INIT. IORDTOT.
      CALL VICLR(IORDTOT,1,L0MBS)
      CALL ICOPY(L0MBS,IVALAA,1,IWRK,1)
      DO 100 I=1,NCORTOT
        DO 110 J=1,L0MBS
          IF(IWRK(J).NE.1) GO TO 110
          IF(MAPAA(J).NE.IATSVD(I)) GO TO 110
          IWRK(J)=0
          IORDTOT(J)=I
          GO TO 100
  110   CONTINUE
  100 CONTINUE
      DO 200 I=NCORTOT+1,L0MBS
        DO 210 J=1,L0MBS
          IF(IWRK(J).NE.2) GO TO 210
          IF(MAPAA(J).NE.IATSVD(I)) GO TO 210
          IWRK(J)=0
          IORDTOT(J)=I
          GO TO 200
  210   CONTINUE
  200 CONTINUE
C
C     PUT "SVD" QUAOS IN THE ORDER OF THE AAMBS.
      CALL DCOPY(L1*L0MBS,VCOPY,1,VEC,1)
      CALL ICOPY(L0MBS,IORDTOT,1,IWRK,1)
      CALL REORDR(VEC,IWRK,L0MBS,L1)
C
C     FORM OVERLAP BETWEEN AAMBS AND REORDERED MOS.
      CALL VCLR(SMO,1,L0MBS*L0MBS)
      CALL MRTRBR(SVMBS,L1,L1,L0MBS,
     *            VEC,L1,L0MBS,
     *            SMO,L0MBS)
C
C     FIND THE MAXIMUM ORBITAL OVERLAPS FOR ORBITALS ON A GIVEN ATOM.
      DO IATM1=1,NAT
        IPOS=IPOSMBS(IATM1)
        ILEN=ILENMBS(IATM1)
        CALL LOCAL_MAXCOIN(ILEN,IWRK,SMO(IPOS,IPOS),L0MBS)
        CALL IREORDR(IORDTOT(IPOS),IWRK,ILEN,1)
      ENDDO
C
C     GET OUT OCCUPATIONS IN PROPER FORM.
      DO I=1,L0MBS
        OCCIMO(I)=-1.0D+00
      ENDDO
      DO I=1,IMBS
        OCCIMO(NCORTOT+I)=DEN(LTPOS(I,I))
      ENDDO
      CALL ICOPY(L0MBS,IORDTOT,1,IWRK,1)
      CALL REORDR(OCCIMO,IWRK,L0MBS,1)
C
C     REORDER VEC.
      CALL DCOPY(L1*L0MBS,VCOPY,1,VEC,1)
      CALL ICOPY(L0MBS,IORDTOT,1,IWRK,1)
      CALL REORDR(VEC,IWRK,L0MBS,L1)
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_EXTSVD2
C> @brief      Forms ordered externals.
C>
C> @author     Aaron West
C>             -August 02, 2013
C>
C> @note       This routine is a major re-write for
C>             forming ordered external orbitals.
C>             Now, the method is decided on, and many
C>             extraneous items are stripped out.
C>             Various tests show that results do not change.
C>
C> @date April 15, 2014-Aaron West
C> -Fix small bug.
C>  Only CLINDEP cases were affected.
C>  Only the external LCAO analysis was affected.
C>  VEC539 runs over all MOs and needs L0MBS+I indexing.
C>  Nothing from first QUAOs publication is affected.
C>
C> @param NAOTOT   is the length of the MO spherical space.
C>                 ...unless it was changed again.
C> @param L0       is the length of the MO VARIATIONAL spherical space.
C> @param L0FIN    is the length of the reduced MO spherical space.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param L3       is the square of L1.
C> @param L0MBS    is the dimension of the minimal basis set number of
C>                 orbitals.
C>                 L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
C> @param NAT      is the number of atoms.
C> @param NINTMX   should be NTINMX from intfil common.
C> @param IPOSMBS  denotes the integer array that holds the starting
C>                 position for the 1st VALENCE MBS AO on a given atom.
C>                 These are in atomic order from the input
C>                 as usual.
C>                 I emphasize the CORE+VALENCE part.
C> @param ILENMBS  gives the number of VALANEC MBS orbitals.
C> @param IATSVD   is an array from the SVD run itself
C>                 that contains atom-orbital correspondences.
C>                 In runs that experience linear dependence,
C>                 IATSVD must be reordered in this routine.
C>                 Then, DAF540 must be re-written outside right
C>                 outside of this but only into the 'valence'.
C> @param IPOSEXT  indicates the orbital index for the first external
C>                 orbital on a given atom in the 1st column.
C>                 In the 2nd column, this integer array indicates
C>                 the total number of external orbitals on a given atom.
C>                 The orbitals are contiguous so that a L0*NAT array
C>                 does not have to given at this time...
C> @param LIMSUP   array contains the upper basis function on an atom.
C> @param LIMLOW   array contains the lower basis function on an atom.

C> @param OCCIMO   contains the occupations of the internal valence
C>                 canonical quasi-atomic orbitals in DAF521.
C> @param S        contains the AO overlaps of length L2.
C> @param S2       is scratch of length L2.
C> @param SWRK     is scratch of length L2.
C> @param SVMBS    holds the SV product of the MBS orbitals
C>                 from the VVOS but in the current
C>                 basis set.
C> @param VEC539   contains the orbitals from DAF539.
C> @param VECCOL   will contain the final ordered external orbitals.
C> @param VEC      is scratch of length L1xL1.
C> @param EIG      is scratch of length L1.
C> @param SAVWGT   will hold the atom-by-atom weights.
C> @param SAVWGT2  will hold the resultant, final weights.
C> @param IWRK     is integer scratch of length L1.
C> @param WRK      is scratch array of length L1*8.
C> @param VWRK1    is scratch array of L1xL1 length.
C> @param VWRK2    is scratch array of L1xL1 length.
C> @param VWRK3    is scratch array of L1xL1 length.
C> @param VWRK4    is scratch array of L1xL1 length.
C> @param NOPK     indicates supermatrix form or not for
C>                 the AO integrals.
C> @param BUFFX    is scratch of length NINTMX.
C> @param BUFFI    is scratch of length NINTMX.
C> @param IWRKP    is an integer array of L1 length.
C>                 This array might hold orbital
C>                 reordering instructions.
C> @param IWRK3    is an integer array of L3 length.
C> @param SOME     is true for master process
C>                 with nprint not equal -5.
C> @param IW       indicates write out to the log file.
      SUBROUTINE LOCAL_NOS_EXTSVD2(
     *     NAOTOT,L0,L0FIN,L1,L2,L3,L0MBS,NAT,NINTMX,
     *     IPOSMBS,ILENMBS,IATSVD,IPOSEXT,
     *     LIMSUP,LIMLOW,
     *     OCCIMO,
     *     S,S2,SWRK,SVMBS,
     *     VEC539,VECCOL,VEC,
     *     EIG,SAVWGT,SAVWGT2,
     *     IWRK,WRK,VWRK1,VWRK2,VWRK3,VWRK4,
     *     NOPK,BUFFX,BUFFI,
     *     IWRKP,
     *     IWRK3,
     *     SOME,IW)
      IMPLICIT NONE
      LOGICAL SOME,ATWGT,EXTRA_PRINT,ALINDEP
      INTEGER IW,
     *        NAOTOT,L0,L0FIN,L1,L2,L3,L0MBS,NAT,NINTMX,
     *        NOPK
      INTEGER IPOSMBS(NAT+1),ILENMBS(NAT),IATSVD(L1),
     *        IPOSEXT(NAT+1),
     *        LIMSUP(NAT),LIMLOW(NAT),
     *        IWRK(L1),IWRKP(L1),IWRK3(L3)
      DOUBLE PRECISION ::
     *       OCCIMO(L0MBS),
     *       S(L2),S2(L2),SWRK(L2),SVMBS(L1,L0MBS),
     *       VEC539(L1,L1),VECCOL(L1,L1),VEC(L1,L1),
     *       EIG(L1),SAVWGT(NAOTOT),SAVWGT2(NAOTOT),WRK(L1*8),
     *       VWRK1(L1,L1),VWRK2(L1,L1),VWRK3(L1,L1),VWRK4(L1,L1),
     *       BUFFX(NINTMX),BUFFI(NINTMX)
C
C
C---------------------------------------------------------------------
      DOUBLE PRECISION :: QMTTOL
      INTEGER ISPHER
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /BASSPH/ QMTTOL,ISPHER
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C----------------------------------------------------------------------
C
C
C     NON-FED-IN VARS NOW FOLLOW.
      LOGICAL SAVDSKWRK,OLDWSO
      INTEGER IATM1,MAX_EXT_ORBS,
     *        IEXTORB,IEXTBEG,IEXTEND,IEXTTOT,IEXTORBF,
     *        IBAS1,IBAS2,ILTH,IBASSPH1,IBASSPH2,ILTHSPH,
     *        IKIND,
     *        ILOOP,NLOOP,ITMP,IDUM,
     *        I,J,ILEN,ISTOP,ILEN2,
     *        IEXTRI,IERR
      DOUBLE PRECISION :: TMP,TOL
C
C     SET UP TOL=QMTTOL
      TOL=ABS(QMTTOL)
C
C
C     FIND THE FIRST EXTERNAL ORBITAL ON EACH ATOM.
C     SAVE THE FIRST EXTERNAL ORBITAL POSITION INTO IPOSEXT.
      CALL LOCAL_IPOSEXT(
     *     IATSVD,IPOSEXT,
     *     NAT,L0MBS,NAOTOT,MAX_EXT_ORBS,
     *     MASWRK,IW)
C
C     CLEAR OUT ANY ARRAYS TO BE FILLED IN THE LOOP OVER ATOMS
      CALL VCLR(VECCOL,1,L3)
      CALL VICLR(IWRKP,1,L1)
C
C     INITIALIZE IEXTTOT
      IEXTTOT=0
C
C
C
C     LOOP OVER ATOMS
      DO IATM1=1,NAT
        IF(SOME) WRITE(IW,9050) IATM1
C
C       GET NUMBER OF EXTERNALS.
C       GET EXTERNAL START POSITION.
        IEXTORB=0
        IEXTBEG=0
        IEXTEND=0
        CALL LOCAL_GET_IEXTORB(
     *       IEXTORB,IEXTBEG,IEXTEND,
     *       IPOSEXT,IATM1,NAT,NAOTOT,L0MBS,MASWRK,IW)
        IEXTTOT=IEXTTOT+IEXTORB
C
C       FORM S**(-1) FOR IATM1 FOR THE PROJECTION BELOW.
        CALL LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *       LIMLOW,LIMSUP,IATM1,NAT,L2,
     *       S2,S,
     *       IBAS1,IBAS2,ILTH,
     *       IBASSPH1,IBASSPH2,ILTHSPH,
     *       .FALSE.)
        ALINDEP=.FALSE.
        IF(TOL.LE.1.0D-06) ALINDEP=.TRUE.
        IKIND=4
        CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *       IKIND,ILTH,S2,VWRK4,
     *       VWRK1,VWRK2,VWRK3,EIG,IWRK,WRK,
     *       L1,L3,L2,ALINDEP,
     *       IW,MASWRK)
C
C       FOR EACH ATOM,
C       FORM THE NORMALIZED PROJECTION OF THE AAMBS ORBITALS
C       ONTO THE CURRENT BASIS FUNCTIONS.
C       NOTE:  NEED THE RESULT IN VWRK1 FOR A BIT IN THIS SECTION.
        CALL VCLR(VWRK2,1,L3)
        CALL VCLR(EIG,1,L1)
        CALL VCLR(S2,1,L2)
        NLOOP=0
        NLOOP=ILENMBS(IATM1)
        IF(NLOOP.LE.0) THEN
          IF(MASWRK) WRITE(IW,9070)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C--------
        DO ILOOP=1,NLOOP
          ITMP=IPOSMBS(IATM1)
          ITMP=ITMP+(ILOOP-1)
          CALL MRARBR(VWRK1,L1,ILTH,ILTH,
     *                SVMBS(IBAS1,ITMP),L1,1,
     *                VWRK2(IBAS1,ILOOP),L1)
C----------
          EIG(ILOOP)=OCCIMO(ITMP)
          IF(EIG(ILOOP).LT.0.0D+00) THEN
            IF(MASWRK) WRITE(IW,9080)
            CALL FLSHBF(IW)
            CALL ABRT
            STOP
          ENDIF
C----------
          CALL TFTRI(S2,S,VWRK2(1,ILOOP),IWRK,1,L1,L1)
          TMP=S2(1)
          TMP=1.0D+00/SQRT(TMP)
          CALL DSCAL(L1,TMP,VWRK2(1,ILOOP),1)
C----------
        ENDDO
C--------
CKEEPC
CKEEPC       VIEW THE INTERNAL ORBITALS ON EACH ATOM.
CKEEP        IF(MASWRK) THEN
CKEEP          WRITE(IW,*) 'INT LOCAL_NOS_EXT ATOM=',IATM1
CKEEP          WRITE(IW,9900)
CKEEP          CALL PRSQL(VWRK2,NLOOP,L1,L1)
CKEEP        ENDIF
C
C       FOR THE PROJECTED NORMALIZED AAMBS ORBITALS,
C       CONSTRUCT THE DENSITY IN THE AO BASIS.
C       NOTE:  NEED THE RESULT IN VWRK2 FOR A BIT IN THIS SECTION.
        IF(SOME) WRITE(IW,9090) NLOOP
        CALL VCLR(S2,1,L2)
        CALL DMTX(S2,VWRK2,EIG,NLOOP,L1,L1)
C
C       GRAB OUT THE EXTERNALS ON A GIVEN ATOM.
        CALL VCLR(VEC,1,L3)
        DO I=1,IEXTORB
          ITMP=IEXTBEG+I-1
          CALL DCOPY(L1,VEC539(1,ITMP),1,VEC(1,I),1)
        ENDDO
C
C       FORM 2 EL EXCHANGE INTEGRALS FOR EXTERNALS ON IATM1.
C       NOTES:  INPUTS=VEC,S2
C               OUTPUTS=S2
        SAVDSKWRK=DSKWRK
        DSKWRK=.TRUE.
        CALL LOCAL_NOS_ACAVO(
     *       VEC,SWRK,S2,
     *       VWRK1,VWRK2,VWRK3,VWRK4,
     *       WRK,BUFFX,BUFFI,
     *       NOPK,NINTMX,L1,L2,
     *       NLOOP,IEXTORB)
        DSKWRK=SAVDSKWRK
C
C       FOR EACH ATOM:
C       --ARRANGE FROM HIGHEST TO LOWEST EIGENVALUE.
C       --DIAGONALIZE EXTERNAL EXCHANGE MATRIX
C       --REVERSE THE SIGN CHANGE.
C       --TRANSFORM THE ORBITALS.
        CALL VCLR(EIG,1,L1)
        CALL VCLR(VWRK1,1,L3)
        CALL VCLR(VWRK2,1,L3)
        IERR=0
        ILEN=IEXTORB
        ILEN2=(ILEN*ILEN+ILEN)/2
        DO I=1,ILEN2
          S2(I)=-S2(I)
        ENDDO
        CALL GLDIAG(L1,ILEN,ILEN,S2,WRK,EIG,VWRK1,IERR,IWRK)
        IF(IERR.GT.0) THEN
          IF(MASWRK) WRITE(IW,9100)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
        IERR=0
        DO I=1,ILEN
          EIG(I)=-EIG(I)
          IF(EIG(I).LT.0.0D+00) IERR=IERR+1
        ENDDO
        IF(IERR.NE.0) THEN
          IF(MASWRK) WRITE(IW,9110)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
        DO I=1,IEXTORB
          CALL DCOPY(L1,VEC(1,I),1,VWRK2(1,I),1)
        ENDDO
        CALL MRARBR(VWRK2,L1,L1,ILEN,
     *              VWRK1,L1,ILEN,
     *              VEC,L1)
C
C       PRINT OFF THE OCCUPATIONS.
C       --DON'T TRY TO MODIFY THIS NEXT PIECE...
        ILEN=IEXTORB
        ISTOP=5
        IF(ILEN.LE.5) ISTOP=ILEN
        IF(SOME) WRITE(IW,9120) (EIG(I),I=1,ISTOP)
        IF(ILEN.GT.5) THEN
          DO J=6,ILEN,5
            ISTOP=J+4
            IF(ISTOP.GT.ILEN) ISTOP=ILEN
            IF(SOME) WRITE(IW,9121) (EIG(I),I=J,ISTOP)
          ENDDO
        ENDIF
C
C       THE WEIGHTS IN EIG ARE NOT COMPARABLE ACROSS ATOMS.
C       FOR EACH ATOM, RESET EIG TO RANGE FROM 0 TO 1.
C       NOTE:
C       FOR EACH ATOM,
C       SET 2ND FALSE BELOW TO TRUE TO PRINT THE NEW WEIGHTS.
        IF(SOME) WRITE(IW,9150)
        ATWGT=.TRUE.
        CALL LOCAL_WSO_PREP(
     *       EIG,IEXTORB,ATWGT,.FALSE.,IW)
C
C       SAVE THE NEW WEIGHTINGS FOR LATER.
        IF(IATM1.EQ.1) CALL VCLR(SAVWGT,1,NAOTOT)
        ITMP=IEXTTOT
        ITMP=ITMP-IEXTORB+1
        CALL DCOPY(IEXTORB,EIG,1,SAVWGT(ITMP),1)
C
C       SAVE OUT THE NEW EXTERNAL ORBITALS.
        ITMP=IEXTTOT
        ITMP=ITMP-IEXTORB
        DO I=1,IEXTORB
          ITMP=ITMP+1
          CALL DCOPY(L1,VEC(1,I),1,VECCOL(1,ITMP),1)
          IWRKP(ITMP)=IATSVD(IEXTBEG+I-1)
        ENDDO
C
C
C
C     END LOOP OVER ATOMS
      ENDDO
C
CLINDEP
CLINDEP
CLINDEP
CLINDEP
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 6
C     ---SKIP IF L0=NAOTOT
C     ---PERFORM KR'S CRITERION WITH THE DISJUNCT SUMMATION.
C     ---IF CRITERION FAILS, ALSO PERFORM REMOVAL OF SMALL SVD EVALUES.
      L0FIN=L0
      IF(L0.EQ.NAOTOT) GO TO 1000
      CALL DCOPY(L3,VECCOL,1,VWRK1,1)
      IF(IEXTTOT.NE.NAOTOT-L0MBS) THEN
        IF(MASWRK) WRITE(IW,9160)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      IEXTORBF=0
      L0FIN=0
      CALL DCOPY(IEXTTOT,SAVWGT,1,VWRK2,1)
      CALL LOCAL_CLINDEP(
     *     IEXTTOT,IEXTORBF,NAOTOT,L0MBS,L0,L1,L2,L3,
     *     IWRKP,IWRK,IWRK3,
     *     VWRK1,VWRK2,TOL,
     *     S,S2,VWRK3,WRK,EIG,
     *     SOME,MASWRK,IW)
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 7
C     ---CREATE A BRAND NEW SUPER AWESOME "L0"s.
      L0FIN=L0MBS+IEXTORBF
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 8
C     ---PERFORM CLINDEP REORDERING.
C     NOTE:  NOT YET THE REDUCED SPACE...
      IDUM=0
      CALL DCOPY(L3,VECCOL,1,VWRK2,1)
      CALL OVLSEL(VWRK2,EIG,VWRK1,S,
     *            VWRK3,IWRK,VWRK4,IWRK,
     *            IDUM,IDUM,NAOTOT,L1,L2,.FALSE.,IEXTTOT)
      CALL VCLR(VWRK1,1,L3)
      CALL VCLR(VWRK2,1,L3)
CLINDEP    similar to local_sort_svdeig
C     SORT OVER EXTERNAL ORBITALS ONLY.
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL REORDR(VECCOL,IWRKP,IEXTTOT,L1)
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL REORDR(SAVWGT,IWRKP,IEXTTOT,1)
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL REORDR(SAVWGT2,IWRKP,IEXTTOT,1)
C     SORT OVER ALL ORBITALS.
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL VICLR(IWRK,1,L1)
      DO I=1,IEXTTOT
        IWRK(L0MBS+I)=L0MBS+IWRKP(I)
      ENDDO
      DO I=1,L0MBS
        IWRK(I)=I
      ENDDO
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL IREORDR(IATSVD,IWRKP,NAOTOT,1)
      CALL ICOPY(L1,IWRK,1,IWRKP,1)
      CALL REORDR(VEC539,IWRKP,NAOTOT,L1)
CLINDEP
      CALL VICLR(IWRK,1,L1)
      CALL VICLR(IWRKP,1,L1)
C
C     SHRINK ORBITAL TRANSFORMATION:  PART 9
C     ---THE ORDERING SCHEME IS COMPLEX AND CONFUSING.
C        IN ORDER TO ELIMINATE ERRORS,
C        E.G. IN OUTSIDE SORTING ROUTINES,
C        WE NOW DESTROY UPPER ORBITALS AND WEIGHTS.
      DO I=IEXTORBF+1,IEXTTOT
        CALL VCLR(VEC539(1,L0MBS+I),1,L1)
        CALL VCLR(VECCOL(1,I),1,L1)
        SAVWGT(I)=0.0D+00
        SAVWGT2(I)=0.0D+00
      ENDDO
CLINDEP
CLINDEP
CLINDEP
CLINDEP
C
C------------------------------------------------
C     PRINT WEIGHTS STUFF.
 1000 CONTINUE
C------------------------------------------------
C
C     CONVERT THE WEIGHTS IN SAVWGT ARRAY.
C     STORE RESULTS IN SAVWGT2 ARRAY.
      CALL DCOPY(L0FIN,SAVWGT,1,SAVWGT2,1)
      ATWGT=.FALSE.
      CALL LOCAL_WSO_PREP(
     *     SAVWGT2,L0FIN-L0MBS,ATWGT,SOME,IW)
C
C     GIVE AN EXTRA PRINTING WHEN MORE GRAPHS ARE NEEDED.
      EXTRA_PRINT=.FALSE.
      IF(EXTRA_PRINT) THEN
        IF(SOME) WRITE(IW,9170)
        DO I=1,L0FIN-L0MBS
          IF(SOME)
     *    WRITE(IW,*) "WSO I,SAV1,SAV2 =",I,SAVWGT(I),SAVWGT2(I)
        ENDDO
        IF(SOME) WRITE(IW,9180)
        CALL DCOPY(L0FIN-L0MBS,SAVWGT2,1,WRK,1)
        CALL LOCAL_SORT_EVALS(.TRUE.,3,L0FIN-L0MBS,IWRK,WRK)
        DO I=1,L0FIN-L0MBS
          IF(SOME) WRITE(IW,*) "WSO I,SAV1,SAV2 =",
     *             I,SAVWGT(IWRK(I)),SAVWGT2(IWRK(I))
        ENDDO
      ENDIF
C
C------------------------------------------------
C     END OF PRINT WEIGHTS STUFF.
C------------------------------------------------
C
C     PERFORM WEIGHTED ORTHOGONALIZATION.
C     --COPY VECCOL INTO VEC.
C     --FORM THE OVERLAP BETWEEN THE EXTERNAL ORBITALS.
C     --COPY THE WEIGHTS OUT FROM SAVWGT2 TO BE SAFE.
C     --FIND THE SIZE OF THE NEEDED MATRIX.
C     --OBTAIN THE TRANSFORMATION MATRIX.
C     --TRANSFORM THE EXTERNAL ORBITALS.
C     --REPLACE VECCOL BY THE NEW ORBITALS.
      CALL DCOPY(L3,VECCOL,1,VEC,1)
      CALL VCLR(S2,1,L2)
      CALL TFTRI(S2,S,VEC,WRK,L0FIN-L0MBS,L1,L1)
      CALL VCLR(WRK,1,L1*8)
      CALL DCOPY(L0FIN,SAVWGT2,1,WRK,1)
      IEXTRI=L0FIN-L0MBS
      IEXTRI=(IEXTRI*IEXTRI+IEXTRI)/2
C
      OLDWSO=.FALSE.
      IF(OLDWSO) THEN
C       WANT WEIGHTED S ** -1/2 HERE...
        IKIND=1
        CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *       IKIND,L0FIN-L0MBS,S2,WRK,
     *       VWRK1,VWRK2,VWRK3,EIG,IWRK,VWRK4,
     *       L1,L3,IEXTRI,.TRUE.,
     *       IW,MASWRK)
        CALL MRARBR(VEC,L1,L1,L0FIN-L0MBS,
     *              VWRK1,L1,L0FIN-L0MBS,
     *              VECCOL,L1)
      ELSE
        IKIND=3
        CALL LOCAL_WEIGHTED_SYM_ORTHOG(
     *       IKIND,L0FIN-L0MBS,S2,WRK,
     *       VWRK1,VWRK2,VWRK3,EIG,IWRK,VWRK4,
     *       L1,L3,IEXTRI,.TRUE.,
     *       IW,MASWRK)
        CALL VCLR(VECCOL,1,L3)
        CALL MRARBR(VEC,L1,L1,L0FIN-L0MBS,
     *              VWRK1,L1,L0FIN-L0MBS,
     *              VECCOL,L1)
        CALL VCLR(VWRK1,1,L3)
        CALL MTARBR(S,L1,VEC,L0FIN-L0MBS,VWRK1,L1,1)
C       NOTE:  NEXT VCLR MAYBE NOT FOR SHOW.
        CALL VCLR(VWRK4,1,L3)
        CALL MRTRBR(VWRK1,L1,L1,L0FIN-L0MBS,
     *              VECCOL,L1,L0FIN-L0MBS,
     *              VWRK4,L1)
        CALL DCOPY(L0FIN,SAVWGT2,1,WRK,1)
        CALL LOCAL_EXTERNAL_JACOBI(
     *       WRK,VWRK1,VWRK4,L1,L1,L0FIN-L0MBS,
     *       SOME,MASWRK,IW)
        CALL DCOPY(L3,VECCOL,1,VWRK2,1)
        CALL MRARBR(VWRK2,L1,L1,L0FIN-L0MBS,
     *              VWRK1,L1,L0FIN-L0MBS,
     *              VECCOL,L1)
      ENDIF
C
C     NOW, SHIFT THE VECCOL VECTORS TO THE CORRECT EXTERNAL POSITIONS.
      CALL DCOPY(L3,VECCOL,1,VEC,1)
      CALL VCLR(VECCOL,1,L3)
      ITMP=0
      DO I=L0MBS+1,L0FIN
        ITMP=ITMP+1
        CALL DCOPY(L1,VEC(1,ITMP),1,VECCOL(1,I),1)
      ENDDO
C
C     CONSTRUCT THE IWRKP ARRAY BEFORE LEAVING.
      CALL VCLR(WRK,1,L1*8)
      DO I=1,L0FIN-L0MBS
        WRK(L0MBS+I)=SAVWGT2(I)
      ENDDO
      CALL VICLR(IWRKP,1,L1)
      DO I=L0MBS+1,L0FIN
        IWRKP(I)=I
      ENDDO
      CALL LOCAL_SORT_EVALS(
     *     .FALSE.,3,L0FIN-L0MBS,IWRKP(L0MBS+1),WRK(L0MBS+1))
      DO I=1,L0MBS
        IWRKP(I)=I
      ENDDO
C
C-------------------------------------------------------------
C     NEED TO FINISH MAKING VECCOL RIGHT AFTER THIS ROUTINE...
C-------------------------------------------------------------
C
      RETURN
 9050 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 PREPARES ORBITALS',
     *        1X,'ON ATOM NUMBER=',I5)
 9070 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 ERROR:',
     *       /1X,'NLOOP CANNOT BE 0.')
 9080 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 ERROR:',
     *       /1X,'OCCIMO IS LESS THAN ZERO.',
     *       /1X,'ATOMIC INDEXING INSIDE OF',
     *        1X,'LOCAL_NOS_EXTSVD1 HAS BROKEN DOWN.')
 9090 FORMAT(/1X,'LOCAL_NOS_EXTSVD2:',
     *        1X,'PREPARING AO DENSITY FROM',I5,
     *        1X,'VALENCE ORBITALS.')
 9100 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 ERROR:',
     *       /1X,'DIAGONALIZATION OF THE EXCHANGE FAILED.')
 9110 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 ERROR:',
     *       /1X,'ALL EXCHANGE EVALUES SHOULD BE POSITIVE.')
 9120 FORMAT(//1X,'LOCAL_NOS_EXT YIELDS EVALUES =',10F6.3//)
 9121 FORMAT(31X,10F6.3)
 9150 FORMAT(/1X,'LOCAL_WSO_PREP NOW SCALES THE WEIGHTS',
     *        1X,'ON THE GIVEN ATOM.')
 9160 FORMAT(/1X,'LOCAL_NOS_EXTSVD2 ERROR:',
     *        1X,'IEXTTOT DOES NOT EQUAL NAOTOT MINUS L0MBS.')
 9170 FORMAT(/1X,'LOCAL_NOS_EXTSVD2:',
     *       /1X,'THE 2 SETS OF WEIGHTS ARE NOW PRINTED',
     *        1X,'TOGETHER IN ATOM ORDER.')
 9180 FORMAT(/1X,'LOCAL_NOS_EXTSVD2:',
     *       /1X,'THE 2 SETS OF WEIGHTS ARE NOW PRINTED',
     *        1X,'TOGETHER IN INCREASING ORDER.')
CKEEP 9900 FORMAT(//10X,'ATOM-SET LOCALIZED ORBITALS')
      END
C*MODULE LOCAL   *DECK LOCAL_WEIGHTED_SYM_ORTHOG
C> @brief      Forms (half-)inverse of matrix but with weights.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -March 21, 2013
C>
C> @details    FOR THE WEIGHTED VERSION,
C>             S**-1/2  --> W * (WSW)**-1/2
C>             where the weights W cannot be zero.
C>             It is the user's responsibility to make
C>             sure that the weights being fed into this
C>             routine make sense.
C>
C> @param IKIND   is for inverse or -1/2 power.
C>                IKIND=1 --> -1/2 power with possible weightings
C>                IKIND=2 --> inverse with possible weightings
C>                IKIND=3 --> -1/2 power with no possible weightings
C>                IKIND=4 --> -1 power with no possible weightings
C> @param ILTH    is the length of the matrix to be diagonalized.
C> @param S       is the overlap matrix of interest in symmetric form.
C>                This needs to be fed in.
C> @param WGT     is the array of weights for the
C>                symmetric orthogonalization.
C> @param VTMP    is a scratch array of L1xL1.
C> @param VTMP2   is a scratch array of L1xL1.
C> @param UVEC    is a scratch array of L1xL1.
C> @param EIG     is a scratch array of length L1 for the eigenvalues.
C> @param IWRK    is a integer scratch array of length L1.
C> @param WRK     is a work array of length L1x8.
C> @param L1      is the length of the AO basis.
C> @param L3      is L1xL1.
C> @param L2      is the triangular length of L1.
C> @param ALINDEP is a logical that controls errors
C>                for small eigenvalues.
C> @param IW      indicates write out to the log file.
C> @param MASWRK  is true for master process.
      SUBROUTINE LOCAL_WEIGHTED_SYM_ORTHOG(
     *           IKIND,ILTH,S,WGT,
     *           VTMP,VTMP2,UVEC,EIG,IWRK,WRK,
     *           L1,L3,L2,ALINDEP,
     *           IW,MASWRK)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IW,ILTH,L1,L2,L3,IKIND
      DOUBLE PRECISION ::
     *       S(L2),VTMP(L1,L1),WGT(ILTH),
     *       VTMP2(L1,L1),UVEC(L1,L1),EIG(L1),WRK(L1,8)
      INTEGER IWRK(L1)
C----------------------------------------------------------
      LOGICAL ALINDEP
      INTEGER I,J,IJ,IERR2,IERR3
      DOUBLE PRECISION :: TMP,TOL,ONE
      PARAMETER (ONE=1.0D+00)
C----------------------------------------------------------
      DOUBLE PRECISION :: QMTTOL
      INTEGER ISPHER
      COMMON /BASSPH/ QMTTOL,ISPHER
C----------------------------------------------------------
C     SET THE TOLERANCE
      TOL=ABS(QMTTOL)
C----------------------------------------------------------
C----------------------------------------------------------
      IF(IKIND.EQ.3) GO TO 100
      IF(IKIND.EQ.4) GO TO 100
C----------------------------------------------------------
C----------------------------------------------------------
C
C     FORM WSW WITH THE WEIGHTS.
      DO I=1,ILTH
        DO J=1,I
          IJ=(I*I-I)/2+J
          TMP=WGT(J)*WGT(I)
          S(IJ)=TMP*S(IJ)
        ENDDO
      ENDDO
C
C     NOW, DIAGONALIZE THE MATRIX.
  100 CONTINUE
      CALL GLDIAG(L1,ILTH,ILTH,S,WRK,EIG,VTMP,IERR2,IWRK)
      IERR3=0
      DO I=1,ILTH
        IF(ALINDEP.AND.EIG(I).LT.TOL) IERR3=IERR3+1
        IF(IKIND.EQ.1.OR.IKIND.EQ.3) THEN
          EIG(I)=ONE/SQRT(EIG(I))
        ELSEIF(IKIND.EQ.2.OR.IKIND.EQ.4) THEN
          EIG(I)=ONE/EIG(I)
        ELSE
          IF(MASWRK) WRITE(IW,9003)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ENDDO
      IF(IERR2.GT.0.OR.IERR3.GT.0) THEN
        IF(MASWRK.AND.IERR2.GT.0) WRITE(IW,9004)
        IF(MASWRK.AND.IERR3.GT.0) WRITE(IW,9005)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      CALL VCLR(UVEC,1,L3)
      DO I=1,ILTH
        DO J=1,ILTH
          UVEC(I,J)=VTMP(J,I)
          UVEC(J,I)=VTMP(I,J)
        ENDDO
      ENDDO
      DO I=1,ILTH
        CALL DSCAL(ILTH,EIG(I),VTMP(1,I),1)
      ENDDO
      CALL VCLR(VTMP2,1,L3)
      CALL MRARBR(VTMP,L1,ILTH,ILTH,UVEC,L1,ILTH,VTMP2,L1)
      CALL DCOPY(L3,VTMP2,1,VTMP,1)
C----------------------------------------------------------
C----------------------------------------------------------
      IF(IKIND.EQ.3) RETURN
      IF(IKIND.EQ.4) RETURN
C----------------------------------------------------------
C----------------------------------------------------------
C     FORM W * (WSW)**-1/2.
      DO I=1,ILTH
        DO J=1,ILTH
          TMP=WGT(I)
          VTMP(I,J)=TMP*VTMP(I,J)
        ENDDO
      ENDDO
C
      RETURN
 9003 FORMAT(//1X,'LOCAL_WEIGHTED_SYM_ORTHOG ERROR:',
     *        /1X,'YOU REQUESTED AN IKIND THAT DOES NOT EXIST.')
 9004 FORMAT(//1X,'LOCAL_WEIGHTED_SYM_ORTHOG ERROR:',
     *        /1X,'PROBLEM IN GLDIAG.')
 9005 FORMAT(//1X,'LOCAL_WEIGHTED_SYM_ORTHOG ERROR:',
     *        /1X,'SYMMETRIC ORTHOGONALIZATION',
     *         1X,'EVALUES ARE TOO SMALL.')
      END
C*MODULE LOCAL   *DECK LOCAL_IPOSEXT
C> @brief      Determines the max. num. of atomic ext. orbitals.
C>
C> @author     Aaron West
C>             -March 23, 2013
C>
C> @details    Determines the maximum number of atomic external
C>             orbitals.  This routine helps to avoid reseting
C>             idaf file sizes in this kind of run.
C>
C> @param IATSVD  holds the atom labels for all
C>                svd orbitals.
C> @param IPOSEXT indicates the orbital index for the first external
C>                orbital on a given atom in the 1st column.
C>                In the 2nd column, this integer array indicates
C>                the total number of external orbitals on a given atom.
C>                The orbitals are contiguous so that a L0*NAT array
C>                does not have to given at this time...
C> @param NAT     is the number of atoms.
C> @param L0MBS   is the dimension of the minimal basis set number of
C>                orbitals.
C>                L0MBS is derived from NCORTOT+LOCAL_NUMVAL.
C> @param L0             is the length of the MO variational space.
C> @param MAX_EXT_ORBS  will hold the max. size of the single
C>                       2s and ext. orbitals on an atom.
C> @param MASWRK       indicates the master process.
C> @param IW           indicates write out to the log file.
C>
      SUBROUTINE LOCAL_IPOSEXT(IATSVD,IPOSEXT,
     *                         NAT,L0MBS,L0,MAX_EXT_ORBS,
     *                         MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IERR,IOFF,IOFF2,IW,IMAX,I,J
      INTEGER MAX_EXT_ORBS,NAT,L0,L0MBS
      INTEGER IATSVD(L0)
      INTEGER IPOSEXT(NAT+1)
C
      IERR=0
      IMAX=0
      DO I=1,NAT
        IOFF=0
        IOFF2=0
        DO J=L0MBS+1,L0
          IF(IATSVD(J).EQ.I.AND.IOFF.EQ.0) IPOSEXT(I)=J
          IF(IATSVD(J).EQ.I) IOFF=IOFF+1
C-----------------------------------
C         SMALL CHECK ON INDEXING...
          IF(IOFF.GT.0.AND.IATSVD(J).NE.I) IOFF2=1
          IF(IOFF2.GT.0.AND.IATSVD(J).EQ.I) IERR=IERR+1
C-----------------------------------
        ENDDO
C       SAVE THE MAX VALUE ACROSS ALL ATOMS.
        IF(IOFF.GT.IMAX) IMAX=IOFF
      ENDDO
      IPOSEXT(NAT+1)=L0+1
C
C
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C
      MAX_EXT_ORBS=IMAX
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_MAXNACT ERROR:',
     *        /1X,'EXTERNAL ORBITAL ATOM LABELS ARE NOT',
     *         1X,'CONTIGUOUS FOR SOME REASON.',
     *        /1X,'INTEGER ARRAYS WERE SET UP FOR THAT...')
      END
C*MODULE LOCAL   *DECK LOCAL_ATOMIC_HSANDT
C> @brief      Calculate nuclear integrals on a single atom.
C>
C> @author     Aaron West
C>             -April 02, 2013
C>
C> @param H            will contain the nuclear attraction integrals
C>                     or atomic inverse radial expectation values
C>                     as chosen by ISVD_NUCINT and ISVD_ATOM with exit.
C> @param LL2          is the triangular dimesion of the 'working' NUM
C>                     from the INFOA.
C> @param ISVD_NUCINT  =1 gives original result from HSANDT
C>                      for the nuclear attraction integrals only
C>                      as summed over all atoms.
C>                     =2 gives the atomic radial expectation value
C>                      for the atomic orbitals relative to
C>                      atom ISVD_ATOM.
C>                     =3 uses the effective nuclear charge
C>                      for the atomic orbitals relative to
C>                      atom ISVD_ATOM.
C> @param ISVD_ATOM     is the atom used in evaluating the integral.
C> @param EFFCHSVD      is the effective nuclear charge.
      SUBROUTINE LOCAL_ATOMIC_HSANDT(
     *           H,LL2,ISVD_NUCINT,ISVD_ATOM,EFFCHSVD)
      IMPLICIT NONE
C-----------------------------------------------------------------------
      INTEGER NONE
      DOUBLE PRECISION :: RNONE
      DATA NONE,RNONE/4HNONE,8HNONE    /
C-----------------------------------------------------------------------
      LOGICAL DOUBLE2
      DOUBLE PRECISION ::
     *       AA,AA1,AAX,AAY,AAZ,AI,AJ,ARRI,AX,AXI,AY,
     *       AYI,AZ,AZI,CX,CY,CZ,DTWO,DUM,FAC,FACI,RR,
     *       SPDIJ,TT,UU,WW,ZNUC
      INTEGER ISVD_NUCINT,ISVD_ATOM
      INTEGER IG,JG,I,I1,I2,IC,IEND,IJ,IN,IPCOUNT,ISTART,J,J0,
     *        J1,J2,JGMAX,JN,JSTART,K,L1,L2,LI,LJ,LL2,
     *        LOCI,LOCIJ,LOCJ,MAX,MM,NATED,NATST,NERR,
     *        NN,NN1,NX,NY,NZ
      DOUBLE PRECISION :: EFFCHSVD
C-----------------------------------------------------------------------
      INTEGER MXSH,MXGTOT,MXATM,MAXSH
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000, MAXSH=84)
C-----------------------------------------------------------------------
C     VARS FOR COMMON BLOCKS NOW FOLLOW IN THE COMMON BLOCK ORDER.
C
      INTEGER NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
C
      INTEGER NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      DOUBLE PRECISION :: ZAN,C
C
      INTEGER IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA
C
      LOGICAL ISEPS,USEPS
C
      DOUBLE PRECISION :: EX,CS,CP,CD,
     *                    CF,CG,CH,CI
      INTEGER KSTART,KATOM,KTYPE,KNG,
     *        KLOC,KMIN,KMAX,NSHELL
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: XX,U,W
      INTEGER NROOTS
C
      LOGICAL SCREEN
      DOUBLE PRECISION :: VLAMB
C
      DOUBLE PRECISION :: PNRM
C
      DOUBLE PRECISION :: XINT,YINT,ZINT,TAA,X0,Y0,Z0,
     *                    XI,YI,ZI,XJ,YJ,ZJ
      INTEGER NI,NJ
C
      DOUBLE PRECISION :: TOL
      INTEGER II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ
      LOGICAL IANDJ
C
      DOUBLE PRECISION :: RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,TAU
      INTEGER IQRORD,MODQR,NESOC,NRATOM,NUMU,NQMTR,NQRDAF,MORDA,
     *        NDARELB
C
      DOUBLE PRECISION :: W1,W2,W3,W4,W5,W6,W7,
     *                    W8,W9,W10,
     *                    W11,W12,W13,W14,W15
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /ISEPS / ISEPS,USEPS
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /SCINP / VLAMB,SCREEN
      COMMON /SHLNRM/ PNRM(84)
      COMMON /STV   / XINT,YINT,ZINT,TAA,X0,Y0,Z0,
     *                XI,YI,ZI,XJ,YJ,ZJ,NI,NJ
      COMMON /SYMIND/ TOL,II,JJ,LIT,LJT,MINI,MINJ,MAXI,MAXJ,IANDJ
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,TAU,
     *                IQRORD,MODQR,NESOC,NRATOM,
     *                NUMU,NQMTR,NQRDAF,MORDA,NDARELB
C                          JUST THE 1ST ELEMENT IS USED, W/O /HERMIT/
      COMMON /WERMIT/ W1,W2(2),W3(3),W4(4),W5(5),W6(6),W7(7),
     *                W8(8),W9(9),W10(10),
     *                W11(11),W12(12),W13(13),W14(14),W15(15)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: ZERO,PT5,ONE,TWO,PI212,RLN10
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00, ONE=1.0D+00, TWO=2.0D+00,
     *           PI212=1.1283791670955D+00, RLN10=2.30258D+00)
C-----------------------------------------------------------------------
C     SOME ORIGINAL VARS GO HERE.
      DOUBLE PRECISION :: H(LL2),VBLK(784),DIJ(784),
     *                    XIN(343),YIN(343),ZIN(343),
     *                    CONI(MAXSH),CONJ(MAXSH)
      INTEGER IJX(784),IJY(784),IJZ(784),
     *        IX(84),IY(84),IZ(84),JX(84),JY(84),JZ(84)
C-----------------------------------------------------------------------
C
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     *          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,
     *          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,
     *          2, 0, 2, 1, 1,
     *          5, 0, 0, 4, 4, 1, 0, 1, 0, 3,
     *          3, 2, 0, 2, 0, 3, 1, 1, 2, 2,
     *          1,
     *          6, 0, 0, 5, 5, 1, 0, 1, 0, 4,
     *          4, 2, 0, 2, 0, 4, 1, 1, 3, 3,
     *          0, 3, 3, 2, 1, 2, 1, 2/
      DATA IX / 1, 8, 1, 1,15, 1, 1, 8, 8, 1,
     *         22, 1, 1,15,15, 8, 1, 8, 1, 8,
     *         29, 1, 1,22,22, 8, 1, 8, 1,15,
     *         15, 1,15, 8, 8,
     *         36, 1, 1,29,29, 8, 1, 8, 1,22,
     *         22,15, 1,15, 1,22, 8, 8,15,15,
     *          8,
     *         43, 1, 1,36,36, 8, 1, 8, 1,29,
     *         29,15, 1,15, 1,29, 8, 8,22,22,
     *          1,22,22,15, 8,15, 8,15/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     *          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,
     *          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,
     *          0, 2, 1, 2, 1,
     *          0, 5, 0, 1, 0, 4, 4, 0, 1, 2,
     *          0, 3, 3, 0, 2, 1, 3, 1, 2, 1,
     *          2,
     *          0, 6, 0, 1, 0, 5, 5, 0, 1, 2,
     *          0, 4, 4, 0, 2, 1, 4, 1, 3, 0,
     *          3, 2, 1, 3, 3, 1, 2, 2/
      DATA IY / 1, 1, 8, 1, 1,15, 1, 8, 1, 8,
     *          1,22, 1, 8, 1,15,15, 1, 8, 8,
     *          1,29, 1, 8, 1,22,22, 1, 8,15,
     *          1,15, 8,15, 8,
     *          1,36, 1, 8, 1,29,29, 1, 8,15,
     *          1,22,22, 1,15, 8,22, 8,15, 8,
     *         15,
     *          1,43, 1, 8, 1,36,36, 1, 8,15,
     *          1,29,29, 1,15, 8,29, 8,22, 1,
     *         22,15, 8,22,22, 8,15,15/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     *          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,
     *          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,
     *          2, 2, 1, 1, 2,
     *          0, 0, 5, 0, 1, 0, 1, 4, 4, 0,
     *          2, 0, 2, 3, 3, 1, 1, 3, 1, 2,
     *          2,
     *          0, 0, 6, 0, 1, 0, 1, 5, 5, 0,
     *          2, 0, 2, 4, 4, 1, 1, 4, 0, 3,
     *          3, 1, 2, 1, 2, 3, 3, 2/
      DATA IZ / 1, 1, 1, 8, 1, 1,15, 1, 8, 8,
     *          1, 1,22, 1, 8, 1, 8,15,15, 8,
     *          1, 1,29, 1, 8, 1, 8,22,22, 1,
     *         15,15, 8, 8,15,
     *          1, 1,36, 1, 8, 1, 8,29,29, 1,
     *         15, 1,15,22,22, 8, 8,22, 8,15,
     *         15,
     *          1, 1,43, 1, 8, 1, 8,36,36, 1,
     *         15, 1,15,29,29, 8, 8,29, 1,22,
     *         22, 8,15, 8,15,22,22,15/
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C     ----- COMPUTE CONVENTIONAL H, S, AND T INTEGRALS -----
C     NOTES:
C     --HSANDT ROUTINE WAS CHOPPED DOWN FOR THE
C       THE BARE NUCLEAR INTEGRALS...
C       BUT SOME UN-SUMMED VERSIONS OF THEM.
C     --INDENTED WAS NOT FIXED DURING CHOPPING.
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C
C     ----- SET TOLERANCE TOL -----
C
      TOL = RLN10*ITOL
C
C     NOTE THAT LL2 IS ALWAYS (NUM*NUM+NUM)/2,
C
      ISTART = 1
      IEND   = NSHELL
      JSTART = 1
      LOCIJ  = 0
      IF(ISVD_NUCINT.EQ.1) THEN
        NATST  = 1
        NATED  = NAT
      ELSEIF(ISVD_NUCINT.GE.2) THEN
        NATST=ISVD_ATOM
        NATED=ISVD_ATOM
      ELSE
      ENDIF
      L1 = NUM
      L2 = (L1*(L1+1))/2
C
C     ----- ERROR OUTS -----
C
      NERR=0
      IF(MPCTYP.NE.NONE) THEN
        IF (MASWRK) WRITE(IW,9010)
        NERR=NERR+1
      END IF
      IF(RMETHOD.NE.RNONE) THEN
        IF (MASWRK) WRITE(IW,9011)
        NERR=NERR+1
      END IF
      IF(LL2.NE.L2) THEN
        IF (MASWRK) WRITE(IW,9012)
        NERR=NERR+1
      END IF
      IF(NFG.NE.0) THEN
        IF (MASWRK) WRITE(IW,9013)
        NERR=NERR+1
      END IF
      IF(SCREEN) THEN
        IF (MASWRK) WRITE(IW,9014)
        NERR=NERR+1
      END IF
      IF(ISEPS) THEN
        IF (MASWRK) WRITE(IW,9015)
        NERR=NERR+1
      END IF
      IF(ISVD_NUCINT.LT.1.AND.ISVD_NUCINT.GT.3) THEN
        IF (MASWRK) WRITE(IW,9016)
        NERR=NERR+1
      ENDIF
      IF(ISVD_NUCINT.GE.2) THEN
      IF(ISVD_ATOM.LT.1.OR.ISVD_ATOM.GT.NAT) THEN
        IF (MASWRK) WRITE(IW,9017)
        NERR=NERR+1
      ENDIF
      ENDIF
      IF(ISVD_NUCINT.EQ.1) THEN
      IF(ISVD_ATOM.NE.0) THEN
        IF (MASWRK) WRITE(IW,9018)
        NERR=NERR+1
      ENDIF
      ENDIF
      IF(NERR.GT.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
C
C     DO WHEN PARALLEL OR NOT.
      CALL VCLR(H ,1,LL2)
C
C     ----- INTIALIZE PARALLEL -----
C
      IPCOUNT = ME - 1
C
C     ----- I SHELL -----
C
      DO 720 II = ISTART,IEND
         I = KATOM(II)
         XI = C(1,I)
         YI = C(2,I)
         ZI = C(3,I)
         I1 = KSTART(II)
         I2 = I1+KNG(II)-1
         LIT = KTYPE(II)
         MINI = KMIN(II)
         MAXI = KMAX(II)
         LOCI = KLOC(II)-MINI-LOCIJ
C
C     ----- J SHELL -----
C
         DO 700 JJ = JSTART,II
C
C     ----- GO PARALLEL! (STATIC LOAD BALANCING) -----
C
            IF (GOPARR) THEN
               IPCOUNT = IPCOUNT + 1
               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 700
            END IF
C
            J = KATOM(JJ)
            XJ = C(1,J)
            YJ = C(2,J)
            ZJ = C(3,J)
            J1 = KSTART(JJ)
            J2 = J1+KNG(JJ)-1
            LJT = KTYPE(JJ)
            MINJ = KMIN(JJ)
            MAXJ = KMAX(JJ)
            LOCJ = KLOC(JJ)-MINJ-LOCIJ
            NROOTS = (LIT+LJT-2)/2+1
            RR = (XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
            IANDJ = II .EQ. JJ
C
C
C     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS
C
            IJ = 0
            MAX = MAXJ
            DO 160 I = MINI,MAXI
               NX = IX(I)
               NY = IY(I)
               NZ = IZ(I)
               IF (IANDJ) MAX = I
               DO 140 J = MINJ,MAX
                  IJ = IJ+1
                  IJX(IJ) = NX+JX(J)
                  IJY(IJ) = NY+JY(J)
                  IJZ(IJ) = NZ+JZ(J)
  140          CONTINUE
  160       CONTINUE
C
            CALL VCLR( VBLK,1,IJ)
C
C     ----- I PRIMITIVE
C
            JGMAX = J2
            DO 520 IG = I1,I2
               AI = EX(IG)
               ARRI = AI*RR
               AXI = AI*XI
               AYI = AI*YI
               AZI = AI*ZI
               CALL SETCONI(CONI,IG,0)
C
C     ----- J PRIMITIVE
C
               IF (IANDJ) JGMAX = IG
               DO 500 JG = J1,JGMAX
                  AJ = EX(JG)
                  AA = AI+AJ
                  AA1 = ONE/AA
                  DUM = AJ*ARRI*AA1
                  IF (DUM .GT. TOL) GO TO 500
                  FAC = EXP(-DUM)
                  CALL SETCONI(CONJ,JG,0)
                  AX = (AXI+AJ*XJ)*AA1
                  AY = (AYI+AJ*YJ)*AA1
                  AZ = (AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
C     THE ONLY REASON WHY -ILZ WORKS WITH THIS DENSITY THAT ASSUMES
C     HERMITICITY IS BECAUSE <I|-ILZ|I>=0 (MOMENTUM QUENCHING).
C
                  DOUBLE2=IANDJ.AND.IG.NE.JG
                  MAX = MAXJ
                  NN = 0
                  DTWO=ONE
                  IF(DOUBLE2) DTWO=TWO
C                 NOTE THAT PNRM FACTORS FOR S AND P SHELLS ARE 1.
                  SPDIJ=CS(IG)*CP(JG)*FAC
                  DO 220 I = MINI,MAXI
                     IF (IANDJ) MAX = I
                     FACI=FAC*CONI(I)*PNRM(I)*DTWO
                     NN1=NN+1
                     DO 200 J = MINJ,MAX
                        NN = NN+1
                        DIJ(NN)=FACI*CONJ(J)*PNRM(J)
C                    WRITE(6,*) 'WWWDIJ',NN,I,J,II,JJ,DIJ(NN)
  200                CONTINUE
C            CORRECT FOR L-SHELL DOUBLE COUNTING OF THE SP
C            OFF-DIAGONAL TERMS (FOR NON-L SHELLS CSI*CPJ IS ZERO).
C            NN1 POINTS TO THE APPROPRIATE DENSITY ELEMENT
                     IF(MINJ.LE.1.AND.I.GT.1.AND.DOUBLE2)
     *                 DIJ(NN1)=DIJ(NN1)*PT5+SPDIJ
  220             CONTINUE
C
C     ----- NUCLEAR ATTRACTION -----
C
                     DUM = PI212*AA1
                     DO 400 I = 1,IJ
                        DIJ(I) = DIJ(I)*DUM
  400                CONTINUE
C
                  AAX = AA*AX
                  AAY = AA*AY
                  AAZ = AA*AZ
C
                  AAX = AA*AX
                  AAY = AA*AY
                  AAZ = AA*AZ
                  DO 460 IC = NATST,NATED
                     ZNUC=1.0D+00
                     IF(ISVD_NUCINT.EQ.1) ZNUC = -ZAN(IC)
C                    DO NOTHING FOR ISVD_NUCINT==2.
                     IF(ISVD_NUCINT.EQ.3) ZNUC = -EFFCHSVD
C
                     CX = C(1,IC)
                     CY = C(2,IC)
                     CZ = C(3,IC)
C
                     XX = AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
                     IF (NROOTS.LE.3) CALL RT123
                     IF (NROOTS.EQ.4) CALL ROOT4
                     IF (NROOTS.EQ.5) CALL ROOT5
                     IF (NROOTS.GE.6) CALL ROOT6
                     MM = 0
                     DO 430 K = 1,NROOTS
                        UU = AA*U(K)
                        WW = W(K)*ZNUC
                        TT = ONE/(AA+UU)
                        TAA = SQRT(TT)
                        X0 = (AAX+UU*CX)*TT
                        Y0 = (AAY+UU*CY)*TT
                        Z0 = (AAZ+UU*CZ)*TT
                        IN = -7+MM
                        J0 = 2
C
C                       J0 SKIPS THE TRIVIAL COMBINATION NI=NJ=1
C                       THAT IS DONE EXPLICITLY NOW
C
                        XIN(IN+8) = W1
                        YIN(IN+8) = W1
                        ZIN(IN+8) = W1*WW
                        DO 420 I = 1,LIT
                           IN = IN+7
                           NI = I
                           DO 410 J = J0,LJT
                              JN = IN+J
                              NJ = J
                              CALL STVINT
                              XIN(JN) = XINT
                              YIN(JN) = YINT
                              ZIN(JN) = ZINT*WW
  410                      CONTINUE
                           J0 = 1
  420                   CONTINUE
                        MM = MM+49
  430                CONTINUE
                     DO 450 I = 1,IJ
                        NX = IJX(I)
                        NY = IJY(I)
                        NZ = IJZ(I)
                        DUM = ZERO
                        MM = 0
                        DO 440 K = 1,NROOTS
                           DUM = DUM+XIN(NX+MM)*YIN(NY+MM)*ZIN(NZ+MM)
                           MM = MM+49
  440                   CONTINUE
                        VBLK(I) = VBLK(I) + DUM*DIJ(I)
  450                CONTINUE
C
  460              CONTINUE
C
C     ----- END OF PRIMITIVE LOOPS -----
C
  500          CONTINUE
  520       CONTINUE
C
C     ----- SET BLOCK OF NUCLEAR ATTRACTION
C
            MAX = MAXJ
            NN = 0
            DO 620 I = MINI,MAXI
               LI = LOCI+I
               IN = (LI*(LI-1))/2
               IF (IANDJ) MAX = I
               DO 600 J = MINJ,MAX
                  LJ = LOCJ+J
                  JN = LJ+IN
                  NN = NN+1
                  H(JN) =  VBLK(NN)
  600          CONTINUE
  620       CONTINUE
C
C     ----- END OF SHELL LOOPS -----
C
  700    CONTINUE
  720 CONTINUE
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C
      IF (GOPARR) THEN
         CALL DDI_GSUMF(910,H,L2)
      END IF
C
C     ----- H MATRIX IS NOW COMPLETE AND RETURNED.
C



      RETURN
 9010 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT IS NOT PROGRAMMED FOR MCPS.')
 9011 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'IS NOT PROGRAMMED FOR RELATIVITY.')
 9012 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT IS NOT PROGRAMMED FOR',
     *        1X,'LL2 NE L2 CONDITIONS.')
 9013 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT IS NOT PROGRAMMED FOR FMO.')
 9014 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'IS NOT PROGRAMMED FOR SCREEN=.TRUE.')
 9015 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'IS NOT PROGRAMMED FOR ISEPS=.TRUE.')
 9016 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT MUST HAVE ISVD_NUCINT=1,2,3.')
 9017 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT HAS ISVD_ATOM OUT OF RANGE.')
 9018 FORMAT(/1X,'LOCAL_ATOMIC_HSANDT',
     *        1X,'HAS ISVD_ATOM NE 0 FOR ISVD_NUCINT.',
     *       /1X,'ISVD_ATOM HAS USE HERE... AND SHOULD BE 0.')
      END
C*MODULE LOCAL   *DECK LOCAL_GET_IEXTORB
C> @brief      Returns the num. of externals on atom.
C>
C> @author     Aaron West
C>             -May 07, 2013
C>
C> @details    This number might already be calculated in
C>             more complex routines or NOT...
C>
C> @param IEXTORB is returned as the total number of external
C>                orbitals on a given atom.
C> @param IEXTBEG gives the starting orbital number for externals
C>                on a given atom.
C> @param IEXTEND gives the ending orbital number for externals
C>                on a given atom.
C> @param IPOSEXT indicates the orbital index for the first external
C>                orbital on a given atom in the 1st column.
C>                In the 2nd column, this integer array indicates
C>                the total number of external orbitals on a given atom.
C>                The orbitals are contiguous so that a L0*NAT array
C>                does not have to given at this time...
C> @param IATM1   is the current atom in the do loop.
C> @param NAT     is the number of atoms.
C> @param L0      is the length of the MO variational space.
C> @param L0MBS   is the number of core+val minimal basis orbitals.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to the log file.
      SUBROUTINE LOCAL_GET_IEXTORB(
     *           IEXTORB,IEXTBEG,IEXTEND,
     *           IPOSEXT,IATM1,NAT,L0,L0MBS,MASWRK,IW)
C
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER NAT,IW,IEXTORB,IEXTBEG,IEXTEND,
     *        IERR,IATM1,L0,L0MBS,IPOSEXT(NAT+1)
C
      IEXTORB=IPOSEXT(IATM1+1)-IPOSEXT(IATM1)
      IEXTBEG=IPOSEXT(IATM1)
      IEXTEND=IPOSEXT(IATM1+1)-1
C
      IERR=0
      IF(IEXTORB.LE.0) THEN
        IF(MASWRK) WRITE(IW,9001)
        IERR=IERR+1
      ENDIF
      IF(IEXTORB.GT.L0) THEN
        IF(MASWRK) WRITE(IW,9002)
        IERR=IERR+1
      ENDIF
      IF(IEXTBEG.LE.L0MBS
     *   .OR.IEXTBEG.GT.L0
     *   .OR.IEXTEND.LE.L0MBS
     *   .OR.IEXTEND.GT.L0) THEN
        IF(MASWRK) WRITE(IW,9003)
        IERR=IERR+1
      ENDIF
      IF(IERR.NE.0) THEN
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9001 FORMAT(//1X,'LOCAL_IPOSEXT ERROR:',
     *        /1X,'IEXTORB CANNOT BE LESS THAN 0.')
 9002 FORMAT(//1X,'LOCAL_IPOSEXT ERROR:',
     *        /1X,'IEXTORB CANNOT BE GREATER THAN L0.')
 9003 FORMAT(//1X,'LOCAL_IPOSEXT ERROR:',
     *        /1X,'PROBLEM WITH IEXTBEG OR IEXTEND.')
      END
C*MODULE LOCAL   *DECK LOCAL_SORT_EVALS
C> @brief      Generally forms reorder array using doub.prec. array.
C>
C> @author     Aaron West
C>             -May 07, 2013
C>
C> @details    This routine generally forms an array
C>             with integer reordering instructions.
C>             The use of IDAMAX has a few limitations:
C>             1.  It only works with positive values.
C>             2.  Under specific conditions, shifting
C>                 can lead to some buggy code.
C>             In the atomic loc. code, we often need
C>             flexible indices in the arrays.
C>             This routine is similar to JACORD, but
C>             here we track and form an integer
C>             reordering array.
C>
C> @param OPTINIT  =TRUE initializes the IPOSNOS.
C>                 Otherwise, IPOSNOS might already be initialized in a
C>                 very specific way.
C> @param IOPT     =1 orders values from large to small.
C>                 =2 orders values from small to large.
C>                 =3 orders values from large to small by magnitude.
C>                 =4 orders values from small to large by magnitude.
C> @param LDIM     is the dimension.
C> @param IPOSNOS  is the integer sorting array.
C> @param EIG      contains the values that are used in the
C>                 sorting e.g. eigenvalues.
      SUBROUTINE LOCAL_SORT_EVALS(
     *           OPTINIT,IOPT,LDIM,IPOSNOS,EIG)
      IMPLICIT NONE
      LOGICAL OPTINIT
      INTEGER IOPT,LDIM,IPOSNOS(LDIM)
      DOUBLE PRECISION :: EIG(LDIM)
      INTEGER IDUM,I,J,ITMP
      DOUBLE PRECISION :: TMP
C
      IF(OPTINIT) THEN
        DO I=1,LDIM
          IPOSNOS(I)=I
        ENDDO
      ENDIF
C
      DO I=1,LDIM
        IDUM=I
        DO J=I+1,LDIM
          IF(IOPT.EQ.1.AND.EIG(J).GT.EIG(IDUM)) IDUM=J
          IF(IOPT.EQ.2.AND.EIG(J).LT.EIG(IDUM)) IDUM=J
          IF(IOPT.EQ.3.AND.ABS(EIG(J)).GT.ABS(EIG(IDUM))) IDUM=J
          IF(IOPT.EQ.4.AND.ABS(EIG(J)).LT.ABS(EIG(IDUM))) IDUM=J
        ENDDO
C
        TMP=EIG(IDUM)
        EIG(IDUM)=EIG(I)
        EIG(I)=TMP
C
        ITMP=IPOSNOS(IDUM)
        IPOSNOS(IDUM)=IPOSNOS(I)
        IPOSNOS(I)=ITMP
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_SORT_INTS
C> @brief      Generally forms reorder array using integer array.
C>
C> @author     Aaron West
C>             -May 25, 2015
C>
C> @param OPTINIT  =TRUE initializes the IPOS.
C>                 Otherwise, IPOS might already be initialized in a
C>                 very specific way.
C> @param IOPT     =1 orders values from large to small.
C>                 =2 orders values from small to large.
C>                 =3 orders values from large to small by magnitude.
C>                 =4 orders values from small to large by magnitude.
C> @param LDIM     is the dimension.
C> @param IPOS     is the integer sorting array.
C> @param ILAB     contains the values that are used in the sorting.
      SUBROUTINE LOCAL_SORT_INTS(
     *           OPTINIT,IOPT,LDIM,IPOS,ILAB)
      IMPLICIT NONE
      LOGICAL OPTINIT
      INTEGER IOPT,LDIM,IPOS(LDIM),ILAB(LDIM)
      INTEGER IDUM,I,J,ITMP
C
      IF(OPTINIT) THEN
        DO I=1,LDIM
          IPOS(I)=I
        ENDDO
      ENDIF
C
      DO I=1,LDIM
        IDUM=I
        DO J=I+1,LDIM
          IF(IOPT.EQ.1.AND.ILAB(J).GT.ILAB(IDUM)) IDUM=J
          IF(IOPT.EQ.2.AND.ILAB(J).LT.ILAB(IDUM)) IDUM=J
          IF(IOPT.EQ.3.AND.IABS(ILAB(J)).GT.IABS(ILAB(IDUM))) IDUM=J
          IF(IOPT.EQ.4.AND.IABS(ILAB(J)).LT.IABS(ILAB(IDUM))) IDUM=J
        ENDDO
C
        ITMP=ILAB(IDUM)
        ILAB(IDUM)=ILAB(I)
        ILAB(I)=ITMP
C
        ITMP=IPOS(IDUM)
        IPOS(IDUM)=IPOS(I)
        IPOS(I)=ITMP
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_ACAVO
C> @brief      Calculate (s2**2)*i,j 2 el matrices for local nos.
C>
C> @author     Aaron West and Mike Schmidt
C>             -May 07, 2013
C>
C> @details    Right now, only exchange matrices are calculated.
C>             THIS ROUTINE IS BASED ON MIKE SCHMIDT'S AVACO ROUTINE.
C>             THIS ROUTINE IS AN EXTREMELY SPECIALIZED VERSION OF
C>             THE AVACO ROUTINE.
C>             PLEASE SEE AVACO ROUTINE FOR ADDITIONAL NOTES.
C>
C> @param VEC     contains the atomic-like orbitals for a given atom.
C> @param DCORE   is scratch of length L2.
C> @param DVAL    contains the needed AO density of length L2 on entry.
C> @param JCORE   is scratch of length L2.
C> @param JVAL    is scratch of length L2.
C> @param KCORE   is scratch of length L2.
C> @param KVAL    is scratch of length L2.
C> @param SCR     is scratch of length L1*8.
C> @param BUFFX   is scratch of length NINTMX.
C> @param BUFFI   is scratch of length NINTMX.
C> @param NOPK    indicates supermatrix form or not for
C>                the AO integrals.
C> @param NINTMX  should be NTINMX from intfil common.
C> @param L1      is the length of the AO coefficients.
C> @param L2      is the triangular length of L1.
C> @param NVAL    is the number of valence orbitals on a given atom.
C> @param IEXTORB is number of external orbitals on given atom.
      SUBROUTINE LOCAL_NOS_ACAVO(
     *           VEC,DCORE,DVAL,
     *           JCORE,JVAL,KCORE,KVAL,
     *           SCR,BUFFX,BUFFI,
     *           NOPK,NINTMX,L1,L2,
     *           NVAL,IEXTORB)
C
      IMPLICIT NONE
C-----------------------------------------------------------------------
      INTEGER L1,L2
      DOUBLE PRECISION :: FJC,FJV,FKC,FKV
      INTEGER NINTMX,NOPK,NVAL,IEXTORB
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: JCORE(L2),JVAL(L2),KCORE(L2),KVAL(L2)
      DOUBLE PRECISION :: PACAVO(6)
      DOUBLE PRECISION :: DCORE(L2),DVAL(L2),VEC(L1,L1),
     *                    SCR(L1,8),BUFFX(NINTMX),
     *                    BUFFI(NINTMX)
C-----------------------------------------------------------------------
C
      INTEGER IA
C
      INTEGER IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
C-----------------------------------------------------------------------
      INTEGER MXAO
      PARAMETER (MXAO=8192)
C-----------------------------------------------------------------------
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C-----------------------------------------------------------------------
C
C     ----- CONSTRUCT GENERAL CORRELATION ADAPTED VIRTUAL ORBITALS -----
C     THIS ROUTINE IS A VERY SPECIALIZED VERSION OF THE ORIGINAL ROUTINE.
C     PLEASE SEE AVACO ROUTINE FOR ADDITIONAL NOTES.
C
C----------------------
C     4-->columb terms
C     6-->exchange terms
C      -->put to 1 rather than -1 for convenience
C         when only non-zero term is term 6.
      PACAVO(1)=0.0D+00
      PACAVO(2)=0.0D+00
      PACAVO(3)=0.0D+00
      PACAVO(4)=0.0D+00
      PACAVO(5)=0.0D+00
      PACAVO(6)=1.0D+00
C----------------------
      IF (MASWRK) WRITE(IW,9000) IEXTORB,NVAL,PACAVO
C
C         VALENCE DENSITY IS ALREADY BUILT AND FED IN.
C         CORE DENSITY IS ZERO.
C
      CALL VCLR(DCORE,1,L2)
C
C         MAKE CORE AND VALENCE COULOMB AND EXCHANGE OPERATORS.
C         THIS IS CODED FOR INTEGRALS ON DISK ONLY, AT PRESENT.
C
      IF(NOPK.NE.1) THEN
         IF(MASWRK) WRITE(IW,9010)
         CALL ABRT
      END IF
      CALL SEQREW(IJK)
      CALL HSTARJK(DCORE,DVAL,JCORE,JVAL,KCORE,KVAL,
     *             BUFFX,BUFFI,NINTMX,IA,NOPK,L1,L2)
C
C         CONSTRUCT THE OPERATOR IN THE AO BASIS IN -DCORE-,
C         USING MATRIX -DVAL- AS SCRATCH STORAGE.
C
cccccc      FT  = PACAVO(1)
cccccc      FV  = PACAVO(2)
      FJC = PACAVO(3)
      FJV = PACAVO(4)
      FKC = PACAVO(5)
      FKV = PACAVO(6)
C
      CALL VCLR(DCORE,1,L2)
cccccc      CALL DAREAD(IDAF,IODA,DVAL ,L2,11,0)
cccccc      CALL DAREAD(IDAF,IODA,DCORE,L2,13,0)
cccccc      CALL VSUB(DCORE,1,DVAL,1,DVAL,1,L2)
cccccc
cccccc      CALL DSCAL(L2,FT ,        DCORE,1)
cccccc      CALL DAXPY(L2,FV ,DVAL ,1,DCORE,1)
      CALL DAXPY(L2,FJC,JCORE,1,DCORE,1)
      CALL DAXPY(L2,FJV,JVAL ,1,DCORE,1)
      CALL DAXPY(L2,FKC,KCORE,1,DCORE,1)
      CALL DAXPY(L2,FKV,KVAL ,1,DCORE,1)

C
C     ----- TRANSFORM INTO MO BASIS -----
C
C     NOTE:  DO NOT SHIFT LIKE THE ORIG. ROUTINE.
      CALL VCLR(DVAL,1,L2)
      CALL TFTRI(DVAL,DCORE,VEC,SCR,IEXTORB,L1,L1)
C
      RETURN
C
 9000 FORMAT(/1X,'LOCAL_NOS_ACAVO:',
     *       /1X,'GENERATING',I5,' GENERAL CORRELATION ADAPTED',
     *        1X,'VIRTUAL ORBITALS...'/
     *        1X,'THERE ARE',I5,' FROZEN VALENCE ORBITALS'/
     *        1X,'ACAVO PARAMETERS=',6F10.5)
 9010 FORMAT(1X,'LOCAL_NOS_ACAVO:',
     *      /1X,'CANNOT FORM J,K MATRICES USING SUPERMATRIX INTEGRALS'/
     *       1X,'PLEASE RESUBMIT WITH NOPK=1')
      END
C*MODULE LOCAL   *DECK LOCAL_GRAB_BASIS_FXNS_ON_ATOM
C> @brief      Grabs out AO overlaps on a given atom.
C>
C> @author     Aaron West
C>             -May 19, 2013
C>
C> @details    AO overlaps on a given atom are grabbed out of
C>             the general AO overlap matrix and placed
C>             starting at index 1 in a symmetric matrix.
C>
C> @param LIMLOW  array contains the lower basis function on an atom.
C> @param LIMSUP  array contains the upper basis function on an atom.
C> @param IATM1   is the current atom.
C> @param NAT     is the number of atoms.
C> @param L2      is the triangular length of the number of
C>                basis functions, which is typically L1=NUM.
C> @param S2      S2 holds the AO overlaps for IATM1 on exit.
C> @param S       holds the AO overlap matrix for all atoms on entry.
C> @param IBAS1   equals the starting index of the first AO
C>                on current atom IATM1.
C> @param IBAS2   equals the ending index of the last AO
C>                on current atom IATM1.
C> @param ILTH    equals the total number of basis functions
C>                on current atom IATM1.
C> @param IBASSPH1   equals the starting index of the first AO
C>                on current atom IATM1.
C> @param IBASSPH2   equals the ending index of the last AO
C>                on current atom IATM1.
C> @param ILTHSPH    equals the total number of basis functions
C>                on current atom IATM1.
C> @param COMBOSPHER indicates if using sphericals.
      SUBROUTINE LOCAL_GRAB_BASIS_FXNS_ON_ATOM(
     *           LIMLOW,LIMSUP,IATM1,NAT,L2,
     *           S2,S,
     *           IBAS1,IBAS2,ILTH,
     *           IBASSPH1,IBASSPH2,ILTHSPH,
     *           COMBOSPHER)
      IMPLICIT NONE
      LOGICAL COMBOSPHER
      INTEGER IATM1,NAT,L2
      INTEGER LIMLOW(NAT),LIMSUP(NAT)
      DOUBLE PRECISION :: S(L2),S2(L2)
C
      INTEGER IBAS1,IBAS2,ILTH,IBASSPH1,IBASSPH2,ILTHSPH,
     *        NAOCART,NAOSPH,IFIND1,IFIND2,
     *        I,J,IJ,IJ2
C
      IBAS1=LIMLOW(IATM1)
      IBAS2=LIMSUP(IATM1)
      ILTH=IBAS2-IBAS1+1
      IBASSPH1=0
      DO I=1,IATM1-1
        CALL LOCAL_COUNTAOS(I,NAOCART,NAOSPH)
        IBASSPH1=IBASSPH1+NAOSPH
      ENDDO
      IBASSPH1=IBASSPH1+1
      I=IATM1
      CALL LOCAL_COUNTAOS(I,NAOCART,NAOSPH)
      IBASSPH2=IBASSPH1-1+NAOSPH
      ILTHSPH=IBASSPH2-IBASSPH1+1
C
C     ASSIGN PROPER LIMITS FOR GRABBING OUT BASIS
      IFIND1=IBAS1
      IFIND2=IBAS2
      IF(COMBOSPHER) THEN
        IFIND1=IBASSPH1
        IFIND2=IBASSPH2
      ENDIF
C
C     GRAB OUT CORRECT BASIS FUNCTIONS.
      CALL VCLR(S2,1,L2)
      IJ2=1
      DO I=IFIND1,IFIND2
        DO J=IFIND1,I
          IJ=(I*I-I)/2 + J
          S2(IJ2)=S(IJ)
          IJ2=IJ2+1
        ENDDO
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_WSO_PREP
C> @brief      Forms relative weights for weighted sym. orthog.
C>
C> @author     Aaron West
C>             -May 24, 2013
C>
C> @details    Routine scales the true weights from 1 to 100.
C>             This scaling preserves the difference in weightings
C>             and avoids issues with orbital orthonormality.
C>
C> @param WGT      array contains the true weights on entry.
C>                 On exit, this array contains the scaled weights.
C> @param ILTH     is the number of weights.
C> @param ATWGT    is a logical that chooses a different relative
C>                 weight.  It is appropriate when this call
C>                 is placed in a loop over atoms and creates
C>                 comparative weights between atoms.
C>                 The weight range for this option is 0 to 1
C>                 rather than 1 to 100.
C> @param SOME   is true for master process with nprint not equal -5.
C> @param IW       indicates write out to the log file.
      SUBROUTINE LOCAL_WSO_PREP(
     *           WGT,ILTH,ATWGT,SOME,IW)
      IMPLICIT NONE
      LOGICAL ATWGT,SOME
C
      INTEGER ILTH,I,IW
      DOUBLE PRECISION :: WGT(ILTH)
      DOUBLE PRECISION :: TMP,WMIN,WMAX,RATIO,RATIOSV,
     *                    ONE,WSPREAD,POWER,BBB
      PARAMETER (ONE=1.0D+00)
      PARAMETER (WSPREAD=99.0D+00,POWER=3.00D+00,BBB=70.0D+00)
C
C     FIND THE BIGGEST AND SMALLEST WEIGHTS.
      TMP=ABS(WGT(1))
      WMIN=TMP
      WMAX=TMP
      DO I=1,ILTH
        TMP=ABS(WGT(I))
        IF(TMP.LT.WMIN) WMIN=TMP
        IF(TMP.GT.WMAX) WMAX=TMP
      ENDDO
C
C     FOR CASES WHERE WMIN,WMAX AS ESSENTIALLY THE SAME,
C     SKIP OVER NUMERICAL ISSUES.
      TMP=WMAX-WMIN
      IF(TMP.LT.1.0D-10.AND.ILTH.GT.1) THEN
        DO I=1,ILTH
          WGT(I)=1.0D+00
        ENDDO
        GO TO 777 ! avoid the division by zero right below here.
      ENDIF
C----------------------------------------------------------------
CORIG      RATIO=1.0D+00
CORIG      DO I=1,ILTH
CORIG        IF(ILTH.GT.1) RATIO=(WGT(I)-WMIN)/(WMAX-WMIN)
CORIG        RATIOSV=RATIO
CORIG        RATIO=RATIO**POWER
CORIG        RATIO=(ONE+BBB)*RATIO/(ONE+BBB*RATIO)
CORIG        WGT(I)=ONE + WSPREAD*RATIO
CORIG        IF(ATWGT) WGT(I)=RATIOSV
CORIG      ENDDO
      RATIO=1.0D+00
      DO I=1,ILTH
        RATIO=WGT(I)/WMAX
        RATIOSV=RATIO
        RATIO=RATIO**POWER
        RATIO=(ONE+BBB)*RATIO/(ONE+BBB*RATIO)
        WGT(I)=ONE + WSPREAD*RATIO
        IF(ATWGT) WGT(I)=RATIOSV
      ENDDO
C
C----------------------------------------------------------------
  777 CONTINUE
C
C     PRINT OFF THE NEW RELATIVE WEIGHTS.
      IF(SOME) THEN
        WRITE(IW,9003)
        DO I=1,ILTH
          WRITE(IW,9004) I,WGT(I)
        ENDDO
      ENDIF
C
      RETURN
 9003 FORMAT(//1X,'LOCAL_WSO_PREP OBTAINS THE RELATIVE WEIGHTS.')
 9004 FORMAT(1X,'ORBITAL',I5,' HAS WSO WEIGHT = ',F12.7)
      END
C*MODULE LOCAL   *DECK LOCAL_RESIZE_DEN
C> @brief      Forms any mini-density matrix.
C>
C> @author     Aaron West
C>             -June 15, 2013
C>
C> @see LOCAL_CPSYM
C>
C> @details    Given reordering instructions, the routine
C>             put any combination of the original density
C>             matrix into a reduced-size density matrix.
C>
C> @param DENOLD  is the original density matrix.
C> @param DENNEW  is the reduced  density matrix.
C> @param IWRK    contains the reordering instructions.
C> @param M1      is the number of active orbitals.
C> @param M2      is the triangular size of M1 and the dimension
C>                of the original density matrix.
C> @param ISIZ    is the size of the reduced density matrix.
      SUBROUTINE LOCAL_RESIZE_DEN(DENOLD,DENNEW,IWRK,M1,M2,ISIZ)
      IMPLICIT NONE
      INTEGER M1,M2,IWRK(M1),
     *        ISIZ,IJ,I2,J2,IJ2,
     *        LTPOS
      DOUBLE PRECISION :: DENOLD(M2),DENNEW(M2)
C
      CALL VCLR(DENNEW,1,M2)
C
      DO I2=1,ISIZ
         DO J2=1,I2
            IJ2=LTPOS(I2,J2)
            IJ=LTPOS(IWRK(I2),IWRK(J2))
            DENNEW(IJ2)=DENOLD(IJ)
         ENDDO
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_CHECK_PHASES
C> @brief      Checks phases of orbitals against density.
C>
C> @author     Aaron West and Mike Schmidt
C>             -August 27, 2014
C>
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param NCORTOT  is the number of chemical core orbitals.
C> @param M1       is the number of valence orbitals.
C> @param M2       is the triangular length of M1.
C> @param CLMO     is the L1xL0 orbitals for this density matrix.
C> @param DEN      holds density matrix for the CLMO valence orbitals.
C> @param DENKE    is scratch space of size L2.
C> @param STRI     is scratch space of size L2.
C> @param WRKTRI   is scratch space of size L2.
C> @param WRK      is scratch space of size L1.
C> @param SOME     is true for master process with nprint not equal -5.
C> @param MASWRK  indicates the master process.
      SUBROUTINE LOCAL_CHECK_PHASES(
     *           L1,L2,NCORTOT,M1,M2,
     *           CLMO,DEN,DENKE,STRI,WRKTRI,WRK,
     *           SOME,MASWRK)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER L1,L2,NCORTOT,M1,M2
      DOUBLE PRECISION ::
     *       CLMO(L1,L1),DEN(M2),DENKE(L2),STRI(L2),WRKTRI(L2),WRK(L1)
C------------------------------------------------------------------
      INTEGER NOCC,I,J,IJ,IJV,
     *        LTPOS
      DOUBLE PRECISION ::
     *       TMP,SAV,
     *       RNONE,
     *       ZERO,TWO,TOL
      PARAMETER (ZERO=0.0D+00,TWO=2.0D+00,TOL=5.0D-06)
C------------------------------------------------------------------
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C------------------------------------------------------------------
      DATA RNONE/8HNONE    /
C------------------------------------------------------------------
C
C     EXITS FOR INAPPROP.
      IF(ILOCAL.EQ.4.AND.CCTYP.NE.RNONE) RETURN
C
C     PRINT OFF BANNER.
      IF(SOME) WRITE(IW,9000)
C
C     MAKE NOCC.
      NOCC=NCORTOT+M1
C
C     CONSTRUCT CORE+VAL DENSITY.
      CALL VCLR(DENKE,1,L2)
      DO I=1,NCORTOT
        IJ=LTPOS(I,I)
        DENKE(IJ)=TWO
      ENDDO
      DO I=1,M1
        DO J=1,I
          IJ=LTPOS(I,J)
          IJV=LTPOS(NCORTOT+I,NCORTOT+J)
          DENKE(IJV)=DEN(IJ)
        ENDDO
      ENDDO
C
C     FIND DENSITY IN THE AO BASIS
      CALL VCLR(STRI,1,L2)
      CALL TRPOSQ(CLMO,L1)
      CALL TFTRI(STRI,DENKE,CLMO,WRK,
     *           L1,NOCC,L1)
      CALL TRPOSQ(CLMO,L1)
C
C     COMPARE DENSITY TO DENSITY ON DAF16,20.
      CALL DENDD1(DENKE,WRKTRI,L2)
      CALL VSUB(DENKE,1,STRI,1,STRI,1,L2)
      SAV=ZERO
      DO I=1,L2
        TMP=ABS(STRI(I))
        IF(TMP.GT.SAV) SAV=TMP
      ENDDO
      IF(SAV.GT.TOL) THEN
        IF(MASWRK) WRITE(IW,9100) SAV
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      CALL VCLR(STRI,1,L2)
      CALL VCLR(DENKE,1,L2)
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_PHASE_CHECK:',
     *         1X,'CHECKING PHASES OF DENSITY AND ORBITALS.')
 9100 FORMAT(/1X,'LOCAL_CHECK_PHASES ERROR',
     *       /1X,'THE DENSITY AND LCAO HAVE A PHASE ISSUE.',
     *       /1X,'LARGEST DIFFERENCE =',F20.10,
     *       /1X,'IF THIS FAILS, TRY TIGHTENING CONV IN THE SCF GROUP.')
      END
C*MODULE LOCAL   *DECK LOCAL_PRINTDEN
C> @brief      Form KBOs and extra print statements.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -July 03, 2013
C>
C> @param L1      is the length of the AO coefficients.
C> @param L2      is the triangular length of the number of
C>                basis functions, which is typically L1=NUM.
C> @param M1      denotes the number of orbitals that make up
C>                 the density matrix.
C> @param M2      is the triangular length of M1.
C> @param NOUTA   denotes the number of frozen orbitals
C>                in the localization on entry.
C> @param NUMLOC  equals number of core+valence orbitals right now.
C> @param NUMLOC2 equals triangular length of NUMLOC.
C> @param STRI    is the kinetic energy matrix over the MOs
C>                on entry.
C> @param DENKE   will hold bond order times KE integrals on exit.
C> @param DEN     is the density matrix of M2 length on entry.
C> @param CLMO    are the L1xL0 orbitals for this density matrix.
C> @param WRK     is a scratch array of L1 length.
C> @param SOME    is true for master process with nprint not equal -5.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_PRINTDEN(
     *           L1,L2,M1,M2,NOUTA,NUMLOC,NUMLOC2,
     *           STRI,DENKE,DEN,CLMO,WRK,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER L1,L2,M1,M2,NOUTA,NUMLOC,NUMLOC2,IW
      DOUBLE PRECISION :: STRI(L2),DENKE(NUMLOC2),DEN(M2),
     *                    CLMO(L1,L1),WRK(L1)
C------------------------------------------------------------------
      LOGICAL NOSKIP
      INTEGER I,J,IJ,IJV,LTPOS
      DOUBLE PRECISION :: TOTKE,TMP,
     *                    ZERO,ONE,TWO,TOL
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00,TOL=1.0D-08)
C------------------------------------------------------------------
      INTEGER MXRT
      PARAMETER (MXRT=100)
      DOUBLE PRECISION ::
     *       ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *       VEN,VEE,EPOT,EKIN,ESTATE,STATN,EDFT,EDISP
C
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
C------------------------------------------------------------------
C
C     SETUP ORIENTED ORBITAL KINETIC ENERGY INTEGRALS IN STRI.
C     NOTE:  DEN MUST BE LEFT AS THE ORIGINAL DENSITY MATRIX.
      CALL VCLR(DENKE,1,NUMLOC2)
      CALL TFTRI(DENKE,STRI,CLMO,
     *           WRK,NUMLOC,L1,L1)
      CALL VCLR(STRI,1,L2)
      CALL DCOPY(NUMLOC2,DENKE,1,STRI,1)
      CALL VCLR(DENKE,1,NUMLOC2)
C
C     INITIALIZE TOTKE.
      TOTKE=ZERO
C
C     WORK ON CORE TERMS.
      DO I=1,NOUTA
        IJ=LTPOS(I,I)
        TOTKE=TOTKE+TWO*STRI(IJ)
      ENDDO
C
C     WORK ON VALENCE TERMS.
      DO I=1,M1
         DO J=1,I
            IJ=LTPOS(I,J)
            IJV=LTPOS(NOUTA+I,NOUTA+J)
C           EVALUATE FOR BOS*KEI.
            DENKE(IJ)=STRI(IJV)*DEN(IJ)
C           MAKE CONTRIBUTION TO TOTKE.
            TMP=TWO
            IF(I.EQ.J) TMP=ONE
            TOTKE=TOTKE+TMP*DENKE(IJ)
         ENDDO
      ENDDO
C
C     MAKE THE PRINT OUTS.
      IF(SOME) THEN
        WRITE(IW,9070)
        CALL PRTRI(DEN,M1)
      ENDIF
      IF(SOME) THEN
        WRITE(IW,9091)
        CALL PRTRI(DENKE,M1)
      ENDIF
      IF(SOME) WRITE(IW,9100) EKIN,TOTKE
C
C     MAKE AN ERROR OUT COMPARING THE NEW AND OLD KINETIC ENERGIES.
      CALL LOCAL_PROP_DONE(NOSKIP,SOME)
      IF(NOSKIP) THEN
        TMP=ABS(TOTKE-EKIN)
        IF(TMP.GT.TOL) THEN
          IF(MASWRK) WRITE(IW,9200)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
      ENDIF
C
      RETURN
 9070 FORMAT(///1X,'ORIGINAL ORIENTED DENSITY MATRIX'/)
 9091 FORMAT(///1X,'MULTIPLY DENSITY ELEMENTS BY',
     *          1X,'KINETIC ENERGY INTEGRALS FOR NOVEL DENSITY MATRIX.',
     *         /1X,'FULL PRINT OUT OF NOVEL ORIENTED DENSITY'/)
 9100 FORMAT(/1X,'OLD TOTAL KINETIC ENERGY =',F20.10,
     *       /1X,'NEW TOTAL KINETIC ENERGY =',F20.10)
 9200 FORMAT(/1X,'NEW TOTAL KINETIC ENERGY DOES NOT MATCH OLD ONE.',
     *       /1X,'IF THIS SLIGHTLY FAILS,',
     *        1X,'TRY TIGHTENING CONV IN THE SCF GROUP.')
      END
C*MODULE LOCAL   *DECK LOCAL_VVOS_ORB_RANGE_CORE
C> @brief      Automatically finds atom numbers for VVOS orbitals.
C>
C> @author     Aaron West
C>             -July 11, 2013
C>
C> @details    All chem. cores are not at the beginning...
C>
C> @param IPOSCOR denotes the integer array that holds the starting
C>                position for the 1st CORE AO on a given atom.
C> @param ILENCOR denotes the integer array that holds the number of
C>                CORE orbitals on a given atom.
C> @param NAT     is the total number of atoms.
      SUBROUTINE LOCAL_VVOS_ORB_RANGE_CORE(IPOSCOR,ILENCOR,NAT)
      IMPLICIT NONE
C
      INTEGER NAT,IPOSCOR(NAT+1),ILENCOR(NAT)
      INTEGER I,ITYPE,NCOR_NEVER,ITMP,NVAL,ISWMBS
      INTEGER LOCAL_NUMVAL,NVVOS_NUMCOR
C
C     NOTES:
C     1.  GO BACK TO THE BASIC NVVOS_NUMCOR INFO HERE
C         SINCE VVOS IS IN MBS NUMBERS.
C     2.  GO BACK TO NVVOS_NUMCOR ATOM-BY-ATOM.
C         THIS PART TOOK ME A BIT TO REALIZE... AND DANCE.
C
      ITMP=1
      DO I=1,NAT
C
        ITYPE=1
        NCOR_NEVER=NVVOS_NUMCOR(I,ITYPE)
        ISWMBS=1
        NVAL=LOCAL_NUMVAL(I,ISWMBS)
C
        IPOSCOR(I)=ITMP
        ILENCOR(I)=NCOR_NEVER
C
        ITMP=ITMP+NCOR_NEVER
        ITMP=ITMP+NVAL
      ENDDO
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_CHECK_DENS
C> @brief      Checks density matrix occupations.
C>
C> @author     Aaron West
C>             -July 18, 2013
C>
C> @details    This item checks the occupations
C>             against the total number of electrons.
C>             For ilocal=4 type runs, the NCOROT below
C>             is probably always the chemical core orbitals.
C>
C> @date October 19, 2013-Aaron West
C> -Fix some silly mistakes.
C>  Test cases checked out by script.
C>
C> @param DEN     equals the density matrix.
C> @param NACT2   equals the dimension of the density matrix.
C> @param NACT    equals the number of active orbitals.
C> @param NCORTOT equals the number of core orbitals.
C> @param NE      equals the number of electrons.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_CHECK_DENS(
     *           DEN,NACT2,NACT,NCORTOT,NE,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER NACT,NACT2,NCORTOT,NE,IW
      DOUBLE PRECISION :: TMP,TOT,DEN(NACT2)
      INTEGER I,II
C------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       TOL,TWO,
     *       RNONE
      PARAMETER (TOL=1.0D-06,TWO=2.0D+00)
      DATA RNONE/8HNONE    /
C------------------------------------------------------------------
C
C     EXIT FOR COUPLED CLUSTER.
      IF(CCTYP.NE.RNONE) RETURN
C
C     OBTAIN CONTRIBUTIONS FROM DENSITY.
      TOT=0
      DO I=1,NACT
        II=(I*I+I)/2
        TOT=TOT+DEN(II)
      ENDDO
C
C     OBTAIN CONTRIBUTIONS FROM CHEMICAL CORE ORBITALS.
      TOT=TOT+TWO*NCORTOT
C
C     COMPARE TO THE NUMBER OF ELECTRONS.
      TMP=DBLE(NE)
      TMP=ABS(TMP-TOT)
      IF(TMP.GT.TOL) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_CHECK_DENS ERROR:',
     *       /1X,'THE DENSITY DOES NOT ADD UP',
     *        1X,'TO THE NUMBER OF ELECTRONS.')
      END
C*MODULE LOCAL   *DECK LOCAL_CHECK_ORTHOG
C> @brief      Checks if orbitals are orthonormal.
C>
C> @author     Aaron West
C>             -August 02, 2013
C>
C> @param L0       is the length of the MO variational space.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param S2       is scratch space of length L2.
C> @param S        contains the AO overlap matrix of length L2.
C> @param VECCOL   contains the orbitals to be checked.
C> @param WRK      is scratch of length L1*8.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_CHECK_ORTHOG(
     *           L0,L1,L2,
     *           S2,S,VECCOL,WRK,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IW,L0,L1,L2
      DOUBLE PRECISION ::
     *       S2(L2),S(L2),VECCOL(L1,L1),WRK(L1*8)
C
C
      INTEGER IERR,I,J,IJ,ISAV,JSAV
      DOUBLE PRECISION :: TMP,SAV,TOL_NOS_EXT
      PARAMETER (TOL_NOS_EXT=1.0D-08)
      ! part. int. gave 1.2d-10 error diff
C
C
      CALL TFTRI(S2,S,VECCOL,WRK,L0,L1,L1)
      IERR=0
      ISAV=0
      JSAV=0
      SAV=0.0D+00
      DO I=1,L0
        DO 100 J=1,I
          IJ=(I*I-I)/2+J
          TMP=ABS(S2(IJ))
          IF(I.EQ.J) TMP=ABS(S2(IJ)-1.0D+00)
          IF(TMP.LE.TOL_NOS_EXT) GO TO 100
C----------
          IERR=IERR+1
          IF(TMP.LT.SAV) GO TO 100
          SAV=TMP
          ISAV=I
          JSAV=J
C----------
  100   CONTINUE
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9010) ISAV,JSAV,SAV
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9010 FORMAT(//1X,'LOCAL_CHECK_ORTHOG ERROR:',
     *        /1X,'FINAL ORBITALS ARE NOT ORTHONORMAL.',
     *        /1X,'ORBITAL I,ORBITAL J,MAX ERROR VALUE',I4,I4,F20.10)
      END
C*MODULE LOCAL   *DECK LOCAL_SVDEXTOPT_ACROSSATOMS
C> @brief      Preserves degenerate values ACROSS atoms.
C>
C> @author     Aaron West
C>             -September 12, 2013
C>
C> @details    The SVD values must be cut off at some point.
C>             The cut must have non-degenerate values across it.
C>
C> @param ICT_ORB   is the total orbitals out of the SVD.
C> @param IGRPLAB   contains the group labels.
C> @param IATLAB    contains the atom labels.
C> @param IORDBIG   is integer scratch with length of
C>                  LD_EXTOPT.
C> @param IEXTSPACE is the total number of external groups.
C>                  It can only be 1 here.
C> @param L1        is the number of atomic orbitals.
C> @param L0        is the number of molecular orbitals.
C> @param L0MBS     is the number of internal orbitals.
C> @param NCORTOT   is the number of core orbitals.
C> @param NATEXT    is a check on memory allocation.
C> @param IAOMAX    is integer scratch for atom counting.
C> @param IAOFIN    is integer scratch for atom counting.
C> @param IAODEG    is integer scratch for atom counting.
C> @param IAODEGTOT is integer scratch for atom counting.
C> @param NAT       is the number of atoms.
C> @param LD_EXTOPT is used in the leading dimension.
C> @param NACT      is the number of active orbitals.
C> @param NSPACE    is the number ORMAS groups.
C> @param MSTA      holds the orbital ranges for ORMAS groups.
C> @param EIGSAV    saves the SVD evalues from ALL SVDs.
C>                  For each atom, an SVD is done.
C> @param EIGTMP    is scratch space to save EIGSAV array.
C> @param ILENCOR   denotes the integer array that holds the
C>                  number of CORE orbitals on a given atom.
C> @param ILENMBS   gives the number of VALANEC MBS orbitals.
C> @param SOME      is true for master process with nprint
C>                  not equal -5.
C> @param MASWRK    indicates the master process.
C> @param IW        indicates write out to log file.
      SUBROUTINE LOCAL_SVDEXTOPT_ACROSSATOMS(
     *           ICT_ORB,IGRPLAB,IATLAB,IORDBIG,
     *           IEXTSPACE,L1,L0,L0MBS,NCORTOT,NATEXT,
     *           IAOMAX,IAOFIN,IAODEG,IAODEGTOT,
     *           NAT,LD_EXTOPT,NACT,NSPACE,MSTA,
     *           EIGSAV,EIGTMP,
     *           ILENCOR,ILENMBS,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
C
C     VARS THAT ENTER.
      LOGICAL SOME,MASWRK
      INTEGER IW,
     *        ICT_ORB,IEXTSPACE,L1,L0,L0MBS,NCORTOT,NATEXT,
     *        NAT,LD_EXTOPT,NACT,NSPACE
      INTEGER IGRPLAB(LD_EXTOPT),IATLAB(LD_EXTOPT),
     *        IORDBIG(LD_EXTOPT),
     *        IAOMAX(NAT),IAOFIN(NAT),
     *        IAODEG(NAT),IAODEGTOT(NAT),
     *        MSTA(NSPACE),ILENCOR(NAT),ILENMBS(NAT)
      DOUBLE PRECISION ::
     *       EIGSAV(LD_EXTOPT),EIGTMP(LD_EXTOPT)
C
C     VARS MADE HERE.
      INTEGER ISPACE,NERR,LIMORB,IATM1,
     *        NAOCART,NAOSPH,NAOTOT,
     *        ILEN,ITMP,IMARK,IPOS,JPOS,IPOSHLD,IDUM,ITOT,
     *        ICTDEG,IATI,IATJ,IFIND
      DOUBLE PRECISION :: TMP,TMPSAV,TOL
      PARAMETER (TOL=1.0D-05)
C
C     OVERALL GOAL:
C     OBTAIN LIMORB "SELECT" ORBITALS WITH THE FOLLOWING CONDITIONS:
C     --MAX. SVD EVALUES
C     --ACCEPT OR REJECT DEGENERATE ORBITALS ACROSS ATOMS
C     --ACCEPT ORBITALS BELOW IAOMAX LIMIT ON EACH ATOM
C     --DO NOT LOOK AT ONE ATOM WHEN YOU THINK ABOUT THIS PROCEDURE
C     --TOLERANCE WAS SELECTED BASED ON VALUES FROM PARA-QUINONE
C       THAT WAS RUN IN SYMMETRY FOR RHF ENERGY OPTIMIZATION.
C
C
C     CHECK NATEXT FOR GIVEN VALUE.
      IF(NATEXT.NE.4) THEN
        IF(MASWRK) WRITE(IW,9005) NATEXT
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     CHECK THAT ONLY THE LAST GROUP IS IN THE EXTERNALS.
      NERR=0
      IF(IEXTSPACE.NE.1) NERR=NERR+1
      DO ISPACE=1,NSPACE-1
        IF(MSTA(ISPACE).GT.L0MBS) NERR=NERR+1
      ENDDO
      IF(NERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9010)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     DEFINE IAOMAX,NAOTOT
      NERR=0
      NAOTOT=0
      CALL VICLR(IAOMAX,1,NAT)
      DO IATM1=1,NAT
        CALL LOCAL_COUNTAOS(IATM1,NAOCART,NAOSPH)
        IAOMAX(IATM1)=NAOSPH-ILENMBS(IATM1)-ILENCOR(IATM1)
        NAOTOT=NAOTOT+NAOSPH
      ENDDO
      IF(NAOTOT.GT.L1) NERR=NERR+1
      IF(NERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9020)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C
C     DEFINE LIMORB
      LIMORB=NAOTOT-L0MBS
      IF(SOME) WRITE(IW,9025) LIMORB
C
C     CHECK LIMITS
      IF(NACT+NCORTOT.LT.L0) THEN
        IF(MASWRK) WRITE(IW,9030)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     LOCATE IPOS FOR THE EXTERNAL ORBITALS.
      CALL VICLR(IORDBIG,1,LD_EXTOPT)
      IPOS=0
      DO 150 ILEN=1,L1
        IF(IGRPLAB(ILEN).EQ.NSPACE) GO TO 151
        IORDBIG(ILEN)=ILEN
        IPOS=ILEN
  150 CONTINUE
  151 CONTINUE
C
C     LOCATE THE "SELECT" EVALUES.
      CALL DCOPY(LD_EXTOPT,EIGSAV,1,EIGTMP,1)
      CALL VICLR(IAOFIN,1,NAT)
      CALL VICLR(IAODEGTOT,1,NAT)
C     --IPOS IS ALREADY SET.
      IMARK=IPOS+1
      ITOT=0
      DO 200 ILEN=IMARK,ICT_ORB
        IPOS=IPOS+1
        IPOSHLD=IPOS
        IF(IPOS.GT.ICT_ORB) GO TO 201
        IATI=IATLAB(IPOS)
        TMPSAV=EIGTMP(IPOS)
C
        CALL VICLR(IAODEG,1,NAT)
        IAODEG(IATI)=IAODEG(IATI)+1
        IAODEGTOT(IATI)=IAODEGTOT(IATI)+1
        ICTDEG=1
        DO 300 JPOS=IPOSHLD+1,ICT_ORB
          IATJ=IATLAB(JPOS)
          TMP=ABS(EIGTMP(JPOS)-TMPSAV)
          IF(TMP.GE.TOL) GO TO 301
          IAODEG(IATJ)=IAODEG(IATJ)+1
          IAODEGTOT(IATJ)=IAODEGTOT(IATJ)+1
          ICTDEG=ICTDEG+1
          IPOS=IPOS+1
  300   CONTINUE
  301   CONTINUE
        IF(IPOS.GT.ICT_ORB) GO TO 201
        ITMP=ITOT+ICTDEG
        IF(ITMP.GT.LIMORB) GO TO 200
        DO IATM1=1,NAT
          ITMP=IAOFIN(IATM1)+IAODEG(IATM1)
          IF(ITMP.GT.IAOMAX(IATM1)) GO TO 200
        ENDDO
C
        DO JPOS=1,ICTDEG
          ITMP=IPOSHLD-1+JPOS
          IDUM=IMARK-1+ITOT+JPOS
          IORDBIG(IDUM)=ITMP
        ENDDO
C
        DO IATM1=1,NAT
          IAOFIN(IATM1)=IAOFIN(IATM1)+IAODEG(IATM1)
        ENDDO
        ITOT=ITOT+ICTDEG
        IF(ITOT.EQ.LIMORB) GO TO 201
  200 CONTINUE
  201 CONTINUE
      IF(ITOT.EQ.LIMORB) THEN
        IF(SOME) WRITE(IW,9100)
        CALL FLSHBF(IW)
        GO TO 1000
      ENDIF
C--------------------------------------------------------------------
C     SKIP DESCENDING EIGENVALUE SORT
C     SINCE NO TEST CASES NEED IT SO FAR.
C--------------------------------------------------------------------
C     PERFORM FINAL CHECKS AND SORT THE INTEGER ARRAYS.
C--------------------------------------------------------------------
 1000 CONTINUE
      IF(ITOT.EQ.LIMORB) THEN
        IF(SOME) THEN
          WRITE(IW,9500) TOL
          DO IATM1=1,NAT
            WRITE(IW,9510) IATM1,IAODEGTOT(IATM1)
          ENDDO
        ENDIF
      ELSE
        IF(MASWRK) WRITE(IW,9550)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C--------------------------------------------------------------------
C--------------------------------------------------------------------
C
C     FINISH THE CONSTRUCTION OF IORDBIG ARRAY.
C     --FIND FIRST 0 IN IORDBIG.
C     --FIND MISSING POSITIONS.
C     --ADD MISSING POSITIONS ONTO IORDBIG.
      IFIND=0
      DO 1005 ILEN=IMARK,LD_EXTOPT
        IF(IORDBIG(ILEN).NE.0) GO TO 1005
        IFIND=ILEN
        GO TO 1006
 1005 CONTINUE
 1006 CONTINUE
      ITMP=IFIND-1
      DO 1010 ILEN=IMARK,ICT_ORB
        IDUM=0
        DO 1020 JPOS=IMARK,ICT_ORB
          IF(ILEN.EQ.IORDBIG(JPOS)) THEN
            IDUM=1
            GO TO 1021
          ENDIF
 1020   CONTINUE
 1021   CONTINUE
        IF(IDUM.EQ.1) GO TO 1010
        ITMP=ITMP+1
        IORDBIG(ITMP)=ILEN
 1010 CONTINUE
C
C     PRINT OUT ANY DIFFERENCE.
      DO ILEN=IMARK,ICT_ORB
        IF(SOME.AND.IORDBIG(ILEN).NE.ILEN) THEN
          WRITE(IW,9600) ILEN,IATLAB(ILEN),IORDBIG(ILEN),EIGSAV(ILEN)
        ENDIF
      ENDDO
C
C
C
C     REORDER ALL ARRAYS RIGHT AFTER THIS VERY CALL.
C
C
C
      RETURN
 9005 FORMAT(//1X,'LOCAL_SVDEXTOPT_ACROSSATOMS ERROR:',
     *        /1X,'NATEXT MUST BE THE WRONG VALUE=,I4')
 9010 FORMAT(//1X,'LOCAL_SVDEXTOPT_ACROSSATOMS ERROR:',
     *        /1X,'ONLY LAST GROUP CAN BE ABOVE L0MBS RIGHT NOW.')
 9020 FORMAT(//1X,'LOCAL_SVDEXTOPT_ACROSSATOMS ERROR:',
     *        /1X,'MEMORY ERROR RELATIVE TO NAOSPH FOR SOME ATOM.')
 9025 FORMAT(1X,'LOCAL_SVDEXTOPT_ACROSSATOMS:',
     *       2X,'SEEKING EXTERNAL ORBITALS LIMORB=',I4)
 9030 FORMAT(//1X,'LOCAL_SVDEXTOPT_ACROSSATOMS ERROR:',
     *        /1X,'USING LESS THAN ALL EXTERNALS REQUIRES',
     *         1X,'MORE CODING HERE.')
 9100 FORMAT(1X,'LOCAL_SVDEXTOPT_ACROSSATOMS:',
     *       2X,'ASCENDING EIGENVALUE SORT WAS SUCCESSFUL.')
 9550 FORMAT(//1X,'LOCAL_SVDEXTOPT_ACROSSATOMS ERROR:',
     *        /1X,'ITOT DOES NOT EQUAL LIMORB AT THE END.')
CKEEP 9560 FORMAT(1X,'IPOSHLD GREATER THAN ZERO.')
 9500 FORMAT(1X,'LOCAL_SVDEXTOPT_ACROSSATOMS:',
     *      /1X,'BASED ON TOL=',1P,E10.2,',',
     *      /1X,'THE DEGENERATE EVALUES INFORMATION NOW FOLLOWS.',
     *      /1X,'NOTE:  THIS TOTAL DEG. ACROSS ATOMS...')
 9510 FORMAT(1X,'ATOM,NUM. OF DEGENERATE OVERLAP EVALUES',I4,I4)
 9600 FORMAT(1X,'DEGENERACY DIFFERENCE OCCURS FOR',
     *       1X,'COUNT,ATOM,IORDBIG,SVD VALUE=',I4,I4,I4,F12.7)
      END
C*MODULE LOCAL   *DECK LOCAL_BLOCK_ORMAS
C> @brief      Checks block-diagonal form of orbital transform.
C>
C> @author     Aaron West
C>             -August 22, 2013
C>
C> @details    This routine can catch problems with the
C>             extensive sorting in local_ppasvd.
C> @param L1     is the length of the AO coefficients.
C> @param NSPACE is the number ORMAS groups.
C> @param MSTA   holds the orbital ranges for ORMAS groups.
C> @param TRANS  is the orbital transformation of interest.
C> @param MASWRK indicates the master process.
C> @param IW     indicates write out to log file.
      SUBROUTINE LOCAL_BLOCK_ORMAS(
     *           L1,NSPACE,MSTA,TRANS,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER L1,NSPACE,MSTA(NSPACE),IW
      DOUBLE PRECISION :: TRANS(L1,L1)
C
      INTEGER I,J,II,JJ,IERR
      DOUBLE PRECISION :: TMP,TMP2,TOL
      PARAMETER (TOL=1.0D-08)
C
      IERR=0
      DO II=1,NSPACE-1
        DO JJ=II+1,NSPACE
          DO I=MSTA(II),MSTA(II+1)-1
            DO J=MSTA(JJ),MSTA(JJ+1)-1
              TMP =ABS(TRANS(I,J))
              TMP2=ABS(TRANS(J,I))
              IF(TMP.GT.TOL.OR.TMP2.GT.TOL) IERR=IERR+1
            ENDDO
          ENDDO
        ENDDO
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_BLOCK_ORMAS ERROR:',
     *        /1X,'NO ORMAS BLOCK DIGAONAL FORM.')
      END
C*MODULE LOCAL   *DECK LOCAL_SORT_SVDEIG
C> @brief      Sorts atom arrays for local_ppasvd.
C>
C> @author     Aaron West
C>             -August 27, 2013
C>
C> @details    Here, the eigenvalue, transforms, ormas groups, and
C>             atom labels are all sorted at one time.
C>
C> @param IROW      is the number of rows in the orbital transform.
C> @param ICOL      is the number of columns to be sorted.
C> @param LDSVD     gives some leading dimensions from memory.
C> @param EIGSAV    contains the eigenvalues.
C> @param VTVECSAV  contains the orbital transforms.
C> @param IORDBIG   contains the reordering instructions.
C> @param IORDBIG2  is for copying the reordering instructions.
C> @param IGRPLAB   contains the ORMAS group labels.
C> @param IATLAB    contains the atom labels.
C>
      SUBROUTINE LOCAL_SORT_SVDEIG(
     *           IROW,ICOL,
     *           LDSVD,EIGSAV,VTVECSAV,
     *           IORDBIG,IORDBIG2,IGRPLAB,IATLAB)
      IMPLICIT NONE
C
      INTEGER IROW,ICOL,LDSVD
      INTEGER IORDBIG(LDSVD),IORDBIG2(LDSVD),
     *        IGRPLAB(LDSVD),IATLAB(LDSVD)
      DOUBLE PRECISION :: EIGSAV(LDSVD),
     *                    VTVECSAV(IROW,LDSVD)
C
      CALL VICLR(IORDBIG2,1,LDSVD)
      CALL ICOPY(ICOL,IORDBIG,1,IORDBIG2,1)
      CALL REORDR(EIGSAV,IORDBIG2,ICOL,1)
      CALL ICOPY(ICOL,IORDBIG,1,IORDBIG2,1)
      CALL REORDR(VTVECSAV,IORDBIG2,ICOL,IROW)
      CALL ICOPY(ICOL,IORDBIG,1,IORDBIG2,1)
      CALL IREORDR(IGRPLAB,IORDBIG2,ICOL,1)
      CALL ICOPY(ICOL,IORDBIG,1,IORDBIG2,1)
      CALL IREORDR(IATLAB,IORDBIG2,ICOL,1)
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_SORT_SVDALL
C> @brief      Sorts atom arrays for local_ppasvd.
C>
C> @author     Aaron West
C>             -May 31, 2015
C>
C> @param IOPT      =0 reorders by ormas group and svd value.
C>                  =1 reorders by ormas group, svd value, atom label.
C> @param IROW      is the number of rows in the orbital transform.
C> @param ICOL      is the number of columns to be sorted.
C> @param LDSVD     gives some leading dimensions from memory.
C> @param IORDBIG   contains the reordering instructions.
C> @param IORDBIG2  is for copying the reordering instructions.
C> @param IGRPLAB   contains the ORMAS group labels.
C> @param IATLAB    contains the atom labels.
C> @param EIGSAV    contains the eigenvalues.
C> @param VTVECSAV  contains the orbital transforms.
      SUBROUTINE LOCAL_SORT_SVDALL(
     *           IOPT,
     *           IROW,ICOL,LDSVD,
     *           IORDBIG,IORDBIG2,IGRPLAB,IATLAB,
     *           EIGSAV,VTVECSAV)
      IMPLICIT NONE
C---------------------------------------------------------------------
      INTEGER IOPT,IROW,ICOL,LDSVD
      INTEGER IORDBIG(LDSVD),IORDBIG2(LDSVD),
     *        IGRPLAB(LDSVD),IATLAB(LDSVD)
      DOUBLE PRECISION ::
     *       EIGSAV(LDSVD),VTVECSAV(IROW,LDSVD)
C--------------------------------------------------------------------
      LOGICAL SW0,SW1,SW2,SW3,SW4
      INTEGER I,J,ITMP,IDUM
      DOUBLE PRECISION :: TMP
C--------------------------------------------------------------------
C
C     INIT. IORDBIG.
      CALL VICLR(IORDBIG,1,LDSVD)
      DO I=1,ICOL
        IORDBIG(I)=I
      ENDDO
C
C     RUN OVER THE VALUES.
      DO I=1,ICOL
        IDUM=I
        DO J=I+1,ICOL
          SW0=.FALSE.
          SW1=.FALSE.
          SW2=.FALSE.
          SW3=.FALSE.
          SW4=.FALSE.
          IF(IGRPLAB(J).LT.IGRPLAB(IDUM)) SW0=.TRUE.
          IF(IGRPLAB(J).EQ.IGRPLAB(IDUM)) SW1=.TRUE.
          IF(EIGSAV(J).GT.EIGSAV(IDUM)) SW2=.TRUE.
          IF(IATLAB(J).LT.IATLAB(IDUM)) SW3=.TRUE.
          IF(IATLAB(J).EQ.IATLAB(IDUM)) SW4=.TRUE.
          IF(SW0) IDUM=J
          IF(IOPT.EQ.0.AND.SW1.AND.SW2) IDUM=J
          IF(IOPT.EQ.1) THEN
            IF(SW1.AND.SW3) IDUM=J
            IF(SW1.AND.SW2.AND.SW4) IDUM=J
          ENDIF
        ENDDO
C       SWITCH REORDERING VALUES.
        ITMP=IORDBIG(IDUM)
        IORDBIG(IDUM)=IORDBIG(I)
        IORDBIG(I)=ITMP
C       SWITCH EVALUES.
        TMP=EIGSAV(IDUM)
        EIGSAV(IDUM)=EIGSAV(I)
        EIGSAV(I)=TMP
C       SWITCH GROUP LABELS.
        ITMP=IGRPLAB(IDUM)
        IGRPLAB(IDUM)=IGRPLAB(I)
        IGRPLAB(I)=ITMP
C       SWITCH ATOM LABELS.
        ITMP=IATLAB(IDUM)
        IATLAB(IDUM)=IATLAB(I)
        IATLAB(I)=ITMP
      ENDDO
C
C     REORDER THE EIGENVECTORS.
      CALL ICOPY(ICOL,IORDBIG,1,IORDBIG2,1)
      CALL REORDR(VTVECSAV,IORDBIG2,ICOL,IROW)
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_CLINDEP
C> @brief      Finds linearly independent orbitals.
C>
C> @author     Aaron West
C>             -September 27, 2013
C>
C> @details    A given set of orbitals are cycled over.
C>             Any linearly dependent orbitals are removed
C>             in two steps:
C>             Step 1:  Diagonalize the orbital overlap.
C>                      Take the number of 0 eigenvalues.
C>                      Sum over eigenvector components.
C>                      Do this action for ALL eigenvectors.
C>                      Remove the eigenvectors with
C>                             biggest contribution.
C>             Step 2:  On entry into the routine,
C>                      different evalues are given that
C>                                indicate compactness.
C>                      Repeatedly form and diagonalize
C>                                 the orbital overlap.
C>                      Check for linear dependence.
C>                      If present, remove diffuse orbital.
C>                      Repeat process.
C>
C> @param IEXTORB  is the total spherical external orbitals.
C> @param IEXTORBF is the final spherical external orbitals.
C>                 Ater testing for linear dependence,
C>                 IEXTORBF external orbitals are left.
C> @param NAOTOT   denotes the total spherical MOs.
C> @param L0MBS    denotes the minimal basis MOs.
C> @param L0       denotes the variational spherical MOs.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param L3       is the square of L1.
C> @param IATLAB   holds the external atom labels on entry.
C>                 Make sure this is a temporary copy
C>                 and not the permanent copy.
C>                 Permanent copy gets manipulated later.
C> @param IWRK     is scratch of L1 size.
C> @param IWRK2    is scratch of L1 size.
C> @param VTVEC    contains the external orbitals on entry.
C> @param EIGTMP   contains eigenvalues that denote
C>                 orbital compactness on entry.
C> @param TOL      is the linear dependence tolerance.
C> @param S        is the AO overlap of L2 size on entry.
C> @param S2       is scratch of L2 size.
C> @param VTMP     is scratch of L3 size.
C> @param WRK      is scratch of L1x8 size.
C> @param EIG      is scratch of L1 size.
C> @param SOME     is true for master process with nprint not equal -5.
C> @param MASWRK   indicates the master process.
C> @param IW       indicates write out to log file.
C>
      SUBROUTINE LOCAL_CLINDEP(
     *           IEXTORB,IEXTORBF,NAOTOT,L0MBS,L0,L1,L2,L3,
     *           IATLAB,IWRK,IWRK2,
     *           VTVEC,EIGTMP,TOL,
     *           S,S2,VTMP,WRK,EIG,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
C     INPUT VARS.
      LOGICAL SOME,MASWRK
      INTEGER IEXTORB,IEXTORBF,NAOTOT,L0MBS,L0,L1,L2,L3,
     *        IW
      DOUBLE PRECISION ::
     *       TOL,
     *       VTVEC(L1,IEXTORB),EIGTMP(IEXTORB),
     *       S(L2),S2(L2),VTMP(L1,L1),WRK(L1*8),EIG(L1)
      INTEGER IATLAB(IEXTORB),IWRK(L1),IWRK2(L1)
C-----------------------------------------------------------------
      INTEGER ICT,ICTF,I,J,IPOS,ILEN,IERR2,IERR3
      DOUBLE PRECISION ::
     *       DASUM,XASUM
C-----------------------------------------------------------------
C
C     PRINT OUT THE BANNER.
      IF(SOME) WRITE(IW,9000)
C
C     ERROR OUTS
      IF(IEXTORB.NE.NAOTOT-L0MBS) THEN
        IF(MASWRK) WRITE(IW,9010)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     INITIALIZE SOME ITEMS.
      ICT=0
      IEXTORBF=IEXTORB
C
C--------------------------------
C     PERFORM KR'S CRITERION.
C--------------------------------
C
C     PREPARE FOR DISJUNCT DASUM.
      CALL VCLR(S2,1,L2)
      CALL TFTRI(S2,S,VTVEC,WRK,IEXTORB,L1,L1)
      IERR2=0
      CALL VCLR(VTMP,1,L3)
      CALL GLDIAG(L1,IEXTORB,IEXTORB,S2,WRK,EIG,VTMP,IERR2,IWRK)
      IF(IERR2.GT.0) THEN
        IF(MASWRK) WRITE(IW,9020)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     DO SOME MORE CHECKING AND PRINTING.
      ICT=0
      IERR3=0
      DO I=1,IEXTORB
        IF(EIG(I).LT.-1.0D-06) IERR3=IERR3+1
        IF(EIG(I).LT.TOL) THEN
          IF(MASWRK) WRITE(IW,9030) TOL,EIG(I)
          ICT=ICT+1
        ENDIF
      ENDDO
      IF(IERR3.GT.0) THEN
        IF(MASWRK) WRITE(IW,9040)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      IF(ICT.NE.NAOTOT-L0) THEN
        IF(MASWRK) WRITE(IW,9050)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     PERFORM DISJUNCT DASUM OVER EIGENVECTOR
C     --ROWS==>COLUMNS WITH ZERO EVALUES
      CALL VCLR(EIG,1,L1)
      CALL TRPOSQ(VTMP,L1)
      DO I=1,IEXTORB
        EIG(I)=DASUM(ICT,VTMP(1,I),1)
      ENDDO
      CALL VCLR(VTMP,1,L3)
C
C     SORT AND REORDER FROM SMALL TO BIG EIG MAGNITUDES.
      CALL LOCAL_SORT_EVALS(.TRUE.,4,IEXTORB,IWRK,EIG)
      CALL VCLR(EIG,1,L1)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(EIGTMP,IWRK2,IEXTORB,1)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL IREORDR(IATLAB,IWRK2,IEXTORB,1)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(VTVEC,IWRK2,IEXTORB,L1)
C
C     PRINT OUT DROPPED ORBITALS.
      DO I=IEXTORB-ICT+1,IEXTORB
        IF(SOME) WRITE(IW,9060) L0MBS+IWRK(I)
      ENDDO
C
C--------------------------------
C     PERFORM REMOVE SMALL EVALUE.
C--------------------------------
C
C     SORT AND REORDER FROM BIG TO SMALL EIGTMP MAGNITUDES.
C     NOTE:  THE PREVIOUS ICT IS THROWN OUT FOREVER.
      IEXTORBF=IEXTORB-ICT
      CALL LOCAL_SORT_EVALS(.TRUE.,3,IEXTORBF,IWRK,EIGTMP)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL IREORDR(IATLAB,IWRK2,IEXTORBF,1)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(VTVEC,IWRK2,IEXTORBF,L1)
C
C     CYCLE OVER A DIAG. PROCEDURE.
      IEXTORBF=IEXTORB-ICT
      DO I=1,IEXTORB-ICT
        IF(SOME) WRITE(IW,9070) I
        CALL VCLR(S2,1,L2)
        CALL TFTRI(S2,S,VTVEC,WRK,IEXTORBF,L1,L1)
        IERR2=0
        CALL GLDIAG(L1,IEXTORBF,IEXTORBF,S2,WRK,EIG,VTMP,IERR2,IWRK)
        IF(IERR2.GT.0) THEN
          IF(MASWRK) WRITE(IW,9020)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C
C       IF POSSIBLE, BREAK THE CYCLE.
        ICTF=0
        DO J=1,IEXTORBF
          IF(EIG(J).LT.TOL) ICTF=ICTF+1
        ENDDO
        IF(ICTF.EQ.0) GO TO 200
C
C       RESET IEXTORBF.
        IEXTORBF=IEXTORBF-1
      ENDDO
C     THE EXIT LINE.
  200 CONTINUE
C
C     REORDER THE IEXTORBF ORBITALS BY ATOM AND EIGTMP VALUE.
C     NOTE:  OUTSIDE THIS ROUTINE RIGHT NOW,
C            WE TRASH IATLAB AND PROCEED IN ANOTHER FASHION.
      CALL LOCAL_SORT_INTS(.TRUE.,2,IEXTORBF,IWRK,IATLAB)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(EIGTMP,IWRK2,IEXTORBF,1)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(VTVEC,IWRK2,IEXTORBF,L1)
C------
      IPOS=1
      ILEN=0
      ICT=IATLAB(1)
      DO I=1,IEXTORBF
        IWRK(I)=I
      ENDDO
      DO I=IEXTORBF+1,L1
        IWRK(I)=0
      ENDDO
C------
      DO 400 I=1,IEXTORBF
        IF(IATLAB(I).EQ.ICT) ILEN=ILEN+1
        IF(IATLAB(I).EQ.ICT) GO TO 400
        CALL LOCAL_SORT_EVALS(.FALSE.,3,ILEN,IWRK(IPOS),EIGTMP(IPOS))
        IPOS=I
        ILEN=1
        ICT=IATLAB(I)
  400 CONTINUE
      CALL LOCAL_SORT_EVALS(.FALSE.,3,ILEN,IWRK(IPOS),EIGTMP(IPOS))
C------
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL IREORDR(IATLAB,IWRK2,IEXTORBF,1)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(VTVEC,IWRK2,IEXTORBF,L1)
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_CLINDEP HAS BEGUN...')
 9010 FORMAT(//1X,'LOCAL_CLINDEP ERROR:',
     *        /1X,'IEXTORB DOES NOT MAKE SENSE.')
 9020 FORMAT(//1X,'LOCAL_CLINDEP ERROR:',
     *        /1X,'DIAGONALIZATION FAILED.')
 9030 FORMAT(1X,'SVDEXTOPT DIAGONALIZATION WARNING:',
     *       2X,'TOL,SMALL EVALUE=',1X,1P,E10.2,', ',1P,E10.2)
 9040 FORMAT(//1X,'LOCAL_CLINDEP ERROR:',
     *        /1X,'THESE EVALUES CANNOT BE LESS THAN ZERO.')
 9050 FORMAT(//1X,'LOCAL_CLINDEP ERROR:',
     *        /1X,'NUMBER OF BAD EIGENVALUES DOES NOT EQUAL',
     *        /1X,'NAOTOT MINUS L0.')
 9060 FORMAT(1X,'QMTTOL SETTING DROPS QUAO NUMBER=',I4)
 9070 FORMAT(1X,'CLINDEP ITERATION=',I4)
      END
C*MODULE LOCAL   *DECK LOCAL_DAT_ATOMS
C> @brief      Atom label group for external orbitals.
C>
C> @author     Aaron West
C>             -September 27, 2013
C>
C> @details    The group can be written out
C>             at any starting orbital.
C>
C> @param L1       is the length of the AO coefficients.
C> @param L0FIN    in the final spherical MOs.
C> @param ISTART   is the start orbital for writing out atom labels.
C> @param IATLAB   is the integer array that holds the atom labels.
C> @param IP       indicates write out to the dat file.
C> @param MASWRK  indicates the master process.
C> @param IW       indicates write out to the log file.
C>
      SUBROUTINE LOCAL_DAT_ATOMS(
     *           L1,L0FIN,ISTART,IATLAB,IP,MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IP,IW,
     *        L1,L0FIN,ISTART
      INTEGER IATLAB(L1)
C
      INTEGER IERR,I
C
C     CHECK FOR NON-ZERO LABELS IN L0FIN+1 --> L1
C     IF SO, BOMB OUT.  TRUST ME.  PRECISE IS BETTER NOW.
      IERR=0
      DO I=L0FIN+1,L1
        IF(IATLAB(I).NE.0) IERR=IERR+1
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     PRINT OFF ATOM LABELS TO .DAT FILE.
      IF(MASWRK) THEN
        WRITE(IP,9010)
        WRITE(IP,9015) ISTART
        DO I=ISTART,L0FIN-1
          WRITE(IP,9020) IATLAB(I)
          IF(MOD(I,10).EQ.0) WRITE(IP,9030)
        ENDDO
        WRITE(IP,9040) IATLAB(L0FIN)
        WRITE(IP,9050)
      ENDIF
C
      RETURN
 9000 FORMAT(//1X,'LOCAL_DAT_ATOMS ERROR',
     *        /1X,'AFTER L0FIN NEEDS TO BE ALL 0S.')
 9010 FORMAT(//1X,'$IATLAB')
 9015 FORMAT(1X,'IATLAB(',I4,')=')
 9020 FORMAT(I4,',',$)
 9030 FORMAT(1X)
 9040 FORMAT(I4,$)
 9050 FORMAT(/1X,'$END'//)
      END
C*MODULE LOCAL   *DECK LOCAL_SPLITQA
C> @brief      Driver for q.a. split-localized orbitals.
C>
C> @author     Aaron West
C>             -June 28, 2013
C>
C> @details    Given oriented q.a. orbitals,
C>             routine forms split-localized orbitals.
C>             Unlike ER orbitals, process only involves Jacobi
C>             rotations and is more efficient for larger
C>             systems.
C>             The same algorithm is used as in the orientation
C>             code but the Jacobi rotations are not restricted
C>             to be intra-atomic.
C>
C> @date March 12, 2014-Aaron West
C> -Updated to actually make ORMAS split-localized orbitals.
C>
      SUBROUTINE LOCAL_SPLITQA
      IMPLICIT NONE
      LOGICAL SOME,ORMFUL_SAV
      INTEGER ISIZE_FCCWFN,
     *        L0,L1,L2,L3,
     *        NCORTOT,IMBS,IMBS2,L0MBS,L2MBS,
     *        NAOTOT,NAOTRI
      INTEGER ISHFT,I,J,IJNEW,IJOLD,IG,
     *        LTPOS
      INTEGER NCORSV,NACTSV,NOCC,NOCC2
      INTEGER NGOTMX,LOADFM,LAST,NEED,
     *        LS,LS2,
     *        LVTORB,LVECSV1,LVECSV2,LDENSV,
     *        LMSTA_INT,LMSTA_SAV,LMSTA_ORIG,LITRKA,
     *        LNOROT,LIIR,LTRANS,
     *        LVEC,LWRK,LQ,LIWRK,
     *        LVECSV3,LOCCSV,LSCR,LVEC15
      INTEGER NOUT,IPASS,MCORE,MDOC,N1,
     *        NSPACE_ORIG,NSPACE_INT,NSPACE_SAV,IVVOS_SAV
      DOUBLE PRECISION :: SCFTYP_SAV,CISTEP_SAV,
     *                    RHF,ROHF,RMC,ORMAS,SPLITQ3
C
      INTEGER MXITER,ISKIP
      DOUBLE PRECISION :: CRIT
C-----------------------------------------------------------------------
      INTEGER NSPACE,MSTA,MNUM,MINI,MAXI,
     *        IAMI,IAMA,IBMI,IBMA,IDIMFCC,
     *        LBST,NREF0
      LOGICAL FDIRCT,QCORR
      DOUBLE PRECISION :: C0SQ
C
      DOUBLE PRECISION :: X
C
      DOUBLE PRECISION :: C,ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION ::
     *       FINALCI,METHOD,CISTEP,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT
C
      DOUBLE PRECISION :: CVGLOC
      INTEGER MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *        MOOUTA,MOOUTB
C
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
      INTEGER ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C
C-----------------------------------------------------------------------
      INTEGER MXATM,MXNORO,MXAO
      PARAMETER (MXATM=2000, MXNORO=250, MXAO=8192)
C-----------------------------------------------------------------------
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /OPTLOC/ CVGLOC,MAXLOC,IPRTLO,ISYMLO,IFCORE,NOUTA,NOUTB,
     *                MOOUTA(MXAO),MOOUTB(MXAO)
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-----------------------------------------------------------------------
C
C     DATA STUFF
      DATA CHECK/8HCHECK   /
      DATA ORMAS/8HORMAS   /
      DATA RHF/8HRHF     /
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
      DATA SPLITQ3/8HSPLITQ3 /
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     PRINT STUFF
      IF(SOME) WRITE(IW,9000)
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     SET UP SOME ORBITAL DIMENSIONS
      ISIZE_FCCWFN=51
      CALL LOCAL_SVDORB_VARS(
     *     L0,L1,L2,L3,
     *     NCORTOT,IMBS,IMBS2,L0MBS,L2MBS,
     *     NAOTOT,NAOTRI)
C
C     ALLOCATE MAIN MEMORY.
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LS          = LOADFM    + 1
      LS2         = LS        + L2
      LVTORB      = LS2       + L2
      LVECSV1     = LVTORB    + L3
      LVECSV2     = LVECSV1   + L3
      LDENSV      = LVECSV2   + L3
      LMSTA_SAV   = LDENSV    + L2
      LMSTA_ORIG  = LMSTA_SAV + ISIZE_FCCWFN   ! must be isize_fccwfn.
      LMSTA_INT   = LMSTA_ORIG+ ISIZE_FCCWFN   ! must be isize_fccwfn.
      LITRKA      = LMSTA_INT + ISIZE_FCCWFN   ! must be isize_fccwfn.
      LNOROT      = LITRKA    + ISIZE_FCCWFN
      LIIR        = LNOROT    + L0MBS*L0MBS
      LTRANS      = LIIR      + L1
      LVEC        = LTRANS    + L0MBS*L0MBS
      LWRK        = LVEC      + L3
      LQ          = LWRK      + L1
C     MORE MEMORY FOR ORMAS NOS.
      LIWRK       = LQ        + L3
      LVECSV3     = LIWRK     + L1
      LOCCSV      = LVECSV3   + L3
      LSCR        = LOCCSV    + L1
      LVEC15      = LSCR      + L1*8
      LAST        = LVEC15    + L3
      NEED        = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
C     SAVE THE ORIGINAL MSTA ARRAY.
      CALL ICOPY(ISIZE_FCCWFN,MSTA,1,X(LMSTA_SAV),1)
      NSPACE_SAV=NSPACE
      CALL VICLR(MSTA,1,ISIZE_FCCWFN)
C     LEAVE NSPACE ALONE FOR THE MOMENT.
C
C     SETUP RHF,ROHF,RMC ORBITAL DIMENSIONS.
C     NOTE:
C     --RIGHT AWAY, SET UP THE CORE TO BE LOCALIZED.
C       THIS ACTION WILL PAY OFF WITH BIGGER MOLECULES.
C       CORE ORBITALS PROBABLY ONLY HAVE SVD DONE.
C     --SVD ALREADY HAS ERRORS OUT FOR ACCESSING OUTSIDE
C       THE ACTUAL SIZE OF THE MSTA ARRAY.
C       SO, THOSE ERROR OUTS ARE NOT REPEATED HERE.
C     --THIS IS ALL DESIGNED TO AVOID REORDERING
C       THE ORBITALS AND THE TRANSFORM.
      IF(SCFTYP.EQ.RHF) THEN
        NSPACE=3
        MSTA(1)=1
        MSTA(2)=NCORTOT+1
        MSTA(3)=NA+1
        MSTA(4)=L0MBS+1
      ELSEIF(SCFTYP.EQ.ROHF) THEN
        NSPACE=4
        MSTA(1)=1
        MSTA(2)=NCORTOT+1
        MSTA(3)=NB+1
        MSTA(4)=NA+1
        MSTA(5)=L0MBS+1
      ELSEIF(SCFTYP.EQ.RMC) THEN
        CALL LOCAL_MCSPLITQA_DIMS(
     *       NCORTOT,L0MBS,ISIZE_FCCWFN,NSPACE,
     *       MSTA,X(LMSTA_SAV),X(LITRKA),
     *       EXTLOC,
     *       SOME,MASWRK,IW)
        NSPACE_INT=NSPACE
        CALL ICOPY(ISIZE_FCCWFN,MSTA,1,X(LMSTA_INT),1)
      ELSE
        IF(MASWRK) WRITE(IW,9050)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     GRAB THE NEEDED ORBITAL SETS.
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL DAREAD(IDAF,IODA,X(LVECSV1),L3,538,0)
      CALL DCOPY(L3,X(LVECSV1),1,X(LVECSV3),1)
      CALL LOCAL_CHECK_ORTHOG(
     *     L0,L1,L2,
     *     X(LS2),X(LS),X(LVECSV1),X(LVTORB),
     *     MASWRK,IW)
      CALL DAREAD(IDAF,IODA,X(LVECSV2),L3,286,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     L0DEP0,L1,L2,
     *     X(LS2),X(LS),X(LVECSV2),X(LVTORB),
     *     MASWRK,IW)
C
C     PERFORM EXTRA OPERATIONS FOR WAVEFXN WITH TRUE DENSITY MATRIX.
      IF(SCFTYP.EQ.RMC) THEN
C
C       FORM BLOCK NATURAL ORBITALS IN ORIG ACTIVE SPACES.
C       NOTE:
C       ASSUME NOTHING ABOUT WHETHER BLOCK WAS TURNED ON.
C       ASSUME BLOCK MIGHT NEED BE FALSE FOR EARLIER IN THIS RUN.
C       --LOAD DAF68 INTO LS VARIABLE.
C       --PUT DAF538 ONTO DAF15 FOR THE MOMENT.
C       --LOCCSV WILL HOLD OCCUPATIONS.
C       --LVECSV1 WILL HOLD ORMAS NATURAL ORBITALS.
C         SO, IT IS INDEED MODIFIED TO REFLECT THE DENSITY MATRIX
C             OF THE NOS USED IN MAKING THE OVERLAPS BELOW.
C       --LDENSV WILL HOLD THE TRUE DENSITY MATRIX
C         THIS DENSITY INCLUDES THE CHEM.CORE.
C       --RESTORE DAF15.
        CALL LOCAL_SVDVVOS_RMC_SETUP1(NCORSV,NACTSV)
        NOCC=NCORSV+NACTSV
        NOCC2=(NOCC*NOCC+NOCC)/2
        CALL DAREAD(IDAF,IODA,X(LS),NOCC2,68,0)
        CALL DAREAD(IDAF,IODA,X(LVEC15),L3,15,0)
        CALL DAWRIT(IDAF,IODA,X(LVECSV1),L3,15,0)
        NSPACE_ORIG=NSPACE_SAV
        CALL DCOPY(ISIZE_FCCWFN,X(LMSTA_SAV),1,X(LMSTA_ORIG),1)
        IF(EXTLOC.EQ.SPLITQ3) THEN
          NSPACE_ORIG=1
          CALL VICLR(X(LMSTA_ORIG),1,ISIZE_FCCWFN)
          CALL ICOPY(1,NCORSV+1,1,X(LMSTA_ORIG),1)
          CALL ICOPY(1,NCORSV+NACTSV+1,1,X(LMSTA_ORIG+1),1)
        ENDIF
        CALL LOCAL_ORMAS_BLOCKDIAG(
     *       .FALSE.,
     *       L0,L1,L2,L3,NCORSV,NOCC,NSPACE_ORIG,
     *       X(LMSTA_ORIG),X(LIWRK),
     *       X(LDENSV),X(LS),
     *       X(LVECSV1),X(LQ),X(LOCCSV),X(LWRK),X(LSCR))
        CALL DAWRIT(IDAF,IODA,X(LVEC15),L3,15,0)
C
C       CHECK THE ORBITAL TRANSFORM BEFORE PROCEEDING.
        CALL VCLR(X(LVTORB),1,L3)
        CALL VCLR(X(LQ),1,L3)
        CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
        CALL MTARBR(X(LS),L1,X(LVECSV1),L0MBS,X(LQ),L1,1)
        CALL MRTRBR(X(LVECSV3),L1,L1,L0MBS,X(LQ),L1,L0MBS,X(LVTORB),L1)
        DO I=L0MBS+1,L0
          ISHFT=L1*(I-1) + I
          X(LVTORB+ISHFT-1)=1.0D+00
        ENDDO
        CALL LOCAL_BLOCK_ORMAS(
     *       L1,NSPACE,MSTA,X(LVTORB),
     *       MASWRK,IW)
C
C       PULL ACTIVE DENSITY OUT.
        CALL DCOPY(L2,X(LDENSV),1,X(LS2),1)
        CALL VCLR(X(LDENSV),1,L2)
        DO I=1,L0MBS-NCORTOT
          DO J=1,I
            IJOLD=LTPOS(NCORTOT+I,NCORTOT+J)
            IJNEW=LTPOS(I,J)
            X(LDENSV+IJNEW-1)=X(LS2+IJOLD-1)
          ENDDO
        ENDDO
        CALL VCLR(X(LS2),1,L2)
C
C       FORM NEW ORMAS GROUP STRUCTURE.
        CALL LOCAL_MCSPLITQA_NOS(
     *       L0MBS,L1,NSPACE,NSPACE_ORIG,ISIZE_FCCWFN,
     *       X(LITRKA),MSTA,X(LMSTA_ORIG),
     *       X(LIWRK),
     *       X(LOCCSV),
     *       SOME,MASWRK,IW)
      ENDIF
C
C     GRAB THE NEEDED ORBITAL TRANSFORMATION.
C     NOTE:  THIS NEXT VCLR IS NOT FOR SHOW...
      CALL VCLR(X(LVTORB),1,L3)
      CALL VCLR(X(LQ),1,L3)
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL MTARBR(X(LS),L1,X(LVECSV1),L0MBS,X(LQ),L1,1)
      CALL MRTRBR(X(LVECSV2),L1,L1,L0MBS,X(LQ),L1,L0MBS,X(LVTORB),L1)
CKEEP      CALL MALMQ_TORB
C
C     SETUP VARIABLES FOR THE LMOFRZ USAGE.
C     NOTES:
C     --FOR ILOCAL=4,    LMOPSI DOES NOT LEAVE WAVEFXN INVARIANT.
C       FOR HATREE-FOCK, LMOPSI IS SETUP FOR QUASI-ATOMIC ORBITALS.
C     --IVVOS REDIM. IS ALSO TRICKY.
C       LOCAL_SVDVVOS REDIM. ROUTINES DO NOT LEAVE WAVEFXN INVARIANT.
C     --JUST USE ORMAS GROUPS FOR EVERYTHING IN LMOFRZ TO BE SAFE.
      NOUT=0
      IPASS=1
      MCORE=0
      MDOC=0
      N1=L0MBS
C
C     SETUP LNOROT ARRAY THROUGH LMOFRZ IN ORMAS-LIKE FASHION.
C     NOTE:  IF SYMLOC=.T., SYMMETRY WILL WORK.
      SCFTYP_SAV=SCFTYP
      SCFTYP=RMC
      CISTEP_SAV=CISTEP
      CISTEP=ORMAS
      IVVOS_SAV=IVVOS
      IVVOS=0
      ORMFUL_SAV=ORMFUL
      ORMFUL=.FALSE.
      CALL LMOFRZ(NOUT,IPASS,MCORE,MDOC,N1,X(LNOROT),X(LIIR),L1)
      SCFTYP=SCFTYP_SAV
      CISTEP=CISTEP_SAV
      IVVOS=IVVOS_SAV
      ORMFUL=ORMFUL_SAV
C
C     PERFORM JACOBI ROTATIONS
      IF(MAXLOC.EQ.250) THEN
        MXITER=100000
      ELSE
        MXITER=MAXLOC
      ENDIF
      CRIT=CVGLOC
      ISKIP=0
      CALL LOCAL_SPLITQA_JACOBI(
     *     X(LTRANS),X(LVTORB),X(LNOROT),
     *     L1,L0MBS,L0MBS,NCORTOT,CRIT,MXITER,ISKIP,
     *     SOME,MASWRK,IW)
C
C     CHECK OUT TRANSFORM.
      CALL LOCAL_BLOCK_ORMAS(
     *     L0MBS,NSPACE,MSTA,X(LTRANS),
     *     MASWRK,IW)
C
C     RESTORE TRUE ORMAS GROUPS.
C     NOTE:  ALWAYS CHECK FOR ANY ISSUES BELOW.
C            I MADE A PRINT OFF FOR LUKE THAT
C            RE-RESETS AND THEN RESETS EVERYTHING BELOW.
C            HOWEVER, CHECK AS NEEDED.
      CALL ICOPY(ISIZE_FCCWFN,X(LMSTA_SAV),1,MSTA,1)
      NSPACE=NSPACE_SAV
C
C     CLEAR OUT THE DENSITY FOR LMOS ON DAF71.
      CALL VCLR(X(LVTORB),1,L3)
      CALL DAWRIT(IDAF,IODA,X(LVTORB),IMBS2,285,0)
C
C     FORM DENSITY MATRIX IN SPECIFIC CASES.
C     NOTE:  NEXT TFTRI IS QUITE DIFFERENT FROM THE USUAL CALLING.
      IF(SCFTYP.NE.RMC) GO TO 8888
      CALL VCLR(X(LS2),1,L2)
      CALL TFTRI(X(LS2),X(LDENSV),X(LTRANS+L0MBS*NCORTOT+NCORTOT),
     *           X(LWRK),IMBS,IMBS,L0MBS)
      CALL LOCAL_CHECK_DENS(
     *     X(LS2),IMBS2,IMBS,NCORTOT,NE,
     *     MASWRK,IW)
      IF(SOME) THEN
        WRITE(IW,9060)
        CALL PRTRI(X(LS2),IMBS)
      ENDIF
C
C     FORM QA SPLIT LOCALIZED ORBITALS.
 8888 CONTINUE
      CALL DCOPY(L3,X(LVECSV1),1,X(LVEC),1)
      CALL MRARBR(
     *     X(LVECSV1),L1,L1,L0MBS,
     *     X(LTRANS),L0MBS,L0MBS,
     *     X(LVEC),L1)
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     L0,L1,L2,
     *     X(LS2),X(LS),X(LVEC),X(LVTORB),
     *     MASWRK,IW)
C------------------------------------------
C------------------------------------------
C
C     PRINT SPLITQA ORBITALS.
      IF(SOME) THEN
        WRITE(IW,9070)
        WRITE(IW,9071) L0MBS
        CALL PRSQL(X(LVEC),L0MBS,L1,L1)
      ENDIF
      IF(MASWRK) THEN
        WRITE(IP,9080)
        CALL PUSQL(X(LVEC),L0MBS,L1,L1)
        WRITE(IP,9085)
      ENDIF
C
C     PRINT BLOCKNOS ORBITALS.
      IF(SCFTYP.EQ.RMC) THEN
      IF(SOME) THEN
        WRITE(IW,9100)
        WRITE(IW,9071) L0
        CALL PRSQL(X(LVECSV1),L0,L1,L1)
      ENDIF
      IF(MASWRK) THEN
        WRITE(IP,9110)
        CALL PUSQL(X(LVECSV1),L0,L1,L1)
        WRITE(IP,9085)
      ENDIF
      ENDIF
C
C     EXTRA PRINT OFF FOR LUKE R. FOR INACTIVES AND VVOS.
      IF(SCFTYP.EQ.RMC) THEN
C
C       RESET BACK TO INTERMEDIATE ORMAS GROUPS... NOT THE LAST.
        NSPACE=NSPACE_INT
        CALL ICOPY(ISIZE_FCCWFN,X(LMSTA_INT),1,MSTA,1)
C
C       SETUP THE GROUPS IN AN INTEGER ARRAY FOR THE NEXT CALL.
        CALL VICLR(X(LWRK),1,L1)
        DO IG=1,NSPACE
          DO I=MSTA(IG),MSTA(IG+1)-1
            CALL ICOPY(1,IG,1,X(LWRK+I-1),1)
          ENDDO
        ENDDO
C
C       GET OUT THE ORBITALS IN A DIFFERENT ORDER.
        ISHFT=0
        CALL LOCAL_LUKE_PRTGRPS(
     *       ISHFT,
     *       L1,L3,ISHFT,ISHFT,ISHFT,L0MBS,NSPACE,
     *       X(LWRK),
     *       X(LVEC),X(LQ))
C
C       RESET BACK TO ORIGINAL ORMAS GROUPS.
        CALL ICOPY(ISIZE_FCCWFN,X(LMSTA_SAV),1,MSTA,1)
        NSPACE=NSPACE_SAV
      ENDIF
C------------------------------------------
C------------------------------------------
C
C     NOW, WRITE TO DAF71.
C     --LOCAL_NOS_EXT VERSIONS PICK UP DAF534.
C     --LOCAL_EXT_LMO(2) PUTS ORBITALS FROM DAF71 INTO DAF534.
C     --LOCAL_LCAO_WGTS USES DAF534 FOR EXTLOC SITUATIONS.
      CALL DAWRIT(IDAF,IODA,X(LVEC),L3,71,0)
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED)
C
C     FINISH UP.
 8999 CONTINUE
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_SPLITQA NOW LOCALIZES ORBITALS ONTO'/
     *   5X,'AS FEW QUAOS AS POSSIBLE.'/
     *   5X,60(1H-))
 9050 FORMAT(/1X,'LOCAL_SPLITQA ERROR:',
     *       /1X,'SCFTYP DOES NOT EXIST YET.')
 9060 FORMAT(/1X,'SPLITQA DENSITY MATRIX')
 9070 FORMAT(//10X,'SPLITQA LOCALIZED ORBITALS')
 9071 FORMAT(10X,I5,1X,'ORBITALS ARE SHOWN.')
 9080 FORMAT('SPLITQA LOCALIZED ORBITALS'/' $VEC')
 9085 FORMAT(' $END')
 9100 FORMAT(//10X,'BLOCKNOS LOCALIZED ORBITALS')
 9110 FORMAT('BLOCKNOS LOCALIZED ORBITALS'/' $VEC')
 9300 FORMAT(1X,'... DONE WITH LOCAL_SPLITQA ...')
      END
C*MODULE LOCAL   *DECK LOCAL_SPLITQA_JACOBI
C> @brief      Forms q.a. split-localized orbitals.
C>
C> @author     Aaron West
C>             -June 28, 2013
C>
C> @details    The canonical orbitals can be expressed in terms of
C>             the oriented q.a. orbitals.  A transformation is developed
C>             that expresses the canonical orbitals in terms of fewest
C>             oriented q.a. orbitals that are of course as large as possible.
C>
C> @param TRANS   will hold the final orbital transformation.
C> @param VTORB   is the orbital transformation between
C>                the oriented q.a. and canonical orbitals from DAF538.
C> @param NOROT   is the index array that holds allowed Jacobi rotations.
C>                =0 means the rotation is permitted.
C>                =1 means the rotation is not permitted.
C> @param L1      is the length of the AO coefficients.
C> @param LDMORB  is leading dimension for TRANS and NOROT
C>                and depends on memory.
C> @param MORB    is the total number of orbitals that might
C>                be used in the rotations.
C> @param NCORTOT is the total number of chemical core orbitals.
C> @param CRIT    is the tolerance for convergence.
C> @param MXITER  is allowed maximum iterations.
C> @param ISKIP   skips the block-diagonal form analysis for the orbitals.
C>                ISKIP=0 does NOT skip.
C>                ISKIP=1 does skip.
C> @param SOME    is true for master process with nprint not equal -5.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
C>
      SUBROUTINE LOCAL_SPLITQA_JACOBI(
     *           TRANS,VTORB,NOROT,
     *           L1,LDMORB,MORB,NCORTOT,CRIT,MXITER,ISKIP,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
C-----------------------------------------
      LOGICAL SOME,MASWRK
      DOUBLE PRECISION :: CRIT
      INTEGER L1,LDMORB,MORB,NCORTOT,MXITER,ISKIP,IW
      DOUBLE PRECISION :: VTORB(L1,L1),TRANS(LDMORB,LDMORB)
      INTEGER NOROT(LDMORB,LDMORB)
C-----------------------------------------
      INTEGER I,J,ITER,NUMROT,IERR,IK
      DOUBLE PRECISION ::
     *       Q,QTOL,R2,R3,PIKI,PIKJ,PIKJ2,PIKI2,PIKIJ,
     *       ATAN2,THETA,A,B,TMP,TMP2
C-----------------------------------------
      DOUBLE PRECISION :: ZERO,ONE,TOL2
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TOL2=1.0D-08)
C-----------------------------------------
C
C     DEFINE THE Q VAR.
      QTOL=CRIT*1.0D-02
C
C     MODIFY NOROT TO SKIP I=J ROTATIONS.
      DO I=1,MORB
        NOROT(I,I)=1
      ENDDO
C
C     INTIALIZE ITER AND THE ORBITAL TRANSFORM HERE.
      ITER=0
      CALL VCLR(TRANS,1,LDMORB*LDMORB)
      DO I=1,MORB
        TRANS(I,I)=ONE
      ENDDO
C
C     AT THIS POINT, VTORB MUST BE BLOCK-DIAGONAL.
C     NOTE:  THIS RESULT ACTUALLY MEANS THAT THE SUM
C            OVER IK BELOW IS LEGAL.
      IF(ISKIP.NE.0) GO TO 90
      IERR=0
      DO I=1,NCORTOT
        DO J=NCORTOT+1,L1
          TMP =ABS(VTORB(I,J))
          TMP2=ABS(VTORB(J,I))
          IF(TMP.GT.TOL2.OR.TMP2.GT.TOL2) IERR=IERR+1
          VTORB(I,J)=ZERO
          VTORB(J,I)=ZERO
        ENDDO
      ENDDO
      DO I=NCORTOT+1,MORB
        DO J=MORB+1,L1
          TMP =ABS(VTORB(I,J))
          TMP2=ABS(VTORB(J,I))
          IF(TMP.GT.TOL2.OR.TMP2.GT.TOL2) IERR=IERR+1
          VTORB(I,J)=ZERO
          VTORB(J,I)=ZERO
        ENDDO
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9020)
        IF(MASWRK) WRITE(IW,9100)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     PRINT START OF JACOBI ROTATIONS.
   90 CONTINUE
      IF(SOME) WRITE(IW,9000)
      IF(SOME) WRITE(IW,9010)
C
C     LOOP OVER PAIRS OF ORBITALS.
  100 CONTINUE
      NUMROT=0
      ITER = ITER + 1
C----------------------------------------------
C----------------------------------------------
      DO 8000 I=1,MORB
        DO 7000 J=I+1,MORB
          IF(NOROT(I,J).EQ.1) GO TO 7000
C----------------------------------------------
C----------------------------------------------
C
C         OBTAIN ROTATION ANGLE.
          R2=ZERO
          R3=ZERO
          DO 6000 IK=1,MORB
            PIKI=VTORB(IK,I)
            PIKJ=VTORB(IK,J)
            PIKI2 = PIKI*PIKI
            PIKJ2 = PIKJ*PIKJ
            PIKIJ = PIKI*PIKJ
C
            R2 = R2 + PIKI2*PIKI2
     *              - 6.0D+00*PIKI2*PIKJ2
     *              + PIKJ2*PIKJ2
            R3 = R3 + PIKI2*PIKIJ - PIKJ2*PIKIJ
C
 6000          CONTINUE
C
          R2 = (R2/4.0D+00)
          Q = SQRT(R2*R2 + R3*R3)
          IF (Q.LT.QTOL) GO TO 7000
          THETA = (ATAN2((R3/Q),(R2/Q)))/4.0D+00
C
C         CHECK IF THE ROTATION IS WORTH EXECUTING.
          IF(ABS(THETA).LT.CRIT) GOTO 7000
C
C         UPDATE TRANSFORMATION.
C         UPDATE D COEFFICIENTS. I.E. VTORB.
          NUMROT = NUMROT + 1
          A = COS(THETA)
          B = -SIN(THETA)
          CALL ADJTR(I,J,L1,A,B,VTORB)
          CALL ADJTR(I,J,LDMORB,A,B,TRANS)
C
C----------------------------------------------
C----------------------------------------------
 7000     CONTINUE
 8000   CONTINUE
C----------------------------------------------
C----------------------------------------------
C
      IF(ITER.GT.MXITER) THEN
        IF(MASWRK) THEN
          WRITE(IW,9020)
          WRITE(IW,9030) MXITER
        ENDIF
         CALL FLSHBF(IW)
         CALL ABRT
      ENDIF
C
C  IF THERE WERE ANY ROTATIONS, DO ANOTHER SWEEP.
C
      IF (NUMROT.GT.0) GOTO 100
C
      IF(MASWRK) THEN
        WRITE(IW,9000)
        WRITE(IW,9040) ITER
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_SPLITQA_JACOBI:')
 9010 FORMAT(1X,'BEGIN SPLITQA JACOBI ROTATIONS.')
 9020 FORMAT(/1X,'LOCAL_SPLITQA_JACOBI ERROR:')
 9030 FORMAT(1X,'ORBITALS NOT CONVERGED AFTER ',I10,' ITERS.')
 9040 FORMAT(1X,' -- NUMBER OF SWEEPS REQUIRED FOR CONVERGENCE =',I5)
 9100 FORMAT(1X,'BLOCK DIAGONAL FORM OF VTORB IS INCORRECT.')
      END
C*MODULE LOCAL   *DECK LOCAL_LINEQ_ATOM
C> @brief      Reorders atomic linear equations.
C>
C> @author     Aaron West
C>             -October 22, 2013
C>
C> @param NAT     is the number of atoms.
C> @param IORDAT  holds the reordering instructions.
C> @param DMAT    is the matrix with dimension of NATxNAT.
C> @param FRHS    is the right hand side of NATx1.
C> @param ATSCR   is a scratch array of dimensions NATx(NAT+1)
C> @param RESID   will hold the solution to solving linear equation.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_LINEQ_ATOM(
     *           NAT,IORDAT,
     *           DMAT,FRHS,ATSCR,RESID,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IW,
     *        NAT
      INTEGER IORDAT(NAT)
      DOUBLE PRECISION ::
     *       DMAT(NAT,NAT),FRHS(NAT),ATSCR(NAT,NAT+1),
     *       RESID
C
      INTEGER I,J,IERR
      DOUBLE PRECISION :: TMP
C
C     CHECK ATOM LABELS.
C     NOTE1:  RUN HAS ALREADY BOMBED IF LESS THAN 2 ATOMS.
C     NOTE2:  VAR TYPES ARE NOT VIOLATED INSIDE OF ROUTINES.
      CALL ICOPY(NAT,IORDAT,1,ATSCR,1)
      CALL ICOPY(NAT,IORDAT,1,ATSCR(1,2),1)
      CALL IREORDR(ATSCR,ATSCR(1,2),NAT,1)
C
C     GRAB MAX RESIDUAL AND CHECK CONVERGENCE.
      RESID=ABS(FRHS(1))
      DO I=1,NAT
        TMP=ABS(FRHS(I))
        RESID=MAX(RESID,TMP)
      ENDDO
C
C     SHIFT EQUATION.
      CALL VCLR(ATSCR,1,NAT*(NAT+1))
      CALL DCOPY(NAT,FRHS,1,ATSCR(1,NAT+1),1)
      CALL DCOPY(NAT*NAT,DMAT,1,ATSCR,1)
      DO I=1,NAT
        FRHS(I)=ATSCR(IORDAT(I),NAT+1)
        DO J=1,NAT
          DMAT(I,J)=ATSCR(IORDAT(I),IORDAT(J))
        ENDDO
      ENDDO
      CALL VCLR(ATSCR,1,NAT*(NAT+1))
C
C     SOLVE DMAT * X = FRHS LINEAR EQUATION.
      IERR=0
      CALL SLVLEQ(DMAT,FRHS,ATSCR,NAT-1,NAT,0,IERR)
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9005)
        CALL FLSHBF(IW)
        CALL ABRT
         STOP
      ENDIF
C
C     SHIFT RESULTS BACK.
      CALL VCLR(ATSCR,1,NAT*(NAT+1))
      CALL DCOPY(NAT,FRHS,1,ATSCR(1,NAT+1),1)
      CALL DCOPY(NAT*NAT,DMAT,1,ATSCR,1)
      DO I=1,NAT
        FRHS(IORDAT(I))=ATSCR(I,NAT+1)
        DO J=1,NAT
          DMAT(IORDAT(I),IORDAT(J))=ATSCR(I,J)
        ENDDO
      ENDDO
      CALL VCLR(ATSCR,1,NAT*(NAT+1))
C
      RETURN
 9005 FORMAT(/1X,'LOCAL_ATOM_LINEQ ERROR:',
     *       /1X,'ERROR IN SMALL LINEAR EQUATION.')
      END
C*MODULE LOCAL   *DECK LOCAL_SVDORB_VARS
C> @brief      Sets up several orbital dimensions for SVD.
C>
C> @author     Aaron West
C>             -November 25, 2013
C>
C> @param L0       denotes the variational spherical MOs.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param L3       is the square of L1.
C> @param NCORTOT  is the number of chemical core orbitals.
C> @param IMBS     is the number of valance MBS orbitals.
C> @param IMBS2    is the triangular size of IMBS.
C> @param L0MBS    is the number of MBS orbitals.
C> @param L2MBS    is the triangular size of L0MBS.
C> @param NAOTOT   is the true number of sphericals.is the
C> @param NAOTRI   is the triangular size of the NAOTOT.
      SUBROUTINE LOCAL_SVDORB_VARS(
     *           L0,L1,L2,L3,
     *           NCORTOT,IMBS,IMBS2,L0MBS,L2MBS,
     *           NAOTOT,NAOTRI)
      IMPLICIT NONE
      INTEGER L0,L1,L2,L3,
     *        NCORTOT,IMBS,IMBS2,L0MBS,L2MBS,
     *        NAOTOT,NAOTRI
C----------------------------------------------------------------------
      DOUBLE PRECISION :: C,ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C-----------------------------------------------------------------------
      INTEGER MXATM
      PARAMETER (MXATM=2000)
C----------------------------------------------------------------------
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C----------------------------------------------------------------------
      INTEGER ISWMBS,I,LOCAL_NUMVAL,NVVOS_NUMCOR,
     *        NAOCART,NAOSPH
C
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
      IMBS=0
      ISWMBS=1
      DO I=1,NAT
        IMBS=IMBS+LOCAL_NUMVAL(I,ISWMBS)
      ENDDO
      NCORTOT=NVVOS_NUMCOR(0,0)
      L0MBS=IMBS+NCORTOT
      IMBS2=(IMBS*IMBS+IMBS)/2
      L2MBS=(L0MBS*L0MBS+L0MBS)/2
C
      NAOTOT=0
      DO I=1,NAT
        CALL LOCAL_COUNTAOS(I,NAOCART,NAOSPH)
        NAOTOT=NAOTOT+NAOSPH
      ENDDO
      NAOTRI=(NAOTOT*NAOTOT+NAOTOT)/2
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_SQMAT_INV
C> @brief      Convenient routine for inverting square matrix.
C>
C> @author     Aaron West
C>             -January 10, 2014
C>
C> @note       Use MALMQ_TORB to get the transformation.
C>             Use LOCAL_SQMAT_INV to invert that transformation.
C>             Then, generally transform a density matrix.
C>
C> @param TRANS  NORBxNORB matrix to be inverted with L1 lead dim.
C> @param WRK    is L1 work matrix.
C> @param IWRK   is L1 integer work matrix.
C> @param L1     is the LCAO length.
C> @param NORB   is size of matrix to be inverted.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
C>
      SUBROUTINE LOCAL_SQMAT_INV(
     *           TRANS,WRK,IWRK,L1,NORB,
     *           MASWRK,IW)
C-----------------------------------------------------------------------
      IMPLICIT NONE
C     VARS
      LOGICAL MASWRK
      INTEGER IW,
     *        L1,NORB
      DOUBLE PRECISION RCOND
C-----------------------------------------------------------------------
      INTEGER IWRK(L1)
      DOUBLE PRECISION ::
     *       TRANS(L1,NORB),WRK(L1),DET(2)
C
C     FORM TRANS-INV
      CALL DGECO(TRANS,L1,NORB,IWRK,RCOND,WRK)
      CALL DGEDI(TRANS,L1,NORB,IWRK,DET,WRK,01)
C
C     ERROR OUT IF RCOND TOO SMALL.
      IF(RCOND.LT.1.0D-10) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9000 FORMAT(1X,'PROBLEM IN LOCAL_SQMAT_INV ROUTINE.')
      END
C*MODULE LOCAL   *DECK LOCAL_MODELORB_DRIV
C> @brief      Driver for maximizing SVD orbital projection onto AAMBS.
C>
C> @author     Aaron West
C>             -February 14, 2014
C>
C> @details    We interupt the SVD process in mid-stream.
C>             Then, we piece it back together by modifying the
C>                   orthogonalizing matrix.
C>
C> @param KEEPER     is a logical and is true when
C>                   CISTEP=ORMAS + NSPACE>1 + ORMFUL=.FALSE.
C>                   SCFTYP=RHF
C> @param IORBF1     gives daf dict file with starting orbitals.
C> @param L1DIM      is L1 for LCAOs.
C> @param NACTDEP    is the number of active orbitals where
C>                   CLINDEP is taken into account.
C> @param L0DEP0     is the number of active orbitals where
C>                   CLINDEP is taken into account.
C>                   Note:  For some calls, maybe value is not
C>                          yet returned to the common.
C> @param IATLAB     is the integer array that holds the atom labels.
C>                   Here it is for the active orbitals.
C> @param VTMP       is the orthogonalizing transformation
C>                   for the symmetric orthogonalization
C>                   for the nonorthogonal SVD orbitals.
      SUBROUTINE LOCAL_MODELORB_DRIV(
     *           KEEPER,IORBF1,L1DIM,NACTDEP,L0DEP0,
     *           IATLAB,VTMP)
      IMPLICIT NONE
      LOGICAL SOME,KEEPER
      INTEGER IORBF1,L1DIM,NACTDEP,L0DEP0
      INTEGER IATLAB(L1DIM)
      DOUBLE PRECISION :: VTMP(L1DIM,L1DIM)
C---------------------------------------------------------------------
      LOGICAL DWNSHT_ACT,DWNSHT_ATOM
      INTEGER LOADFM,LAST,NEED,
     *        LS,LVEC,LTRANS,LVWRK1,LVWRKO,LAMBSOV,LIWRK,
     *        LTRANSJ,
     *        LIPOSMBS,LILENMBS
      INTEGER L0,L1,L2,L3,
     *        NCORTOT,IMBS,IMBS2,L0MBS,L2MBS,
     *        NAOTOT,NAOTRI,
     *        MORB,
     *        ISHFT1,I,IPOS,
     *        MXITER,
     *        NERR,IDUM1,IDUM2
      DOUBLE PRECISION ::
     *       CRIT
C---------------------------------------------------------------------
      DOUBLE PRECISION :: X
C
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
      DOUBLE PRECISION :: C,ZAN
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C----------------------------------------------------------------------
      INTEGER MXATM
      PARAMETER (MXATM=2000)
C---------------------------------------------------------------------
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C---------------------------------------------------------------------
C
C     DEFINE PRINT STUFF
      SOME = NPRINT.NE.-5 .AND. MASWRK
C
C     PRINT BANNER.
      IF(SOME) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C     SET UP SOME ORBITAL DIMENSIONS
      CALL LOCAL_SVDORB_VARS(
     *     L0,L1,L2,L3,
     *     NCORTOT,IMBS,IMBS2,L0MBS,L2MBS,
     *     NAOTOT,NAOTRI)
C
C     SET THE MORB VAR.
      MORB=IMBS
      NERR=NACTDEP
C
C     OBTAIN MEMORY.
      CALL VALFM(LOADFM)
      LS        = LOADFM    + 1
      LVEC      = LS        + L2
      LTRANS    = LVEC      + L3
      LVWRK1    = LTRANS    + L3
      LVWRKO    = LVWRK1    + L3
      LAMBSOV   = LVWRKO    + L3
      LIWRK     = LAMBSOV   + L3
      LTRANSJ   = LIWRK     + L3
      LIPOSMBS  = LTRANSJ   + MORB*MORB
      LILENMBS  = LIPOSMBS  + NAT+1
      LAST      = LILENMBS  + NAT
      NEED      = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
C     READ CORE-CORE 523,524.
C     READ ACT-ACT VTMP.
      CALL DAREAD(IDAF,IODA,X(LVWRK1),L3,523,0)
      CALL DAREAD(IDAF,IODA,X(LVWRKO),L3,524,0)
      DO I=1,MORB
        ISHFT1=L1*(NCORTOT+I-1)+NCORTOT
        CALL DCOPY(MORB,VTMP(1,I),1,X(LVWRKO+ISHFT1),1)
      ENDDO
C
C     CONSTRUCT SYM.ORTHOG.SVD ORBITALS.
      CALL VCLR(X(LTRANS),1,L3)
      CALL MRARBR(X(LVWRK1),L1,L0,L0,
     *            X(LVWRKO),L1,L0,
     *            X(LTRANS),L1)
      CALL DAREAD(IDAF,IODA,X(LVWRK1),L3,IORBF1,0)
      CALL VCLR(X(LVEC),1,L3)
      CALL MRARBR(X(LVWRK1+L1*NCORTOT),L1,L1,MORB,
     *            X(LTRANS+L1*NCORTOT+NCORTOT),L1,MORB,
     *            X(LVEC),L1)
C
C     CHECK THE SYM.ORTHOG.SVD ORBITALS.
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     MORB,L1,L2,
     *     X(LVWRK1),X(LS),X(LVEC),X(LVWRKO),
     *     MASWRK,IW)
C
C     CONSTRUCT <SYM.ORTHOG.SVD | AAMBS> OVERLAP
C     FOR FIRST JACOBI PAIR.
      CALL VCLR(X(LVWRKO),1,L3)
      CALL DAREAD(IDAF,IODA,X(LVWRKO),L1*L0MBS,533,0)
      CALL VCLR(X(LAMBSOV),1,L3)
      CALL MRTRBR(X(LVEC),L1,L1,MORB,
     *            X(LVWRKO),L1,L0MBS,
     *            X(LAMBSOV),L1)
C
C     SETUP VALENCE AAMBS POSITIONS AND LENGTHS.
      CALL LOCAL_VVOS_ORB_RANGE(X(LIPOSMBS),X(LILENMBS),NAT)
C
C     SETUP IWRK ARRAY FOR JACOBI ROTATIONS.
      DWNSHT_ACT=.TRUE.
      DWNSHT_ATOM=.TRUE.
      CALL LOCAL_SVD_SETUPNOROT(
     *     KEEPER,DWNSHT_ACT,DWNSHT_ATOM,
     *     L1,MORB,L0DEP0,
     *     IATLAB,X(LIWRK))
C
C     PERFORM FOURTH-POWER DENSITY MATRIX MINIMIZATION.
      CRIT=1.0D-10
      MXITER=10000
      CALL LOCAL_MODELORB_JACOBI(
     *     NAT,L1,MORB,L0MBS,MXITER,
     *     X(LIWRK),IATLAB,X(LIPOSMBS),X(LILENMBS),
     *     CRIT,X(LVEC),X(LVWRKO),X(LAMBSOV),
     *     X(LTRANSJ),
     *     SOME,MASWRK,IW)
      CALL VCLR(X(LVEC),1,L3)
C
C     ADD THE FINAL ORTHOGONAL TRANSFORM ONTO THE ACT-ACT
C     SYM.ORTHOG. TRANSFORM THAT SITS IN THE VTMP...
      CALL DCOPY(L3,VTMP,1,X(LVWRK1),1)
      CALL MRARBR(X(LVWRK1),L1,MORB,MORB,
     *            X(LTRANSJ),MORB,MORB,
     *            VTMP,L1)
C
C     CHECK ORBITAL ATOM ORDER.
      NERR=0
      CALL LOCAL_MAXCOIN(MORB,X(LIWRK),VTMP,L1)
      DO I=1,MORB
        CALL ICOPY(1,X(LIWRK+I-1),1,IPOS,1)
        IDUM1=IATLAB(I)
        IDUM2=IATLAB(IPOS)
        IF(IDUM1.NE.IDUM2) NERR=NERR+1
      ENDDO
      IF(NERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9020)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     ALWAYS PRESERVE ORIGINAL ORDERING
      CALL REORDR(VTMP,X(LIWRK),MORB,L1)
C
C     FINISH UP.
      CALL RETFM(NEED)
      IF(SOME) WRITE(IW,9300)
      CALL FLSHBF(IW)
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'ENTER LOCAL_MODELORB_DRIV.'/
     *   5X,60(1H-))
 9020 FORMAT(/1X,'LOCAL_MODELORB_DRIV ERROR:',
     *       /1X,'ATOM ORDER IS WRONG.')
 9300 FORMAT(1X,'... DONE WITH LOCAL_MODELORB_DRIV ...')
      END
C*MODULE LOCAL   *DECK LOCAL_SVD_SETUPNOROT
C> @brief      Sets up the orbital rotation table for Jacobi rotations.
C>
C> @author     Aaron West
C>             -February 14, 2014
C>
C> @param KEEPER      is a logical and is true when
C>                    CISTEP=ORMAS + NSPACE>1 + ORMFUL=.FALSE.
C>                    SCFTYP=RHF
C> @param DWNSHT_ACT  downshifts the indices to active indices.
C> @param DWNSHT_ATOM remove intra-atomic rotations.
C> @param L1          is the length of the AO coefficients.
C> @param MORB        is the number of orbitals in the future
C>                    jacobi rotations.
C>                    MORB is mean't to flexible as
C>                    active or total index.  So, take care.
C> @param L0DEP0      is the number of CLINDEP variational MOs.
C> @param IATLAB      is the integer array that holds the atom labels.
C>                    Here it is for the active orbitals.
C> @param IWRK        will hold the integer orbital rotation table.
      SUBROUTINE LOCAL_SVD_SETUPNOROT(
     *           KEEPER,DWNSHT_ACT,DWNSHT_ATOM,
     *           L1,MORB,L0DEP0,
     *           IATLAB,IWRK)
      IMPLICIT NONE
      LOGICAL KEEPER,DWNSHT_ACT,DWNSHT_ATOM
      INTEGER L0,L1,MORB,L0DEP0
      INTEGER IATLAB(L1),IWRK(L1,L1)
C---------------------------------------------------------------------
      INTEGER L3,NCORTOT,NVVOS_NUMCOR,I,J,IPOS,JPOS,
     *        ISPACE,JSPACE,JORB1,JORB2,KORB1,KORB2
C---------------------------------------------------------------------
      LOGICAL FDIRCT,QCORR
      DOUBLE PRECISION :: C0SQ
      INTEGER NSPACE,MSTA,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,IBMA,
     *        IDIMFCC,LBST,NREF0
C
      DOUBLE PRECISION :: C,ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C---------------------------------------------------------------------
      INTEGER MXATM
      PARAMETER (MXATM=2000)
C---------------------------------------------------------------------
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C---------------------------------------------------------------------
C
C     INIT. STUFF.
      NCORTOT=NVVOS_NUMCOR(0,0)
      L3=L1*L1
      CALL VICLR(IWRK,1,L3)
      L0=NQMT
C
C     SETUP NOROT FOR ORMAS GROUPS.
C     NOTE:  PERFORM SETUP INSIDE OF ACTIVE ORBITAL INDICES.
      DO 1000 ISPACE=1,NSPACE
        IF(KEEPER) THEN
          JORB1=MSTA(ISPACE)
          IF(DWNSHT_ACT) JORB1=JORB1-MSTA(1)+1
          JORB2=MSTA(ISPACE+1)-1
          IF(JORB2.EQ.L0) JORB2=L0DEP0
          IF(DWNSHT_ACT) JORB2=JORB2-MSTA(1)+1
        ELSE
          JORB1=NCORTOT+1
          IF(DWNSHT_ACT) JORB1=1
          JORB2=L0DEP0
          IF(DWNSHT_ACT) JORB2=MORB
        ENDIF
        IF(JORB1.GT.MORB) GO TO 1000
        DO 1010 JSPACE=1,NSPACE
          IF(ISPACE.EQ.JSPACE) GO TO 1010
          IF(KEEPER) THEN
            KORB1=MSTA(JSPACE)
            IF(DWNSHT_ACT) KORB1=KORB1-MSTA(1)+1
            KORB2=MSTA(JSPACE+1)-1
            IF(KORB2.EQ.L0) KORB2=L0DEP0
            IF(DWNSHT_ACT) KORB2=KORB2-MSTA(1)+1
          ELSE
            KORB1=NCORTOT+1
            IF(DWNSHT_ACT) KORB1=1
            KORB2=L0DEP0
            IF(DWNSHT_ACT) KORB2=MORB
          ENDIF
          IF(KORB1.GT.MORB) GO TO 1010
          DO I=JORB1,JORB2
            DO J=KORB1,KORB2
              IWRK(I,J)=1
              IWRK(J,I)=1
            ENDDO
          ENDDO
 1010   CONTINUE
 1000 CONTINUE
C
C     SETUP NOROT FOR ONLY INTER-ATOMIC ROTATIONS.
C     NOTE TO USER:  DO NOT USE UNLESS YOU CHECK THIS PIECE.
      IF(DWNSHT_ATOM) THEN
        DO 1020 I=1,MORB
          DO 1030 J=1,MORB
            IPOS=IATLAB(I)
            JPOS=IATLAB(J)
            IF(IPOS.NE.JPOS) GO TO 1030
            IWRK(I,J)=1
            IWRK(J,I)=1
 1030     CONTINUE
 1020   CONTINUE
      ENDIF
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_MODELORB_JACOBI
C> @brief      Maximizes SVD orbital projection onto AAMBS.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -February 14, 2014
C>
C> @param NAT      is the number of atoms.
C> @param L1       is the length of AO coefficients.
C> @param MORB     is the number of valence orbitals in the jacobi.
C> @param L0MBS    is the number of minimal basis valence orbitals.
C> @param MXITER   is the number of maximum iterations.
C> @param NOROT    is the integer orbital rotation table.
C> @param IATLAB   contains the atom lables for orbitals.
C>                 Here it is for valence orbitals.
C> @param IPOSMBS  contains the starting valence position for
C>                 AAMBS orbitals on each atom.
C> @param ILENMBS  contains the number of AAMBS valence orbitals on a
C>                 given atom.
C> @param CRIT     is the convergence tolerance.
C> @param VEC      holds the LCAO coefficients.
C> @param VWRKO    holds the overlap between the working
C>                 basis functions and the AAMBS orbitals.
C> @param AMBSOV   holds and will hold updated orbital overlaps
C>                 between current molecular orbitals and AAMBS.
C> @param TRANS    will hold the final orbital transformation.
C> @param SOME    is true for master process with nprint not equal -5.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_MODELORB_JACOBI(
     *           NAT,L1,MORB,L0MBS,MXITER,
     *           NOROT,IATLAB,IPOSMBS,ILENMBS,
     *           CRIT,VEC,VWRKO,AMBSOV,
     *           TRANS,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
C-----------------------------------------
      LOGICAL SOME,MASWRK
      INTEGER IW,
     *        NAT,L1,MORB,L0MBS,MXITER
      INTEGER NOROT(L1,L1),IATLAB(L1),IPOSMBS(NAT+1),ILENMBS(NAT)
      DOUBLE PRECISION ::
     *       CRIT,
     *       VEC(L1,L1),VWRKO(L1,L0MBS),AMBSOV(L1,L0MBS),
     *       TRANS(MORB,MORB)
C-----------------------------------------
      INTEGER ITER,NUMROT,
     *        IROT,JROT,
     *        IATA,IATB,ILENA,ILENB,IBEGA,IBEGB,IENDA,IENDB,IPOS
      DOUBLE PRECISION ::
     *       PI,TMP,TMP2,THETA,A,B,
     *       TC,TD,TF,RAD,ACOS,ATAN2
C-----------------------------------------
      DOUBLE PRECISION :: ZERO,HALF,ONE,TWO
      PARAMETER (ZERO=0.0D+00,HALF=0.5D+00,ONE=1.0D+00,TWO=2.0D+00)
C-----------------------------------------
C
C     DEFINE PI.
      PI=ACOS(-1.0D+00)
C
C     MODIFY NOROT TO SKIP I=J ROTATIONS.
      DO IROT=1,MORB
        NOROT(IROT,IROT)=1
      ENDDO
C
C     INTIALIZE ITER AND THE ORBITAL TRANSFORM HERE.
      ITER=0
      CALL VCLR(TRANS,1,MORB*MORB)
      DO IROT=1,MORB
        TRANS(IROT,IROT)=ONE
      ENDDO
C
C     PRINT START OF JACOBI ROTATIONS.
      IF(SOME) WRITE(IW,9000)
      IF(SOME) WRITE(IW,9010)
C
C     LOOP OVER PAIRS OF ORBITALS.
  100 CONTINUE
      NUMROT=0
      ITER = ITER + 1
C----------------------------------------------
C----------------------------------------------
      DO 8000 IROT=1,MORB
        DO 7000 JROT=IROT+1,MORB
          IF(NOROT(IROT,JROT).EQ.1) GO TO 7000
C----------------------------------------------
C----------------------------------------------
C
C         SETUP VARIOUS ARRAYS.
          IATA=IATLAB(IROT)
          IATB=IATLAB(JROT)
          ILENA=ILENMBS(IATA)
          ILENB=ILENMBS(IATB)
          IBEGA=IPOSMBS(IATA)
          IBEGB=IPOSMBS(IATB)
          IENDA=IBEGA+ILENA-1
          IENDB=IBEGB+ILENB-1
C
C         CONSTRUCT THE TERMS.
          TC=ZERO
          TD=ZERO
          TF=ZERO
          DO IPOS=IBEGA,IENDA
            TC=TC+HALF*AMBSOV(IROT,IPOS)**2+HALF*AMBSOV(JROT,IPOS)**2
            TD=TD+HALF*AMBSOV(IROT,IPOS)**2-HALF*AMBSOV(JROT,IPOS)**2
            TF=TF+AMBSOV(IROT,IPOS)*AMBSOV(JROT,IPOS)
          ENDDO
          DO IPOS=IBEGB,IENDB
            TC=TC+HALF*AMBSOV(JROT,IPOS)**2+HALF*AMBSOV(IROT,IPOS)**2
            TD=TD+HALF*AMBSOV(JROT,IPOS)**2-HALF*AMBSOV(IROT,IPOS)**2
            TF=TF-AMBSOV(JROT,IPOS)*AMBSOV(IROT,IPOS)
          ENDDO
C
C         SOLVE FOR ROTATION ANGLE.
          RAD=SQRT(TD*TD+TF*TF)
          IF(ABS(RAD).LT.CRIT) GO TO 7000
          TMP=TD/RAD
          TMP2=TF/RAD
          THETA = ATAN2(TMP2,TMP)/TWO
          IF(ABS(THETA).LT.CRIT) GOTO 7000
          IF(ABS(THETA).GT.PI/TWO) THEN
            IF(MASWRK) WRITE(IW,9015)
            CALL FLSHBF(IW)
            CALL ABRT
            STOP
          ENDIF
C
CCCCC         CONSTRUCT THE FINAL TERM JUST IN CASE.
CCCC          TMP=TC+TD*COS(TWO*THETA)+TF*SIN(TWO*THETA)
C
C         UPDATE TRANSFORMATION.
C         UPDATE DENSITY MATRIX.
C         UPDATE THE AAMBS OVERLAPS.
          NUMROT = NUMROT + 1
          A = COS(THETA)
          B = -SIN(THETA)
          CALL ADJTR(IROT,JROT,MORB,A,B,TRANS)
          CALL ADJTR(IROT,JROT,L1,A,B,VEC)
          CALL MRTRBR(VEC,L1,L1,MORB,
     *                VWRKO,L1,L0MBS,
     *                AMBSOV,L1)
C----------------------------------------------
C----------------------------------------------
 7000     CONTINUE
 8000   CONTINUE
C----------------------------------------------
C----------------------------------------------
C
      IF(ITER.GT.MXITER) THEN
        IF(MASWRK) THEN
          WRITE(IW,9020)
          WRITE(IW,9030) MXITER
        ENDIF
         CALL FLSHBF(IW)
         CALL ABRT
      ENDIF
C
C  IF THERE WERE ANY ROTATIONS, DO ANOTHER SWEEP.
C
      IF (NUMROT.GT.0) GOTO 100
C
      IF(MASWRK) THEN
        WRITE(IW,9000)
        WRITE(IW,9040) ITER
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_MODELORB_JACOBI:')
 9010 FORMAT(1X,'BEGIN LOCAL_MODELORB_JACOBI JACOBI ROTATIONS.')
 9015 FORMAT(/1X,'LOCAL_MODELORB_JACOBI:',
     *       /1X,'THETA MUST BE WITHIN CERTAIN LIMITS.')
 9020 FORMAT(/1X,'LOCAL_MODELORB_JACOBI ERROR:')
 9030 FORMAT(1X,'ORBITALS NOT CONVERGED AFTER ',I10,' ITERS.')
 9040 FORMAT(1X,' -- NUMBER OF SWEEPS REQUIRED FOR CONVERGENCE =',I5)
      END
C*MODULE LOCAL   *DECK LOCAL_MAXCOIN
C> @brief      Find max. coincidence of orbital overlap.
C>
C> @author     Aaron West and Mike Schmidt
C>             -February 14, 2014
C>
C> @details   This routine is taken from OVLSEL.
C>            It finds the max. coincidence of orbital overlap
C>            given an orbital transformation.
C>
C> @param L0LIM   is the number of orbitals considered.
C> @param IWRK    will hold the orbital reordering instructions.
C> @param SMO     is the orbital transformation upon entry.
C> @param L1      is the leading dimension of SMO.
      SUBROUTINE LOCAL_MAXCOIN(L0LIM,IWRK,SMO,L1)
      IMPLICIT NONE
      INTEGER L1,L0LIM
      INTEGER IWRK(L0LIM)
      DOUBLE PRECISION :: SMO(L1,L0LIM)
C---------------------------------------------------------------------
      INTEGER I,J,K
      DOUBLE PRECISION :: SMAX,SS,ZERO
      PARAMETER(ZERO=0.0D+00)
C---------------------------------------------------------------------
      DO 290 I=1,L0LIM
         SMAX = ZERO
         IWRK(I) = 0
         DO 230 J=1,L0LIM
            DO 210 K=1,I
               IF(IWRK(K).EQ.J) GO TO 230
  210       CONTINUE
            SS = ABS(SMO(I,J))
            IF(SS.GT.SMAX) THEN
               SMAX = SS
               IWRK(I) = J
            END IF
  230    CONTINUE
  290 CONTINUE
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_SVD_CHKSYM
C> @brief      Checks for valid symmetry during a SVD determinant run.
C>
C> @author     Aaron West
C>             -February 14, 2014
C> @param OKSYM_SVDDET  is the output logical for checking symmetry.
      SUBROUTINE LOCAL_SVD_CHKSYM(OKSYM_SVDDET)
      LOGICAL OKSYM_SVDDET
C---------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       CRIT,DWPARM,GLIST,GRPDET,PRTTOL,SDET,SPINS,SZDET,
     *       WSTATE,STSYM,FSTATE
      INTEGER MXRT,IDWEIGH,IGPDET,IPURES,IROOT,IWTS,KDET,KSTDET,
     *        KSTSYM,MAXP,MAXW1,NACTDT,NADET,NBDET,NCI,NCOR,NCORSV,
     *        NFLGDM,NFTGCI,NITDET,NORBDT,IFTS
C
      DOUBLE PRECISION :: T
      INTEGER MAPSHL,MAPCTR,INVT,NT
C---------------------------------------------------------------------
      PARAMETER(MXATM=2000, MXRT=100, MXSH=5000)
C---------------------------------------------------------------------
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,SDET,SZDET,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACTDT,NORBDT,
     *                NADET,NBDET,KDET,KSTDET,IROOT,IPURES,MAXW1,NITDET,
     *                MAXP,NCI,IGPDET,KSTSYM,NFTGCI,IDWEIGH,
     *                fstate(mxrt),ifts(mxrt)
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
C---------------------------------------------------------------------
      DOUBLE PRECISION :: FANT(8)
      DATA FANT/8HC1      ,8HCI      ,8HCS      ,8HC2      ,
     *          8HD2      ,8HC2V     ,8HC2H     ,8HD2H     /
C---------------------------------------------------------------------
      OKSYM_SVDDET=.FALSE.
      IF(GRPDET.EQ.FANT(1).AND.NT.EQ.1) OKSYM_SVDDET=.TRUE.
C     NOTE:  GRPDET MUST BE C1 FROM THE START FOR THESE KINDS OF RUNS.
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_AIMSVD
C> @brief      Driver for all SVD manipulations past SVD formation.
C>
C> @author     Aaron West
C>             -February 14, 2014
C>
C> @param IORBF1 indicates daf dict file with starting orbitals
C>               from which the localized orbitals are formed.
      SUBROUTINE LOCAL_AIMSVD(IORBF1)
      IMPLICIT NONE
      LOGICAL SOME,OK,REDO_INT
      INTEGER IORBF1,IORBF2
C---------------------------------------------------------------------
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
      INTEGER ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
C
      LOGICAL DIRSCF,FDIFF
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      DOUBLE PRECISION :: T
      INTEGER MAPSHL,MAPCTR,INVT,NT
C
      LOGICAL DIRTRF
      DOUBLE PRECISION :: CUTTRF
      INTEGER NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF
C---------------------------------------------------------------------
      INTEGER MXATM,MXSH
      PARAMETER (MXATM=2000, MXSH=5000)
C---------------------------------------------------------------------
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                T(432),INVT(48),NT
      COMMON /TRFOPT/ CUTTRF,NWDTRF,MPTRAN,ITRFAO,NOSYMT,IPURTF,DIRTRF
C---------------------------------------------------------------------
      NPRINT=-5
      IF(IW.EQ.6) RETURN
C
C     DEFINE PRINT STUFF
      SOME  = NPRINT.NE.-5 .AND. MASWRK
C
C     PRINT BANNER.
      IF(SOME) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C     PERFORM EXITS.
      OK=.TRUE.
      IF(ILOCAL.NE.4) OK=.FALSE.
      IF(.NOT.OK) GO TO 8999
C
C     TURN OFF SYMMETRY AND ADDRESS INTEGRALS.
      REDO_INT=.FALSE.
      IF(.NOT.GOPARR.AND.
     *  (.NOT.DIRSCF.OR..NOT.DIRTRF)) REDO_INT=.TRUE.
      IF(NT.EQ.1) REDO_INT=.FALSE.
      CALL SYMOFF
      IF(REDO_INT) THEN
        IF(SOME) WRITE(IW,9050)
        CALL FLSHBF(IW)
        CALL JANDK
      ENDIF
      CALL SEQREW(IS)
C
C     PERFORM MAIN CALLS.
CKEEP      IORBF1=15 ! ,15,
      IORBF2=71 ! ,71,
      IF(ORIENT) IORBF2=286 ! ,286,
      IF(ENGATM) THEN
      ELSE
        CALL LOCAL_NTDRIV(IORBF1,IORBF2)
      ENDIF
C
C     TURN ON SYMMETRY.
      CALL SYMON
C
C     PUT ALL RETURN LINES BELOW.
 8999 CONTINUE
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_AIMSVD BEGINS.'/
     *   5X,60(1H-))
 9050 FORMAT(/1X,'LOCAL_AIMSVD REQUIRES C1 INTEGRALS.')
 9300 FORMAT(1X,'... DONE WITH LOCAL_AIMSVD ...')
      END
C*MODULE LOCAL   *DECK LOCAL_NTDRIV
C> @brief      Driver for coupled NT.
C>
C> @author     Aaron West, Klaus Ruedenberg, Mike Schmidt
C>             -November 01, 2013
C>
C> @details    This driver is for any NT SCF procedure.
C>             The aim is to trick the file system
C>             that is already present for the Malmqvist
C>             so that the Malmqvist can be used for
C>             general purposes.
C>             Coupled runs will eventually be added.
C>             Enjoy...
C>
C> @param IORBF1 indicates daf record with starting orbitals.
C> @param IORBF2 indicates daf record with final orbitals.
      SUBROUTINE LOCAL_NTDRIV(IORBF1,IORBF2)
      IMPLICIT NONE
      LOGICAL SOME,OK,FULLVAL,OKSYM_SVDDET
      INTEGER IORBF1,IORBF2
      DOUBLE PRECISION ::
     *       RMC,ROHF,ORMAS,RHF,RNONE
      INTEGER NGOTMX,LOADFM,LAST,NEEDNT,
     *        LIATPOP,LIGRPPOP,LDENPOP,LDENPOP2,
     *                LATPOP,LATPOP2,LATPOP3
      INTEGER L0,L1,L2,L3,NAOTOT,NAOTRI,
     *        NCORTOT,IMBS,IMBS2,L0MBS,L2MBS
      INTEGER NCORSV,NACTSV,NACTSV2,
     *        MOCC,MTOT,
     *        IBEG1_550,IBEG2_550,
     *        ICIMALMQ,IFILDEN,IFILAT,IFILGRP,
     *        IGRPNUM
C----------------------------------------------------------------------
C
      LOGICAL FDIRCT,QCORR
      INTEGER NSPACE,MSTA,MNUM,MINI,MAXI,IAMI,IAMA,IBMI,IBMA,
     *        IDIMFCC,LBST,NREF0
      DOUBLE PRECISION :: C0SQ
C
      DOUBLE PRECISION :: X
C
C
      DOUBLE PRECISION :: C,ZAN
      INTEGER ICH,NQMT,NUM,MUL,NA,NAT,NB,NE,IAN
C
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      LOGICAL CANONC,FCORE,FORS,EKT,LINSER
      DOUBLE PRECISION :: FINALCI,METHOD,CISTEP,ACURCY,ENGTOL,DAMP
      INTEGER MICIT,NWRDMC,NORBMC,NOROT,MOFRZ,
     *        NPFLG,NOFO,MCFMO,IDIABAT
C
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
      INTEGER ISVMOR,ISVDOP,L0DEP0
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DOUBLE PRECISION :: ETOLLZ
      INTEGER ILOCAL,IAHARD
C
      DOUBLE PRECISION :: RUNTYP,EXETYP,CHECK
      INTEGER NEVALS,NGLEVL,NHLEVL
C
C
      INTEGER IVVOS,NVVOS
      DOUBLE PRECISION :: BNDDEN
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C
C-----------------------------------------------------------------------
      INTEGER MXATM,MXNORO,MXRT
      PARAMETER (MXATM=2000, MXNORO=250, MXRT=100)
C-----------------------------------------------------------------------
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIMFCC(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHOD,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWRDMC,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C----------------------------------------------------------------------
C
C     DATA STUFF
      DATA CHECK/8HCHECK   /
      DATA RMC/8HMCSCF   /
      DATA ORMAS/8HORMAS   /
      DATA RHF/8HRHF     /
      DATA ROHF/8HROHF    /
      DATA RNONE/8HNONE    /
C
C     DEFINE PRINT STUFF
      SOME  = NPRINT.NE.-5 .AND. MASWRK
C
C     PRINT BANNER.
      IF(SOME) WRITE(IW,9000)
      CALL FLSHBF(IW)
C
C     SKIP FOR EXETYP
      IF(EXETYP.EQ.CHECK) GO TO 8999
C
C     SET UP SOME ORBITAL DIMENSIONS
      CALL LOCAL_SVDORB_VARS(
     *     L0,L1,L2,L3,
     *     NCORTOT,IMBS,IMBS2,L0MBS,L2MBS,
     *     NAOTOT,NAOTRI)
C
C     CHECK WAVEFXN FOR VALID NT RUN.
      OK=.FALSE.
      IF(SCFTYP.EQ.RMC) OK=.TRUE.
      IF(SCFTYP.EQ.RHF) OK=.TRUE.
      IF(SCFTYP.EQ.ROHF) OK=.TRUE.
      IF(.NOT.OK) GO TO 8999
      OK=.TRUE.
      IF(CCTYP.NE.RNONE) OK=.FALSE.
      IF(DFTYPE.NE.RNONE) OK=.FALSE.
      IF(.NOT.OK) GO TO 8999
C
C     SETUP SOME RUNTYP-SPECIFIC DIMS.
      NCORSV=0
      NACTSV=0
      IBEG1_550=NCORTOT+1
      IF(SCFTYP.EQ.RMC) THEN
        CALL LOCAL_SVDVVOS_RMC_SETUP1(NCORSV,NACTSV)
        MOCC=NCORSV-NCORTOT
        MTOT=IMBS-NACTSV
        IBEG2_550=NCORSV+NACTSV+1
      ELSEIF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
        NCORSV=0
        NACTSV=0
        MOCC=NA-NCORTOT
        MTOT=IMBS
        IBEG2_550=NCORTOT+MOCC+1
      ELSE
        IF(MASWRK) WRITE(IW,9020)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      NACTSV2=(NACTSV*NACTSV+NACTSV)/2
C
C     SET UP FULLVAL.
      FULLVAL=.FALSE.
      IF(NACTSV+NCORTOT.GE.L0MBS) THEN
C       ENABLE BY WAVEFXN KIND HERE.
        IF(SCFTYP.EQ.RMC) FULLVAL=.TRUE.
      ENDIF
C
C     CHECK OPTIONS FOR VALID NT RUN.
      OK=.TRUE.
      IF(ILOCAL.NE.4) OK=.FALSE.
      IF(EXTLOC.NE.RNONE) OK=.FALSE.
      IF(IORBF1.NE.15) OK=.FALSE.
      IF(IVVOS.EQ.0.AND..NOT.FULLVAL) OK=.FALSE.
      IF(ORMFUL) OK=.FALSE.
      IF(ICH.NE.0) OK=.FALSE.
      IF(.NOT.OK) GO TO 8999
C
C-----------------------------------------------------------------
C-----------------------------------------------------------------
C     DETERMINANT ONLY NT RUNS.
      IF(FULLVAL) THEN
C       INITIALIZE RNNTSCF.
        RNNTSCF=.FALSE.
C       OBTAIN CI COEFFICIENTS FOR LOCALIZED ORBITALS OF CHOICE.
        ICIMALMQ=1
        CALL MALMQ_CIDRIV(325,IORBF2,ICIMALMQ)
C       OBTAIN CI COEFFICIENTS FOR NO CHARGE TRANSFER WAVEFUNCTION.
        ICIMALMQ=3
        CALL MALMQ_CIDRIV(325,IORBF2,ICIMALMQ)
C       CALCULATE CHARGE TRANSFER RESULTS
        CALL LOCAL_SVD_CHKSYM(OKSYM_SVDDET)
        IF(.NOT.OKSYM_SVDDET) GO TO 8999
        IGRPNUM=1
        IF(CISTEP.EQ.ORMAS) IGRPNUM=NSPACE
        CALL GOTFM(NGOTMX)
        CALL VALFM(LOADFM)
        LIATPOP    = LOADFM    + 1
        LIGRPPOP   = LIATPOP   + L1
        LDENPOP    = LIGRPPOP  + L1
        LDENPOP2   = LDENPOP   + NACTSV2
        LATPOP     = LDENPOP2  + NACTSV2
        LATPOP2    = LATPOP    + NAT*IGRPNUM
        LATPOP3    = LATPOP2   + NAT*IGRPNUM
        LAST       = LATPOP3   + NAT
        NEEDNT     = LAST - LOADFM - 1
        CALL GETFM(NEEDNT)
ccccccccc
        IFILAT=528
        IF(ORIENT) IFILAT=547
        CALL DAREAD(IDAF,IODA,X(LIATPOP),L1,IFILAT,1)
        IFILGRP=546
        IF(ORIENT) IFILGRP=548
        CALL DAREAD(IDAF,IODA,X(LIGRPPOP),L1,IFILGRP,1)
        IFILDEN=526
        IF(ORIENT) IFILDEN=287
        CALL DAREAD(IDAF,IODA,X(LDENPOP),NACTSV2,IFILDEN,0)
        CALL DAREAD(IDAF,IODA,X(LDENPOP2),NACTSV2,552,0)
        CALL DAWRIT(IDAF,IODA,X(LDENPOP2),NACTSV2,553,0)
ccccccccc
        CALL LOCAL_QUAO_CTRANS(
     *       NAT,IGRPNUM,L1,NACTSV,NACTSV2,
     *       X(LIATPOP),X(LIGRPPOP),
     *       X(LDENPOP),X(LDENPOP2),X(LATPOP),X(LATPOP2),X(LATPOP3),
     *       SOME,IW)
        CALL RETFM(NEEDNT)
ccccccccc
C       GET OUT
        GO TO 8999
      ENDIF
      LAST=IBEG1_550+IBEG2_550+MTOT+MXRT
C
C     PUT ALL RETURN LINES BELOW.
 8999 CONTINUE
      IF(SOME) THEN
        WRITE(IW,9300)
        CALL TIMIT(1)
      ENDIF
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'LOCAL_NTDRIV BEGINS.'/
     *   5X,60(1H-))
 9020 FORMAT(/1X,'LOCAL_NTDRIV ERROR:',
     *       /1X,'SCFTYP DOES NOT EXIST YET.')
 9300 FORMAT(1X,'... DONE WITH LOCAL_NTDRIV ...')
      END
C*MODULE LOCAL   *DECK LOCAL_QUAO_CTRANS
C> @brief      Calculate true NT differences.
C>
C> @author     Aaron West
C>             -December 14, 2013
C>
C> @param NAT       is the number of atoms.
C> @param IGRPNUM   is the number of ORMAS groups.
C> @param L1        is the LCAO length.
C> @param NACT      is the number of active orbitals.
C> @param NACT2     is the triangular length of NACT.
C> @param IATLAB    contains the atom labels.
C> @param IGRPLAB   contains the ORMAS group labels.
C> @param DEN       is the wave function density matrix.
C> @param DEN2      is the NT wave function density matrix.
C> @param ATPOP     will hold the wave function atomic populations.
C> @param ATPOP2    will hold the NT wave function atomic populations.
C> @param ATPOP3    will hold the total CT.
C> @param SOME      is true for master process with nprint not equal -5.
C> @param IW        indicates write out to .log file.
      SUBROUTINE LOCAL_QUAO_CTRANS(
     *           NAT,IGRPNUM,L1,NACT,NACT2,
     *           IATLAB,IGRPLAB,
     *           DEN,DEN2,ATPOP,ATPOP2,ATPOP3,
     *           SOME,IW)
C
      IMPLICIT NONE
      LOGICAL SOME
      INTEGER IW,
     *        NAT,IGRPNUM,L1,NACT,NACT2
      INTEGER IATLAB(L1),IGRPLAB(L1)
      DOUBLE PRECISION ::
     *       DEN(NACT2),DEN2(NACT2),
     *       ATPOP(NAT,IGRPNUM),ATPOP2(NAT,IGRPNUM),ATPOP3(NAT)
C
      INTEGER I,II,IAT,ISPACE,LTPOS
      DOUBLE PRECISION :: TMP
C
C     DETERMINE ATOMIC POPULATIONS.
      CALL VCLR(ATPOP,1,NAT*IGRPNUM)
      CALL VCLR(ATPOP2,1,NAT*IGRPNUM)
      DO I=1,NACT
        II=LTPOS(I,I)
        IAT=IATLAB(I)
        ISPACE=IGRPLAB(I)
        ATPOP(IAT,ISPACE)=ATPOP(IAT,ISPACE)+DEN(II)
        ATPOP2(IAT,ISPACE)=ATPOP2(IAT,ISPACE)+DEN2(II)
      ENDDO
      CALL VCLR(ATPOP3,1,NAT)
      DO IAT=1,NAT
        DO ISPACE=1,IGRPNUM
          TMP=ATPOP(IAT,ISPACE)-ATPOP2(IAT,ISPACE)
          ATPOP3(IAT)=ATPOP3(IAT)+TMP
        ENDDO
      ENDDO
C
C     PRINT OUT QUAO POPULATIONS.
      IF(SOME) WRITE(IW,9010)
      DO ISPACE=1,IGRPNUM
        DO IAT=1,NAT
          IF(SOME) WRITE(IW,9100) ISPACE,IAT,ATPOP(IAT,ISPACE)
        ENDDO
      ENDDO
C
C     PRINT OUT NT QUAO POPULATIONS.
      IF(SOME) WRITE(IW,9020)
      DO ISPACE=1,IGRPNUM
        DO IAT=1,NAT
          IF(SOME) WRITE(IW,9100) ISPACE,IAT,ATPOP2(IAT,ISPACE)
        ENDDO
      ENDDO
C
C     PRINT OUT CHARGE TRANSFERS.
      IF(SOME) WRITE(IW,9030)
      DO ISPACE=1,IGRPNUM
        DO IAT=1,NAT
          TMP=ATPOP(IAT,ISPACE)-ATPOP2(IAT,ISPACE)
          IF(SOME) WRITE(IW,9100) ISPACE,IAT,TMP
        ENDDO
      ENDDO
C
C     PRINT OUT TOTAL CHARGE TRANSFERS.
      IF(SOME) WRITE(IW,9040)
      DO IAT=1,NAT
        IF(SOME) WRITE(IW,9110) IAT,ATPOP3(IAT)
      ENDDO
C
      IF(SOME) WRITE(IW,*)
      CALL FLSHBF(IW)
C
      RETURN
 9010 FORMAT(//1X,'QUAO ATOMIC POPULATIONS NOW FOLLOW.')
 9020 FORMAT(//1X,'QUAO ATOMIC NT POPULATIONS NOW FOLLOW.')
 9030 FORMAT(//1X,'QUAO ATOMIC CTS NOW FOLLOW.')
 9040 FORMAT(//1X,'QUAO ATOMIC TOTAL CTS NOW FOLLOW.')
 9100 FORMAT(1X,'GROUP',I5,3X,'ATOM',I5,3X,'QUAO POPULATION =',F7.4)
 9110 FORMAT(1X,'ATOM',I5,3X,'QUAO POPULATION =',F7.4)
      END
C*MODULE LOCAL   *DECK LOCAL_NOS_CC
C> @brief      Prepares svd coupled cluster natural orbitals.
C>
C> @author     Aaron West
C>             -February 27, 2014
C>
C> @param IORBF1  indicates daf dict file with starting orbitals
C>                from which the localized orbitals are formed.
C> @param NE      equals number of electrons.
C> @param NCORTOT equals number of chemical core orbitals.
C> @param L0      is the length of the MO variational space.
C> @param L1      is the length of the AO coefficients.
C> @param L2      is the triangular length of L1.
C> @param L3      is the square of L1.
C> @param ISIZSVD is the size of the work space.
C> @param IWRK    is an integer array.
C> @param S       is work space of dimension L2.
C> @param DEN     is work space of dimension L2.
C> @param VTMP    is work space of dimension L3.
C> @param VSAV    is work space of dimension L3.
C> @param EIG     is work space of dimension L1.
C> @param WRKSVD  is work space of dimension ISIZSVD.
C> @param SOME    is true for master process with nprint not equal -5.
C> @param MASWRK  indicates the master process.
      SUBROUTINE LOCAL_NOS_CC(
     *           IORBF1,
     *           NE,NCORTOT,L0,L1,L2,L3,ISIZSVD,
     *           IWRK,
     *           S,DEN,
     *           VTMP,VSAV,EIG,WRKSVD,
     *           SOME,MASWRK)
C-------------------------------------------------------------------
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER IORBF1,
     *        NE,NCORTOT,L0,L1,L2,L3,ISIZSVD
      INTEGER IWRK(L1)
      DOUBLE PRECISION ::
     *       S(L2),DEN(L2),
     *       VTMP(L1,L1),VSAV(L1,L1),EIG(L1),
     *                   WRKSVD(ISIZSVD)
C-------------------------------------------------------------------
      INTEGER N0,N0TRI,KDIAGSV,I,LTPOS
      DOUBLE PRECISION :: CCTYP_SV
C-------------------------------------------------------------------
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
C
      INTEGER KDIAG,ICORFL,IXDR,MODIO,mem10,lpnt10,mem10m
C
      DOUBLE PRECISION ::
     *       SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C-------------------------------------------------------------------
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MACHSW/ KDIAG,ICORFL,IXDR,MODIO,mem10,lpnt10,mem10m
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C-------------------------------------------------------------------
      DOUBLE PRECISION :: RNONE
      DATA RNONE/8HNONE    /
C-------------------------------------------------------------------
C
C     DEFINE VARS.
      N0=L0
      N0TRI=(N0*N0+N0)/2
C
C     REPLACE IORBF1 WITH CC NATURAL ORBITALS.
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL DAREAD(IDAF,IODA,VTMP,L3,45,0)
      CALL MTARBR(S,L1,VTMP,N0,VSAV,L1,1)
      CALL VCLR(DEN,1,L2)
      CALL DAREAD(IDAF,IODA,S,L2,16,0)
      CALL TFTRI(DEN,S,VSAV,WRKSVD,N0,L1,L1)
      DO I=1,N0TRI
        DEN(I) = -DEN(I)
      ENDDO
      CALL VCLR(VSAV,1,L3)
      KDIAGSV=KDIAG
      KDIAG=3
      CALL SYMDIA(DEN,VSAV,EIG,WRKSVD,IWRK,N0,L2,L1)
      KDIAG=KDIAGSV
      CALL TFSQB(VSAV,VTMP,WRKSVD,N0,L1,L1)
      CALL DCOPY(L3,VSAV,1,VTMP,1)
      DO I=1,N0
        EIG(I) = -EIG(I)
      ENDDO
C
C     CHECK THE ORBITAL ORTHOG.
      CALL DAREAD(IDAF,IODA,S,L2,12,0)
      CALL LOCAL_CHECK_ORTHOG(
     *     N0,L1,L2,
     *     DEN,S,VTMP,WRKSVD,
     *     MASWRK,IW)
C
C     PUT NEW ORBITALS ONTO DAF15.
C     NOTE:  ANY FILES IN THE BASIS OF DAF15 ARE NO GOOD HERE.
      CALL DAWRIT(IDAF,IODA,VTMP,L3,IORBF1,0)
      IF(SOME) THEN
        WRITE(IW,9100)
        WRITE(IW,9101) N0
        CALL PRSQL(VTMP,N0,L1,L1)
      ENDIF
      IF(MASWRK) THEN
        WRITE(IP,9102)
        CALL PUSQL(VTMP,N0,L1,L1)
        WRITE(IP,9103)
      ENDIF
C
C     SAVE AND CHECK THE VALENCE DENSITY FOR CC NATURAL ORBITALS.
      CALL VCLR(DEN,1,L2)
      DO I=1,N0-NCORTOT
        DEN(LTPOS(I,I))=EIG(I+NCORTOT)
      ENDDO
      CCTYP_SV=CCTYP
      CCTYP=RNONE
      CALL LOCAL_CHECK_DENS(
     *     DEN,N0TRI,N0,NCORTOT,NE,
     *     MASWRK,IW)
      CCTYP=CCTYP_SV
C
      RETURN
 9100 FORMAT(//10X,'COUPLED CLUSTER NATURAL ORBITALS')
 9101 FORMAT(10X,I5,1X,'ORBITALS ARE MADE.')
 9102 FORMAT('COUPLED CLUSTER NATURAL ORBITALS'/' $VEC')
 9103 FORMAT(' $END')
      END
C*MODULE LOCAL   *DECK LOCAL_MCSPLITQA_DIMS
C> @brief      Creates 1st groups for split localized ORMAS runs.
C>
C> @author     Aaron West
C>             -March 13, 2014
C>
C> @param NCORTOT      is the number of chemical core orbitals.
C> @param L0MBS        is the number of minimal basis orbitals.
C> @param ISIZE_FCCWFN is the size of the msta array.
C> @param NSPACE       is the number ORMAS groups.
C> @param MSTA         holds the orbital ranges for ORMAS groups.
C> @param MSTA_SAV     holds the orbital ranges for ORMAS groups
C>                     for the old ORMAS groups.
C> @param ITRKA        will keep track of true active ORMAS groups.
C> @param EXTLOC       indicates a possible external orbitals run.
C> @param SOME         indicates print or not.
C> @param MASWRK       indicates the master process.
C> @param IW           indicates write out to log file.
      SUBROUTINE LOCAL_MCSPLITQA_DIMS(
     *           NCORTOT,L0MBS,ISIZE_FCCWFN,NSPACE,
     *           MSTA,MSTA_SAV,ITRKA,
     *           EXTLOC,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER IW,
     *        NCORTOT,L0MBS,ISIZE_FCCWFN,NSPACE
      INTEGER MSTA(ISIZE_FCCWFN),MSTA_SAV(ISIZE_FCCWFN),
     *        ITRKA(ISIZE_FCCWFN)
      DOUBLE PRECISION :: EXTLOC
C-------------------------------------------------------------------
      LOGICAL GRPCOR,GRPVVO
      INTEGER I,NCORSV,NACTSV,
     *        INC,INCCOR,INCVVO,
     *        JSPACE,IORB1,IORB2
      DOUBLE PRECISION :: SPLITQ3
C-------------------------------------------------------------------
      DATA SPLITQ3/8HSPLITQ3 /
C
C     PRINT OFF THE CURRENT ORMAS GROUPS.
      IF(SOME) WRITE(IW,9010) NSPACE,(MSTA_SAV(I),I=1,NSPACE)
      IF(SOME) WRITE(IW,9020)
      CALL FLSHBF(IW)
C
C     INIT. ITRKA.
      CALL VICLR(ITRKA,1,ISIZE_FCCWFN)
C
C     FIGURE OUT CORE AND VVOS INFORMATION.
      CALL LOCAL_SVDVVOS_RMC_SETUP1(NCORSV,NACTSV)
      GRPCOR=.FALSE.
      IF(MSTA_SAV(1).NE.NCORTOT+1) GRPCOR=.TRUE.
      INCCOR=NCORSV - NCORTOT
      GRPVVO=.FALSE.
      INC=NCORSV+NACTSV
      IF(INC.NE.L0MBS) GRPVVO=.TRUE.
      INCVVO=L0MBS - INC
C
C     CONSTRUCT NEW ORMAS GROUP STRUCTURE.
      IORB1=1
      IORB2=NCORTOT
      JSPACE=1
      MSTA(JSPACE)=IORB1
      IF(GRPCOR) THEN
        INC=INCCOR
        IORB1=IORB2+1
        IORB2=IORB2+INC
        JSPACE=JSPACE+1
        MSTA(JSPACE)=IORB1
      ENDIF
      IF(EXTLOC.NE.SPLITQ3) THEN
        DO I=1,NSPACE
          INC=MSTA_SAV(I+1)-MSTA_SAV(I)
          IORB1=IORB2+1
          IORB2=IORB2+INC
          JSPACE=JSPACE+1
          MSTA(JSPACE)=IORB1
          ITRKA(JSPACE)=1
        ENDDO
      ELSE
        INC=MSTA_SAV(NSPACE+1)-MSTA_SAV(1)
        IORB1=IORB2+1
        IORB2=IORB2+INC
        JSPACE=JSPACE+1
        MSTA(JSPACE)=IORB1
        ITRKA(JSPACE)=1
      ENDIF
      IF(GRPVVO) THEN
        INC=INCVVO
        IORB1=IORB2+1
        IORB2=IORB2+INC
        JSPACE=JSPACE+1
        MSTA(JSPACE)=IORB1
      ENDIF
      IORB1=IORB2+1
C     IORB2 IS WHATEVER.
      JSPACE=JSPACE+1
      MSTA(JSPACE)=IORB1
C
C     RESET THE NSPACE VARIABLE.
      JSPACE=JSPACE-1
      NSPACE=JSPACE
C
C     PRINT OFF THE CURRENT ORMAS GROUPS.
      IF(SOME) WRITE(IW,9010) NSPACE,(MSTA(I),I=1,NSPACE)
      CALL FLSHBF(IW)
C
C     ERROR OUT FOR IORB1.
      IF(IORB1.NE.L0MBS+1) THEN
        IF(MASWRK) WRITE(IW,9050) IORB1,L0MBS+1
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
 9010 FORMAT(/1X,'THE NUMBER OF SPACES             =',I4/
     *        1X,'EACH SPACE STARTS AT ORBITAL     =',50I4)
 9020 FORMAT(/1X,'LOCAL_MCSPLITQA_DIMS CHANGES NUMBER OF ORMAS GROUPS.')
 9050 FORMAT(/1X,'LOCAL_MCSPLITQA_DIMS ERROR:',
     *       /1X,'IORB1',I4,' MUST EQUAL L0MBS+1',I4,' AT THIS POINT.')
      END
C*MODULE LOCAL   *DECK LOCAL_ORMAS_BLOCKDIAG
C> @brief      Driver for true ORMAS canonical or natural orbitals.
C>
C> @author     Aaron West, Mike Schmidt, Klaus Ruedenberg
C>             -March 13, 2014
C>
C> @param RUNCAN   is set to true when making block ORMAS
C>                 canonical orbitals based on the Fock operator
C>                 in the MO basis.
C>                 RUNCAN is set to false when making block
C>                 ORMAS natural orbitals.
C> @param L0       is the length of the MO variational space.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param L3       is the square of L1.
C> @param NCORSV   is the number of all doubly occupied orbitals.
C> @param NOCC     is the number of occupied orbitals.
C> @param NSPACE   is the number of ORMAS groups.
C> @param MSTA     holds the orbital ranges for the ORMAS groups.
C> @param IWRK     is an integer work array of L1 length.
C> @param GIJ      is a work array of L2 length.
C> @param GMN      is the triangular matrix of interest to be
C>                 provided on entry.
C>                 Then, it is used as a work array of L2 length.
C> @param VEC      is a work array of L3 length.
C>                 On exit, VEC holds the new LCAO coefficients.
C> @param Q        is a work array of L3 length.
C> @param OCC      is a work array of L1 length.
C>                 On exit, OCC holds the new eigenvalues.
C> @param WRK      is a work array of L1 length.
C> @param SCR      is a work array of L1x8 length.
      SUBROUTINE LOCAL_ORMAS_BLOCKDIAG(
     *           RUNCAN,
     *           L0,L1,L2,L3,NCORSV,NOCC,NSPACE,
     *           MSTA,IWRK,
     *           GIJ,GMN,
     *           VEC,Q,OCC,WRK,SCR)
      IMPLICIT NONE
      LOGICAL RUNCAN
      INTEGER L0,L1,L2,L3,NCORSV,NOCC,NSPACE
      INTEGER MSTA(NSPACE),IWRK(L1)
      DOUBLE PRECISION ::
     *       GIJ(L2),GMN(L2),VEC(L1,L1),Q(L1,L1),OCC(L1),
     *       WRK(L1),SCR(L1,8)
C-------------------------------------------------------------------
      INTEGER LOADFM,LAST,NEED,
     *        LIWRK2,LOCCSV,LVECSV,LSQ,LMSTANOW,LGMNSV,
     *        NSPACENOW
C-------------------------------------------------------------------
      DOUBLE PRECISION :: X
C
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
C-------------------------------------------------------------------
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C-------------------------------------------------------------------
C
C     ERROR OUT.
      IF(MSTA(1).LE.NCORSV) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     SMALL ALLOCATION.
      NSPACENOW=NSPACE+3
      CALL VALFM(LOADFM)
      LIWRK2    = LOADFM   +  1
      LOCCSV    = LIWRK2   + L1
      LVECSV    = LOCCSV   + L1
      LSQ       = LVECSV   + L3
      LMSTANOW  = LSQ      + L3
      LGMNSV    = LMSTANOW + NSPACENOW
      LAST      = LGMNSV   + L2
      NEED      = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
C     PROPERLY FORM THE ORMAS BLOCK ORBITALS.
      CALL LOCAL_ORMAS_BLOCKDIAG2(
     *     RUNCAN,
     *     L0,L1,L2,L3,NCORSV,NOCC,NSPACE,
     *     MSTA,IWRK,
     *     GIJ,GMN,
     *     VEC,Q,OCC,WRK,SCR,
     *     NSPACENOW,X(LIWRK2),X(LOCCSV),X(LVECSV),X(LSQ),
     *     X(LMSTANOW),X(LGMNSV))
C
C     PREPARE FOR WRIT STATEMENTS OUTSIDE OF HERE.
      CALL DCOPY(L3,X(LVECSV),1,VEC,1)
      CALL DCOPY(L1,X(LOCCSV),1,OCC,1)
C
C     SMALL DEALLOCATION.
      CALL RETFM(NEED)
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_ORMAS_BLOCKDIAG ERROR:',
     *       /1X,'CANNOT DEAL WITH MSTA SHIFTED TO ACTIVE POSITIONS.')
      END
C*MODULE LOCAL   *DECK LOCAL_ORMAS_BLOCKDIAG2
C> @brief      Makes true ORMAS canonical or natural orbitals.
C>
C> @author     Aaron West, Mike Schmidt, Klaus Ruedenberg
C>             -March 13, 2014
C>
C> @details    Create true ORMAS canonical or natural orbitals
C>             even for cases with degenerate orbitals between
C>             ORMAS groups.
C>
C> @param RUNCAN   is set to true when making block ORMAS
C>                 canonical orbitals based on the Fock operator
C>                 in the MO basis.
C>                 RUNCAN is set to false when making block
C>                 ORMAS natural orbitals.
C> @param L0       is the length of the MO variational space.
C> @param L1       is the length of the AO coefficients.
C> @param L2       is the triangular length of L1.
C> @param L3       is the square of L1.
C> @param NCORSV   is the number of all doubly occupied orbitals.
C> @param NOCC     is the number of occupied orbitals.
C> @param NSPACE   is the number of ORMAS groups.
C> @param MSTA     holds the orbital ranges for the ORMAS groups.
C> @param IWRK     is an integer work array of L1 length.
C> @param GIJ      is a work array of L2 length.
C> @param GMN      is the triangular matrix of interest to be
C>                 provided on entry.
C>                 Then, it is used as a work array of L2 length.
C> @param VEC      is a work array of L3 length.
C>                 On exit, VEC holds the new LCAO coefficients.
C> @param Q        is a work array of L3 length.
C> @param OCC      is a work array of L1 length.
C>                 On exit, OCC holds the new eigenvalues.
C> @param WRK      is a work array of L1 length.
C> @param SCR      is a work array of L1x8 length.
C> @param NSPACENOW is the leading dimension for the modified
C>                  ORMAS group size.
C> @param IWRK2     is integer scratch space of L1 length.
C> @param OCCSV     will hold the saved eigenvalues.
C> @param VECSV     will hold the saved LCAO orbital vectors.
C> @param SQ        is scratch space of size L3.
C> @param MSTANOW   will hold the range of the new ORMAS groups.
C> @param GMNSV     is scratch space used to save out GMN array.
C>                  Please see the notes on GMN above.
      SUBROUTINE LOCAL_ORMAS_BLOCKDIAG2(
     *           RUNCAN,
     *           L0,L1,L2,L3,NCORSV,NOCC,NSPACE,
     *           MSTA,IWRK,
     *           GIJ,GMN,
     *           VEC,Q,OCC,WRK,SCR,
     *           NSPACENOW,IWRK2,OCCSV,VECSV,SQ,
     *           MSTANOW,GMNSV)
      IMPLICIT NONE
      LOGICAL RUNCAN
      INTEGER L0,L1,L2,L3,NCORSV,NOCC,NSPACE,
     *        NSPACENOW
      INTEGER MSTA(NSPACE),IWRK(L1),
     *        IWRK2(L1),MSTANOW(NSPACENOW)
      DOUBLE PRECISION ::
     *       GIJ(L2),GMN(L2),VEC(L1,L1),Q(L1,L1),OCC(L1),
     *       WRK(L1),SCR(L1,8),
     *       OCCSV(L1),VECSV(L1,L1),SQ(L1,L1),GMNSV(L2)
C-------------------------------------------------------------------
      INTEGER ISPACE,ILEN,IBEG,IEND,I,J,LTPOS,
     *        IDUM,IJ,
     *        KDSAVE,
     *        NTOTSP,ISIZ,ISIZ2
      DOUBLE PRECISION :: DUM
C-------------------------------------------------------------------
C
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      INTEGER KDIAG,ICORFL,IXDR,MODIO,mem10,lpnt10,mem10m
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
C-------------------------------------------------------------------
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MACHSW/ KDIAG,ICORFL,IXDR,MODIO,mem10,lpnt10,mem10m
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C-------------------------------------------------------------------
      DOUBLE PRECISION :: ZERO,TWO,DINC
      PARAMETER(ZERO=0.0D+00,TWO=2.0D+00,DINC=0.1D+00)
C-------------------------------------------------------------------
C
C     INITIALIZATIONS.
C     NOTE:  VECSV IS REPLACED IN THE ORMAS GROUPS.
      CALL DAREAD(IDAF,IODA,VECSV,L3,15,0)
      CALL VCLR(OCCSV,1,L1)
      IF(.NOT.RUNCAN) THEN
         DO I=1,NCORSV
            OCCSV(I)=TWO
         ENDDO
      ENDIF
      CALL VCLR(GMNSV,1,L2)
C
C     SETUP OCCUPIED VARIABLES.
C     SAVE OUT THE NEEDED DAF FILE BEFORE ITS DESTRUCTION.
      ISIZ=NOCC
      IF(RUNCAN) ISIZ=L0
      ISIZ2=(ISIZ*ISIZ+ISIZ)/2
      CALL DCOPY(ISIZ2,GMN,1,GMNSV,1)
C
C     CREATE ORMAS GROUPS FOR BLOCK DIAG. BELOW.
      NTOTSP=0
      CALL VICLR(MSTANOW,1,NSPACENOW)
      IF(.NOT.RUNCAN) THEN
         NTOTSP=NSPACE
         CALL ICOPY(NSPACE+1,MSTA,1,MSTANOW,1)
      ELSE
         NTOTSP=0
         IF(MSTA(1).NE.1) THEN
           NTOTSP=1
           MSTANOW(NTOTSP)=1
         ENDIF
         DO I=1,NSPACE
            NTOTSP=NTOTSP+1
            MSTANOW(NTOTSP)=MSTA(I)
         ENDDO
         IF(MSTA(NSPACE+1).NE.L0+1) THEN
            NTOTSP=NTOTSP+1
            MSTANOW(NTOTSP)=MSTA(NSPACE+1)
         ENDIF
         MSTANOW(NTOTSP+1)=L0+1
      ENDIF
      IF(NTOTSP+1.GT.NSPACENOW) THEN
         IF(MASWRK) WRITE(IW,9000)
         CALL FLSHBF(IW)
         CALL ABRT
         STOP
      ENDIF
C
C     MAKE ORMAS NOS.
      DO 100 ISPACE=1,NTOTSP
C
C        OBTAIN ORBITAL LIMITS.
         IBEG=MSTANOW(ISPACE)
         IEND=MSTANOW(ISPACE+1)-1
         ILEN=IEND+1-IBEG
C
C        OBTAIN THE MODIFIED DENSITY MATRIX IN GIJ.
C        NOTE:  FOR FOCK MATRIX AS OPPOSED TO OCCUPATIONS,
C               FIXED VALUE OF THREE DOES NOT CUT IT.
         CALL DCOPY(ISIZ2,GMNSV,1,GMN,1)
         DUM=GMN(LTPOS(IBEG,IBEG))
         DO I=IBEG,IEND
            IJ=LTPOS(I,I)
            IF(GMN(IJ).GT.DUM) DUM=GMN(IJ)
         ENDDO
         DO IJ=1,L2
           GIJ(IJ)=ZERO
         ENDDO
         DO I=1,L0
            DUM=DUM+DINC
            GIJ(LTPOS(I,I))=DUM
         ENDDO
         DO I=IBEG,IEND
            DO J=IBEG,I
               IJ=LTPOS(I,J)
               GIJ(IJ)=GMN(IJ)
            ENDDO
         ENDDO
C
C        TRANSFORM TO THE AO BASIS.
C        TRANSFORM TO THE Q  BASIS.
         CALL DAREAD(IDAF,IODA,VEC,L3,15,0)
         CALL TRPOSQ(VEC,L1)
         CALL TFTRI(GMN,GIJ,VEC,WRK,L1,ISIZ,L1)
         CALL DAREAD(IDAF,IODA,GIJ,L2,12,0)
         CALL DAREAD(IDAF,IODA,Q,L3,45,0)
         CALL MTARBR(GIJ,L1,Q,L0,SQ,L1,1)
         CALL TFTRI(GIJ,GMN,SQ,WRK,L0,L1,L1)
C
C        DIAGONALIZE.
C        TRANSFORM TO THE AO BASIS.
         KDSAVE=KDIAG
         KDIAG=3
         CALL SYMDIA(GIJ,VEC,OCC,SCR,IWRK,L0,L2,L1)
         KDIAG=KDSAVE
         CALL TFSQB(VEC,Q,WRK,L0,L1,L1)
C
C        USE OVLSEL TO GET AT THE ORMAS GROUP.
C        SAVE OUT THE NEEDED VALUES.
         IDUM=0
         CALL DAREAD(IDAF,IODA,GIJ,L2,12,0)
         CALL DAREAD(IDAF,IODA,Q,L3,15,0)
         CALL OVLSEL(VEC,OCC,Q,GIJ,
     *               SQ,IWRK,WRK,IWRK,
     *               IDUM,IDUM,L0,L1,L2,.FALSE.,L0)
         CALL DCOPY(L1*ILEN,VEC(1,IBEG),1,VECSV(1,IBEG),1)
         CALL DCOPY(ILEN,OCC(IBEG),1,OCCSV(IBEG),1)
  100 CONTINUE
C
C     PREPARE TO REORDER THE ORMAS NOS.
C     NOTE:  FOR RUNCAN, REORDERING IS FINISHED IN NTNCAN.
      IF(RUNCAN) RETURN
      CALL DCOPY(L1,OCCSV,1,WRK,1)
      DO I=1,L1
         IWRK(I)=I
      ENDDO
      DO 110 ISPACE=1,NTOTSP
C
C        OBTAIN ORBITAL LIMITS.
         IBEG=MSTANOW(ISPACE)
         IEND=MSTANOW(ISPACE+1)-1
         ILEN=IEND+1-IBEG
C
C        PREPARE INSIDE OF A SINGLE ORMAS GROUP.
         CALL LOCAL_SORT_EVALS(.FALSE.,3,ILEN,IWRK(IBEG),WRK(IBEG))
  110 CONTINUE
C
C     PERFORM THE REORDERING.
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(OCCSV,IWRK2,L0,1)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(VECSV,IWRK2,L0,L1)
C
C     PUT DENSITY MATRIX INTO GIJ FOR WRITS.
C     NOTE:  INTER-ORMAS GROUP ELEMENTS MUST BE KEPT.
      CALL VCLR(GIJ,1,L2)
      CALL DCOPY(ISIZ2,GMNSV,1,GIJ,1)
      DO 120 ISPACE=1,NTOTSP
         IBEG=MSTANOW(ISPACE)
         IEND=MSTANOW(ISPACE+1)-1
         ILEN=IEND+1-IBEG
         DO I=IBEG,IEND
            DO J=IBEG,I
               IJ=LTPOS(I,J)
               GIJ(IJ)=ZERO
               IF(I.EQ.J) GIJ(IJ)=OCCSV(I)
            ENDDO
         ENDDO
  120 CONTINUE
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_ORMAS_BLOCKDIAG2 ERROR:',
     *       /1X,'NTOTSP+1 CANNOT BE GREATER THAN NSPACENOW.')
      END
C*MODULE LOCAL   *DECK LOCAL_MCSPLITQA_NOS
C> @brief      Creates 2nd groups for split localized ORMAS runs.
C>
C> @author     Aaron West
C>             -March 13, 2014
C>
C> @param L0MBS        is the dimension of the minimal basis set number
C>                     of orbitals.
C> @param L1            is the lenght of AO coefficients.
C> @param NSPACE        are the number of ORMAS groups.
C> @param NSPACE_SAV    are the original number of ORMAS groups.
C> @param ISIZE_FCCWFN  is the size of the msta array.
C> @param ITRKA         keeps track of true active groups.
C> @param MSTA          holds the orbital ranges for the ORMAS groups.
C> @param MSTA_SAV      holds the orbital ranges for the ORMAS groups
C>                      for the original ORMAS groups.
C> @param IWRK          is a integer scratch array of length L1.
C> @param OCCSV         holds the occupations for the natural orbitals.
C> @param SOME          indicates print or not.
C> @param MASWRK        indicates the master process.
C> @param IW            indicates write out to log file.
      SUBROUTINE LOCAL_MCSPLITQA_NOS(
     *           L0MBS,L1,NSPACE,NSPACE_SAV,ISIZE_FCCWFN,
     *           ITRKA,MSTA,MSTA_SAV,
     *           IWRK,
     *           OCCSV,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER IW,
     *        L0MBS,L1,NSPACE,NSPACE_SAV,ISIZE_FCCWFN
      INTEGER ITRKA(ISIZE_FCCWFN),
     *        MSTA(ISIZE_FCCWFN),
     *        MSTA_SAV(ISIZE_FCCWFN),
     *        IWRK(L1)
      DOUBLE PRECISION ::
     *       OCCSV(L1)
C-------------------------------------------------------------------
      LOGICAL OK
      INTEGER ICTNEW,ICTNEW2,ICTNEW3,ICTNEW4,IERR,ISPACE,IBEG,IEND,I,
     *        IPOSAV
      DOUBLE PRECISION ::
     *       VALTMP,VALSAV,
     *       CUTOFF,TOL
      PARAMETER (CUTOFF=0.9D+00,TOL=1.0D-14)
C-------------------------------------------------------------------
C
C     CHECK THAT ITRKA SURVIVED.
      ICTNEW=0
      IERR=0
      DO ISPACE=1,NSPACE
        OK=.FALSE.
        IF(ITRKA(ISPACE).EQ.0) OK=.TRUE.
        IF(ITRKA(ISPACE).EQ.1) OK=.TRUE.
        IF(.NOT.OK) IERR=1
        IF(ITRKA(ISPACE).EQ.1) ICTNEW=ICTNEW+1
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9010)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     ENSURE THAT OCCUPATIONS DECREASE INSIDE EACH ORMAS GROUP.
      IERR=0
      DO ISPACE=1,NSPACE
        IBEG=MSTA(ISPACE)
        IEND=MSTA(ISPACE+1)-1
        DO I=IBEG+1,IEND
          IF(OCCSV(I).GT.OCCSV(I-1)) IERR=1
        ENDDO
      ENDDO
      IF(IERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9015)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     PRINT OUT ALL OCCUPATIONS.
      IF(SOME) THEN
        WRITE(IW,9016)
        IBEG=MSTA_SAV(1)
        IEND=MSTA_SAV(NSPACE_SAV+1)-1
        DO I=IBEG,IEND
          WRITE(IW,9017) I,OCCSV(I)
        ENDDO
        CALL FLSHBF(IW)
      ENDIF
C
C     MAKE INITS.
      CALL VICLR(IWRK,1,L1)
C
C     LOCATE 'NEW NEW' LIMITS.
      ICTNEW2=0
      ICTNEW4=0
      DO 100 ISPACE=1,NSPACE_SAV
        IBEG=MSTA_SAV(ISPACE)
        IEND=MSTA_SAV(ISPACE+1)-1
        IPOSAV=IBEG
        VALSAV=0.0D+00
        DO I=IBEG+1,IEND
          VALTMP=ABS(OCCSV(I)-OCCSV(I-1))
          IF(ABS(OCCSV(I)).LT.CUTOFF.AND.VALTMP.GT.VALSAV) THEN
            IPOSAV=I
            VALSAV=VALTMP
          ENDIF
        ENDDO
        IWRK(IPOSAV)=1
        ICTNEW4=ICTNEW4+1
C       NOTE:  FOR DISSOCIATED SPECIES, NO NEW GROUP IS ADDED.
        IF(VALSAV.GT.TOL) ICTNEW2=ICTNEW2+1
  100 CONTINUE
C
C     ADD ON THE 'OLD NEW' LIMITS.
      DO ISPACE=1,NSPACE
        IBEG=MSTA(ISPACE)
        IWRK(IBEG)=1
      ENDDO
C
C     CREATE ANOTHER NEW MSTA ARRAY.
      ICTNEW3=NSPACE
      NSPACE=0
      CALL VICLR(MSTA,1,ISIZE_FCCWFN)
      DO 200 I=1,L1
        IF(IWRK(I).EQ.0) GO TO 200
        NSPACE=NSPACE+1
        MSTA(NSPACE)=I
  200 CONTINUE
C     TACK ON THE LAST LIMIT ABOVE THE NSPACE VALUE.
      MSTA(NSPACE+1)=L0MBS+1
C
C     MAKE A CHECK ON THE NEW NSPACE.
      ICTNEW3=ICTNEW3+ICTNEW2
      IF(NSPACE.NE.ICTNEW3) THEN
        IF(MASWRK) WRITE(IW,9020) NSPACE,ICTNEW3
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
      IF(ICTNEW.NE.ICTNEW4) THEN
        IF(MASWRK) WRITE(IW,9030)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     PRINT OFF THE OCCUPATIONS OF IBEG AND IEND.
      DO ISPACE=1,NSPACE
        IBEG=MSTA(ISPACE)
        IEND=MSTA(ISPACE+1)-1
        IF(SOME) WRITE(IW,9100) ISPACE
        IF(SOME) WRITE(IW,9110) IBEG,OCCSV(IBEG)
        IF(SOME) WRITE(IW,9120) IEND,OCCSV(IEND)
      ENDDO
C
      RETURN
 9010 FORMAT(/1X,'LOCAL_MCSPLITQA_NOS ERROR:',
     *       /1X,'ITRKA IS NOT RIGHT.')
 9015 FORMAT(/1X,'LOCAL_MCSPLITQA_NOS ERROR:',
     *       /1X,'OCCUPATIONS DO NOT DECREASE IN ORMAS GROUP.')
 9016 FORMAT(/1X,'LOCAL_MCSPLITQA_NOS OCCUPATIONS:')
 9017 FORMAT(1X,'ORBITAL,OCC=',I4,F12.7)
 9020 FORMAT(/1X,'LOCAL_MCSPLITQA_NOS ERROR:',
     *       /1X,'NSPACE=',I4,' DOES NOT EQUAL ICTNEW3=',I4,' HERE.',
     *       /1X,'THESE TWO VARIABLES SHOULD BE EQUAL.')
 9030 FORMAT(/1X,'LOCAL_MCSPLITQA_NOS ERROR:',
     *       /1X,'ICTNEW DOES NOT EQUAL ICTNEW4.',
     *       /1X,'THESE TWO VARIABLES SHOULD BE EQUAL.')
 9100 FORMAT(/1X,'ORMAS GROUP',I4)
 9110 FORMAT(5X,'START ORBITAL,OCCUPATION=',I4,F12.7)
 9120 FORMAT(5X,'END   ORBITAL,OCCUPATION=',I4,F12.7)
      END
C*MODULE LOCAL   *DECK LOCAL_EXTERNAL_JACOBI
C> @brief      Orthogonalize external orbitals.
C>
C> @author     Aaron West
C>             -April 17, 2014
C>
C> @param WGT      contains external orbital weights.
C> @param TRANS    will hold the orthogonal transformation.
C> @param OVRLP    contains the orbital overlap between the
C>                 nonorthogonal and symmetrically orthogonalized
C>                 external orbitals on entry.
C> @param L1       is the lenght of AO coefficients.
C> @param LDMORB   is the leading dimension of TRANS.
C> @param MORB     is the working dimension of TRANS.
C> @param SOME     indicates print or not.
C> @param MASWRK   indicates the master process.
C> @param IW       indicates write out to log file.
      SUBROUTINE LOCAL_EXTERNAL_JACOBI(
     *           WGT,TRANS,OVRLP,L1,LDMORB,MORB,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
C------------------------------------------------------
      LOGICAL SOME,MASWRK
      INTEGER L1,LDMORB,MORB,IW
      DOUBLE PRECISION :: WGT(MORB),OVRLP(L1,L1),TRANS(LDMORB,LDMORB)
C------------------------------------------------------
      INTEGER MXITER,
     *        I,J,ITER,NUMROT
      DOUBLE PRECISION ::
     *       CRIT,
     *       TB,TC,RAD,
     *       ATAN2,THETA,A,B
C------------------------------------------------------
      DOUBLE PRECISION :: ONE
      PARAMETER (ONE=1.0D+00)
C------------------------------------------------------
C
C     DEFINE CRIT.
      CRIT=1.0D-10
C
C     DEFINE MXITER.
      MXITER=10000
C
C     INTIALIZE ITER AND THE ORBITAL TRANSFORM HERE.
      ITER=0
      CALL VCLR(TRANS,1,LDMORB*LDMORB)
      DO I=1,MORB
        TRANS(I,I)=ONE
      ENDDO
C
C     PRINT START OF JACOBI ROTATIONS.
      IF(SOME) WRITE(IW,9000)
      IF(SOME) WRITE(IW,9010)
C
C     LOOP OVER PAIRS OF ORBITALS.
  100 CONTINUE
      NUMROT=0
      ITER = ITER + 1
C------------------------------------------------------
C------------------------------------------------------
      DO 8000 I=1,MORB
        DO 7000 J=I+1,MORB
C------------------------------------------------------
C         SECTION FOR MAXIMIZING ON THE SECOND POWER.
C------------------------------------------------------
CCC
CCC         OBTAIN INITIAL VALUES FOR SUM.
CC          TMPA=WGT(I)*OVRLP(I,I)**2 + WGT(J)*OVRLP(J,J)**2
CC          TMPB=WGT(I)*OVRLP(I,J)**2 + WGT(J)*OVRLP(J,I)**2
CC          TMPC=WGT(I)*OVRLP(I,I)*OVRLP(I,J)
CC     *        -WGT(J)*OVRLP(J,J)*OVRLP(J,I)
CCC
CCC         OBTAIN FINAL VALUES FOR SUM.
CCCKEEP          TA=(TMPA+TMPB)/TWO
CC          TB=(TMPA-TMPB)/TWO
CC          TC=TMPC
CC          THETA = ATAN2(TC,TB)/TWO
CC          IF(ABS(THETA).LT.CRIT) GOTO 7000
C------------------------------------------------------
C         SECTION FOR MAXIMIZING ON THE FIRST POWER.
C------------------------------------------------------
C
C         OBTAIN INITIAL VALUES FOR SUM.
          TB=WGT(I)*OVRLP(I,I) + WGT(J)*OVRLP(J,J)
          TC=WGT(I)*OVRLP(I,J) - WGT(J)*OVRLP(J,I)
          RAD=SQRT(TB**2+TC**2)
          IF(ABS(RAD).LT.CRIT) GO TO 7000
C         NO RAD NEEDED IN NEXT FXN.
          THETA = ATAN2(TC,TB)
          IF(ABS(THETA).LT.CRIT) GO TO 7000
C------------------------------------------------------
C         UPDATE TRANSFORMATION.
C         UPDATE OVERLAPS.
C------------------------------------------------------
C         NOTE:  WITH NO LEADING DIM. IN ADJTR,
C                OVRLP NEEDS TO BE PRISTINE ON ENTRY.
          NUMROT = NUMROT + 1
          A = COS(THETA)
          B = -SIN(THETA)
          CALL ADJTR(I,J,L1,A,B,OVRLP)
          CALL ADJTR(I,J,LDMORB,A,B,TRANS)
C
C------------------------------------------------------
C------------------------------------------------------
 7000     CONTINUE
 8000   CONTINUE
C------------------------------------------------------
C------------------------------------------------------
C
      IF(ITER.GT.MXITER) THEN
        IF(MASWRK) THEN
          WRITE(IW,9020)
          WRITE(IW,9030) MXITER
        ENDIF
         CALL FLSHBF(IW)
         CALL ABRT
      ENDIF
C
C  IF THERE WERE ANY ROTATIONS, DO ANOTHER SWEEP.
C
      IF (NUMROT.GT.0) GOTO 100
C
      IF(MASWRK) THEN
        WRITE(IW,9000)
        WRITE(IW,9040) ITER
      ENDIF
C
      RETURN
 9000 FORMAT(/1X,'LOCAL_EXTERNAL_JACOBI:')
 9010 FORMAT(1X,'BEGIN EXTERNAL JACOBI ROTATIONS.')
 9020 FORMAT(/1X,'LOCAL_EXTERNAL_JACOBI ERROR:')
 9030 FORMAT(1X,'ORBITALS NOT CONVERGED AFTER ',I10,' ITERS.')
 9040 FORMAT(1X,' -- NUMBER OF SWEEPS REQUIRED FOR CONVERGENCE =',I5)
      END
C*MODULE LOCAL   *DECK LOCAL_ORIENBOS_ORBDIR
C> @brief      Get dipoles,quadrupoles for oriented orbitals.
C>
C> @author     Aaron West and Klaus Ruedenberg
C>             -April 09, 2014
C>
C> @param IVAR3    equals 3.
C> @param NCORTOT  is the number of chemical core orbitals.
C> @param L1       is the length of AO coefficients.
C> @param M1       is the number of oriented valence orbitals.
C> @param MAPT3    holds the oriented orbital-atom correspondence.
C> @param VORB     holds the oriented orbitals.
C> @param DIPDIR   will hold the dipoles for each orbital
C>                 on exit.
C> @param QUADDIR  will hold the quadrupoles for each orbital
C>                 on exit.
C> @param QUADEIG  will hold the quadrupole evalues for each orbital
C>                 on exit.
      SUBROUTINE LOCAL_ORIENBOS_ORBDIR(
     *           IVAR3,NCORTOT,L1,M1,MAPT3,
     *           VORB,DIPDIR,QUADDIR,QUADEIG)
      IMPLICIT NONE
      INTEGER IVAR3,NCORTOT,L1,M1
      INTEGER MAPT3(L1)
      DOUBLE PRECISION ::
     *       VORB(L1,L1),DIPDIR(IVAR3,M1),
     *       QUADDIR(IVAR3*IVAR3,M1),QUADEIG(IVAR3,M1)
C----------------------------------------------------------------------
      LOGICAL DEALDAF20
      INTEGER L2,IERR,
     *        LOADFM,LAST,NEED,
     *        LDEN,LDAF16_SAV,LDAF20_SAV,LZAN_SAV,
     *        I,ITMP,IACT,NPOINT_SAV,IEMOM_SAV,
     *        NPRINT_SAV,
     *        IWRK3(3)
      DOUBLE PRECISION ::
     *       TMP,
     *       XPOINT_SAV,YPOINT_SAV,ZPOINT_SAV,ELMLOC_SAV,
     *       POINTS,
     *       RHF,RMC,ROHF,
     *       TRI3(6),EIG3(3),SCR3(3,8),VEC3(3,3)
C----------------------------------------------------------------------
      INTEGER IEDEN,IEMOM,IEPOT,IEFLD,MODENS,
     *        IEDOUT,IEMOUT,IEPOUT,IEFOUT,
     *        IEDINT,IEMINT,IEPINT,IEFINT
      DOUBLE PRECISION :: ELDLOC,ELMLOC,ELPLOC,ELFLOC
C
      DOUBLE PRECISION :: X
C
      INTEGER NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      DOUBLE PRECISION :: ZAN,C
C
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      INTEGER NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
C
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      INTEGER NPOINT,IPUNIT
      DOUBLE PRECISION :: XPOINT,YPOINT,ZPOINT
C
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C
      DOUBLE PRECISION ::
     *                XP,YP,ZP,
     *                DMX,DMY,DMZ,
     *                QXX,QYY,QZZ,QXY,QXZ,QYZ,
     *                QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ,
     *                OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ,
     *                OXZZ,OYZZ,OZZZ,OXYZ,
     *                OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY,
     *                OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ
C----------------------------------------------------------------------
      INTEGER MXATM,MXPTPT
      PARAMETER (MXATM=2000,MXPTPT=100)
C----------------------------------------------------------------------
      COMMON /ELPROP/ ELDLOC,ELMLOC,ELPLOC,ELFLOC,
     *                IEDEN,IEMOM,IEPOT,IEFLD,MODENS,
     *                IEDOUT,IEMOUT,IEPOUT,IEFOUT,
     *                IEDINT,IEMINT,IEPINT,IEFINT
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /POINTS/ NPOINT,IPUNIT,XPOINT(MXPTPT),YPOINT(MXPTPT),
     *                ZPOINT(MXPTPT)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /XYZPRP/ XP,YP,ZP,
     *                DMX,DMY,DMZ,
     *                QXX,QYY,QZZ,QXY,QXZ,QYZ,
     *                QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ,
     *                OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ,
     *                OXZZ,OYZZ,OZZZ,OXYZ,
     *                OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY,
     *                OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ
C----------------------------------------------------------------------
C
C     DATA STUFF
      DATA POINTS/8HPOINTS  /
      DATA RHF/8HRHF     /
      DATA RMC/8HMCSCF   /
      DATA ROHF/8HROHF    /
C
C     CHECK ON PROPER MEMORY.
      IF(IVAR3.NE.3) THEN
        IF(MASWRK) WRITE(IW,9010)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     ALLOCATE MEMORY.
      L2=(L1*L1+L1)/2
      CALL VALFM(LOADFM)
      LDEN       = LOADFM     + 1
      LDAF16_SAV = LDEN       + L2
      LDAF20_SAV = LDAF16_SAV + L2
      LZAN_SAV   = LDAF20_SAV + L2
      LAST       = LZAN_SAV   + NAT
      NEED       = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
C     CLEAR OUT QUADDIR.
      CALL VCLR(QUADDIR,1,IVAR3*IVAR3*M1)
      CALL VCLR(QUADEIG,1,IVAR3*M1)
C
C     PROPERLY DEAL WITH DAF20 IN OVERKILL FASHION.
      DEALDAF20=.FALSE.
      IF(SCFTYP.EQ.RMC) THEN
      ELSEIF(SCFTYP.EQ.RHF) THEN
      ELSEIF(SCFTYP.EQ.ROHF) THEN
        DEALDAF20=.TRUE.
      ELSE
        IF(MASWRK) WRITE(IW,9050)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     LOOP OVER THE QUAOS.
C     SAVE VARIOUS ITEMS FOR ELMOMC.
      CALL DAREAD(IDAF,IODA,X(LDAF16_SAV),L2,16,0)
      IF(DEALDAF20) CALL DAREAD(IDAF,IODA,X(LDAF20_SAV),L2,20,0)
      XPOINT_SAV=XPOINT(1)
      YPOINT_SAV=YPOINT(1)
      ZPOINT_SAV=ZPOINT(1)
      ELMLOC_SAV=ELMLOC
      ELMLOC=POINTS
      NPOINT_SAV=NPOINT
      NPOINT=1
      IEMOM_SAV=IEMOM
      IEMOM=2
      CALL DCOPY(NAT,ZAN,1,X(LZAN_SAV),1)
      CALL VCLR(ZAN,1,NAT) ! should preserve the elec qmxx,etc.
      DO I=NCORTOT+1,NCORTOT+M1
C       SET UP ACTIVE POSITION.
        IACT=I-NCORTOT
C       SET UP THE POINT.
        XPOINT(1)=C(1,MAPT3(IACT))
        YPOINT(1)=C(2,MAPT3(IACT))
        ZPOINT(1)=C(3,MAPT3(IACT))
C       SET UP AO DENSITY FOR ONE ORBITAL.
        TMP=1.0D+00
        ITMP=1
        CALL DMTX(X(LDEN),VORB(1,I),TMP,ITMP,L1,L1)
        CALL DAWRIT(IDAF,IODA,X(LDEN),L2,16,0)
        IF(DEALDAF20) THEN
C         PLEASE SEE USAGE IN DENDD1 ROUTINE.
          CALL DSCAL(L2,0.5D+00,X(LDEN),1)
          CALL DAWRIT(IDAF,IODA,X(LDEN),L2,16,0)
          CALL DAWRIT(IDAF,IODA,X(LDEN),L2,20,0)
        ENDIF
C       FIND QUAD.
        NPRINT_SAV=NPRINT
        NPRINT=-5
        CALL ELMOMC
        NPRINT=NPRINT_SAV
C       DIAGONALIZE THE QUAD. MATRIX.
C       NOTE:  +NUMBER DOES NOT MAKE SENSE.  MAYBE B/C IMP.NONE.
        CALL VCLR(TRI3,1,6)
        TRI3(1)= -QMXX
        TRI3(2)= -QMXY
        TRI3(3)= -QMYY
        TRI3(4)= -QMXZ
        TRI3(5)= -QMYZ
        TRI3(6)= -QMZZ
        DO ITMP=1,6
          TRI3(ITMP) = -TRI3(ITMP)
        ENDDO
        CALL GLDIAG(3,3,3,TRI3,SCR3,EIG3,VEC3,IERR,IWRK3)
        DO ITMP=1,3
          EIG3(ITMP) = -EIG3(ITMP)
        ENDDO
        IF(IERR.NE.0) THEN
          IF(MASWRK) WRITE(IW,9060)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C       SAVE OUT EVAL AND EVEC.
C       NOTE:  DOWNSHIFT TO ACTIVE INDEX TERMS.
        DIPDIR(1,IACT)=DMX
        DIPDIR(2,IACT)=DMY
        DIPDIR(3,IACT)=DMZ
        CALL DCOPY(IVAR3*IVAR3,VEC3,1,QUADDIR(1,IACT),1)
        CALL DCOPY(IVAR3,EIG3,1,QUADEIG(1,IACT),1)
      ENDDO
C     RESTORE VARIOUS ITEMS FOR ELMOMC.
      CALL DAWRIT(IDAF,IODA,X(LDAF16_SAV),L2,16,0)
      IF(DEALDAF20) CALL DAWRIT(IDAF,IODA,X(LDAF20_SAV),L2,20,0)
      NPOINT=NPOINT_SAV
      ELMLOC=ELMLOC_SAV
      XPOINT(1)=XPOINT_SAV
      YPOINT(1)=YPOINT_SAV
      ZPOINT(1)=ZPOINT_SAV
      IEMOM=IEMOM_SAV
      CALL DCOPY(NAT,X(LZAN_SAV),1,ZAN,1)
C
C     DEALLOCATE MEMORY.
      CALL RETFM(NEED)
C
C     RESTORE THE DAF FILES FROM ELMOMC.
      NPRINT_SAV=NPRINT
      NPRINT=-5
      CALL ELMOMC
      NPRINT=NPRINT_SAV
C
      RETURN
 9010 FORMAT(/1X,'LOCAL_ORIENBOS_ORBDIR ERROR:',
     *       /1X,'IVAR3 MUST BE 3.')
 9050 FORMAT(/1X,'LOCAL_ORIENBOS_ORBDIR ERROR:',
     *       /1X,'SCFTYP DOES NOT HAVE AN OPTION HERE.')
 9060 FORMAT(/1X,'LOCAL_ORIENBOS_ORBDIR ERROR:',
     *       /1X,'DIAGONALIZATION HAS ISSUE HERE.')
      END
C*MODULE LOCAL   *DECK LOCAL_ORIENBOS_ASSIGN_ORBTYP
C> @brief      Assigns orbital types for s,p,sigma,pi MOs.
C>
C> @author     Aaron West
C>             -April 09, 2014
C>
C> @param NAT2      is the triangular size of NAT number of atoms.
C> @param MCORE     is the number of chemical core orbitals.
C> @param M1        is the number of oriented valence orbitals.
C> @param M2        is the triangular length of M1.
C> @param IVAR2     equals 2.
C> @param IVAR3     equals 3.
C> @param MAPT3     holds the oriented atom-orbital correspondence.
C> @param IATPAR    will hold 1s for unique atom pairs for strong bonds.
C> @param IORBTYP   will hold the orbital type.
C> @param IORBEND   will hold the complement orbital type if any.
C> @param IORBCT    will hold the total number of complement orbitals.
C> @param IWRK2     is a scratch array of size M2.
C> @param DEN       is the oriented orbital density.
C> @param DENCP     is scratch space of M2 length.
C> @param ATDIR     will hold the atom pair directions.
C> @param QUADDIR   contains the quadrupole directions.
C> @param SOME      is true for master process with nprint not equal -5.
C> @param MASWRK    indicates the master process.
C> @param IW        indicates write out to log file.
      SUBROUTINE LOCAL_ORIENBOS_ASSIGN_ORBTYP(
     *           NAT2,MCORE,M1,M2,IVAR2,IVAR3,
     *           MAPT3,IATPAR,IORBTYP,
     *           IORBEND,IORBCT,IWRK2,
     *           DEN,DENCP,
     *           ATDIR,QUADDIR,
     *           SOME,MASWRK,IW)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER IW,
     *        NAT2,MCORE,M1,M2,IVAR2,IVAR3
      INTEGER MAPT3(M1),IATPAR(NAT2),
     *                  IORBTYP(M1,IVAR2),
     *        IORBEND(M1,M1),IORBCT(M1),IWRK2(M2)
      DOUBLE PRECISION ::
     *       DEN(M2),DENCP(M2),ATDIR(IVAR3),QUADDIR(IVAR3,IVAR3,M1)
C-------------------------------------------------------------------
      INTEGER NSTRBO,
     *        I,J,IJ,JSAV,
     *        IAT,JAT,IJAT,
     *        ISKIP,IATSKIP,NERR,
     *        LTPOS
      DOUBLE PRECISION ::
     *       TOLSBO,TOLLPOCC,TOLPIOCC,TOLRDOCC,TOLRDBO,TOLOVRLP,
     *       SAV,TMP,DUM,
     *       X1,Y1,Z1,OCC,DDOT,XDOT
C-------------------------------------------------------------------
      DOUBLE PRECISION ::
     *       ZERO,ONE
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
C-------------------------------------------------------------------
      INTEGER MXATM
      PARAMETER (MXATM=2000)
C-------------------------------------------------------------------
      INTEGER NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      DOUBLE PRECISION :: ZAN,C
C
      DOUBLE PRECISION :: EXTLOC,EREFATM,BOTOL
      INTEGER ISVMOR,ISVDOP,L0DEP0
      LOGICAL ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
C-------------------------------------------------------------------
C
C     DEFINE THE TOLERANCES.
      TOLSBO=BOTOL(1)
      TOLLPOCC=BOTOL(2)
      TOLPIOCC=BOTOL(3)
      TOLRDOCC=BOTOL(4)
      TOLRDBO=BOTOL(5)
      TOLOVRLP=BOTOL(6)
      IF(SOME) WRITE(IW,9010)
     *               TOLSBO,TOLLPOCC,TOLPIOCC,TOLRDOCC,TOLRDBO,TOLOVRLP
      CALL FLSHBF(IW)
C
C     SORT THE BOND ORDER MAGNITUDES.
      CALL DCOPY(M2,DEN,1,DENCP,1)
      DO I=1,M1
        DENCP(LTPOS(I,I))=ZERO
      ENDDO
      CALL LOCAL_SORT_EVALS(.TRUE.,3,M2,IWRK2,DENCP)
C
C     FIND THE 'BONDING' BOND ORDERS.
      NSTRBO=0
      DO 100 IJ=1,M2
        IF(ABS(DENCP(IJ)).LT.TOLSBO) GO TO 101
        CALL LOCATD_FIND2POS(IWRK2(IJ),I,J)
        IAT=MAPT3(I)
        JAT=MAPT3(J)
        IF(I.EQ.J.OR.IAT.EQ.JAT) GO TO 100
C       PREPARE NSTRBO,IWRK2.
        NSTRBO=NSTRBO+1
        IWRK2(NSTRBO)=LTPOS(I,J)
  100 CONTINUE
  101 CONTINUE
C
C     INITIALIZE IORBTYP ARRAY.
      CALL VICLR(IORBTYP(1,1),1,M1)
C
C     ASSIGN ANY LONE PAIRS.
      DO 355 I=1,M1
        IF(IORBTYP(I,1).NE.0) GO TO 355
        OCC=ABS(DEN(LTPOS(I,I)))
        IF(OCC.LT.TOLLPOCC) GO TO 355
        IORBTYP(I,1)=1
  355 CONTINUE
C
C     ASSIGN BIRADICAL ORBITALS.
      DO 375 I=1,M1
C--------
        CALL LOCAL_ORIENBOS_SKIP(I,IATSKIP,M1,MAPT3)
        IF(IATSKIP.EQ.1) GO TO 375
        IF(IORBTYP(I,1).NE.0) GO TO 375
C--------
        TMP=ABS(ONE-DEN(LTPOS(I,I)))
        IF(TMP.GT.TOLRDOCC) GO TO 375
C       LOCATE THE BIGGEST BO FOR THE ITH MO.
        JSAV=0
        SAV=ZERO
        DO 380 J=1,M1   ! note:  must run over M1
          IF(I.EQ.J) GO TO 380
          TMP=ABS(DEN(LTPOS(I,J)))
          IF(TMP.LT.SAV) GO TO 380
          SAV=TMP
          JSAV=J
  380   CONTINUE
        IF(JSAV.EQ.0.OR.SAV.LE.TOLRDBO) IORBTYP(I,1)=2
  375 CONTINUE
C
C     ASSIGN THE SIGMA ORBITALS.
      NERR=0
      CALL VICLR(IATPAR,1,NAT2)
      DO 400 IJ=1,NSTRBO
        CALL LOCATD_FIND2POS(IWRK2(IJ),I,J)
        IF(IORBTYP(I,1).NE.0) GO TO 400
        IF(IORBTYP(J,1).NE.0) GO TO 400
C--------
        IAT=MAPT3(I)
        JAT=MAPT3(J)
        IJAT=LTPOS(IAT,JAT)
C--------
        X1=C(1,IAT)-C(1,JAT)
        Y1=C(2,IAT)-C(2,JAT)
        Z1=C(3,IAT)-C(3,JAT)
        TMP=SQRT(X1**2+Y1**2+Z1**2)
        ATDIR(1)=X1/TMP
        ATDIR(2)=Y1/TMP
        ATDIR(3)=Z1/TMP
        TMP=DDOT(3,ATDIR,1,QUADDIR(1,1,I),1)
        DUM=DDOT(3,ATDIR,1,QUADDIR(1,1,J),1)
        TMP=(ABS(TMP)+ABS(DUM))/2.0D+00
        IF(TMP.LT.TOLOVRLP) GO TO 400
C--------
        IATPAR(IJAT)=IATPAR(IJAT)+1
        IF(IATPAR(IJAT).GT.1) THEN
          NERR=NERR+1
          GO TO 401
        ENDIF
C--------
        CALL LOCAL_ORIENBOS_SKIP(I,IATSKIP,M1,MAPT3)
        IF(IATSKIP.EQ.1) GO TO 411
        IORBTYP(I,1)=3
C--------
  411   CONTINUE
        CALL LOCAL_ORIENBOS_SKIP(J,IATSKIP,M1,MAPT3)
        IF(IATSKIP.EQ.1) GO TO 400
        IORBTYP(J,1)=3
C--------
  400 CONTINUE
  401 CONTINUE
      IF(NERR.NE.0) THEN
        IF(MASWRK) WRITE(IW,9050) MCORE+I,MCORE+J,IAT,JAT
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     ASSIGN THE PI ORBITALS.
      DO 500 I=1,M1
        CALL LOCAL_ORIENBOS_SKIP(I,IATSKIP,M1,MAPT3)
        IF(IATSKIP.EQ.1) GO TO 500
        IF(IORBTYP(I,1).NE.0) GO TO 500
        OCC=ABS(DEN(LTPOS(I,I)))
C       LOCATE THE BIGGEST BO FOR THE ITH MO.
        JSAV=0
        SAV=ZERO
        DO 510 J=1,M1   ! note:  must run over M1.
          IF(I.EQ.J) GO TO 510
          TMP=ABS(DEN(LTPOS(I,J)))
          IF(TMP.LT.SAV) GO TO 510
          SAV=TMP
          JSAV=J
  510   CONTINUE
        IF(OCC.GE.TOLPIOCC.AND.ABS(SAV).GE.TOLSBO) IORBTYP(I,1)=4
  500 CONTINUE
C
C     ASSIGN THE COMPLEMENT ORBITAL LAST.
      CALL VICLR(IORBEND,1,M1*M1)
      CALL VICLR(IORBCT,1,M1)
      DO 600 IJ=1,NSTRBO
        CALL LOCATD_FIND2POS(IWRK2(IJ),I,J)
C-------------------------------------
        IF(I.EQ.J) GO TO 600
        IF(MAPT3(I).EQ.MAPT3(J)) GO TO 600
C-------------------------------------
        ISKIP=0
        IF(IORBTYP(I,1).EQ.0) ISKIP=1
        IF(IORBTYP(I,1).EQ.1) ISKIP=1
        IF(IORBTYP(I,1).EQ.2) ISKIP=1
C       --KEEPING 3.
C       --KEEPING 4.
        IF(ISKIP.EQ.1) GO TO 611
C-------------------------------------
        IORBCT(I)=IORBCT(I)+1
        IORBEND(I,IORBCT(I))=J
C-------------------------------------
  611   CONTINUE
        ISKIP=0
        IF(IORBTYP(J,1).EQ.0) ISKIP=1
        IF(IORBTYP(J,1).EQ.1) ISKIP=1
        IF(IORBTYP(J,1).EQ.2) ISKIP=1
C       --KEEPING 3.
C       --KEEPING 4.
        IF(ISKIP.EQ.1) GO TO 600
C-------------------------------------
        IORBCT(J)=IORBCT(J)+1
        IORBEND(J,IORBCT(J))=I
C-------------------------------------
  600 CONTINUE
C
      RETURN
 9010 FORMAT(/1X,'LOCAL_ORIENBOS_ASSIGN_ORBTYP TOLERANCES:',
     *       /1X,'TOLSBO   = ',F5.2,
     *       /1X,'TOLLPOCC = ',F5.2,
     *       /1X,'TOLPIOCC = ',F5.2,
     *       /1X,'TOLRDOCC = ',F5.2,
     *       /1X,'TOLRDBO  = ',F5.2,
     *       /1X,'TOLOVRLP = ',F5.2)
 9050 FORMAT(/1X,'LOCAL_ORIENBOS_ASSIGN_ORBTYP ERROR:',
     *       /1X,'ALGORITHM TRIES TO ASSIGN TOO MANY SIGMAS.',
     *       /1X,'LOOK AT ORBITALS',I4,I4,
     *       /1X,'LOOK AT ATOMS',I4,I4)
      END
C*MODULE LOCAL   *DECK LOCAL_ORIENBOS_SKIP
C> @brief      Skips orbital assignments for certain atom kinds.
C>
C> @author     Aaron West
C>             -April 20, 2014
C>
C> @param IORB     is the active oriented orbital index.
C> @param IATSKIP  equals 1 when a skip is needed.
C> @param M1       is the number of oriented orbitals.
C> @param MAPT3    is the oriented orbital-atom correspondence.
      SUBROUTINE LOCAL_ORIENBOS_SKIP(IORB,IATSKIP,M1,MAPT3)
      IMPLICIT NONE
      INTEGER IORB,IATSKIP,M1,MAPT3(M1)
C----------------------------------------------------------------------
      INTEGER ITMP
C----------------------------------------------------------------------
      DOUBLE PRECISION :: ZAN,C
      INTEGER NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,IAN
C----------------------------------------------------------------------
      INTEGER MXATM
      PARAMETER (MXATM=2000)
C----------------------------------------------------------------------
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NEX,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C----------------------------------------------------------------------
C
      IATSKIP=0
C
      ITMP=IAN(MAPT3(IORB))
C
      IF(ITMP.GE.21.AND.ITMP.LE.30) IATSKIP=1
      IF(ITMP.GE.39.AND.ITMP.LE.48) IATSKIP=1
      IF(ITMP.GE.57.AND.ITMP.LE.80) IATSKIP=1
      IF(ITMP.GE.89               ) IATSKIP=1
C
      RETURN
      END
C*MODULE LOCAL   *DECK LOCAL_ORIENBOS_PRINT
C> @brief      Prints out orientation information by magnitude.
C>
C> @author     Aaron West
C>             -April 09, 2014
C>
C> @param IVAR2     equals 2.
C> @param MCORE     is the number of chemical core orbitals.
C> @param M1        is the number of oriented valence orbitals.
C> @param M2        is the triangular length of M1.
C> @param MAPT3     holds the oriented atom-orbital correspondence.
C> @param IORBTYP   will hold the orbital type.
C> @param IORBEND   will hold the complement orbital type if any.
C> @param IORBCT    will hold the total number of complement orbitals
C> @param IWRK2     is a scratch array of size M2.
C> @param DEN       is the oriented orbital density.
C> @param DENCP     is scratch space of M2 length.
C> @param DENKE     will hold bond order times KE integrals on exit.
C> @param SOME      is true for master process with nprint not equal -5.
C> @param IW        indicates write out to log file.
      SUBROUTINE LOCAL_ORIENBOS_PRINT(
     *           IVAR2,MCORE,M1,M2,
     *           MAPT3,IORBTYP,
     *           IORBEND,IORBCT,IWRK2,
     *           DEN,DENCP,DENKE,
     *           SOME,IW)
      IMPLICIT NONE
      LOGICAL SOME
      INTEGER IW,
     *        IVAR2,MCORE,M1,M2
      INTEGER MAPT3(M1),IORBTYP(M1,IVAR2),
     *        IORBEND(M1,M1),IORBCT(M1),IWRK2(M2)
      DOUBLE PRECISION ::
     *       DEN(M2),DENCP(M2),DENKE(M2)
C-------------------------------------------------------------------
      INTEGER ILOOP,I,J,ISAV,JSAV,IORB1,IORB2,IATM1,IATM2,
     *        IATCMP1,IATCMP2,IMORE,
     *        LTPOS
      DOUBLE PRECISION ::
     *       TMP,
     *       OCC1,OCC2,BORD,OKE1,OKEBORD,
     *       ATOM1,ATOM2,
     *       CMPAT1,CMPAT2
C-------------------------------------------------------------------
      INTEGER MXATM,MXAO
      PARAMETER (MXATM=2000, MXAO=8192)
      DOUBLE PRECISION :: ZERO,TOLDEN
      PARAMETER (ZERO=0.0D+00,TOLDEN=1.0D-03)
C-------------------------------------------------------------------
      DOUBLE PRECISION :: TITLE,A,B,BFLAB
C
      COMMON /RUNLAB/ TITLE(10),A(MXATM),B(MXATM),BFLAB(MXAO)
C-------------------------------------------------------------------
C
C     PRINT OFF BANNER.
      IF(SOME) WRITE(IW,9000)
C
C     PRINT INFORMATION FOR BOND ORDERS FROM BIGGEST TO SMALLEST
C           USING THE DENKE VALUES.
      IF(SOME) WRITE(IW,9010)
      CALL DCOPY(M2,DENKE,1,DENCP,1)
      DO I=1,M1
        DENCP(LTPOS(I,I))=ZERO
      ENDDO
      CALL LOCAL_SORT_EVALS(.TRUE.,3,M2,IWRK2,DENCP)
      DO 100 ILOOP=1,M2
        IF(ABS(DENCP(ILOOP)).LT.TOLDEN) GO TO 101
        CALL LOCATD_FIND2POS(IWRK2(ILOOP),ISAV,JSAV)
        IF(ISAV.EQ.JSAV) GO TO 100
C
C       PRINT OFF NEEDED INFORMATION.
        OCC1=DEN(LTPOS(ISAV,ISAV))
        OCC2=DEN(LTPOS(JSAV,JSAV))
        BORD=DEN(LTPOS(ISAV,JSAV))
        OKEBORD=DENKE(LTPOS(ISAV,JSAV))
        IATM1=MAPT3(ISAV)
        IATM2=MAPT3(JSAV)
        ATOM1=A(IATM1)
        ATOM2=A(IATM2)
        IORB1=MCORE+ISAV
        IORB2=MCORE+JSAV
C-----------------------------------
        IF(SOME) THEN
          WRITE(IW,9020) BORD
          WRITE(IW,9020) OKEBORD
          WRITE(IW,9030) IORB1
          WRITE(IW,9020) OCC1
          WRITE(IW,9040) ATOM1
          WRITE(IW,9030) IATM1
C-----------------------------------
C         START EXTRA PRINT.
          IF(IORBCT(ISAV).NE.0) THEN
C           ACCOUNT FOR MANY IMPORTANT ATOMS.
            DO IMORE=1,IORBCT(ISAV)
              IATCMP1=MAPT3(IORBEND(ISAV,IMORE))
              CMPAT1=A(IATCMP1)
              IF(IMORE.EQ.1) WRITE(IW,9210)
              IF(IMORE.GT.1) WRITE(IW,9219)
              WRITE(IW,9040) CMPAT1
              WRITE(IW,9030) IATCMP1
            ENDDO
            WRITE(IW,9220)
          ELSE
            WRITE(IW,9200)
          ENDIF
C         END EXTRA PRINT.
C-----------------------------------
          IF(IORBTYP(ISAV,1).EQ.0) WRITE(IW,9099)
          IF(IORBTYP(ISAV,1).EQ.1) THEN
            IF(IORBTYP(ISAV,2).EQ.1) WRITE(IW,9100)
            IF(IORBTYP(ISAV,2).EQ.2) WRITE(IW,9110)
            IF(IORBTYP(ISAV,2).GT.2) WRITE(IW,9111)
          ENDIF
          IF(IORBTYP(ISAV,1).EQ.2) WRITE(IW,9120)
          IF(IORBTYP(ISAV,1).EQ.3) WRITE(IW,9130)
          IF(IORBTYP(ISAV,1).EQ.4) WRITE(IW,9140)
          WRITE(IW,9030) IORB2
          WRITE(IW,9020) OCC2
          WRITE(IW,9040) ATOM2
          WRITE(IW,9030) IATM2
C-----------------------------------
C         START EXTRA PRINT.
          IF(IORBCT(JSAV).NE.0) THEN
C           ACCOUNT FOR MANY IMPORTANT ATOMS.
            DO IMORE=1,IORBCT(JSAV)
              IATCMP2=MAPT3(IORBEND(JSAV,IMORE))
              CMPAT2=A(IATCMP2)
              IF(IMORE.EQ.1) WRITE(IW,9210)
              IF(IMORE.GT.1) WRITE(IW,9219)
              WRITE(IW,9040) CMPAT2
              WRITE(IW,9030) IATCMP2
            ENDDO
            WRITE(IW,9220)
          ELSE
            WRITE(IW,9200)
          ENDIF
C         END EXTRA PRINT.
C-----------------------------------
          IF(IORBTYP(JSAV,1).EQ.0) WRITE(IW,9099)
          IF(IORBTYP(JSAV,1).EQ.1) THEN
            IF(IORBTYP(JSAV,2).EQ.1) WRITE(IW,9100)
            IF(IORBTYP(JSAV,2).EQ.2) WRITE(IW,9110)
            IF(IORBTYP(JSAV,2).GT.2) WRITE(IW,9111)
          ENDIF
          IF(IORBTYP(JSAV,1).EQ.2) WRITE(IW,9120)
          IF(IORBTYP(JSAV,1).EQ.3) WRITE(IW,9130)
          IF(IORBTYP(JSAV,1).EQ.4) WRITE(IW,9140)
          WRITE(IW,*)
        ENDIF
  100 CONTINUE
  101 CONTINUE
C
C     PRINT AN END STATEMENT.
      IF(SOME) WRITE(IW,9300)
C
C     PRINT OFF SECOND BANNER.
      IF(SOME) WRITE(IW,9001)
C
C     PRINT INFORMATION FOR OCCUPATIONS FROM BIGGEST TO SMALLEST.
      IF(SOME) WRITE(IW,9050)
      CALL VCLR(DENCP,1,M2)
      DO I=1,M1
        DENCP(I)=DEN(LTPOS(I,I))
      ENDDO
      CALL VICLR(IWRK2,1,M2)
      CALL LOCAL_SORT_EVALS(.TRUE.,3,M1,IWRK2,DENCP)
      DO 200 ILOOP=1,M1
        ISAV=IWRK2(ILOOP)
        IF(ABS(DENCP(ILOOP)).LT.TOLDEN) GO TO 201
C
C       PRINT OFF NEEDED INFORMATION.
        OCC1=DEN(LTPOS(ISAV,ISAV))
        OKE1=DENKE(LTPOS(ISAV,ISAV))
        IATM1=MAPT3(ISAV)
        ATOM1=A(IATM1)
        IORB1=MCORE+ISAV
C-----------------------------------
        IF(SOME) THEN
          WRITE(IW,9020) OCC1
          WRITE(IW,9020) OKE1
          WRITE(IW,9030) IORB1
          WRITE(IW,9040) ATOM1
          WRITE(IW,9030) IATM1
C-----------------------------------
C         START EXTRA PRINT.
          IF(IORBCT(ISAV).NE.0) THEN
C           ACCOUNT FOR MANY IMPORTANT ATOMS.
            DO IMORE=1,IORBCT(ISAV)
              IATCMP1=MAPT3(IORBEND(ISAV,IMORE))
              CMPAT1=A(IATCMP1)
              IF(IMORE.EQ.1) WRITE(IW,9210)
              IF(IMORE.GT.1) WRITE(IW,9219)
              WRITE(IW,9040) CMPAT1
              WRITE(IW,9030) IATCMP1
            ENDDO
            WRITE(IW,9220)
          ELSE
            WRITE(IW,9200)
          ENDIF
C         END EXTRA PRINT.
C-----------------------------------
          IF(IORBTYP(ISAV,1).EQ.0) WRITE(IW,9099)
          IF(IORBTYP(ISAV,1).EQ.1) THEN
            IF(IORBTYP(ISAV,2).EQ.1) WRITE(IW,9100)
            IF(IORBTYP(ISAV,2).EQ.2) WRITE(IW,9110)
            IF(IORBTYP(ISAV,2).GT.2) WRITE(IW,9111)
          ENDIF
          IF(IORBTYP(ISAV,1).EQ.2) WRITE(IW,9120)
          IF(IORBTYP(ISAV,1).EQ.3) WRITE(IW,9130)
          IF(IORBTYP(ISAV,1).EQ.4) WRITE(IW,9140)
          WRITE(IW,*)
        ENDIF
  200 CONTINUE
  201 CONTINUE
C
C     PRINT AN END STATEMENT.
      IF(SOME) WRITE(IW,9300)
C
C     PRINT THE INTERATOMIC VALENCE KBO SUM.
      TMP=ZERO
      DO 500 I=1,M1
        IATM1=MAPT3(I)
        DO 510 J=1,M1
          IATM2=MAPT3(J)
          IF(IATM1.EQ.IATM2) GO TO 510
          TMP=TMP+DENKE(LTPOS(I,J))
  510   CONTINUE
  500 CONTINUE
      IF(SOME) WRITE(IW,9500) TMP
C
      RETURN
 9000 FORMAT(/1X,'PRINT OFF ORIENTATION INFORMATION',
     *        1X,'BY KEI-BO MAGNITUDE.')
 9001 FORMAT(/1X,'PRINT OFF ORIENTATION INFORMATION',
     *        1X,'BY OCCUPATION MAGNITUDE.')
 9010 FORMAT(/1X,'BOND ORDER',5X,
     *           'KEI-BO',5X,
     *           'ORB I',5X,
     *           'OCC I',5X,
     *           'ATM I',5X,
     *           'ORBTYP I',5X,
     *           'ORB J',5X,
     *           'OCC J',5X,
     *           'ATM J',5X,
     *           'ORBTYP J')
 9020 FORMAT(1X,F12.7,$)
 9030 FORMAT(1X,I4,$)
 9040 FORMAT(1X,A2,$)
 9050 FORMAT(/1X,'OCCUPATION',5X,
     *           'KEI-OCC I',5X,
     *           'ORB I',5X,
     *           'ATM I',5X,
     *           'ORBTYP I')
 9099 FORMAT(1X,'NWB   0',$)
 9100 FORMAT(1X,'SLP    ',$)
 9110 FORMAT(1X,'PLP    ',$)
 9111 FORMAT(1X,'NO LABEL ASSIGNED YET',$)
 9120 FORMAT(1X,'RADICAL',$)
 9130 FORMAT(1X,'SIGMA  ',$)
 9140 FORMAT(1X,'PI     ',$)
 9200 FORMAT(1X,'( NWB   0 )',$)
 9210 FORMAT(1X,'(',$)
 9219 FORMAT(1X,',',$)
 9220 FORMAT(1X,')',$)
 9300 FORMAT(/1X,'END OF CURRENT INFORMATION')
 9500 FORMAT(/1X,'INTERATOMIC KEI-BO SUM',F20.10)
      END
C*MODULE LOCAL   *DECK LOCAL_ORIENBOS_LONETYP
C> @brief      Determines the orbital type of oriented valence QUAOs.
C>
C> @author     Juan Duchimaza-Heredia and Aaron West
C>             -September 05, 2014
C>
C> @param IVAR2    equals 2.
C> @param NAT      is the number of atoms.
c> @param IAN      is from INFOA common.
C> @param L1       is the length of AO coefficients.
C> @param L0MBS        is the dimension of the minimal basis set number
C>                     of orbitals.
C> @param NCORTOT  is the number of chemical core orbitals.
C> @param M1       is the number of oriented valence orbitals.
C> @param INUMTYP  is the length of s,p,d,etc orbitals.
C>                 At this moment on September 05 2014,
C>                 only s,p,d orbitals are present in the AAMBS.
C>                 So, INUMTYP equals 3 for s=1,p=2,d=3.
C> @param ITOTLIST will hold the orbital type for each oriented orbital
C>                 in the total oriented orbital list.
C>                 ITOTLIST includes the core and valence orbitals.
C> @param IORBTYP  will hold the orbital type for each oriented orbital
C>                 IORBTYP includes only the valence orbitals.
C> @param MAPT3    holds ORMAS group label for each oriented orbital.
C> @param IPOSCOR  denotes the integer array that holds the starting
C>                 position for the 1st CORE AO on a given atom.
C> @param IPOSMBS  denotes the integer array that holds the starting
C>                 position for the 1st MBS AO on a given atom.
C>                 These are in atomic order from the input
C>                 as usual.
C> @param ILENCOR  denotes the integer array that holds the
C>                 number of CORE orbitals on a given atom.
C> @param ILENMBS  gives the number of VALANEC MBS orbitals.
C> @param IWRK     is an integer work array of size L1.
C> @param IWRK2    is an integer work array of size L1.
C> @param SVMBS    is an array that holds the overlap to the true AOs
C>                 from the VVOS run.
C> @param OVLMBS   is a work array of size L0MBSxL0MBS for overlaps.
C> @param CLMO     holds the oriented orbitals.
C> @param FACTYP   is a work array of size INUMTYP.
C> @param SOME    is true for master process with nprint not equal -5.
C> @param MASWRK   indicates the master process.
      SUBROUTINE LOCAL_ORIENBOS_LONETYP(
     *           IVAR2,NAT,IAN,
     *           L1,L0MBS,NCORTOT,M1,INUMTYP,
     *           ITOTLIST,IORBTYP,
     *           MAPT3,IPOSCOR,IPOSMBS,ILENCOR,ILENMBS,
     *           IWRK,IWRK2,
     *           SVMBS,OVLMBS,CLMO,
     *           FACTYP,
     *           SOME,MASWRK)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER IVAR2,NAT,L1,L0MBS,NCORTOT,M1,INUMTYP,
     *        IAN(NAT),
     *        ITOTLIST(L0MBS),IORBTYP(M1,IVAR2),
     *        MAPT3(L1),
     *        IPOSCOR(NAT+1),IPOSMBS(NAT+1),ILENCOR(NAT),ILENMBS(NAT),
     *        IWRK(L1),IWRK2(L1)
      DOUBLE PRECISION ::
     *       SVMBS(L1,L0MBS),OVLMBS(L0MBS,L0MBS),CLMO(L1,L1),
     *       FACTYP(INUMTYP)
C-------------------------------------------------------------------
      DOUBLE PRECISION :: ZERO
      PARAMETER (ZERO=0.0D+00)
C-------------------------------------------------------------------
      INTEGER IALL,I,J,NTOT_AAMBS,IATM1,NUCZ,NPASS,IPOS,ILEN,ICT,JSAV
      INTEGER IELIST(11),ICLIST(11),ITLIST(11),IGLIST(11)
      DOUBLE PRECISION :: TMP,BIG,FACTNM
C-------------------------------------------------------------------
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C-------------------------------------------------------------------
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C-------------------------------------------------------------------
C
C     PRINT BANNER FOR ORBITAL CHARACTER PERCENT.
      IF(SOME) WRITE(IW,9000)
      IF(SOME) WRITE(IW,9010)
C
C     OBTAIN ITOTLIST.
C     --ITLIST CONTAINS THE ORBITAL TYPE LABELS FOR CORE+VALENCE AAMBS.
      CALL VICLR(ITOTLIST,1,L0MBS)
      IALL=0
      DO IATM1=1,NAT
        NUCZ=IAN(IATM1)
        CALL ETSHELL(NUCZ,.FALSE.,NPASS,IELIST,ICLIST,ITLIST,IGLIST)
        DO I=1,NPASS
          NTOT_AAMBS=0
          IF(ITLIST(I).EQ.1) NTOT_AAMBS=1 ! s orbital
          IF(ITLIST(I).EQ.2) NTOT_AAMBS=3 ! p orbital
          IF(ITLIST(I).EQ.3) NTOT_AAMBS=5 ! d orbital
          IF(NTOT_AAMBS.EQ.0) THEN
            IF(MASWRK) WRITE(IW,9100)
            CALL FLSHBF(IW)
            CALL ABRT
            STOP
          ENDIF
          DO J=1,NTOT_AAMBS
            IALL=IALL+1
            ITOTLIST(IALL)=ITLIST(I)
          ENDDO
        ENDDO
      ENDDO
      IF(IALL.NE.L0MBS) THEN
        IF(MASWRK) WRITE(IW,9150)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     MAKE ORBITAL OVERLAP BETWEEN AAMBS AND ORIENTED ORBITALS.
      CALL DAREAD(IDAF,IODA,SVMBS,L1*L0MBS,533,0)
      CALL MRTRBR(CLMO,L1,L1,L0MBS,
     *            SVMBS,L1,L0MBS,
     *            OVLMBS,L0MBS)
C
C     SETUP REORDERING ARRAY FOR THE NEXT STEP.
      CALL LOCAL_VVOS_ORB_RANGE_CORE(IPOSCOR,ILENCOR,NAT)
      CALL LOCAL_VVOS_ORB_RANGE(IPOSMBS,ILENMBS,NAT)
      CALL VICLR(IWRK,1,L1)
      ICT=0
      DO IATM1=1,NAT
        IPOS=IPOSCOR(IATM1)
        ILEN=ILENCOR(IATM1)
        DO I=IPOS,IPOS+ILEN-1
          ICT=ICT+1
          IWRK(ICT)=I
        ENDDO
      ENDDO
      DO IATM1=1,NAT
        IPOS=IPOSMBS(IATM1)
        ILEN=ILENMBS(IATM1)
        DO I=IPOS,IPOS+ILEN-1
          ICT=ICT+1
          IWRK(ICT)=I
        ENDDO
      ENDDO
C
C     TAKE OVERLAP MATRIX.
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL REORDR(OVLMBS,IWRK2,L0MBS,L0MBS)
      CALL ICOPY(L1,IWRK,1,IWRK2,1)
      CALL IREORDR(ITOTLIST,IWRK2,L0MBS,1)
C
C     CALCULATE THE PERCENT CHARACTER OF EACH ORBITAL OVERLAP
C     NOTE:  INUMTYP CONTROLS IF S,P,D,F,ETC. ARE PRESENT.
      CALL VICLR(IORBTYP,1,M1*IVAR2)
      DO I=NCORTOT+1,NCORTOT+M1
        FACTNM=ZERO
        CALL VCLR(FACTYP,1,INUMTYP)
        DO 200 J=NCORTOT+1,NCORTOT+M1
C------------
C         NOTE:  THIS NEXT LINE ONLY WORKS SINCE THE ORIENTED
C                ORBITALS ARE PUT INTO THE ORDER OF ATOMS.
C                IF THIS WAS EVER MODIFIED AWAY FROM THAT PATTERN,
C                THEN ONE COULD NOT USE MAPT3 IN THE ATOM ASSIGNMENT
C                OF INDEX J.  I WOULD THEN MAKE A NEW ASSIGNMENT ABOVE.
          IF(MAPT3(I-NCORTOT).NE.MAPT3(J-NCORTOT)) GO TO 200
C------------
          IPOS=ITOTLIST(J)
          IF(IPOS.LE.0.OR.IPOS.GT.INUMTYP) THEN
            IF(MASWRK) WRITE(IW,9200)
            CALL FLSHBF(IW)
            CALL ABRT
            STOP
          ENDIF
          TMP=OVLMBS(I,J)
          FACTNM=FACTNM+TMP*TMP
          FACTYP(IPOS)=FACTYP(IPOS)+TMP*TMP
  200   CONTINUE
        BIG=ZERO
        JSAV=0
        DO J=1,INUMTYP
          TMP=ABS(FACTYP(J)/FACTNM)
          IF(TMP.GE.BIG) THEN
            BIG=TMP
            JSAV=J
          ENDIF
        ENDDO
        IF(JSAV.LE.0) THEN
          IF(MASWRK) WRITE(IW,9250)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
        IPOS=I-NCORTOT
        IORBTYP(IPOS,2)=JSAV
C------- PRINT OFF ORBITAL CHARACTER INFO.
        IF(SOME) WRITE(IW,9265) I
        DO J=1,INUMTYP
          TMP=ABS(FACTYP(J)/FACTNM)
          IF(SOME) WRITE(IW,9270) TMP
        ENDDO
        IF(SOME) WRITE(IW,*)
C-------
      ENDDO
C
C     PRINT AN END STATEMENT.
      IF(SOME) WRITE(IW,9300)
C
      RETURN
 9000 FORMAT(/1X,'PRINT OFF ORIENTATION INFORMATION',
     *        1X,'FOR VALENCE ORBITAL CHARACTER PERCENT.')
 9010 FORMAT(/2X,'ORB I',2X,'PERCENT S',4X,'PERCENT P',4X,'PERCENT D')
 9100 FORMAT(/1X,'LOCAL_ORIENBOS_LONETYP ERROR:',
     *       /1X,'MISSING ORBITAL TYPE HERE. NEED TO DEFINE IN CODE.')
 9150 FORMAT(/1X,'LOCAL_ORIENBOS_LONETYP ERROR:',
     *       /1X,'IALL DOES NOT EQUAL L0MBS LIKE IT SHOULD.')
 9200 FORMAT(/1X,'LOCAL_ORIENBOS_LONETYP ERROR:',
     *       /1X,'ITOTLIST IS OUT OF RANGE.  A MEMORY NO NO...')
 9250 FORMAT(/1X,'LOCAL_ORIENBOS_LONETYP ERROR:',
     *       /1X,'JSAV CANNOT BE 0.  A MEMORY NO NO...')
 9265 FORMAT(1X,I4,$)
 9270 FORMAT(1X,F12.7,$)
 9300 FORMAT(/1X,'END OF CURRENT INFORMATION')
      END
C*MODULE LOCAL   *DECK LOCAL_LUKE_PRTGRPS
C> @brief     Puts oriented orbitals into .dat file in ORMAS groups.
C>
C> @author     Aaron West
C>             -August 03, 2014
C>
C> @details    I made this item at the request of Luke R.
C>
C> @param ICORPRT =1 prints off the chemical core orbitals.
C> @param L1       is the length of AO coefficients.
C> @param L3      is the square of L1.
C> @param MCORE   is the number of chemical core orbitals.
C> @param MDOC    is the number of inactive orbitals.
C> @param NVVOS   is the number of VVOs orbitals.
C> @param M1      is the number of oriented valence orbitals.
C> @param NSPACE  is the number of ORMAS groups.
C> @param MAPT3   holds the ORMAS group label for each oriented orbital.
C> @param CLMO    holds the oriented orbitals.
C> @param VCP     is a temporary array of size L3.
      SUBROUTINE LOCAL_LUKE_PRTGRPS(
     *        ICORPRT,
     *        L1,L3,MCORE,MDOC,NVVOS,M1,NSPACE,
     *        MAPT3,
     *        CLMO,VCP)
      IMPLICIT NONE
      INTEGER ICORPRT,L1,L3,MCORE,MDOC,NVVOS,M1,NSPACE
      INTEGER MAPT3(L1)
      DOUBLE PRECISION ::
     *       CLMO(L1,L1),VCP(L1,L1)
C-----------------------------------------------------------------------
      INTEGER IG,I,ITOT,ISAV,IPOS,INEW,LUFILE
C-----------------------------------------------------------------------
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C-----------------------------------------------------------------------
C
C     PRINT OUT THE CORE ORBITALS IF DESIRED.
      IF(ICORPRT.EQ.1) THEN
        INEW=0
        LUFILE = IP
        IG=0
        WRITE(IP,9080) IG
        CALL PUSQLF(LUFILE,CLMO,MCORE,L1,L1,INEW)
        WRITE(IP,9085)
      ENDIF
C
C     PULL OUT THE ORBITALS FOR EACH GROUP.
      ITOT=MCORE+MDOC
      DO 90 IG=1,NSPACE
        IPOS=0
        ISAV=ITOT
        CALL VCLR(VCP,1,L3)
        DO 100 I=1,M1
          IF(MAPT3(I).NE.IG) GO TO 100
          IF(MDOC+NVVOS.GT.0.AND.IG.EQ.1) GO TO 100
          IPOS=IPOS+1
          ITOT=ITOT+1
          CALL DCOPY(L1,CLMO(1,MCORE+I),1,VCP(1,IPOS),1)
  100   CONTINUE
C
C       SKIP THE INACTIVE+VVOS PIECE IF ANY.
        IF(MDOC+NVVOS.GT.0.AND.IG.EQ.1) GO TO 90
C
C       PRINT OUT THE CURRENT SET OF ORBITALS TO THE .DAT FILE.
        INEW=ISAV
        LUFILE = IP
        WRITE(IP,9080) IG
        CALL PUSQLF(LUFILE,VCP,IPOS,L1,L1,INEW)
        WRITE(IP,9085)
   90 CONTINUE
C
      RETURN
 9080 FORMAT('SVD RUN ORIENTED ORBITALS FOR GROUP',I4,/' $VEC')
 9085 FORMAT(' $END')
      END
C*MODULE LOCAL   *DECK LOCAL_ATOMIC_DIPOLE
C> @brief      Dipole decomposition for atomic orbitals.
C>
C> @author     Aaron West
C>             -August 27, 2014
C>
C> @param IVAR3   equals 3 for the number of coordinates.
C> @param NAT     is the number of atoms.
C> @param L1       is the length of AO coefficients.
C> @param L2      is the triangular length of L1.
C> @param M1SVD   is the number of orbitals to use in forming
C>                the QUAO dipole integrals.
C>                Right now, M1SVD equals L0MBS.
C>                However, it is left flexible.
C> @param M2SVD   is the triangular length of M1SVD.
C> @param M1      is the number of active orbitals.
C> @param M2      is the triangular size of M1.
C> @param NCORTOT is the number of chemical core orbitals.
C> @param ICH     is the molecular charge.
C> @param MAPT3   will hold the oriented orbital-atom correspondence.
C> @param STRI    is a triangular work array of length L2.
C> @param CLMO    holds the LCAO for the oriented QUAOs.
C> @param WRK     is a work array of length L1.
C> @param DEN     holds the oriented QUAO density matrix.
C> @param QACH    will hold the electronic population on each atom.
C> @param ZAN     holds the nuclear charge on each atom.
C> @param C       holds the atomic x,y,z coordinates for each atom.
C> @param DIPQ    will hold the x,y,z oriented QUAO dipole integrals.
C> @param DIPAT   will hold the x,y,z dipole contributions
C>                for each atom.
C> @param DIPBND  will hold the x,y,z dipole contributions
C>                for each atom pair.
C> @param DIPCOP  is a work space of NATxNATxIVAR3 dimensions.
C> @param SOME    is true for master process with nprint not equal -5.
C> @param MASWRK  indicates the master process.
      SUBROUTINE LOCAL_ATOMIC_DIPOLE(
     *           IVAR3,NAT,L1,L2,M1SVD,M2SVD,M1,M2,NCORTOT,ICH,
     *           MAPT3,
     *           STRI,CLMO,WRK,DEN,
     *           QACH,ZAN,C,
     *           DIPQ,DIPAT,DIPBND,DIPCOP,
     *           SOME,MASWRK)
      IMPLICIT NONE
      LOGICAL SOME,MASWRK
      INTEGER IVAR3,NAT,L1,L2,M1SVD,M2SVD,M1,M2,NCORTOT,ICH
      INTEGER MAPT3(L1)
      DOUBLE PRECISION ::
     *       STRI(L2),CLMO(L1,L1),WRK(L1),DEN(M2),
     *       QACH(NAT),ZAN(NAT),C(3,NAT),
     *       DIPQ(M2SVD,IVAR3),DIPAT(NAT,IVAR3),
     *       DIPBND(NAT,NAT,IVAR3),DIPCOP(NAT,NAT,IVAR3)
C-----------------------------------------------------------------------
      LOGICAL NOSKIP
      INTEGER IATM1,IATM2,I,J,IJ,IJV,IDIR,ICORTOT,ICORST,
     *        ISAV,JSAV,ILOOP,
     *        NVVOS_NUMCOR,LTPOS
      DOUBLE PRECISION ::
     *       TMP,DUM,TMPNRM,TMPPRJ,
     *       ZTOT,QTOT,
     *       TMPX,TMPY,TMPZ,SAV,ATOM1,ATOM2,
     *       CZ(3),CQ(3),
     *       DT1(3),DT2(3),DTTOT(3),COMTMP(3),TMPDIR(3)
C----------------------------------------------------------------------
      INTEGER MXATM,MXAO
      PARAMETER (MXATM=2000, MXAO=8192)
      DOUBLE PRECISION :: ZERO,HALF,TWO,DFAC
      PARAMETER (ZERO=0.0D+00,HALF=0.5D+00,TWO=2.0D+00,
     *           DFAC=2.541766D+00)
C-----------------------------------------------------------------------
      INTEGER IW,IDAF,IODA,IP,IPK,IR,IS,NAV
C
      DOUBLE PRECISION :: TITLE,A,B,BFLAB
C
      DOUBLE PRECISION ::
     *                XP,YP,ZP,
     *                DMX,DMY,DMZ,
     *                QXX,QYY,QZZ,QXY,QXZ,QYZ,
     *                QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ,
     *                OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ,
     *                OXZZ,OYZZ,OZZZ,OXYZ,
     *                OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY,
     *                OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ
C-----------------------------------------------------------------------
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      COMMON /RUNLAB/ TITLE(10),A(MXATM),B(MXATM),BFLAB(MXAO)
C
      COMMON /XYZPRP/ XP,YP,ZP,
     *                DMX,DMY,DMZ,
     *                QXX,QYY,QZZ,QXY,QXZ,QYZ,
     *                QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ,
     *                OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ,
     *                OXZZ,OYZZ,OZZZ,OXYZ,
     *                OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY,
     *                OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ
C-----------------------------------------------------------------------
C
C     PRINT OFF BANNER.
      IF(SOME) WRITE(IW,9000)
C
C     GET ATOM LABELS.
      CALL DAREAD(IDAF,IODA,MAPT3,L1,547,1)
C
C     CREATE THE ORIENTED QUAO DIPOLE INTEGRALS NOW.
      CALL VCLR(DIPQ,1,M2SVD*IVAR3)
      CALL DAREAD(IDAF,IODA,STRI,L2,95,0)
      CALL TFTRI(DIPQ(1,1),STRI,CLMO,WRK,M1SVD,L1,L1)
      CALL DAREAD(IDAF,IODA,STRI,L2,96,0)
      CALL TFTRI(DIPQ(1,2),STRI,CLMO,WRK,M1SVD,L1,L1)
      CALL DAREAD(IDAF,IODA,STRI,L2,97,0)
      CALL TFTRI(DIPQ(1,3),STRI,CLMO,WRK,M1SVD,L1,L1)
C
C     DEFINE COMTMP FOR CONVENIENCE.
      COMTMP(1)=XP
      COMTMP(2)=YP
      COMTMP(3)=ZP
C
C     CREATE THE QACH ATOMIC POPULATIONS.
C     --ALSO, CALCULATE ZTOT AND QTOT.
      ZTOT=ZERO
      QTOT=ZERO
      CALL VCLR(QACH,1,NAT)
      DO IATM1=1,NAT
        ZTOT=ZTOT+ZAN(IATM1)
        TMP=TWO*NVVOS_NUMCOR(IATM1,1)
        QTOT=QTOT+TMP
        QACH(IATM1)=QACH(IATM1)+TMP
      ENDDO
      DO I=1,M1
        IATM1=MAPT3(I)
        TMP=DEN(LTPOS(I,I))
        QTOT=QTOT+TMP
        QACH(IATM1)=QACH(IATM1)+TMP
      ENDDO
C
C     CALCULATE CZ=CENTROID OF ALL NUCLEAR CHARGES.
C     CALCULATE CQ=CENTROID OF ALL ATOMIC POPULATIONS.
      CALL VCLR(CZ,1,3)
      CALL VCLR(CQ,1,3)
      DO IATM1=1,NAT
        TMP=ZAN(IATM1)/ZTOT
        DUM=QACH(IATM1)/QTOT
        DO IDIR=1,3
          CZ(IDIR)=CZ(IDIR)+TMP*C(IDIR,IATM1)
          CQ(IDIR)=CQ(IDIR)+DUM*C(IDIR,IATM1)
        ENDDO
      ENDDO
C
C     DT TERM = CONTRIBUTION DUE TO CHARGE TRANSFERS
      CALL VCLR(DT1,1,3)
      CALL VCLR(DT2,1,3)
      CALL VCLR(DTTOT,1,3)
      TMP=HALF*(ZTOT+QTOT)
      DUM=HALF*(ZTOT-QTOT)
      DO IDIR=1,3
        TMPNRM=TMP*(CZ(IDIR)-CQ(IDIR))
        TMPPRJ=DUM*(CZ(IDIR)+CQ(IDIR))
        DT1(IDIR)=DT1(IDIR)+TMPNRM
        DT2(IDIR)=DT2(IDIR)+TMPPRJ
        DTTOT(IDIR)=DTTOT(IDIR)+TMPNRM+TMPPRJ
      ENDDO
      CALL DSCAL(IVAR3,DFAC,DT1,1)
      CALL DSCAL(IVAR3,DFAC,DT2,1)
      CALL DSCAL(IVAR3,DFAC,DTTOT,1)
C
C     CREATE SOME CORE ATOM LABELS.
      CALL VICLR(MAPT3,1,L1)
      ICORTOT=0
      DO IATM1=1,NAT
        ICORST=ICORTOT+1
        ICORTOT=ICORTOT+NVVOS_NUMCOR(IATM1,1)
        DO I=ICORST,ICORTOT
          MAPT3(I)=IATM1
        ENDDO
      ENDDO
      IF(ICORTOT.NE.NCORTOT) THEN
        IF(MASWRK) WRITE(IW,9010)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     DIPAT CORE TERM = CONTRIBUTION FROM ATOM A
      CALL VCLR(DIPAT,1,NAT*IVAR3)
      DO 40 I=1,NCORTOT
        IATM1=MAPT3(I)
        DO IDIR=1,3
          TMP=C(IDIR,IATM1)-COMTMP(IDIR)
          DIPAT(IATM1,IDIR)=DIPAT(IATM1,IDIR)+TWO*TMP
        ENDDO
        IJV=LTPOS(I,I) ! note:  these run over core.
        DO IDIR=1,3
          DIPAT(IATM1,IDIR)=DIPAT(IATM1,IDIR)-TWO*DIPQ(IJV,IDIR)
        ENDDO
   40 CONTINUE
C------
      CALL DAREAD(IDAF,IODA,MAPT3,L1,547,1)
C------
      DO 100 I=1,M1
        IATM1=MAPT3(I)
        IJ=LTPOS(I,I)
        DO IDIR=1,3
          TMP=C(IDIR,IATM1)-COMTMP(IDIR)
          DIPAT(IATM1,IDIR)=DIPAT(IATM1,IDIR)+DEN(IJ)*TMP
        ENDDO
        DO 110 J=1,M1
          IF(IATM1.NE.MAPT3(J)) GO TO 110
          IJ=LTPOS(I,J)
          IJV=LTPOS(NCORTOT+I,NCORTOT+J) ! note:  these run over val.
          DO IDIR=1,3
            DIPAT(IATM1,IDIR)=DIPAT(IATM1,IDIR)-DEN(IJ)*DIPQ(IJV,IDIR)
          ENDDO
  110   CONTINUE
  100 CONTINUE
      CALL DSCAL(NAT*IVAR3,DFAC,DIPAT,1)
C
C     DIPBND TERM = CONTRIBUTION FROM BOND A-B
      CALL VCLR(DIPBND,1,NAT*NAT*IVAR3)
      DO 200 I=1,M1
        DO 210 J=1,M1
          IATM1=MAPT3(I)
          IATM2=MAPT3(J)
          IJ=LTPOS(I,J)
          IJV=LTPOS(NCORTOT+I,NCORTOT+J)
          IF(IATM1.EQ.IATM2) GO TO 210
          DO IDIR=1,3
            DIPBND(IATM1,IATM2,IDIR)=
     *      DIPBND(IATM1,IATM2,IDIR)-TWO*DEN(IJ)*DIPQ(IJV,IDIR)
          ENDDO
  210   CONTINUE
  200 CONTINUE
      CALL DSCAL(NAT*NAT*IVAR3,DFAC,DIPBND,1)
C
C     PRINT OUT RESULTS FOR ZTOT,QTOT.
      IF(SOME) WRITE(IW,9040) ZTOT,QTOT,ZTOT-QTOT
C
C     PRINT OUT CZ AND CQ VECTORS.
      IF(SOME) THEN
        WRITE(IW,9070)
        WRITE(IW,9200)
        WRITE(IW,9210) CZ(1),CZ(2),CZ(3)
        WRITE(IW,9071)
        WRITE(IW,9200)
        WRITE(IW,9210) CQ(1),CQ(2),CQ(3)
      ENDIF
C
C     PRINT OUT COM VECTOR.
      TMPX=COMTMP(1)
      TMPY=COMTMP(2)
      TMPZ=COMTMP(3)
      IF(SOME) THEN
        WRITE(IW,9072)
        WRITE(IW,9200)
        WRITE(IW,9210) TMPX,TMPY,TMPZ
      ENDIF
C
C     PRINT OUT NOTE ABOUT C.F. AND PROJ.
      IF(SOME) WRITE(IW,9075) DFAC
C
C     PRINT OUT RESULTS FOR THE DT1 TERM.
      TMPX=DT1(1)
      TMPY=DT1(2)
      TMPZ=DT1(3)
      TMPNRM=SQRT(TMPX**2+TMPY**2+TMPZ**2)
      TMPPRJ=SQRT(DMX**2+DMY**2+DMZ**2)
      TMPPRJ=(TMPX*DMX+TMPY*DMY+TMPZ*DMZ)/TMPPRJ
      IF(SOME) THEN
        WRITE(IW,9080)
        WRITE(IW,9110)
        WRITE(IW,9120) TMPX,TMPY,TMPZ,TMPNRM,TMPPRJ
        WRITE(IW,*)
      ENDIF
C
C     PRINT OUT RESULTS FOR THE DT2 TERM.
C------
      TMPX=DTTOT(1)
      TMPY=DTTOT(2)
      TMPZ=DTTOT(3)
      TMPNRM=SQRT(TMPX**2+TMPY**2+TMPZ**2)
      TMPPRJ=SQRT(DMX**2+DMY**2+DMZ**2)
      TMPPRJ=(TMPX*DMX+TMPY*DMY+TMPZ*DMZ)/TMPPRJ
      IF(SOME) THEN
        WRITE(IW,9091)
        WRITE(IW,9110)
        WRITE(IW,9120) TMPX,TMPY,TMPZ,TMPNRM,TMPPRJ
        WRITE(IW,*)
      ENDIF
C------
      TMPX=DTTOT(1)-(ZTOT-QTOT)*COMTMP(1)
      TMPY=DTTOT(2)-(ZTOT-QTOT)*COMTMP(2)
      TMPZ=DTTOT(3)-(ZTOT-QTOT)*COMTMP(3)
      TMPNRM=SQRT(TMPX**2+TMPY**2+TMPZ**2)
      TMPPRJ=SQRT(DMX**2+DMY**2+DMZ**2)
      TMPPRJ=(TMPX*DMX+TMPY*DMY+TMPZ*DMZ)/TMPPRJ
      IF(SOME) THEN
        WRITE(IW,9093)
        WRITE(IW,9110)
        WRITE(IW,9120) TMPX,TMPY,TMPZ,TMPNRM,TMPPRJ
        WRITE(IW,*)
      ENDIF
C------
C
C     PRINT OUT NOTE ABOUT REFERENCE VECTOR FOR TRANSLATIONAL TERM.
      IF(SOME) WRITE(IW,9100) QTOT-ZTOT
C
C     PRINT OUT RESULTS FOR THE DIPAT TERM.
      IF(SOME) THEN
        WRITE(IW,9101)
        WRITE(IW,9111)
      ENDIF
      CALL VCLR(DIPCOP,1,NAT*NAT*IVAR3)
      DO IATM1=1,NAT
        DO I=1,3
          DIPCOP(1,IATM1,I)=DIPAT(IATM1,I)
        ENDDO
      ENDDO
      DO 500 ILOOP=1,NAT
        SAV=ZERO
        ISAV=1
        DO 505 I=1,NAT
          TMP=SQRT(DIPCOP(1,I,1)**2+DIPCOP(1,I,2)**2+DIPCOP(1,I,3)**2)
          IF(ABS(TMP).LE.ABS(SAV)) GO TO 505
          SAV=TMP
          ISAV=I
  505   CONTINUE
C
C       DEFINE THE ATOM INFO. AT THIS POINT.
        IATM1=ISAV
        ATOM1=A(IATM1)
        TMPX=DIPCOP(1,ISAV,1)
        TMPY=DIPCOP(1,ISAV,2)
        TMPZ=DIPCOP(1,ISAV,3)
        TMPPRJ=SQRT(DMX**2+DMY**2+DMZ**2)
        TMPPRJ=(TMPX*DMX+TMPY*DMY+TMPZ*DMZ)/TMPPRJ
        IF(SOME) THEN
          WRITE(IW,9130) ATOM1
          WRITE(IW,9140) IATM1
          WRITE(IW,9120) TMPX,TMPY,TMPZ,SAV,TMPPRJ
          WRITE(IW,*)
        ENDIF
C
C       PREPARE FOR NEXT ROUND.
        DIPCOP(1,ISAV,1)=ZERO
        DIPCOP(1,ISAV,2)=ZERO
        DIPCOP(1,ISAV,3)=ZERO
  500 CONTINUE
C
C     PRINT OUT RESULTS FOR THE DIPBND TERM.
      IF(SOME) THEN
        WRITE(IW,9102)
        WRITE(IW,9112)
      ENDIF
      CALL VCLR(DIPCOP,1,NAT*NAT*IVAR3)
      CALL DCOPY(NAT*NAT*IVAR3,DIPBND,1,DIPCOP,1)
      DO 600 ILOOP=1,NAT*(NAT-1)/2
        SAV=ZERO
        ISAV=1
        JSAV=1
        DO 605 I=1,NAT
          DO 610 J=1,I-1
            TMP=SQRT(DIPCOP(I,J,1)**2+DIPCOP(I,J,2)**2+DIPCOP(I,J,3)**2)
            IF(ABS(TMP).LE.ABS(SAV)) GO TO 610
            SAV=TMP
            ISAV=I
            JSAV=J
  610     CONTINUE
  605   CONTINUE
C
C       DEFINE THE ATOM INFO. AT THIS POINT.
        IATM1=ISAV
        ATOM1=A(IATM1)
        IATM2=JSAV
        ATOM2=A(IATM2)
        TMPX=DIPCOP(ISAV,JSAV,1)
        TMPY=DIPCOP(ISAV,JSAV,2)
        TMPZ=DIPCOP(ISAV,JSAV,3)
        TMPPRJ=SQRT(DMX**2+DMY**2+DMZ**2)
        TMPPRJ=(TMPX*DMX+TMPY*DMY+TMPZ*DMZ)/TMPPRJ
        IF(SOME) THEN
          WRITE(IW,9130) ATOM1
          WRITE(IW,9140) IATM1
          WRITE(IW,9130) ATOM2
          WRITE(IW,9140) IATM2
          WRITE(IW,9120) TMPX,TMPY,TMPZ,SAV,TMPPRJ
          WRITE(IW,*)
        ENDIF
C
C       PREPARE FOR NEXT ROUND.
        DIPCOP(ISAV,JSAV,1)=ZERO
        DIPCOP(JSAV,ISAV,1)=ZERO
        DIPCOP(ISAV,JSAV,2)=ZERO
        DIPCOP(JSAV,ISAV,2)=ZERO
        DIPCOP(ISAV,JSAV,3)=ZERO
        DIPCOP(JSAV,ISAV,3)=ZERO
  600 CONTINUE
C
C     PRINT OFF THE TOTAL DIPOLE RECOVERED TO BE CONVENIENT.
      IF(SOME) WRITE(IW,9400)
      DO IDIR=1,3
        TMPDIR(IDIR)=DTTOT(IDIR)
      ENDDO
      DO IDIR=1,3
        DO IATM1=1,NAT
          TMPDIR(IDIR)=TMPDIR(IDIR)+DIPAT(IATM1,IDIR)
        ENDDO
        DO IATM1=1,NAT
          DO IATM2=1,IATM1-1
            TMPDIR(IDIR)=TMPDIR(IDIR)+DIPBND(IATM1,IATM2,IDIR)
          ENDDO
        ENDDO
      ENDDO
      TMPX=TMPDIR(1)
      TMPY=TMPDIR(2)
      TMPZ=TMPDIR(3)
      TMP=SQRT(TMPX**2+TMPY**2+TMPZ**2)
      TMPPRJ=SQRT(DMX**2+DMY**2+DMZ**2)
      TMPPRJ=(TMPX*DMX+TMPY*DMY+TMPZ*DMZ)/TMPPRJ
      IF(SOME) THEN
        WRITE(IW,9110)
        WRITE(IW,9120) TMPX,TMPY,TMPZ,TMP,TMPPRJ
        WRITE(IW,*)
      ENDIF
C
C     FIGURE OUT IF PROPERTIES WERE DONE.
C     I.E.   IF DIPOLE INFORMATION WAS ACTUALLY STORED.
      CALL LOCAL_PROP_DONE(NOSKIP,SOME)
      IF(ICH.NE.0) NOSKIP=.FALSE.
      IF(NOSKIP) THEN
        IF(SOME) WRITE(IW,9440)
      ELSE
        IF(SOME) WRITE(IW,9445)
      ENDIF
C
C     ERROR OUT IF THE RECOVERED DIPOLE DOES NOT MATCH GAMESS DIPOLE.
C     NOTE:  MAYBE LATER FIGURE OUT IF A KEYWORD OR LOGICAL
C            INDICATES WHETHER OR NOT PROPERTIES WERE COMPUTED.
      TMPX=TMPDIR(1)
      TMPY=TMPDIR(2)
      TMPZ=TMPDIR(3)
      SAV=ZERO
      TMP=ABS(TMPX-DMX)
      IF(TMP.GT.SAV) SAV=TMP
      TMP=ABS(TMPY-DMY)
      IF(TMP.GT.SAV) SAV=TMP
      TMP=ABS(TMPZ-DMZ)
      IF(TMP.GT.SAV) SAV=TMP
      IF(SAV.GT.1.0D-05.AND.NOSKIP) THEN
        IF(MASWRK) WRITE(IW,9450)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
C     PRINT THE EXIT BANNER.
      IF(SOME) WRITE(IW,9500)
      CALL FLSHBF(IW)
C
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'BEGIN ATOMIC DIPOLE DECOMPOSITION.'/
     *   5X,60(1H-))
 9010 FORMAT(/1X,'LOCAL_ATOMIC_DIPOLE ERROR:',
     *       /1X,'ICORTOT DOES NOT EQUAL NCORTOT AT THIS POINT.')
 9040 FORMAT(/1X,'MOLECULAR NUCLEAR CHARGE = ZTOT =',F12.6,
     *       /1X,'MOLECULAR ELECTRON POPULATION = QTOT =',F12.6,
     *       /1X,'MOLECULAR IONICITY =',1X,'ZTOT - QTOT=',F12.6)
 9070 FORMAT(/1X,'XZ = CENTROID VECTOR OF NUCLEAR CHARGE')
 9071 FORMAT(/1X,'XQ = CENTROID VECTOR OF ATOMIC ELECTRON POPULATION')
 9072 FORMAT(/1X,'NUCLEAR MOLECULAR CENTER OF MASS VECTOR')
 9075 FORMAT(//1X,'DIPOLE CONTRIBUTIONS FOLLOW IN',1X,F12.6,1X,
     *         'DEBYE = 1 ELECTRONxBOHR',
     *        /1X,'PROJ MEANS PROJECTION ON THE TOTAL DIPOLE VECTOR.')
 9080 FORMAT(//1X,'TRANSLATIONAL DIPOLE TERM W.R.T. (XZ+XQ)/2 VECTOR.')
 9091 FORMAT(/1X,'TRANSLATIONAL DIPOLE TERM W.R.T. (0,0,0) VECTOR.')
 9093 FORMAT(/1X,'TRANSLATIONAL DIPOLE TERM',
     *        1X,'W.R.T. CENTER OF MASS VECTOR.')
 9100 FORMAT(/1X,'NOTE:  TO OBTAIN THE TRANSLATIONAL DIPOLE TERM',
     *        1X,'W.R.T. AN ARBITRARY REFERENCE VECTOR A,',
     *       /1X,'ADD THE VECTOR ',F12.6,'xA,',
     *        1X,'TO THE DIPOLE LISTED FOR THE',
     *        1X,'(0,0,0) REFERENCE VECTOR.')
 9101 FORMAT(/1X,'ATOMIC DIPOLE TERMS.')
 9102 FORMAT(/1X,'BOND DIPOLE TERMS.')
 9110 FORMAT(4X,'DX',10X,'DY',10X,'DZ',10X,'D(DEBYE) ',
     *       3X,'PROJ(DEBYE) ')
 9111 FORMAT(12X,'DX',10X,'DY',10X,'DZ',10X,'D(DEBYE) ',
     *       3X,'PROJ(DEBYE) ')
 9112 FORMAT(20X,'DX',10X,'DY',10X,'DZ',10X,'D(DEBYE) ',
     *       3X,'PROJ(DEBYE) ')
 9120 FORMAT(5F12.6,$)
 9130 FORMAT(1X,A2,$)
 9140 FORMAT(1X,I4,$)
 9200 FORMAT(4X,'X',11X,'Y',11X,'Z (BOHR)')
 9210 FORMAT(3F12.6)
 9400 FORMAT(/1X,'TOTAL MOLECULAR DIPOLE.')
 9440 FORMAT(/1X,'THE RECOVERED DIPOLE IS CHECKED',
     *        1X,'AGAINST THE PROPERTIES DIPOLE.')
 9445 FORMAT(/1X,'CANNOT CHECK RECOVERED DIPOLE FOR SOME REASON.')
 9450 FORMAT(/1X,'LOCAL_ATOMIC_DIPOLE ERROR:',
     *       /1X,'RECOVERED DIPOLE DOES NOT MATCH ORIGINAL DIPOLE.')
 9500 FORMAT(/5X,60(1H-)/
     *   5X,'END ATOMIC DIPOLE DECOMPOSITION.'/
     *   5X,60(1H-))
      END
C*MODULE LOCAL   *DECK LOCAL_ATOMIC_DIPOLE2
C> @brief        Dipole decomposition for atomic orbitals extra print.
C>
C> @author     Aaron West
C>             -September 01, 2014
C>
C> @param IVAR2   equals 2.
C> @param IVAR3   equals 3.
C> @param L1      is the length of AO coefficients.
C> @param NCORTOT is the number of chemical core orbitals.
C> @param M1      is the number of active orbitals.
C> @param M2      is the triangular size of M1.
C> @param M2SVD   is the triangular length of M1SVD.
C>                M1SVD = NCORTOT + M1.
C> @param MAPT3   already holds oriented orbital-atom correspondence.
C> @param DEN     holds the oriented QUAO density matrix.
C> @param DENCP   is scratch space of M2 length.
C> @param DIPQ    holds the x,y,z oriented QUAO dipole integrals.
C> @param DIPDEN  will hold quantities associated with the
C>                density matrix elements times the dipole integrals.
C> @param SOME    is true for master process with nprint not equal -5.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_ATOMIC_DIPOLE2(
     *           IVAR2,IVAR3,L1,NCORTOT,M1,M2,M2SVD,
     *           MAPT3,
     *           DEN,DENCP,DIPQ,DIPDEN,
     *           SOME,IW)
      IMPLICIT NONE
      LOGICAL SOME
      INTEGER IW,
     *        IVAR2,IVAR3,L1,NCORTOT,M1,M2,M2SVD
      INTEGER MAPT3(L1)
      DOUBLE PRECISION ::
     *       DEN(M2),DENCP(M2),DIPQ(M2SVD,IVAR3),DIPDEN(M2,IVAR2)
C-----------------------------------------------------------------------
      INTEGER I,J,IJ,IJV,ILOOP,ISAV,JSAV,IJSAV,IJVSAV,
     *        IORB1,IORB2,IATM1,IATM2,
     *        LTPOS
      DOUBLE PRECISION ::
     *       DUM,TMPX,TMPY,TMPZ,
     *       TMP,SAV,
     *       ATOM1,ATOM2,BO,DNRMINT,PROJ
C----------------------------------------------------------------------
      INTEGER MXATM,MXAO
      PARAMETER (MXATM=2000, MXAO=8192)
      DOUBLE PRECISION :: ZERO,DFAC
      PARAMETER (ZERO=0.0D+00,
     *           DFAC=2.541766D+00)
C-----------------------------------------------------------------------
      DOUBLE PRECISION :: TITLE,A,B,BFLAB
C
      DOUBLE PRECISION ::
     *                XP,YP,ZP,
     *                DMX,DMY,DMZ,
     *                QXX,QYY,QZZ,QXY,QXZ,QYZ,
     *                QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ,
     *                OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ,
     *                OXZZ,OYZZ,OZZZ,OXYZ,
     *                OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY,
     *                OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ
C-----------------------------------------------------------------------
      COMMON /RUNLAB/ TITLE(10),A(MXATM),B(MXATM),BFLAB(MXAO)
      COMMON /XYZPRP/ XP,YP,ZP,
     *                DMX,DMY,DMZ,
     *                QXX,QYY,QZZ,QXY,QXZ,QYZ,
     *                QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ,
     *                OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ,
     *                OXZZ,OYZZ,OZZZ,OXYZ,
     *                OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY,
     *                OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ
C-----------------------------------------------------------------------
C
C     PRINT BANNER.
      IF(SOME) WRITE(IW,9000)
      IF(SOME) WRITE(IW,9001)
      CALL FLSHBF(IW)
C
C     DNRMINT = NORM OF ORIENTED ORBITAL PAIR DIPOLE.
C     PUT THIS DIPOLE INTO DIPDEN COLUMN 1.
C     PROJ = PROJECTION OF ORBITAL PAIR DIPOLE ONTO TOTAL DIPOLE.
C     PUT BOND ORDER X PROJ. INTO DIPDEN COLUMN 2.
      CALL VCLR(DIPDEN,1,M2*IVAR2)
      DO I=1,M1
        DO J=1,I
          IJ=LTPOS(I,J)
          IJV=LTPOS(NCORTOT+I,NCORTOT+J)
          TMPX=DIPQ(IJV,1)
          TMPY=DIPQ(IJV,2)
          TMPZ=DIPQ(IJV,3)
          DUM=SQRT(TMPX**2+TMPY**2+TMPZ**2)
          DIPDEN(IJ,1)=DUM*ABS(DEN(IJ))
          DUM=SQRT(DMX**2+DMY**2+DMZ**2)
          DUM=(TMPX*DMX+TMPY*DMY+TMPZ*DMZ)/DUM
          DIPDEN(IJ,2)=DUM*DEN(IJ)
        ENDDO
      ENDDO
      CALL DSCAL(M2*IVAR2,DFAC,DIPDEN,1)
C
C     COPY OUT DIPDEN COLUMN 2 FOR MANIPULATION.
      DO IJ=1,M2
        DENCP(IJ)=DIPDEN(IJ,2)
      ENDDO
C
C     FOR ORBITALS ON THE SAME ATOM A,
C     PRINT INFO FOR ORBITAL PAIR DIPOLES BY MAGNITUDE OF
C     DIPDEN COLUMN 2.
      CALL FLSHBF(IW)
      IF(SOME) WRITE(IW,9005)
      IF(SOME) WRITE(IW,9010)
      CALL FLSHBF(IW)
C------
      DO 100 ILOOP=1,M2
C------
        SAV=ZERO
        ISAV=0  ! must avoid repeated pointless print offs.
        JSAV=0  ! must avoid repeated pointless print offs.
        DO 105 I=1,M1
          DO 110 J=1,I
C------------
            IATM1=MAPT3(I)
            IATM2=MAPT3(J)
            IF(IATM1.NE.IATM2) GO TO 110
C------------
            TMP=DENCP(LTPOS(I,J))
            IF(ABS(TMP).LE.ABS(SAV)) GO TO 110
C------------
            SAV=TMP
            ISAV=I
            JSAV=J
  110     CONTINUE
  105   CONTINUE
        IF(ISAV.EQ.0) GO TO 100  ! must avoid mem. errors.
        IF(JSAV.EQ.0) GO TO 100  ! must avoid mem. errors.
        IJSAV=LTPOS(ISAV,JSAV)
        IJVSAV=LTPOS(NCORTOT+ISAV,NCORTOT+JSAV)
C
C       ASSIGN VARS FOR PRINTING.
        IATM1=MAPT3(ISAV)
        IATM2=MAPT3(JSAV)
C--------
        IF(IATM1.NE.IATM2) GO TO 100
C--------
        IORB1=NCORTOT+ISAV
        IORB2=NCORTOT+JSAV
        ATOM1=A(IATM1)
        ATOM2=A(IATM2)
        TMPX=DIPQ(IJVSAV,1)
        TMPY=DIPQ(IJVSAV,2)
        TMPZ=DIPQ(IJVSAV,3)
        BO=DEN(IJSAV)
        DNRMINT=DIPDEN(IJSAV,1)
        PROJ=DIPDEN(IJSAV,2)
C
C       PRINT OUT INFO.
        IF(SOME) THEN
          WRITE(IW,9020) IORB1
          WRITE(IW,9020) IORB2
          WRITE(IW,9030) ATOM1
          WRITE(IW,9020) IATM1
          WRITE(IW,9030) ATOM2
          WRITE(IW,9020) IATM2
          WRITE(IW,9040) TMPX
          WRITE(IW,9040) TMPY
          WRITE(IW,9040) TMPZ
          WRITE(IW,9040) BO
          WRITE(IW,9040) DNRMINT
          WRITE(IW,9040) PROJ
          WRITE(IW,*)
        ENDIF
C------
C       PREPARE DENCP FOR NEXT ROUND.
        DENCP(LTPOS(ISAV,JSAV))=ZERO
  100 CONTINUE
C------
C
C     FOR ORBITALS ON THE DIFFERENT ATOMS A AND B,
C     PRINT INFO FOR ORBITAL PAIR DIPOLES BY MAGNITUDE OF
C     DIPDEN COLUMN 2.
      CALL FLSHBF(IW)
      IF(SOME) WRITE(IW,9100)
      IF(SOME) WRITE(IW,9010)
      CALL FLSHBF(IW)
C------
      DO 200 ILOOP=1,M2
C------
        SAV=ZERO
        ISAV=0  ! must avoid repeated pointless print offs.
        JSAV=0  ! must avoid repeated pointless print offs.
        DO 205 I=1,M1
          DO 210 J=1,I-1
C------------
            IATM1=MAPT3(I)
            IATM2=MAPT3(J)
            IF(IATM1.EQ.IATM2) GO TO 210
C------------
            TMP=DENCP(LTPOS(I,J))
            IF(ABS(TMP).LE.ABS(SAV)) GO TO 210
C------------
            SAV=TMP
            ISAV=I
            JSAV=J
  210     CONTINUE
  205   CONTINUE
        IF(ISAV.EQ.0) GO TO 200  ! must avoid mem. errors.
        IF(JSAV.EQ.0) GO TO 200  ! must avoid mem. errors.
        IJSAV=LTPOS(ISAV,JSAV)
        IJVSAV=LTPOS(NCORTOT+ISAV,NCORTOT+JSAV)
C
C       ASSIGN VARS FOR PRINTING.
        IATM1=MAPT3(ISAV)
        IATM2=MAPT3(JSAV)
C--------
        IF(IATM1.EQ.IATM2) GO TO 200
C--------
        IORB1=NCORTOT+ISAV
        IORB2=NCORTOT+JSAV
        ATOM1=A(IATM1)
        ATOM2=A(IATM2)
        TMPX=DIPQ(IJVSAV,1)
        TMPY=DIPQ(IJVSAV,2)
        TMPZ=DIPQ(IJVSAV,3)
        BO=DEN(IJSAV)
        DNRMINT=DIPDEN(IJSAV,1)
        PROJ=DIPDEN(IJSAV,2)
C
C       PRINT OUT INFO.
        IF(SOME) THEN
          WRITE(IW,9020) IORB1
          WRITE(IW,9020) IORB2
          WRITE(IW,9030) ATOM1
          WRITE(IW,9020) IATM1
          WRITE(IW,9030) ATOM2
          WRITE(IW,9020) IATM2
          WRITE(IW,9040) TMPX
          WRITE(IW,9040) TMPY
          WRITE(IW,9040) TMPZ
          WRITE(IW,9040) BO
          WRITE(IW,9040) DNRMINT
          WRITE(IW,9040) PROJ
          WRITE(IW,*)
        ENDIF
C------
C       PREPARE DENCP FOR NEXT ROUND.
        DENCP(LTPOS(ISAV,JSAV))=ZERO
  200 CONTINUE
C------
C
C     PRINT THE EXIT BANNER.
      IF(SOME) WRITE(IW,9500)
      CALL FLSHBF(IW)
C
      RETURN
 9000 FORMAT(/5X,60(1H-)/
     *   5X,'BEGIN ATOMIC DIPOLE DECOMPOSITION2.'/
     *   5X,60(1H-))
 9001 FORMAT(/1X,'P = BOND ORDER.',
     *       /1X,'D = DIPOLE MOMENT FOR GIVEN ORBITAL PAIR.',
     *       /1X,'PROJ = PROJECTION ONTO THE TOTAL DIPOLE.')
 9005 FORMAT(/1X,'DIPOLE CONTRIBUTIONS OF ORBITAL PAIRS ON',
     *        1X,'SAME ATOM.')
 9010 FORMAT(/1X,'ORB1',
     *        1X,'ORB2',
     *        4X,'ATM1',
     *        4X,'ATM2',
     *       11X,'DX',
     *       11X,'DY',
     *       11X,'DZ',
     *        3X,'BOND ORDER',
     *        6X,'|P x D|',
     *        3X,'PROJ(P x D)')
 9020 FORMAT(1X,I4,$)
 9030 FORMAT(1X,A2,$)
 9040 FORMAT(1X,F12.7,$)
 9100 FORMAT(/1X,'DIPOLE CONTRIBUTIONS OF ORBITAL PAIRS ON',
     *        1X,'DIFFERENT ATOMS.')
 9500 FORMAT(/5X,60(1H-)/
     *   5X,'END ATOMIC DIPOLE DECOMPOSITION2.'/
     *   5X,60(1H-))
      END
C*MODULE LOCAL   *DECK LOCAL_PROP_DONE
C> @brief      Figures out whether properties are done or not.
C>
C> @author     Aaron West
C>             -August 28, 2014
C>
C> @param NOSKIP  is a logical that indicates whether
C>                properties were performed or not.
C> @param SOME    is true for master process with nprint not equal -5.
      SUBROUTINE LOCAL_PROP_DONE(NOSKIP,SOME)
      IMPLICIT NONE
      LOGICAL NOSKIP,SOME
      INTEGER NSTATAVG,IDEGAVG
      DOUBLE PRECISION :: RMC,RNONE
      DATA RMC/8HMCSCF   /
      DATA RNONE/8HNONE    /
C----------------------------------------------------------------------
      INTEGER IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      INTEGER MPLEVL,MPCTYP
C----------------------------------------------------------------------
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C----------------------------------------------------------------------
C
      NOSKIP=.TRUE.
      IF(SCFTYP.EQ.RMC) THEN
        CALL STAVGCHK(NSTATAVG,IDEGAVG)
        IF(NSTATAVG.GT.1.AND.IDEGAVG.NE.1) NOSKIP=.FALSE.
      ENDIF
      IF(CCTYP.NE.RNONE) THEN
        NOSKIP=.FALSE.
        IF(SOME) WRITE(IW,9430)
      ENDIF
C
      RETURN
 9430 FORMAT(/1X,'SKIPING RECOVERED DIPOLE CHECK FOR CC RUNS FOR NOW.')
      END
C*MODULE LOCAL   *DECK LOCAL_AAMBS_ATLAB
C> @brief
C>
C> @author     Aaron West
C>             -May 24, 2015
C>
C> @param NAT       is the number of atoms.
C> @param L0MBS     is the number of minimal basis set orbitals.
C> @param IPOSCOR  denotes the integer array that holds the starting
C>                 position for the 1st CORE AO on a given atom.
C> @param ILENCOR  denotes the integer array that holds the
C>                 number of CORE orbitals on a given atom.
C> @param IPOSMBS  denotes the integer array that holds the starting
C>                 position for the 1st MBS AO on a given atom.
C>                 These are in atomic order from the input
C>                 as usual.
C> @param ILENMBS  gives the number of VALANEC MBS orbitals.
C> @param MAPAA    is an integer array of length L0MBS.
C>                 On exit, it will hold the AAMBS atom labels.
C> @param IVALAA   is an integer array of length L0MBS.
C>                 On exit, it will hold either a 1 or a 2.
C>                 A 1 indicates a core AAMBS.
C>                 A 2 indicates a valence AAMBS.
C> @param MASWRK  indicates the master process.
C> @param IW      indicates write out to log file.
      SUBROUTINE LOCAL_AAMBS_ATLAB(
     *           NAT,L0MBS,
     *           IPOSCOR,ILENCOR,IPOSMBS,ILENMBS,
     *           MAPAA,IVALAA,
     *           MASWRK,IW)
      IMPLICIT NONE
      LOGICAL MASWRK
      INTEGER IW,
     *        NAT,L0MBS,
     *        IPOSCOR(NAT+1),ILENCOR(NAT),
     *        IPOSMBS(NAT+1),ILENMBS(NAT),
     *        MAPAA(L0MBS),IVALAA(L0MBS)
C--------------------------------------------------------------------
      INTEGER IATM1,IPOS,ILEN,ICT,I,IERR
C--------------------------------------------------------------------
C
C     CLEAR OUT MAPAA.
      CALL VICLR(MAPAA,1,L0MBS)
      CALL VICLR(IVALAA,1,L0MBS)
C
C     FILL UP THE ATOM ARRAYS.
      CALL LOCAL_VVOS_ORB_RANGE_CORE(IPOSCOR,ILENCOR,NAT)
      CALL LOCAL_VVOS_ORB_RANGE(IPOSMBS,ILENMBS,NAT)
C
C     PUT AAMBS ATOM LABELS INTO A SINGLE ARRAY.
      ICT=0
      DO IATM1=1,NAT
        IPOS=IPOSCOR(IATM1)
        ILEN=ILENCOR(IATM1)
        DO I=IPOS,IPOS+ILEN-1
          ICT=ICT+1
          MAPAA(ICT)=IATM1
          IVALAA(ICT)=1
        ENDDO
        IPOS=IPOSMBS(IATM1)
        ILEN=ILENMBS(IATM1)
        DO I=IPOS,IPOS+ILEN-1
          ICT=ICT+1
          MAPAA(ICT)=IATM1
          IVALAA(ICT)=2
        ENDDO
      ENDDO
C
C     ERROR OUT IF MAPAA HAS 0S.
      IERR=0
      DO I=1,L0MBS
        IF(MAPAA(I).EQ.0) IERR=1
        IF(IVALAA(I).EQ.0) IERR=1
      ENDDO
      IF(IERR.EQ.1) THEN
        IF(MASWRK) WRITE(IW,9000)
        CALL FLSHBF(IW)
        CALL ABRT
        STOP
      ENDIF
C
      RETURN
9000  FORMAT(/1X,'LOCAL_AAMBS_ATLAB ERROR:',
     *       /1X,'MAPAA OR IVALAA HAS 0S IN IT.  THERE IS A PROBLEM.')
      END
