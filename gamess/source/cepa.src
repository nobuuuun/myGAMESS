C 13 Sep 14 - JI  - ADD NEW CEPA METHOD TO GAMESS
C
C*MODULE CEPA  *DECK CEPAC1
C> @brief      This routine drives SR- and MR-CEPA computations.
C>
C> @author     Joe Ivanic
C>             -2014
C>
C> @details    Literally drives SR- and MR-CEPA computations.
C>             For a good review of the SR and MR-CEPA methods computed in this
C>             module see:
C>             P.G. Szalay, in Modern Ideas in Coupled-Cluster Methods,
C>             R. J. Bartlett (ed), World Scientific, Singapore (1997), pp 81-123.
C>
C>             The CEPA computation is similar to CISD/MRCISD except that an
C>             energy correction is added to the Hamiltonian diagonal elements
C>             corresponding to only external determinants. The CEPA iterations
C>             are similar to CISD/MRCISD iterations, as such, the CEPA
C>             iterations programmed here use underlying ORMAS functionalities.
C>             For more on the ORMAS method see:
C>             Joseph Ivanic, Journal of Chemical Physics, 9364, V. 119, (2003).
C>             Joseph Ivanic, Journal of Chemical Physics, 9376, V. 119, (2003).
C>
C> @param      NPRINT   Verbosity.
C> @param      CLABEL   Governs whether transformed inegrals on file
C>                       IJKT include the core orbitals or not.
C> @param      DDITRF   Governs selection of a distributed memory
C>                      parallel integral transformation.
C> @param      NDM1     Governs whether 1st-order density matrix computed.
C> @param      NDM2     Governs whether 2nd-order density matrix computed.
C> @param      NPRI5    Governs whether 1st-order density matrix printed.
C> @param      NPRI6    Governs whether 2st-order density matrix printed.
C> @param      ICIMALMQ Results in the different CI transformations when
C>                      icimalmq equals 1,3.
C>
      SUBROUTINE CEPAC1(NPRINT,CLABEL,DDITRF,NDM1,NDM2,NPRI5,NPRI6,
     *                  ICIMALMQ)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL CLABEL,DDITRF,SOME,PACK2E,GOPARR,DSKWRK,MASWRK,FDIRCT,
     *        QCORR,JACOBI,CEECHK,SAFLG,ANALYS,SALAST,
     *        ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,ENGATM
C
      PARAMETER (MXRT=100, MXATM=2000)
C
      COMMON /DETPAR/ ICLBBR,ANALYS,SAFLG,IPRTSA
      COMMON /CEEIS3/ NEEDCI, CEECHK
      COMMON /CEPAPA/ CEPA,GVAL,ECREF,NCREF
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DETWFN/ WSTATE(MXRT),SPINS(MXRT),CRIT,PRTTOL,S,SZ,
     *                GRPDET,STSYM,GLIST,DWPARM,
     *                NFLGDM(MXRT),IWTS(MXRT),NCORSV,NCOR,NACT,NORB,
     *                NA,NB,K,KST,IROOT,IPURES,MAXW1,NITER,MAXP,NCI,
     *                IGPDET,KSTSYM,NFTGCI,IDWEIGH,
     *                FSTATE(MXRT),IFTS(MXRT)
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,STOT,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FMCOM / X(1)
      COMMON /FUNCT / E,EGRAD(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,MA,MB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IS,IJKT,IDAF,NAV,IODA(950)
      COMMON /JACOBI/ JACOBI,NJAOR,ELAST,ISTAT
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /ORNTMO/ EXTLOC,EREFATM,BOTOL(6),
     *                ISVMOR(MXATM),ISVDOP,L0DEP0,
     *                ORIENT,ORIKIN,ORMFUL,ORMRESET,RNNTSCF,SVDCOPT,
     *                ENGATM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PSILVL/ IPSI,ISKPRP
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
      DATA AMCSCF/8HMCSCF   /
      DATA CHECK/8HCHECK   /
      DATA READ/8HREAD    /
C
C     ----- DRIVER FOR SR- AND MR-CEPA COMPUTATIONS -----
C
      SOME = MASWRK  .AND.  NPRINT.NE.-5
      FDIRCT = .TRUE.
C
C        CORE CONTRIBUTION TO THE ENERGY IS OBTAINED FROM -ECORE-,
C        AND FROM MODIFICATIONS TO THE TRANSFORMED 1E- INTEGRALS.
C        THIS EFFECTIVELY REMOVES CORE ORBITALS FROM THE COMPUTATION.
C
      ECONST = ECORE + ENUCR
      NTOT = NACT + NCORSV
      NTCO = NCORSV
      NORB = NACT
      NCOR = 0
      NSYM = 2**IGPDET
C
C  MODIFY MSTA TO GET RID OF CORE.
C
      DO II=1,NSPACE+1
         MSTA(II) = MSTA(II) - NCORSV
      ENDDO
C
C        COMPUTE THE TOTAL NUMBER OF SD-CI DETERMINANTS IN THE CEPA CALCULATION
C        DECIDE NECESSARY DOUBLE/INTEGER WORKING STORAGE -IDS- AND -IIS-
C
C     FIRST NEED TO STORE NSPACE SETS OF BINOMIAL COEFFICIENTS FOR EACH
C     SUB-SPACE.  THERE IS REASON BEHIND THIS, TRUST ME.  JUST ASK ME.
C     LBST(I) WILL STORE WHERE IN X BINOMIAL ARRAYS FOR SPACE I START.
C     IDIM(I) WILL STORE THE MAXIMUM NUMBER OF ALPHA OR BETA ELECTRONS.
C
      CALL VALFM(LOADFM)
      LBST(1)  = LOADFM + 1
      DO II=2,NSPACE
         IDIM(II-1) = MAX(IAMA(II-1),IBMA(II-1))
         LBST(II) = LBST(II-1)+((MNUM(II-1)+1)*(IDIM(II-1)+1))
      ENDDO
      IDIM(NSPACE) = MAX(IAMA(NSPACE),IBMA(NSPACE))
      LAST = LBST(NSPACE)+((MNUM(NSPACE)+1)*(IDIM(NSPACE)+1))
      NEED1 = LAST - LOADFM - 1
C
      IF (SOME) THEN
         IF (NCREF.EQ.1) THEN
            IF (CEPA.EQ.READ) THEN
               WRITE(IW,9000) GVAL
            ELSE
               WRITE(IW,9002) CEPA
            ENDIF
         ELSE
            IF (CEPA.EQ.READ) THEN
               WRITE(IW,9005) GVAL
            ELSE
               WRITE(IW,9006) CEPA
            ENDIF
         ENDIF
         WRITE(IW,9008) NEED1
      ENDIF
      CALL GETFM(NEED1)
C
      DO II=1,NSPACE
         CALL BINOM8(X(LBST(II)),MNUM(II),IDIM(II))
      ENDDO
C
C     NOW TO MAKE ORMAS TABLES FOR THE CEPA PROBLEM.
C     MAKE MEMORY AVAILABLE FOR TABLE INFO AND
C     TABLES THEMSELVES.
C
      CALL VALFM(LOADFM)
      LBOX1 = LOADFM + 1
      LBOX2 = LBOX1 + NSPACE/NWDVAR + 1
      LBOX3 = LBOX2 + NSPACE/NWDVAR + 1
      LBOX4 = LBOX3 + NSPACE/NWDVAR + 1
      LBOX5 = LBOX4 + NSPACE/NWDVAR + 1
      LIBO = LBOX5 + NSPACE/NWDVAR + 1
      LAST = LIBO + NTOT/NWDVAR + 1
      NEED2 = LAST - LOADFM - 1
      CALL GETFM(NEED2)
C
C    READ ORBITALS LABELS AND GET RID OF THE CORE PART.
C
      CALL DAREAD(IDAF,IODA,X(LIBO),NTOT,262,1)
      CALL CORTRA(X(LIBO),NTOT,NTCO)
C
C    WORK OUT HOW MANY ALPHA AND BETA GROUPS THERE ARE.
C
      CALL TOTALCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2),ITGA)
      CALL TOTALCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2),ITGB)
C
      IF (SOME) WRITE(IW,9010) ITGA,ITGB
C
C    DETERMINE THE TOTAL NUMBER OF ALPHA AND BETA STRINGS.
C
      CALL RESETCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2))
      IAST = 0
      DO II=1,ITGA
      CALL TOTDETG(X(LBOX1),NSPACE,LBST,X(LBST(1)),NEED1,
     *    MNUM,IDIM,ITOT)
      IAST = IAST + ITOT
      CALL PUSHCO(X(LBOX1),NSPACE,NA,IAMA,IAMI,X(LBOX2),IEND)
      ENDDO
C
      CALL RESETCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2))
      IBST = 0
      DO II=1,ITGB
      CALL TOTDETG(X(LBOX1),NSPACE,LBST,X(LBST(1)),NEED1,
     *    MNUM,IDIM,ITOT)
      IBST = IBST + ITOT
      CALL PUSHCO(X(LBOX1),NSPACE,NB,IBMA,IBMI,X(LBOX2),IEND)
      ENDDO
C
      IF (SOME) WRITE(IW,9020) IAST,IBST
C
C    MAKE STORAGE TO HOLD SYMMETRY INFORMATION OF STRINGS.
C    THE LABELS BELOW APPEAR THE SAME IN ROUTINE MAKTABS
C    AND THIS ROUTINE ALSO EXPLAINS WHAT THEY ARE USED FOR.
C
      CALL VALFM(LOADFM)
      LWRK   = LOADFM + 1
      LCOA   = LWRK   + 43/NWDVAR + 1
      LCOB   = LCOA   + (NSYM*ITGA)/NWDVAR + 1
      LGMUL  = LCOB   + (NSYM*ITGB)/NWDVAR + 1
      LKTAB  = LGMUL  + (NSYM*NSYM)/NWDVAR + 1
      LCON   = LKTAB  + NSYM/NWDVAR + 1
      LCON1  = LCON   + NA/NWDVAR + 1
      LCON2  = LCON1  + NA/NWDVAR + 1
      LCON3  = LCON2  + NA/NWDVAR + 1
      LANDET = LCON3  + NA/NWDVAR + 1
      LBNDET = LANDET + (ITGA*NSPACE)/NWDVAR + 1
      NAST   = LBNDET + (ITGB*NSPACE)/NWDVAR + 1
      NBST   = NAST   + (ITGA+1)/NWDVAR + 1
      LSYMA  = NBST   + (ITGB+1)/NWDVAR + 1
      LSYMB  = LSYMA  + IAST/NWDVAR + 1
      LGCOM  = LSYMB  + IBST/NWDVAR + 1
      LSPA   = LGCOM  + (ITGA*ITGB)/NWDVAR + 1
      LSPB   = LSPA   + IAST/NWDVAR + 1
      LDISB  = LSPB   + IBST/NWDVAR + 1
      LSAS   = LDISB  + (NSYM*ITGB*ITGA)/NWDVAR + 1
      LSBS   = LSAS   + ((NSYM+1)*ITGA)/NWDVAR + 1
      LSAC   = LSBS   + ((NSYM+1)*ITGB)/NWDVAR + 1
      LSBC   = LSAC   + IAST/NWDVAR + 1
      LAST   = LSBC   + IBST/NWDVAR + 1
      NEED3 = LAST - LOADFM - 1
      IF (SOME) WRITE(IW,9030) NEED2 + NEED3
      CALL GETFM(NEED3)
C
C    MAKE INTEGER TABLES FOR ORMAS-RUN CEPA. GET NUMBER OF DETS, ETC.
C
      IF (SOME) CALL TSECND(E0)
C
      CALL MAKTABS(IW,SOME,X(LBOX1),X(LBOX2),X(LBOX3),NSPACE,
     *             NA,NB,LBST,X(LBST(1)),NEED1,
     *             IAMA,IAMI,IBMA,IBMI,MNUM,IDIM,MSTA,
     *             X(LIBO),IGPDET,KSTSYM,NSYM,
     *             NACT,X(LWRK),X(LKTAB),X(LGMUL),
     *             X(LCON),X(LCOA),X(LCOB),X(LANDET),X(LBNDET),
     *             X(NAST),X(NBST),X(LSYMA),X(LSYMB),X(LGCOM),
     *             MINI,MAXI,X(LSPA),X(LSPB),X(LDISB),
     *             X(LSAS),X(LSBS),X(LSAC),X(LSBC),
     *             ITGA,ITGB,IAST,IBST,NCI,NA1EX,NB1EX,FDIRCT)
C
      IF(SOME) THEN
         CALL TSECND(E1)
         ELAP = E1 - E0
         E0 = E1
         WRITE(IW,9107) ELAP
      ENDIF
C
      IF(SOME) THEN
         WRITE(IW,9110) STSYM,GRPDET,SZ,NCI
      END IF
C
C   END OF INTEGER TABLES.  NOW TO DETERMINE THE EXTRA MEMORY
C   REQUIREMENTS, DOUBLE PRECISION AND INTEGER.
C   USED TO DO THIS BY CALLING MEMCI OR SOMETHING SIMILAR, I AM
C   JUST GOING TO DO IT HERE.
C
      M1 = NACT
      M2 = (M1*M1+M1)/2
      M4 = (M2*M2+M2)/2
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
C     Define simple items for Malmqvist work.
      NATOMS=NAT
      MXRTMQ=MXRT
C
C   INTEGRAL STORAGE REQUIREMENTS FIRST.
C
      CALL VALFM(LOADFM)
      LSINT1   = LOADFM   + 1
      LSINT2   = LSINT1   + M2
      LIA      = LSINT2   + M4
      LXX      = LIA      + M2/NWDVAR + 1
      LIXX     = LXX      + NINTMX
C
C   ORMAS DOUBLE PRECISION NEXT.
C
      KCOEFF = LIXX   + NINTMX
      KAB    = KCOEFF + MAXP*NCI
      KQ     = KAB    + MAXP*NCI
      KB     = KQ     + NCI
      KEF    = KB     + 8*MAXW1
      KF     = KEF    + MAXW1*MAXW1
      KEC    = KF     + (MAXW1*(MAXW1+1))/2
      KGR    = KEC    + MAXP*MAXP
      KEL    = KGR    + MAXP
      KSP    = KEL    + MAXW1
      LAST   = KSP    + MAXW1
C
C   STORAGE FOR REFERENCE 1ST ORDER DENSITY MATRIX
C
      IF (NDM1.GT.0) THEN
         NREFA = MSTA(NSPACE) - 1
         NREFA2 = (NREFA*NREFA + NREFA)/2
         LREFDM1 = LAST
         LAST    = LREFDM1 + NREFA2
      ENDIF
C
C    STORAGE FOR REFERENCE 1ST AND 2ND ORDER MATRICES
C
      IF (NDM2.GT.0) THEN
         NREFA = MSTA(NSPACE) - 1
         NREFA2 = (NREFA*NREFA + NREFA)/2
         NREFA4 = (NREFA2*NREFA2 + NREFA2)/2
         LREFDM1 = LAST
         LREFDM2 = LREFDM1 + NREFA2
         LAST    = LREFDM2 + NREFA4
      ENDIF
C
C   ORMAS INTEGER STORAGE IS LAST.
C
      IPOSA  = LAST
      IPERA  = IPOSA  + (NA*(NACT-NA)*NSYM)/NWDVAR + 1
      IIND1  = IPERA  + (NA*(NACT-NA)*NSYM)/NWDVAR + 1
      IGROA  = IIND1  + (NA*(NACT-NA)*NSYM)/NWDVAR + 1
      IWRK1  = IGROA  + (NA*(NACT-NA)*NSYM)/NWDVAR + 1
C        ALLOW FOR UP TO 16 UNPAIRED SPINS (12,870 DETS) IN SPIN DETERM.
      N16UN  = 13000
      MBIG   = MAX(MAXW1,N16UN)
      IWRK2  = IWRK1  + (2*MBIG)/NWDVAR + 1
      ISD    = IWRK2  + MBIG/NWDVAR + 1
      ISO    = ISD    + (NA+NB)/NWDVAR + 1
      INDEX  = ISO    + NA/NWDVAR + 1
      IMMC   = INDEX  + ((NACT*(NACT+1))/2+1)/NWDVAR + 1
      IHMCON = IMMC + NSYM
C
C  LEAVE SPACE FOR THE SINGLE EXCITED STORAGE.
C  NOTE, IF FDIRCT = .TRUE. THEN NB1EX = ITGA.
C
      JB1GR = IHMCON + K
      JB1PE = JB1GR + NB1EX/NWDVAR + 1
      JB1IN = JB1PE + NB1EX/NWDVAR + 1
      JB1PO = JB1IN + NB1EX/NWDVAR + 1
      JB1SY = JB1PO + NB1EX/NWDVAR + 1
      JB1ST = JB1SY + (NB*(NACT-NB))/NWDVAR + 1
C
      IF (.NOT.FDIRCT) THEN
         LAST   = JB1ST + ((IBST+1)*(NSYM+1))/NWDVAR + 1
         IBST2 = (IBST+1)*(NSYM+1)
      ELSE
         LAST = JB1ST + 1
         NB1EX = ITGA
         IBST2 =  1
      ENDIF
C
C ADD INTEGER ARRAY FOR STORAGE OF REFERENCE DETERMINANT LIST FOR CEPA
C
      IREFDE = LAST
      LAST   = IREFDE + NCREF/NWDVAR + 1
C
C   MALMQVIST CI TRANSFORMATION STUFF.
C   NOTE:  NEED SOME EXTRA CI STORAGE FOR ICIMALMQ=3 ONLY.
C
      LVTORB      = LAST
      LDMAT       = LVTORB    + L1*L1
      LDMAT2      = LDMAT     + NATOMS*NATOMS
      LFRHS       = LDMAT2    + NATOMS*(NATOMS+1)
      LNATM       = LFRHS     + NATOMS*2
      LIORDACT2   = LNATM     + L1
      LIWTSMQ     = LIORDACT2 + NATOMS
      LWGTMQ      = LIWTSMQ   + MXRTMQ
      LAST        = LWGTMQ    + MXRTMQ
C
      NEED4  = LAST - LOADFM - 1
      NEEDCI = NEED1 + NEED2 + NEED3 + NEED4
C
      IF (SOME) THEN
          WRITE(IW,9120) KCOEFF-LOADFM-1,
     *          NEED4-(KCOEFF-LOADFM-1),MAXP,NEEDCI
          IFDM = ((NB1EX/NWDVAR) + 1)*4 +
     *    (((IBST+1)*(NSYM+1))/NWDVAR)+1 + (NB*(NACT-NB))/NWDVAR + 1
          IF (.NOT.FDIRCT) WRITE(IW,9125) NEEDCI-IFDM+6
      ENDIF
C
      IF (CEECHK) THEN
        CALL RETFM(NEED3)
        CALL RETFM(NEED2)
        CALL RETFM(NEED1)
        DO II=1,NSPACE+1
          MSTA(II) = MSTA(II) + NCORSV
        ENDDO
        RETURN
      ENDIF
C
      CALL GETFM(NEED4)
C
      IF(EXETYP.EQ.CHECK) THEN
         DO IST=1,MIN(K,MXRT)
            SPINS(IST) = S
            ESTATE(IST) = ZERO
         ENDDO
         LCIVEC = KCOEFF
         CALL VCLR(X(KCOEFF),1,K*NCI)
         GO TO 450
      END IF
C
C     -- OBTAIN 1 AND 2 E- TRANSFORMED INTEGRALS OVER ACTIVE ORBITALS --
C     CALLING ARGUMENT -CLABEL- GOVERNS WHETHER TRANSFORMED INTEGRALS
C     ON FILE -IJKT- INCLUDE THE CORE ORBITALS OR NOT.  IT IS ASSUMED
C     THAT NO CORE INTEGRALS ARE IN -IJKT-, SO THIS VARIABLE TELLS IF
C     THE ACTIVE ORBITALS START FROM 1,2,3... OR NCORSV+1,NCORSV+2,...
C
      NCORE = 0
      IF(CLABEL) NCORE=NCORSV
      CALL RDCI12(DDITRF,IJKT,X(LSINT1),X(LSINT2),NCORE,M1,M2,M4,X(LIA),
     *            X(LXX),X(LIXX),NINTMX)
C
C        ----- COMPUTE CEPA ENERGY/WAVEFUNCTION -----
C
      CALL CEPAC2(IW,SOME,ECONST,ISTAT,
     *           X(LSINT1),X(LSINT2),M2,M4,NACT,NCI,NA,NB,
     *           K,KST,MAXP,MAXW1,NITER,CRIT,X(LBST(1)),NEED1,
     *           X(KSP),X(KEL),NSYM,X(LIBO),
     *           X(LBOX1),X(LBOX2),X(LBOX3),X(LBOX4),X(LBOX5),
     *           X(KCOEFF),X(KAB),X(KQ),X(KB),X(KEF),X(KF),
     *           X(KEC),X(KGR),
     *           X(IPOSA),X(IPERA),X(IIND1),X(IGROA),
     *           X(IWRK1),X(IWRK2),
     *           X(ISD),X(ISO),
     *           X(INDEX),X(IMMC),X(IHMCON),
     *           X(LGMUL),X(LKTAB),
     *           X(LCON),X(LCON1),X(LCON2),X(LCON3),
     *           X(LANDET),X(LBNDET),X(NAST),X(NBST),
     *           X(LSYMA),X(LSYMB),X(LGCOM),X(LSPA),X(LSPB),
     *           X(LDISB),X(LSAS),X(LSBS),X(LSAC),X(LSBC),
     *           ITGA,ITGB,IAST,IBST,
     *           NB1EX,IBST2,
     *           X(JB1GR),X(JB1PE),X(JB1IN),X(JB1PO),X(JB1ST),
     *           X(JB1SY),
     *           X(LVTORB),L1,NCORSV,ICIMALMQ,
     *           NATOMS,X(LDMAT),X(LDMAT2),X(LFRHS),X(LNATM),
     *           X(LIORDACT2),MXRTMQ,X(LIWTSMQ),X(LWGTMQ),
     *           X(IREFDE),ECORR,WEXT)
C
      DO I=1,MIN(K,MXRT)
         ESTATE(I) = X(KEL-1+I)+ECONST
         SPINS(I)  = X(KSP-1+I)
      ENDDO
C
C        SAVE ENERGY QUANTITIES
C
  450 CONTINUE
      EREFATM=X(KQ)
      IROOTX = 1   ! MCSCF RESETS E LATER, SO G.S. IS OK FOR IT
      IF(IPSI.NE.1) GO TO 460
C
C        CI RUNS SHOULD ENFORCE -PURES-
C        IROOTX WILL BE THE IROOT-TH STATE OF SPIN S
C
      NXRT=0
      DO 455 I=1,K
         IF (IPURES.EQ.1 .AND. ABS(SPINS(I)-S).GT.0.03D+00) GOTO 455
         NXRT=NXRT+1
         IF ( IROOT .EQ. NXRT) THEN
            IROOTX=I
            GOTO 460
         ENDIF
  455 CONTINUE
C  IF WE FIND OURSELF HERE IT IS BECAUSE IROOT .GT. NXRT
      WRITE(IW,9045) K,IROOT,S
      CALL ABRT
C
  460 CONTINUE
      ETOT = ESTATE(IROOTX)
      EELCT = ETOT - ENUCR
      STOT = SPINS(IROOTX)
      SZZ = STOT*(STOT+ONE)
      STATN = K
C
C        SAVE EIGENVECTORS TO DISK
C
      CALL SEQOPN(NFT12,'CIVECTR','UNKNOWN',.FALSE.,'UNFORMATTED')
      CALL SEQREW(NFT12)
      IF(MASWRK) WRITE(NFT12) K,NCI
      DO 420 IST=1,K
         LCIVEC = KCOEFF + (IST-1)*NCI
         CALL STFASE(X(LCIVEC),NCI,NCI,1)
         CALL SQWRIT(NFT12,X(LCIVEC),NCI)
  420 CONTINUE
      CALL SEQREW(NFT12)
C
C  COPY CI VECTORS TO AB AS THE ONES IN KCOEFF ARE DESTROYED
C  DURING PRINTING.
C
      CALL CICOPY(X(KCOEFF),X(KAB),NCI*K)
C
C  PRINT RESULTS OF THE CI CALCULATION
C
      CALL MASPRT(IW,SOME,X(KAB),X(NAST),ITGA,ITGB,X(LSYMA),
     *            IAST,IBST,X(LGCOM),X(LSBS),NSYM,X(LSBC),
     *            X(LBOX1),X(LBOX2),X(LBOX3),X(LCON1),X(LCON2),
     *            X(LKTAB))
C
      IF(SOME) WRITE(IW,9140)
      IF(SOME) CALL TIMIT(1)
C
C  DETERMINE 1ST ORDER DENSITY MATRIX IF REQUESTED (AT -LSINT1-)
C  CI JOBS WILL EXECUTE THIS, AND SHOULD LOOP OVER EVERY STATE.
C  MCSCF JOBS WILL MAKE DM1 AND DM2 INSIDE OF MASDM2, NOT HERE.
C
      IF (NDM1.GT.0) THEN
C
C READ REFERENCE DENSITY MATRIX IN MO BASIS AND DETERMINE SCALING PARAMETER:
C
         AEXT = 1.0D0/(1.0D0 - GVAL*WEXT)
         AREF = 1.0D0 - AEXT
         CALL DAREAD(IDAF,IODA,X(LREFDM1),NREFA2,288,0)
C
         IF (SAFLG) THEN
            CALL VCLR (X(LSINT2),1,M2)
         END IF
         IF(SOME) THEN
            IF(IPURES.EQ.1) THEN
               WRITE(IW,9301) IROOT,S
            ELSE
               WRITE(IW,9300) IROOT
            END IF
         END IF
C
C     ANY STATEMENT THAT ASKS ABOUT NFLGDM WILL USE NXRT,
C     WHICH COUNTS ACCORDING TO PURES
C
         NXRT=0
         IRESTORE=0
         WTTMP = 0.0D+00
         DO 700 IST=1,K
            IF(IPURES.EQ.1  .AND.  ABS(SPINS(IST)-S).GT.0.03D+00)
     *      GO TO 700
            NXRT=NXRT+1
            IF(NFLGDM(NXRT).EQ.0) GO TO 700
C
C        SAVE THE ENERGY OF THE ROOT WHOSE PROPERTIES WILL BE COMPUTED
C
            IF(NXRT.EQ.IROOT) EROOT = ESTATE(IST)
            IF(SOME) WRITE(IW,9310) IST,ESTATE(IST)
C
            IF(SAFLG) WTTMP = WSTATE(NXRT)
C
            CALL MASDM1(X(LSINT1),X(LSINT2),M2,NACT,NCI,NA,NB,
     *                  X(LBST(1)),NEED1,X(KCOEFF+(NCI*(IST-1))),
     *                  X(INDEX),NSYM,X(LIBO),X(LBOX1),X(LBOX2),
     *                  X(LBOX4),X(LBOX5),X(LKTAB),X(LCON),X(LCON1),
     *                  X(LCON2),X(LCON3),X(LANDET),X(LBNDET),X(NAST),
     *                  X(NBST),X(LSYMA),X(LSYMB),X(LGCOM),X(LSPA),
     *                  X(LSPB),X(LDISB),X(LSAS),X(LSBS),X(LSAC),
     *                  WTTMP,ITGA,ITGB,IAST,IBST)
C
C  MAKE CEPA DENSITY USING REFERENCE DENSITY (X(LREFDM1))
C  AND CI-SD DENSITY (X(LSINT1))
C
            DO JOE=1,NREFA2
               X(LSINT1+JOE-1) = AREF*X(LREFDM1+JOE-1) +
     *                           AEXT*X(LSINT1+JOE-1)
            ENDDO
            DO JOE=NREFA2+1,M2
               X(LSINT1+JOE-1) = AEXT*X(LSINT1+JOE-1)
            ENDDO
C
            IF(SOME  .AND. (NPRI5.GT.0  .OR.  NFLGDM(NXRT).EQ.2)) THEN
               WRITE(IW,9320)
               CALL PRTRI(X(LSINT1),NORB)
               IF(NXRT.EQ.1.AND.MPLEVL.EQ.2)THEN
                  CALL SEQOPN(NFT15,'WORK15','UNKNOWN',.FALSE.,
     *                 'UNFORMATTED')
                  CALL SEQREW(NFT15)
                  CALL SQWRIT(NFT15,X(LSINT1),(NORB*(NORB+1))/2)
               ELSEIF(MPLEVL.EQ.2)THEN
                  CALL SQWRIT(NFT15,X(LSINT1),(NORB*(NORB+1))/2)
               ENDIF
            END IF
C
C     -DETNO- SAVE DENSITY TO DIRECT ACCESS FILE, IF IST.EQ.IROOT
            CALL VALFM(LOADFM)
            LDAO = LOADFM + 1
            LVAO   = LDAO   + L2
            LVNO   = LVAO   + L3
            LOCCNO = LVNO   + L3
            LIWRK  = LOCCNO + L1
            LWRK   = LIWRK  + L1
            LSCR   = LWRK   + 8*L1
            LS     = LSCR   + L3
            LAST   = LS     + L2
            NEED5 = LAST - LOADFM - 1
            CALL GETFM(NEED5)
C
            SALAST=.FALSE.
            IF(MPLEVL.EQ.2)SALAST=.TRUE.
            CALL DETNO(SOME,X(LSINT1),X(LDAO),X(LVAO),X(LVNO),
     *           X(LOCCNO),X(LIWRK),X(LWRK),X(LSCR),X(LS),
     *           IROOT,NXRT,IST,NCORSV,NACT,M1,M2,L0,L1,L2,
     *           L3,SALAST)
C
C        STASH A COPY OF THE -IROOT- STATE'S DENSITY TO BETA RECORD.
            IF(NXRT.EQ.IROOT) CALL DAWRIT(IDAF,IODA,X(LDAO),L2,20,0)
C
            IF(SOME  .AND.  NFLGDM(NXRT).EQ.3) THEN
               IF(IROOT.EQ.NXRT) THEN
                  IF(MASWRK) WRITE(IW,9240) IROOT
               ELSE
                  IRESTORE=1
                  IROOTSAVE=IROOT
                  E    = ESTATE(IST)
                  ETOT = ESTATE(IST)
                  CALL DAWRIT(IDAF,IODA,ENUCR,MXRT+15,2,0)
                  CALL DAWRIT(IDAF,IODA,X(LDAO),L2,16,0)
                  IROOT=NXRT
                  CALL PROPTY('CI E')
                  IROOT=IROOTSAVE
               END IF
            END IF
C
            CALL RETFM(NEED5)
  700    CONTINUE
C
         IF (SAFLG) THEN
C           Record the State Averaged Density Matrix
            IF (IPRTSA.EQ.2) THEN
               WRITE(IW,9325)
               CALL PRTRI(X(LSINT2),NORB)
            ENDIF
C
C           -DETNO-
            IF (IPRTSA.GT.0) WRITE(IW,9326)
            CALL VALFM(LOADFM)
            LDAO = LOADFM + 1
            LVAO   = LDAO   + L2
            LVNO   = LVAO   + L3
            LOCCNO = LVNO   + L3
            LIWRK  = LOCCNO + L1
            LWRK   = LIWRK  + L1
            LSCR   = LWRK   + 8*L1
            LS     = LSCR   + L3
            LAST   = LS     + L2
            NEED5 = LAST - LOADFM - 1
            CALL GETFM(NEED5)
C
            CALL DETNO(SOME,X(LSINT2),X(LDAO),X(LVAO),X(LVNO),
     *           X(LOCCNO),X(LIWRK),X(LWRK),X(LSCR),X(LS),
     *           IROOT,NXRT,K,NCORSV,NACT,M1,M2,L0,L1,L2,
     *           L3,.TRUE.)
C
            CALL RETFM(NEED5)
         END IF
C
         E    = EROOT
         ETOT = EROOT
C
C        RECOVER DENSITY FOR STATE -IROOT-, IF NEED BE
C        AFTER THIS POINT, WE MUST STORE -E- AND -DENSITY- FOR
C        THE SINGLE STATE SPECIFIED BY THE USER'S -IROOT- CHOICE.
C
         IF(IRESTORE.EQ.1) THEN
            CALL DAREAD(IDAF,IODA,X(LDAO),L2,20,0)
            CALL DAWRIT(IDAF,IODA,X(LDAO),L2,16,0)
         ENDIF
C
         IF (SOME) WRITE(IW,9330)
         IF (SOME) CALL TIMIT(1)
      ENDIF
C
C  DETERMINE IF STATE AVERAGED 1E- AND 2E- DENSITY MATRICES REQUESTED
C
      IF (NDM2.GT.0) THEN
         IF (.NOT.FDIRCT) THEN
            IDIM1 = NSYM+1
            IDIM2 = IBST+1
         ELSE
            IDIM1 = 1
            IDIM2 = 1
         ENDIF
C
C IF STATE WEIGHTS ARE CHOSEN DYNAMICALLY DETERMINE THE WEIGHTS HERE.
C  DYNAMIC WEIGHTS (DW) ARE CHOOSEN ACCORDING TO THE CI ENERGIES
C  RELATIVE TO THE GROUND STATE.
C
      IF(IDWEIGH.EQ.0) GOTO 200
C
C DETERMINE WHICH STATE IS THE GROUND STATE WE WANT TO USE A THE
C REFERENCE TO THE DYNAMICALLY WEIGHTED AVERAGE.
C
      NXTR=0
      DO 210 IDWREF=1,K
         IF(IPURES.EQ.1  .AND.  ABS(SPINS(IDWREF)-S).GT.0.03D+00)
     *        GO TO 210
         NXTR=NXTR+1
         IF(NXTR.EQ.IDWEIGH.AND.WSTATE(NXTR).GT.ZERO)GOTO 220
 210       CONTINUE
 220         CONTINUE
C
C DETERMINE THE UNNORMALIZED DYNAMIC WEIGHTS
C
      WSUM = ZERO
      NXTR = 0
      ESHIFT = DWPARM/27.2113957D+00
      DO 153 IST = 1,K
         IF(IPURES.EQ.1.AND.ABS(SPINS(IST)-S).GT.0.03D+00) GO TO 153
         NXTR=NXTR+1
         IF(WSTATE(NXTR).GT.ZERO)THEN
            E_DIFF = ESTATE(IST)-ESTATE(IDWREF)
            WSTATE(NXTR)=1/(DCOSH(E_DIFF/ESHIFT))**2
            WSUM = WSUM + WSTATE(NXTR)
         ENDIF
  153 CONTINUE
C
C NORMALIZE DYNAMIC WEIGHTS
C
      NXTR = 0
      DO 155 IST = 1,K
         IF(IPURES.EQ.1.AND.ABS(SPINS(IST)-S).GT.0.03D+00) GO TO 155
         NXTR=NXTR+1
         IF(WSTATE(NXTR).GT.ZERO)WSTATE(NXTR) = WSTATE(NXTR)/WSUM
  155 CONTINUE
C
 200  CONTINUE                  !(IDWEIGH.EQ.0)
C
C READ REFERENCE DENSITY MATRICES IN MO BASIS AND DETERMINE SCALING PARAMETER:
C
         AEXT = 1.0D0/(1.0D0 - GVAL*WEXT)
         AREF = 1.0D0 - AEXT
         CALL DAREAD(IDAF,IODA,X(LREFDM1),NREFA2,288,0)
         CALL DAREAD(IDAF,IODA,X(LREFDM2),NREFA4,289,0)
C
         CALL CEPDM2(IW,NPRI6,IWTS,WSTATE,SPINS,IPURES,S,K,GRPDET,
     *           NCORSV,
     *           X(LSINT1),X(LSINT2),M2,M4,NACT,NCI,NA,NB,
     *           X(KCOEFF),X(KAB),
     *           X(LBST(1)),NEED1,
     *           X(INDEX),NSYM,X(LIBO),
     *           X(LBOX1),X(LBOX2),X(LBOX3),X(LBOX4),X(LBOX5),
     *           X(LGMUL),X(LKTAB),
     *           X(LCON),X(LCON1),X(LCON2),X(LCON3),
     *           X(LANDET),X(LBNDET),X(NAST),X(NBST),
     *           X(LSYMA),X(LSYMB),X(LGCOM),X(LSPA),X(LSPB),
     *           X(LDISB),X(LSAS),X(LSBS),X(LSAC),X(LSBC),
     *           ITGA,ITGB,IAST,IBST,
     *           X(IPOSA),X(IPERA),X(IIND1),X(IGROA),X(IMMC),
     *           NB1EX,
     *           X(JB1GR),X(JB1PE),X(JB1IN),X(JB1PO),X(JB1ST),
     *           IDIM1,IDIM2,IDWEIGH,DWPARM,
     *           X(LREFDM1),X(LREFDM2),NREFA2,NREFA4,AEXT,AREF)
      ENDIF
C
      CALL RETFM(NEED4)
      CALL RETFM(NEED3)
      CALL RETFM(NEED2)
      CALL RETFM(NEED1)
C
C  GOOD REASON FOR THIS SMALL PART, DON'T WORRY
C
      DO II=1,NSPACE+1
         MSTA(II) = MSTA(II) + NCORSV
      ENDDO
C
      IF(EXETYP.NE.CHECK  .AND.  ISTAT.NE.0 .AND. SCFTYP.NE.AMCSCF) THEN
         IF(MASWRK) WRITE(IW,9150)
         CALL ABRT
         STOP
      END IF
C
      RETURN
C
 9000 FORMAT(/1X,50(1H-)/
     *       1X,'DIRECT DETERMINANT SINGLE-REFERENCE-CEPA'/
     *       1X,'       INPUT G-VALUE  = ',E15.8)
 9002 FORMAT(/1X,50(1H-)/
     *       1X,'DIRECT DETERMINANT SINGLE-REFERENCE-',A5)
 9005 FORMAT(/1X,50(1H-)/
     *       1X,'DIRECT DETERMINANT MULTIREFERENCE-CEPA'/
     *       1X,'       INPUT G-VALUE  = ',E15.8)
 9006 FORMAT(/1X,50(1H-)/
     *       1X,'DIRECT DETERMINANT MULTIREFERENCE-',A5)
 9008 FORMAT(1X,50(1H-)//
     *       1X,'STORAGE OF BINOMIAL COEFFICIENTS REQUIRES',
     *       I12,' WORDS')
 9010 FORMAT(/1X,'TOTAL NUMBER OF ALPHA GROUPS  = ',I12/
     *        1X,'TOTAL NUMBER OF BETA  GROUPS  = ',I12)
 9020 FORMAT(/1X,'TOTAL NUMBER OF ALPHA STRINGS = ',I12/
     *        1X,'TOTAL NUMBER OF BETA  STRINGS = ',I12)
 9030 FORMAT(/1X,'STORAGE OF TABLES REQUIRES              ',
     *       I12,' WORDS')
 9045 FORMAT(/1X,'ORMAS ERROR.  THIS RUN FOUND NSTATE=',I4,' ROOTS,'/
     *        1X,'BUT FEWER OF THESE THAN IROOT=',I4,
     *           ' HAVE THE DESIRED SPIN S=',F5.2/
     *        1X,'PLEASE INCREASE -NSTATE- TO CONTINUE')
 9107 FORMAT(/1X,'TIME FOR SETTING UP TABLE SET 1 :',F13.1)
 9110 FORMAT(/1X,'THE NUMBER OF DETERMINANTS HAVING SPACE SYMMETRY ',A3/
     *        1X,'IN POINT GROUP ',A4,' WITH SZ=',F5.1,' IS',I15)
 9120 FORMAT(/1X,'INTEGRAL STORAGE REQUIRES         ',I16,' WORDS'/
     *        1X,'EXTRA ORMAS-CEPA STORAGE REQUIRES ',I16,' WORDS'/
     * 1X,'(EXTRA ORMAS STORAGE INCLUDES THAT FOR MXXPAN =',I3,')'/
     *        1X,'TOTAL CEPA CALCULATION REQUIRES   ',I16,' WORDS')
 9125 FORMAT(/1X,'FULLY DIRECT WOULD REQUIRE        ',I16,' WORDS')
 9140 FORMAT(/1X,'..... DONE WITH ORMAS-CI COMPUTATION .....')
 9150 FORMAT(1X,'CI COMPUTATION DID NOT CONVERGE, JOB CANNOT CONTINUE')
 9240 FORMAT(1X,'INPUT VALUE FOR -NFLGDM- REQUESTED PROPERTIES FOR',
     *          ' STATE -IROOT- ',I4/
     *       1X,'WHICH WILL BE PRINTED IN THE NORMAL PROPERTY',
     *          ' OUTPUT (BELOW)')
 9300 FORMAT(/5X,27(1H-)/5X,'ONE PARTICLE DENSITY MATRIX'/5X,27(1H-)//
     *  1X,'DENSITY MATRIX WILL BE SAVED FOR PROPERTIES OF STATE',I4)
 9301 FORMAT(/5X,27(1H-)/5X,'ONE PARTICLE DENSITY MATRIX'/5X,27(1H-)//
     *  1X,'DENSITY MATRIX WILL BE SAVED FOR',I4,'-TH STATE WITH S=',
     *      F5.2)
 9310 FORMAT(/1X,'CI EIGENSTATE',I4,' TOTAL ENERGY =',F20.10)
 9320 FORMAT(/1X,'1-PARTICLE DENSITY MATRIX IN MO BASIS')
 9325 FORMAT(/1X,'MRCISD-SA 1-PARTICLE DENSITY MATRIX IN MO BASIS')
 9326 FORMAT(/1X,'MRCISD-SA NATURAL ORBITALS IN AO BASIS')
 9330 FORMAT(1X,'..... DONE WITH ONE PARTICLE DENSITY MATRIX .....')
C
      END
C
C*MODULE CEPA  *DECK CEPAC2
C> @brief      This routine forms the guts of SR- and MR-CEPA computations.
C>
C> @author     Joe Ivanic
C>             -2014
C>
C> @details    Literally is the guts of SR- and MR-CEPA computations.
C>             For a good review of the SR and MR-CEPA methods computed in this
C>             module see:
C>             P.G. Szalay, in Modern Ideas in Coupled-Cluster Methods,
C>             R. J. Bartlett (ed), World Scientific, Singapore (1997), pp 81-123.
C>
C>             The CEPA computation is similar to CISD/MRCISD except that an
C>             energy correction is added to the Hamiltonian diagonal elements
C>             corresponding to only external determinants. The CEPA iterations
C>             are similar to CISD/MRCISD iterations, as such, the CEPA
C>             iterations programmed here use underlying ORMAS functionalities.
C>             For more on the ORMAS method see:
C>             Joseph Ivanic, Journal of Chemical Physics, 9364, V. 119, (2003).
C>             Joseph Ivanic, Journal of Chemical Physics, 9376, V. 119, (2003).
C>
C> @param      IW       Output file number.
C> @param      SOME     Governs amount of printing.
C> @param      ECONST   Stores constant core CI energy.
C> @param      ECONST   Stores constant core CI energy.
C> @param      ISTAT    ISTAT=1 means successful CI.
C> @param      SI1      One-electron integrals.
C> @param      SI2      Two-electron integrals.
C> @param      M1       Number of one-electron integrals.
C> @param      M4       Number of two-electron integrals.
C> @param      NACT     Number of active orbitals.
C> @param      NCI      Number of determinants.
C> @param      NA       Number of alpha electrons.
C> @param      NB       Number of beta electrons.
C> @param      K        Number of states required.
C> @param      KST      Number of starting states.
C> @param      MAXP     Number of CI expansion vectors in Davidson steps.
C> @param      MAXW1    Size of initial guess.
C> @param      NITER    Maximum number of Davidson iterations.
C> @param      CRIT     Convergence criterion.
C> @param      X        Stores intermediate excitation data.
C> @param      X        Length of X.
C> @param      SPIN     Contains spins of CI states.
C> @param      EL       Used for small diagonalizations in Davidson steps.
C> @param      NSYM     Number of symmetry labels.
C> @param      IOB      Stores irreps of the orbitals.
C> @param      LBOX1 -> LBOX5  Scratch storage of electron space occupations.
C> @param      CI       Stores CI vectors.
C> @param      AB       Stores H*C.
C> @param      Q        Stores diagonal determinant energies.
C> @param      B -> EC  Scratch storage for small diagonalizations.
C> @param      GR       Gradients of CI vectors.
C> @param      IPOSA -> IGROA String symmetry data.
C> @param      IWRK1    Scratch work space.
C> @param      IWRK2    Scratch work space.
C> @param      ISD      Scratch work space.
C> @param      IDO      Scratch work space.
C> @param      INDEX    Integral position array.
C> @param      IMMC     Scratch symmetry data.
C> @param      IHMCON   CI state convergence data.
C> @param      LGMUL    Symmetry multiplication table.
C> @param      KTAB     Stores symmetry-opposite element.
C> @param      IACON1 -> IBCON2 Scratch orbital occupation data.
C> @param      LANDET -> JB1SY String symmetry data.
C> @param      VTORB    Contains Malmqvist' factorized orbital transformation.
C> @param      L1       Denotes the length of the AO coefficients.
C> @param      NCORSV   Denotes the number of MCSCF core orbitals.
C> @param      ICIMALMQ Results in the different CI transformations
C>                      when icimalmq equals 1,3.
C> @param      NATOMS   Number of atoms.
C> @param      DMAT     NATOMS-by-NATOMS matrix for charge transfer run.
C> @param      DMAT2    NATOMS-by-NATOMS+1 matrix integer scratch matrix.
C> @param      FRHS     Vector with NATOMS length for charge transfer run.
C> @param      NATM     Vector with L1 length defines atoms for orbital number.
C>                      For quasi-atomic orbitals, these orbital limits assign
C>                      each orbital to a single atom.
C> @param      IORDACT2 NATOMS integer scratch array.
C> @param      MXRTMQ   MXRT parameter in many common blocks.
C> @param      IWTSMQ   The index of SA-CI roots.
C> @param      WGTMQ    Contains the weights of the SA-CI roots.
C> @param      IREFDE   Scratch array storing positions of reference functions.
C> @param      ECORR    Current correlation energy.
C> @param      WEXT     Weight of external determinants in wavefunction.
C>
      SUBROUTINE CEPAC2(IW,SOME,ECONST,ISTAT,
     *           SI1,SI2,M2,M4,NACT,NCI,NA,NB,K,KST,MAXP,MAXW1,
     *           NITER,CRIT,
     *           X,NX,
     *           SPIN,EL,NSYM,IOB,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           CI,AB,Q,B,EF,F,EC,GR,
     *           IPOSA,IPERA,IIND1,IGROA,IWRK1,IWRK2,
     *           ISD,IDO,INDEX,IMMC,IHMCON,
     *           LGMUL,KTAB,IACON1,IACON2,IBCON1,IBCON2,
     *           LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *           LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,LSBC,
     *           ITGA,ITGB,IAST,IBST,
     *           NB1EX,IBST2,
     *           JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,JB1SY,
     *           VTORB,L1,NCORSV,ICIMALMQ,
     *           NATOMS,DMAT,DMAT2,FRHS,NATM,
     *           IORDACT2,MXRTMQ,IWTSMQ,WGTMQ,
     *           IREFDE,ECORR,WEXT)
C     ------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SOME,GOPARR,DSKWRK,MASWRK,DSKSAV,FDIRCT,QCORR,ANALYS,
     *        SAFLG
C
      COMMON /CEPAPA/ CEPA,GVAL,ECREF,NCREF
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /DETPAR/ ICLBBR,ANALYS,SAFLG,IPRTSA
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION SI1(M2),SI2(M4),X(NX),SPIN(KST),EL(MAXW1)
      DIMENSION IOB(NACT),LBOX1(NSPACE),LBOX2(NSPACE),LBOX3(NSPACE)
      DIMENSION LBOX4(NSPACE),LBOX5(NSPACE)
      DIMENSION CI(NCI,MAXP),AB(NCI,MAXP),Q(NCI),B(8*MAXW1)
      DIMENSION EF(MAXW1,MAXW1),F((MAXW1*(MAXW1+1))/2)
      DIMENSION EC(MAXP,MAXP),GR(MAXP)
      DIMENSION IPOSA(NA*(NACT-NA)*NSYM)
      DIMENSION IPERA(NA*(NACT-NA)*NSYM)
      DIMENSION IIND1(NA*(NACT-NA)*NSYM)
      DIMENSION IGROA(NA*(NACT-NA)*NSYM)
      DIMENSION IWRK1(2*MAXW1),IWRK2(MAXW1),ISD(NA+NB),IDO(NA)
      DIMENSION INDEX((NACT*(NACT+1))/2+1)
      DIMENSION IMMC(NSYM),IHMCON(K)
      DIMENSION LGMUL(NSYM,NSYM),KTAB(NSYM)
      DIMENSION IACON1(NA),IACON2(NA),IBCON1(NA),IBCON2(NA)
      DIMENSION LANDET(NSPACE,ITGA),LBNDET(NSPACE,ITGB)
      DIMENSION NAST(ITGA+1),NBST(ITGB+1)
      DIMENSION LSYMA(IAST),LSYMB(IBST),LGCOM(ITGB,ITGA)
      DIMENSION LSPA(IAST),LSPB(IBST),LDISB(NSYM,ITGB,ITGA)
      DIMENSION LSAS(NSYM+1,ITGA),LSBS(NSYM+1,ITGB)
      DIMENSION LSAC(IAST),LSBC(IBST)
      DIMENSION JB1GR(NB1EX),JB1PE(NB1EX),JB1IN(NB1EX),JB1ST(IBST2)
      DIMENSION JB1PO(NB1EX),JB1SY(NB*(NACT-NB))
      DIMENSION IREFDE(NCREF)
C
      DATA ARTQ/8HARTQ    /
C
C     ATOMIC-LIKE VARS HERE
      DIMENSION VTORB(L1,L1),DMAT(NATOMS,NATOMS),DMAT2(NATOMS,NATOMS+1),
     *          FRHS(NATOMS,2),
     *          WGTMQ(MXRTMQ)
      DIMENSION NATM(L1),IORDACT2(NATOMS),IWTSMQ(MXRTMQ)
C
      IF (.NOT.FDIRCT) THEN
         IDIM1 = NSYM+1
         IDIM2 = IBST+1
      ELSE
         IDIM1 = 1
         IDIM2 = 1
      ENDIF
C
      IF (SOME) CALL TSECND(E0)
      ISTAT=0
C
      DO 7 I=1,(NACT*(NACT+1))/2 + 1
         INDEX(I) = (I*(I-1))/2
    7 CONTINUE
C
      DO 20 II=1,KST
         DO 30 JJ=1,NCI
            CI(JJ,II) = 0.0D+00
            AB(JJ,II) = 0.0D+00
   30    CONTINUE
   20 CONTINUE
C
C   INITITAL SETUP, WORK OUT DIAGONAL ELEMENTS.
C
      CALL GETQFCC(SI1,SI2,NACT,NCI,NA,NB,IACON1,IBCON1,
     *     INDEX,Q,LBOX1,LBOX2,LBOX3,
     *     NAST,NBST,LSYMA,LSYMB,NSYM,LSPA,LSPB,
     *     LGCOM,LSAS,LSBS,KTAB,LSAC,LSBC,LDISB,
     *     ITGA,ITGB,IAST,IBST)
C
C     ----- SEE IF WE HAVE USABLE CI VECTORS ON DISK ALREADY -----
C     1) SKIP IF THE ENTIRE PROBLEM IS BEING FIT INTO INITIAL GUESS
C     2) SKIP IF THE USER CHOSE OPTION TO ALWAYS FORCE INITIAL GUESS
C
      DSKSAV = DSKWRK
      DSKWRK = .FALSE.
      CRITSV = CRIT
      IGUESS = 1
      IF(NCI.LE.MAXW1.AND.ICIMALMQ.EQ.0) GO TO 2345
      IF(ICLBBR.EQ.1.AND.ICIMALMQ.EQ.0)  GO TO 2345
C
C   SEE IF WE HAVE INITIAL GUESS VECTORS ON DISK.
C
      NSTATE=0
      NVECS =0
C
      CALL SEQOPN(NFT12,'CIVECTR','UNKNOWN',.FALSE.,'UNFORMATTED')
      CALL SEQREW(NFT12)
      IF(MASWRK) READ(NFT12,ERR=2343,END=2343) NSTATE,NVECS
      GO TO 2344
C
 2343 CONTINUE
      NSTATE=0
      NVECS =0
C
C         LET OTHER NODES KNOW IF ANYTHING WAS READ
C
 2344 CONTINUE
      IF (GOPARR) CALL DDI_BCAST(2507,'I',NSTATE,1,MASTER)
      IF (GOPARR) CALL DDI_BCAST(2508,'I',NVECS ,1,MASTER)
C
C         IF NOTHING READ, WE MUST MAKE AN INITIAL GUESS
C
      IF (NSTATE+NVECS.EQ.0.AND.ICIMALMQ.EQ.0) GO TO 2345
C
C         IF INCONSISTENCY WITH THE DISK FILE, WE MUST TERMINATE
C
      IF (NVECS.NE.NCI) THEN
         IF (SOME) WRITE(IW,9005) NVECS,NCI
         CALL ABRT
      ENDIF
C
C     WE WILL TIGHTEN THE CONVERGENCE CRITERION, SO THAT AT LEAST A
C     LITTLE IMPROVEMENT IS MADE TO WHAT IS FOUND ON THE DISK.  THE
C     CONVERGENCE CRITERION ON ENTRY WILL BE RESTORED AFTER 3 CYCLES.
C
      CRIT = 1.0D-03 * CRIT
C
C        READ PREVIOUS CI EIGENVECTORS AS THE INITIAL GUESS
C
      IF (SOME) WRITE(IW,9007)
C
      DO 100 ISTATE = 1,NSTATE
         CALL SQREAD(NFT12,CI(1,ISTATE),NVECS)
         IF(NVECS.EQ.0) THEN
            IF (SOME) WRITE(IW,*)
     *         'UNEXPECTED END OF FILE ON UNIT',NFT12
            CALL ABRT
            STOP
         END IF
  100 CONTINUE
C
C        CAN'T INCLUDE EXTRA STATES IF THE VECTORS COME FROM DISK FILE
C
      IF(KST.GT.NSTATE) KST=NSTATE
      DSKWRK = DSKSAV
      IGUESS = 0
      GO TO 3333
C
 2345 CONTINUE
      DSKWRK = DSKSAV
      NVECS = 0
C
C  DETERMINE THE INITIAL GUESS VECTORS.
C
      DO II=1,NCI
         CI(II,1) = Q(II)
      ENDDO
C
      IF(SOME) CALL TSECND(E0)
C
      CALL INITFCC(IW,SOME,B,NCI,NA,NB,NACT,IACON1,IBCON1,
     *     IACON2,IBCON2,ISD,IDO,CI,IWRK1,MAXW1,KST,
     *     INDEX,F,EL,EF,SI1,SI2,IWRK2,IMARK,AB,
     *     LGCOM,NAST,NBST,LSYMA,LSYMB,
     *     LSBS,LSBC,LSPA,LSPB,LDISB,
     *     LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *     X,NX,LANDET,LBNDET,
     *     ITGA,ITGB,IAST,IBST,
     *     KTAB,NSYM)
C
      IF(SOME) THEN
         CALL TSECND(E1)
         ELAP = E1 - E0
         E0 = E1
         IF (NVECS.EQ.0) WRITE(IW,9010) ELAP
      END IF
C
 3333 CONTINUE
C
C   IF NOT FULLY DIRECT, CALL SETUP FOR STORAGE OF B -> B' DATA.
C   THIS IS NEEDED FOR DENSITY MATRIX DETERMINATION IF NOT HERE
C   IN THE CI
C
      IF (.NOT.FDIRCT) THEN
         CALL FCCSUP(IW,NA,NB,NACT,IACON1,IBCON1,IBCON2,
     *           INDEX,NBST,LSPB,
     *           LBOX1,LBOX2,LBOX3,LBOX4,
     *           X,NX,LBNDET,LSYMB,NSYM,
     *           ITGB,IBST,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,JB1SY)
C
         IF(SOME) THEN
            CALL TSECND(E1)
            ELAP = E1 - E0
            E0 = E1
            WRITE(IW,9015) ELAP
         ENDIF
      ENDIF
C
      IF (NA.EQ.NB.and.icimalmq.eq.0) THEN
         CALL  FCCSPIN(NA,NB,IACON1,IACON2,IBCON1,IBCON2,
     *      ISD,IDO,CI,AB,KST,NCI,SPIN,IWRK1,IWRK2,MAXW1,
     *           LGCOM,NAST,NBST,LSYMA,LSYMB,
     *           LSBS,LSBC,LSPA,LSPB,LDISB,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           X,NX,LANDET,LBNDET,
     *           ITGA,ITGB,IAST,IBST,KTAB,NSYM)
C
         DO I=1,KST
            IWRK1(I)=INT(SPIN(I) + 0.3D+00)
            IWRK2(I)=I
         ENDDO
C
         IF(SOME) THEN
            CALL TSECND(E1)
            ELAP = E1 - E0
            E0 = E1
            WRITE(IW,9013) ELAP
         ENDIF
      ENDIF
C
      IF (SOME) WRITE(IW,9014) (SPIN(I),I=1,KST)
C
C  IF MS=0, IMPOSE RESTRICTION ON THE INITIAL CI COEFFICIENTS.
C
      IF (NA.EQ.NB.and.icimalmq.eq.0) THEN
      DO 5511 IGA=1,ITGA
         DO 5522 KKA=NAST(IGA)+1,NAST(IGA+1)
            JPZA1 = LSPA(KKA)
            JASYM = LSYMA(KKA)
            KSYM=KTAB(JASYM)
C
            DO 5533 IGB=1,IGA
            IF (LGCOM(IGB,IGA).NE.1) GOTO 5533
            ICC1 = JPZA1 + LDISB(KSYM,IGB,IGA)
            ICC2 = LDISB(JASYM,IGA,IGB) + LSPB(KKA)
            NIBS=NBST(IGB)
            DO 5544 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
               IBPOS = LSBC(KKB) + NIBS
               IF (IBPOS.GT.KKA) GOTO 5522
               ICI1 = ICC1+LSPB(IBPOS)
               IF (IBPOS.EQ.KKA) THEN
                  DO 5532 KJ=1,KST
                  IPS = (IWRK1(KJ)/2)
                  IF ((IPS+IPS).NE.IWRK1(KJ)) CI(ICI1,KJ) = 0.0D+00
 5532             CONTINUE
                  GOTO 5522
               ENDIF
               ICI2 = LSPA(IBPOS) + ICC2
               DO 5531 KJ=1,KST
               IS = (-1)**IWRK1(KJ)
               CI(ICI2,KJ) = IS*CI(ICI1,KJ)
 5531          CONTINUE
 5544       CONTINUE
 5533       CONTINUE
 5522    CONTINUE
 5511 CONTINUE
      END IF
C
C     PERFORM MALMQVIST CI TRANSFORMATION IF REQUESTED.
C
      IF(ICIMALMQ.NE.0) THEN
C
C       OBTAIN CORRECT ROOT TO ACCESS FOR NEXT ROUTINE.
        CALL MALMQ_IWTS(MXRTMQ,IRTMQ,IWTSMQ,WGTMQ)
        IF(MAXP.LT.2.OR.IWTSMQ(IRTMQ).GT.MAXP-1) THEN
          IF(SOME) WRITE(IW,9016)
          CALL FLSHBF(IW)
          CALL ABRT
          STOP
        ENDIF
C
C       CONFIGURATIONAL TRANSFORMATION WITHOUT DOING CI.
        IF(ICIMALMQ.EQ.1) THEN
          CALL MALMQ_FCHCX1S(
     *         VTORB,L1,NCORSV,MXRTMQ,IWTSMQ,WGTMQ,
     *         NACT,NA,NB,CI,AB,KST,NCI,X,NX,
     *         IACON1,IACON2,IBCON1,IBCON2,
     *         LBOX1,LBOX2,LBOX3,LBOX5,
     *         NSYM,KTAB,
     *         LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *         LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,LSBC,
     *         ITGA,ITGB,IAST,IBST)
        ENDIF
C
C       FIND WAVEFUNCTION WITH NO CHARGE TRANSFER.
        IF(ICIMALMQ.EQ.3) THEN
          NV=KST
          CALL MALMQ_CHARGE_TRANSFER_ORMAS1(
     *         L1,NATOMS,DMAT,DMAT2,FRHS,NATM,
     *         IORDACT2,MXRTMQ,IWTSMQ,WGTMQ,
     *         CI,AB,AB(1,MAXP),NACT,
     *         MASWRK,SOME,
     *         NA,NB,NV,NCI,X,NX,
     *         IACON1,IACON2,IBCON1,IBCON2,
     *         LBOX1,LBOX2,LBOX3,LBOX5,
     *         NSYM,KTAB,
     *         LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *         LSPA,LSPB,LDISB,LSBS,LSBC,
     *         ITGA,ITGB,IAST,IBST,
     *         NSPACE)
        ENDIF
C
C       TAKE CARE OF SPIN
        CALL FCCSPIN(NA,NB,IACON1,IACON2,IBCON1,IBCON2,
     *       ISD,IDO,CI,AB,KST,NCI,SPIN,IWRK1,IWRK2,MAXW1,
     *       LGCOM,NAST,NBST,LSYMA,LSYMB,
     *       LSBS,LSBC,LSPA,LSPB,LDISB,
     *       LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *       X,NX,LANDET,LBNDET,
     *       ITGA,ITGB,IAST,IBST,KTAB,NSYM)
C
C       GET THE EL ENERGY BEFORE EXITING.
C       SO THE RETURN IS BELOW AFTER ONE SIGMA VECTOR.
      ENDIF
C
C  SPECIAL STUFF FOR CEPA, NEED TO FIGURE OUT AND STORE WHERE THE
C  REFEENCE DETERMINANTS ARE IN THE FULL ORMAS LIST
C
      IF (NCREF.EQ.1) THEN
         IREFDE(1) = 1
      ELSE
         ICI = 0
         ICOUNT = 0
         IGA = 1
         DO 410 KKA=NAST(IGA)+1,NAST(IGA+1)
            JASYM=LSYMA(KKA)
            KSYM=KTAB(JASYM)
            DO 500 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 500
               DO 510 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  ICI=ICI+1
                  IF (IGB.EQ.1) THEN
                     ICOUNT = ICOUNT + 1
                     IREFDE(ICOUNT) = ICI
                  ENDIF
  510          CONTINUE
  500       CONTINUE
  410    CONTINUE
         IF (ICOUNT.NE.NCREF) THEN
         WRITE(IW,*) 'SOMETHING SERIOUSLY WRONG IN REF DET STUFF!!!!'
            CALL ABRT
            STOP
         ENDIF
      ENDIF
C
C     ANALYZE INITIAL CORRELATION ENERGY, RELATIVE TO REFERENCE ENERGY,
C     FROM INITIAL GUESS. IDEALLY, WE WANT INITIAL SD-CI ENERGY TO BE
C     LOWER THAN REFERENCE ENERGY. IF SO, THEN ALL IS OKAY.
C     FOUR POSSIBLE SCENARIOS EXIST:
C
C    1. THE INITIAL GUESS DIAGONALIZATION WAS BIG ENOUGH TO SOLVE SD-CI EXACTLY.
C        IN THIS CASE SD-CI ENERGY MUST BE LOWER THAN REFERENCE ENERGY SO
C        WE CAN JUST ADD ECORR INTO DIAGONAL H ELEMENTS OF EXTERNAL DETERMINANTS
C        AND DO CI ITERATIONS BELOW UNTIL CONVERGENCE
C
C    2. INITIAL GUESS DIAGONALIZATION HAS ENERGY LOWER THAN REFERENCEY ENERGY.
C       THIS IS THE MOST COMMON SCENARIO, SO WE JUST ADD ECORR TO DIAGONAL H
C       ELEMENTS OF EXTERNAL DETERMINANTS AND PROCEED INTO CI ITERATIONS
C
C    3. INITIAL GUESS DIAGONALIZATION HAS ENERGY HIGHER THAN REFERENCE ENERGY.
C       THIS WOULD BE AN UNUSUAL SITUATION; HOWEVER, IT IMPLIES THAT THE
C       SD-CI WAS NOT CONVERGED EXACTLY IN THE INITIAL GUESS SO THAT (CLEARLY)
C       THE CI ITERATIONS BELOW WILL SURELY LOWER THE SD-CI ENERGY UNTIL
C       IT IS BELOW THE REFERENCE. AS SUCH, IF ECORR IS +VE, WE JUST SET IT
C       TO ZERO UNTIL IT BECOMES -VE, WHICH IT MUST DO AT SOME POINT.
C
C    4. CI VECTORS WERE READ FROM DISK, AS IN THE LATTER STEPS OF A MCSCF OR
C       WHAT I CALL CEPA-SCF. IN SUCH A CASE WE DON'T KNOW THE INITIAL ENERGY
C       SO WE JUST SET ECORR TO ZERO AS IN SCENARIO 3 ABOVE.
C
      EAREF = ECREF - ECONST
      IF (IGUESS.EQ.1) THEN
         ECORR = EL(1) - EAREF
         IF (SOME) WRITE(IW,9017) ECORR
         IF (ECORR.GT.0.0D0) THEN
            IF (SOME) WRITE(IW,9018)
            ECORR = 0.0D0
         ENDIF
C
C   ADD GVAL*ECORR INTO EXTERNAL DIAGONAL ELEMENTS
C   IF WE ARE DOING SR-ARTQ THEN GVAL = C0, COEFFICIENT OF SCF-LIKE DETERMINANT
C
         IF (CEPA.EQ.ARTQ) GVAL = ABS(CI(1,1))
C
         CORRE = GVAL*ECORR
         DO II=1,NCI
            Q(II) = Q(II) + CORRE
         ENDDO
         DO II=1,NCREF
            Q(IREFDE(II)) = Q(IREFDE(II)) - CORRE
         ENDDO
         COOLD = CORRE
      ELSE
         ECORR = 0.0D0
         CORRE = 0.0D0
      ENDIF
C
C  THE ROUTINE NAMES HAVE MEANING.  FCHC IS COMMON TO ALL OF THEM.
C  THE 5TH CHARACTER CAN BE A 0 OR X.  0 MEANS MS=0, X MEANS OTHERWISE.
C  THE 6TH CHARACTER CAN BE A 1 OR Y.  1 MEANS A SINGLE HC VECTOR IS
C  DETERMINED, Y MEANS MORE THAN ONE IS DETERMINED.
C  THE 7TH AND FINAL CHARACTER CAN BE A D OR S.  D MEANS FULLY DIRECT
C  AND S MEANS SEMI-DIRECT.  D IS YET TO BE IMPLEMENTED, I WILL
C  SEE IF THERE IS A NEED FOR IT FIRST.
C
      IF (NA.EQ.NB.and.icimalmq.eq.0) THEN
      IF (KST.GT.1) THEN
      CALL FCHC0YS(SI1,SI2,INDEX,NACT,NA,NB,CI,AB,KST,Q,NCI,X,NX,
     *           IACON1,IACON2,IBCON1,IBCON2,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           NSYM,IOB,LGMUL,KTAB,
     *           LANDET,LBNDET,NAST,NBST,LSYMA,LGCOM,
     *           LSPA,LSPB,LDISB,LSBS,LSBC,
     *           ITGA,ITGB,IAST,IBST,
     *           IPOSA,IPERA,IIND1,IGROA,IMMC,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,
     *           IWRK1,IWRK2)
      ELSE
      CALL FCHC01S(SI1,SI2,INDEX,NACT,NA,NB,CI,AB,Q,NCI,X,NX,
     *           IACON1,IACON2,IBCON1,IBCON2,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           NSYM,IOB,LGMUL,KTAB,
     *           LANDET,LBNDET,NAST,NBST,LSYMA,LGCOM,
     *           LSPA,LSPB,LDISB,LSBS,LSBC,
     *           ITGA,ITGB,IAST,IBST,
     *           IPOSA,IPERA,IIND1,IGROA,IMMC,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,IDIM1,IDIM2,
     *           IWRK1,IWRK2)
      ENDIF
      ELSE
      IF (KST.GT.1) THEN
      CALL FCHCXYS(SI1,SI2,INDEX,NACT,NA,NB,CI,AB,KST,Q,NCI,X,NX,
     *           IACON1,IACON2,IBCON1,IBCON2,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           NSYM,IOB,LGMUL,KTAB,
     *           LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *           LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,LSBC,
     *           ITGA,ITGB,IAST,IBST,
     *           IPOSA,IPERA,IIND1,IGROA,IMMC,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST)
      ELSE
      CALL FCHCX1S(SI1,SI2,INDEX,NACT,NA,NB,CI,AB,Q,NCI,X,NX,
     *           IACON1,IACON2,IBCON1,IBCON2,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           NSYM,IOB,LGMUL,KTAB,
     *           LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *           LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,LSBC,
     *           ITGA,ITGB,IAST,IBST,
     *           IPOSA,IPERA,IIND1,IGROA,IMMC,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST)
      ENDIF
      ENDIF
C
      IF(SOME) THEN
         CALL TSECND(E1)
         ELAP = E1 - E0
         E0 = E1
         WRITE(IW,9020) ELAP
      ENDIF
C
      DO 13 II=1,KST
         EL(II) = 0.0D+00
         DO 15 KK=1,NCI
            EL(II) = EL(II) + CI(KK,II)*AB(KK,II)
   15    CONTINUE
   13 CONTINUE
C
C     NEXT LINE EXITS BEFORE MUCKING UP CI COEFFS FOR MALMQ_CIDRIV.
      IF(ICIMALMQ.NE.0) RETURN
C
      DO 555 II=1,MAXP
         DO 677 JJ=1,II-1
            EC(II,JJ) = 0.0D+00
            EF(II,JJ) = 0.0D+00
            EC(JJ,II) = 0.0D+00
            EF(JJ,II) = 0.0D+00
  677    CONTINUE
         EC(II,II) = 1.0D+00
         EF(II,II) = 1.0D+00
  555 CONTINUE
C
C     NOW TO GET INTO THE LOOP, SET SOME LOOP CONSTANTS HERE
C     IP IS THE CURRENT NUMBER OF CI VECTORS BEING DEALT WITH.
C     IL IS THE CURRENT ROOT BEING OPTIMIZED.
C
      IPXT = -1
      IP = KST
      IL = 1
      NTCON = K
      DO 4599 KL = 1,K
      IHMCON(KL) = KL
      IWRK2(KL) = KL
 4599 CONTINUE
C
C     LOOP OVER NUMBER OF ROOTS, ITERATIONS FOR EACH ROOT.
C
      IF(SOME) WRITE(IW,9040)
  333 CONTINUE
C
      DO 1315 ITER=0,NITER
C
      IPXT = IPXT + 1
      IF(IPXT.EQ.3) CRIT = CRITSV
C
C     CHECK TO SEE IF IP = MAXP, IF
C     SO THEN TRANSFORM THE FIRST KST VECTORS IN CI AND AB
C     AND START OVER WITH IP = K
C
      IF (IP+NTCON.GT.MAXP) THEN
         CALL TRAN(CI,NCI,MAXW1,EF,IP,EC,KST)
         CALL TRAN(AB,NCI,MAXW1,EF,IP,EC,KST)
         IP = KST
         DO 1396 II=1,MAXP
            EC(II,II) = 1.0D+00
            EF(II,II) = 1.0D+00
            DO 1398 JJ=1,II-1
               EC(II,JJ) = 0.0D+00
               EF(II,JJ) = 0.0D+00
               EC(JJ,II) = 0.0D+00
               EF(JJ,II) = 0.0D+00
 1398       CONTINUE
 1396    CONTINUE
      ENDIF
C
C COMPUTE CURRENT CORRELATION ENERGY FOR CEPA
C
      ECORR = EL(1) - EAREF
C
C   MAKE GRADIENT VECTORS, PUT IN CI(IP+1) -> CI(IP+NTCON)
C
      DO 4588 KK=1,NTCON
      IL = IHMCON(KK)
      GR(KK) = 0.0D+00
      DO 80 II=1,NCI
         CI(II,IP+KK) = 0.0D+00
         DO 70 JJ=1,IP
      CI(II,IP+KK) = CI(II,IP+KK) +
     *     EF(JJ,IL)*(AB(II,JJ)-EL(IL)*CI(II,JJ))
   70    CONTINUE
         GR(KK) = GR(KK) + (CI(II,IP+KK)*CI(II,IP+KK))
   80 CONTINUE
      GR(KK) = SQRT(GR(KK))
      IF(SOME) THEN
         WRITE(IW,9050) ITER,EL(IL)+ECONST,GR(KK),ECORR
         CALL FLSHBF(IW)
      END IF
 4588 CONTINUE
C
      IF (ECORR.GT.0.0D0) ECORR = 0.0D0
C
      IF (SOME.AND.NTCON.GT.1) WRITE(IW,*)
      IF (ITER.EQ.NITER) THEN
         CALL TRAN(CI,NCI,MAXW1,EF,IP,EC,KST)
         GOTO 9890
      ENDIF
C
C     CHECK FOR CONVERGENCE OF ANY STATE, IF CONVERGED, TRANSFORM
C     ALL IP VECTORS IN CI AND AB, MODIFY IHMCON AND NTCON.
C     START WITH  IP = KST AGAIN.
C
      NUMC = 0
      DO 4255 II=1,NTCON
         IWRK2(II) = IHMCON(II)
 4255 CONTINUE
      DO 4522 KK=1,NTCON
      IL = IHMCON(KK)
      IF (GR(KK).LE.CRIT) THEN
         IF(SOME) WRITE(IW,9060) IL,EL(IL)+ECONST,IPXT
         DO 3233 II=KK-NUMC,NTCON-NUMC
         IWRK2(II) = IWRK2(II+1)
 3233    CONTINUE
         NUMC = NUMC + 1
      ENDIF
 4522 CONTINUE
C
      IF (NUMC.GT.0) THEN
         CALL TRAN(CI,NCI,MAXW1,EF,IP,EC,KST)
         CALL TRAN(AB,NCI,MAXW1,EF,IP,EC,KST)
         NTCON = NTCON - NUMC
         DO II=1,NTCON
            IHMCON(II) = IWRK2(II)
         ENDDO
         DO 74 II=1,MAXP
            DO 75 JJ=1,MAXP
               EF(II,JJ) = 0.0D+00
               EC(II,JJ) = 0.0D+00
   75       CONTINUE
            EF(II,II) = 1.0D+00
            EC(II,II) = 1.0D+00
   74    CONTINUE
         IP = KST
         IF (NTCON.NE.0) GOTO 333
         IF(SOME) WRITE(IW,*) 'ALL STATES CONVERGED.'
C
         CALL  FCCSPIN(NA,NB,IACON1,IACON2,IBCON1,IBCON2,
     *      ISD,IDO,CI,AB,K,NCI,SPIN,IWRK1,IWRK2,MAXW1,
     *           LGCOM,NAST,NBST,LSYMA,LSYMB,
     *           LSBS,LSBC,LSPA,LSPB,LDISB,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           X,NX,LANDET,LBNDET,
     *           ITGA,ITGB,IAST,IBST,KTAB,NSYM)
C
C  WORK OUT WEIGHT OF EXTERNAL DETERMINANTS
C       = <PHI(SD)|PHI(SD)> = SUM(i=EXTERNAL SD DETS), CI(i)*CI(i)
C
         WREF = 0.0D0
         WEXT = 0.0D0
         DO II=1,NCREF
            WREF = WREF + CI(IREFDE(II),1)*CI(IREFDE(II),1)
         ENDDO
         WEXT = 1.0D0 - WREF
C
         RETURN
      ENDIF
C
      DO 68 JJ=IP+1,IP+NTCON
         IL = IHMCON(JJ-IP)
         DO 63 II=1,NCI
            CI(II,JJ) = CI(II,JJ)/(EL(IL) - Q(II))
   63    CONTINUE
   68 CONTINUE
C
C  IF MS=0, IMPOSE RESTRICTION ON THE CI COEFFICIENTS.
C
      IF (NA.EQ.NB) THEN
      DO 1111 IGA=1,ITGA
         DO 1122 KKA=NAST(IGA)+1,NAST(IGA+1)
            JPZA1 = LSPA(KKA)
            JASYM = LSYMA(KKA)
            KSYM=KTAB(JASYM)
C
            DO 1133 IGB=1,IGA
            IF (LGCOM(IGB,IGA).NE.1) GOTO 1133
            ICC1 = JPZA1 + LDISB(KSYM,IGB,IGA)
            ICC2 = LDISB(JASYM,IGA,IGB) + LSPB(KKA)
            NIBS=NBST(IGB)
            DO 1144 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
               IBPOS = LSBC(KKB) + NIBS
               IF (IBPOS.GT.KKA) GOTO 1122
               ICI1 = ICC1+LSPB(IBPOS)
               IF (IBPOS.EQ.KKA) THEN
                  DO 3232 KJ=1,NTCON
                  NV=IHMCON(KJ)
                  IPS = (IWRK1(NV)/2)
                  IF ((IPS+IPS).NE.IWRK1(NV)) CI(ICI1,KJ+IP) = 0.0D+00
 3232             CONTINUE
                  GOTO 1122
               ENDIF
               ICI2 = LSPA(IBPOS) + ICC2
               DO 3331 KJ=1,NTCON
               NV = IHMCON(KJ)
               IS = (-1)**IWRK1(NV)
               CI(ICI2,KJ+IP) = IS*CI(ICI1,KJ+IP)
 3331          CONTINUE
 1144       CONTINUE
 1133       CONTINUE
 1122    CONTINUE
 1111 CONTINUE
      ENDIF
C
C   MAKE THE NEW VECTORS (IP+1 -> IP+NTCON).
C
C    ASSUME THE NEW VECTORS ARE BI, HAVE TO ORTHOGONALIZE
C    THESE VECTORS TO ALL OTHERS AND THEN RENORMALIZE.
C
      DO 97 KK=IP+1,IP+NTCON
         SPIN(KK) = SPIN(IHMCON(KK-IP))
         DO 86 II=1,KK-1
            ROV = 0.0D+00
            DO 81 JJ=1,NCI
               ROV = ROV + CI(JJ,KK)*CI(JJ,II)
   81       CONTINUE
            DO 90 JJ=1,NCI
              CI(JJ,KK) = CI(JJ,KK) - ROV*CI(JJ,II)
   90       CONTINUE
   86    CONTINUE
C
         RNOR = 0.0D+00
         DO 40 II=1,NCI
            RNOR = RNOR + CI(II,KK)*CI(II,KK)
   40    CONTINUE
         RNOR = SQRT(RNOR)
         DO 42 II=1,NCI
            CI(II,KK) = CI(II,KK)/RNOR
   42    CONTINUE
   97 CONTINUE
C
      IP = IP + 1
C
C   ADD NEW GVAL*ECORR INTO EXTERNAL DIAGONAL ELEMENTS AND OLD AB ELEMENTS
C   HAVE TO REMOVE THE OLD GVAL*ECORR
C
      IF (CEPA.EQ.ARTQ) THEN
         CREF0 = 0.0D0
         DO II=1,IP-1
            CREF0 = CREF0 + CI(1,II)*EC(II,1)
         ENDDO
         GVAL = ABS(CREF0)
      ENDIF
C
      CORRE = GVAL*ECORR
      CDIFF = CORRE - COOLD
      DO II=1,NCI
         Q(II) = Q(II) + CDIFF
         DO JJ=1,IP-1
            AB(II,JJ) = AB(II,JJ) + CI(II,JJ)*CDIFF
         ENDDO
      ENDDO
      DO II=1,NCREF
         Q(IREFDE(II)) = Q(IREFDE(II)) - CDIFF
         DO JJ=1,IP-1
            AB(IREFDE(II),JJ) =
     *      AB(IREFDE(II),JJ) - CI(IREFDE(II),JJ)*CDIFF
         ENDDO
      ENDDO
C
C     NOW TO RETURN THE NEW PART OF AB
C
      IF (NA.EQ.NB) THEN
      IF (KST.GT.1) THEN
      CALL FCHC0YS(SI1,SI2,INDEX,NACT,NA,NB,CI(1,IP),AB(1,IP),
     *           NTCON,Q,NCI,X,NX,
     *           IACON1,IACON2,IBCON1,IBCON2,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           NSYM,IOB,LGMUL,KTAB,
     *           LANDET,LBNDET,NAST,NBST,LSYMA,LGCOM,
     *           LSPA,LSPB,LDISB,LSBS,LSBC,
     *           ITGA,ITGB,IAST,IBST,
     *           IPOSA,IPERA,IIND1,IGROA,IMMC,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,
     *           IWRK1,IWRK2)
      ELSE
      CALL FCHC01S(SI1,SI2,INDEX,NACT,NA,NB,CI(1,IP),AB(1,IP),
     *           Q,NCI,X,NX,
     *           IACON1,IACON2,IBCON1,IBCON2,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           NSYM,IOB,LGMUL,KTAB,
     *           LANDET,LBNDET,NAST,NBST,LSYMA,LGCOM,
     *           LSPA,LSPB,LDISB,LSBS,LSBC,
     *           ITGA,ITGB,IAST,IBST,
     *           IPOSA,IPERA,IIND1,IGROA,IMMC,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,IDIM1,IDIM2,
     *           IWRK1,IWRK2)
      ENDIF
C
      ELSE
C
      IF (KST.GT.1) THEN
      CALL FCHCXYS(SI1,SI2,INDEX,NACT,NA,NB,CI(1,IP),AB(1,IP),
     *           NTCON,Q,NCI,X,NX,
     *           IACON1,IACON2,IBCON1,IBCON2,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           NSYM,IOB,LGMUL,KTAB,
     *           LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *           LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,LSBC,
     *           ITGA,ITGB,IAST,IBST,
     *           IPOSA,IPERA,IIND1,IGROA,IMMC,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST)
      ELSE
      CALL FCHCX1S(SI1,SI2,INDEX,NACT,NA,NB,CI(1,IP),AB(1,IP),
     *           Q,NCI,X,NX,
     *           IACON1,IACON2,IBCON1,IBCON2,
     *           LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *           NSYM,IOB,LGMUL,KTAB,
     *           LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *           LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,LSBC,
     *           ITGA,ITGB,IAST,IBST,
     *           IPOSA,IPERA,IIND1,IGROA,IMMC,
     *           NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST)
      ENDIF
      ENDIF
C
      IP = IP + NTCON - 1
C
      COOLD = CORRE
C
C  MAKE THE NEW MATRIX ELEMENTS BETWEEN THE CI VECTORS.
C
      IX = 0
      DO 103 II=1,IP
          DO 102 JJ=1,II
          IX = IX + 1
            F(IX) = 0.0D+00
            DO 115 KK=1,NCI
               F(IX) = F(IX) + CI(KK,II)*AB(KK,JJ)
  115       CONTINUE
  102    CONTINUE
  103 CONTINUE
C
C  DIAGONALIZE SMALL MATRIX
C
      CALL EVVRSP(-1,IP,IP,(IP*(IP+1))/2,MAXW1
     *              ,F,B,IWRK2,EL,EF,0,IERR)
      IF (IERR.NE.0) THEN
         IF(SOME) THEN
            WRITE(IW,*) 'ERROR IN SMALL DIAGONALIZATION'
            WRITE(IW,*) IERR
         END IF
         RETURN
      ENDIF
C
C   CHECK TO SEE IF ANY STATES HAVE SKIPPED IN
C
      DO 700 IJK=1,KST
         DO 705 II=1,NTCON
            IF (IJK.EQ.IHMCON(II)) GOTO 700
  705    CONTINUE
         IDXC = 0
         POV = 0.0D+00
         DO 713 JJ=1,KST
            UIT = 0.0D+00
            DO 715 KK=1,IP
               UIT = UIT + EF(KK,JJ)*EC(KK,IJK)
  715       CONTINUE
            POV = ABS(UIT)
            IDXC = JJ
  713    CONTINUE
         DO 720 II=1,NTCON
            IF (JJ.EQ.IHMCON(II)) THEN
               IHMCON(II) = IJK
               GOTO 700
            ENDIF
  720    CONTINUE
  700 CONTINUE
C
C  CHECK TO SEE WHERE THE SPINS OCCUR NOW
C
      IF (NA.EQ.NB) THEN
C
      DO 800 II=1,IP
         POV = 0.0D+00
         DO 813 JJ=1,IP
            UIT = 0.0D+00
            DO 823 KK=1,IP
               UIT = UIT + EF(KK,II)*EC(KK,JJ)
  823       CONTINUE
            IF (ABS(UIT).GT.POV) THEN
               POV = ABS(UIT)
               IDXC = JJ
            ENDIF
  813    CONTINUE
         IF (IDXC.NE.II) THEN
            GR(II) = SPIN(IDXC)
         ELSE
            GR(II) = SPIN(II)
         ENDIF
800   CONTINUE
C
      DO 786 KK=1,IP
         SPIN(KK) = GR(KK)
  786 CONTINUE
C
      ENDIF
C
C  CHECK TO SEE WHERE THE CONVERGED STATES ARE NOW.
C
      NCON = 0
      DO 805 II=1,K
         DO 850 JJ=1,NTCON
            IF (II.EQ.IHMCON(JJ)) GOTO 805
  850    CONTINUE
         DO 852 JJ=1,IP
            UIT = 0.0D+00
            DO 853 KK=1,IP
               UIT = UIT + EF(KK,JJ)*EC(KK,II)
  853       CONTINUE
            IF (ABS(UIT).GT.0.6D+00) THEN
               NCON = NCON + 1
               IWRK1(NCON) = JJ
               GOTO 805
            ENDIF
  852    CONTINUE
C
  805 CONTINUE
C
      NTCON1 = 0
      DO 860 II=1,K
         DO 864 JJ=1,NCON
            IF (II.EQ.IWRK1(JJ)) GOTO 860
  864    CONTINUE
         NTCON1 = NTCON1 + 1
         IHMCON(NTCON1) = II
  860 CONTINUE
C
      IF (NTCON1.NE.NTCON) THEN
         IF(SOME) THEN
            WRITE(6,*)
            WRITE(6,*) 'CONVERGED STATES HAVE SKIPPED OUT'
            WRITE(6,*) 'NUMBER OF UNCONVERGED STATES NOW = ',NTCON1
         END IF
         NTCON = NTCON1
      ENDIF
C
C   END OF CHECK
C
      DO 543 II=1,KST
         IWRK1(II) = INT(SPIN(II) + 0.3D+00)
  543 CONTINUE
C
      DO 55 II=1,IP
         DO 66  JJ=1,IP
            EC(II,JJ) = EF(II,JJ)
   66    CONTINUE
   55 CONTINUE
C
 1315 CONTINUE
C
 9890 CONTINUE
C
      IF (SOME) WRITE(IW,9080) IL
C
      CALL  FCCSPIN(NA,NB,IACON1,IACON2,IBCON1,IBCON2,
     *   ISD,IDO,CI,AB,KST,NCI,SPIN,IWRK1,IWRK2,MAXW1,
     *        LGCOM,NAST,NBST,LSYMA,LSYMB,
     *        LSBS,LSBC,LSPA,LSPB,LDISB,
     *        LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *        X,NX,LANDET,LBNDET,
     *        ITGA,ITGB,IAST,IBST,KTAB,NSYM)
      ISTAT=1
C
      RETURN
C
 9005 FORMAT(/1X,'ERROR, NUMBER OF VECTORS STORED=',I5,
     *           ' NOT EQUAL TO NCI=',I5/
     *        1X,'THIS MAY BE DUE TO A GARBAGE -CIVECTR- FILE',
     *           ' LEFT OVER FROM AN EARLIER RUN.')
 9007 FORMAT(/1X,'INITIAL ORMAS VECTORS READ FROM DISK')
 9010 FORMAT(/1X,'INITIAL ORMAS VECTOR GUESS TIME :',F13.1)
 9013 FORMAT(1X,'ORMAS SPIN CALCULATION TIME     :',F13.1)
 9014 FORMAT(/1X,'INITIAL GUESS SPINS = ',20F5.1)
 9015 FORMAT(1X,'SETTING UP CALCULATION TIME     :',F13.1)
 9016 FORMAT(/1X,'ERROR ON THE SIDE OF CAUTION FOR MALMQVIST.',
     *        1X,'MOST OF THE TIME, TWO STATES IS NOT TOO MUCH',
     *        1X,'BURDEN.',
     *       /1X,'STATE OUT OF IWTSMQ CANNOT BE MAXP.')
 9017 FORMAT(/1X,'INITIAL CORRELATION ENERGY = ',F20.10)
 9018 FORMAT(1X,'SINCE ECORR > 0, ECORR WILL BE SET TO ZERO')
 9020 FORMAT(/1X,'INITIAL ORMAS CI ITERATION TIME :',F13.1)
 9040 FORMAT(/1X,'ITERATION',6X,'ENERGY',11X,'GRADIENT',8X,'E(CORR)')
 9050 FORMAT(1X,I5,F20.10,F15.8,F18.10)
 9060 FORMAT(/1X,'CONVERGED STATE',I5,' ENERGY=',F20.10,' IN',
     *           I5,' ITERS'/)
 9080 FORMAT(1X,'DETERMINANT ORMAS CI FAILED TO CONVERGE',I4,
     *          ' OF THE ROOTS.')
      END
C
C*MODULE CEPA  *DECK CEPDM2
C> @brief      Computes 1e- and 2e- CEPA density matrices
C>
C> @author     Joe Ivanic
C>             -2014
C>
C> @details    Literally computes 1e- and 2e- CEPA density matrices
C>             For a good review of the SR and MR-CEPA methods computed in this
C>             module see:
C>             P.G. Szalay, in Modern Ideas in Coupled-Cluster Methods,
C>             R. J. Bartlett (ed), World Scientific, Singapore (1997), pp 81-123.
C>
C>             The CEPA computation is similar to CISD/MRCISD except that an
C>             energy correction is added to the Hamiltonian diagonal elements
C>             corresponding to only external determinants. The CEPA iterations
C>             are similar to CISD/MRCISD iterations, as such, the CEPA
C>             iterations programmed here use underlying ORMAS functionalities.
C>             For more on the ORMAS method see:
C>             Joseph Ivanic, Journal of Chemical Physics, 9364, V. 119, (2003).
C>             Joseph Ivanic, Journal of Chemical Physics, 9376, V. 119, (2003).
C>
C> @param      IW       Output file number.
C> @param      NPRINT   Governs amount of printing.
C> @param      IWTS     Stores integer list of states to be state-averaged over.
C> @param      WSTATE   Stores weights of states in state averaging.
C> @param      SPINS    Stores spins of states.
C> @param      IPURES   PURES keyword in $CIDET/DET. PURES=.true. same as IPURES=1.
C> @param      S        If IPURES=1 then the spin to be used.
C> @param      K        Number of states.
C> @param      GRPDET   Point group being used.
C> @param      NCORSV   Denotes the number of MCSCF core orbitals.
C> @param      DM1      One-electron density.
C> @param      DM2      Two-electron density.
C> @param      M2       Length of one-electron density.
C> @param      M4       Length of two-electron density.
C> @param      NACT     Number of active orbitals.
C> @param      NCI      Number of determinants.
C> @param      NA       Number of alpha electrons.
C> @param      NB       Number of beta electrons.
C> @param      CI       Stores CI vectors.
C> @param      AB       Scratch storage.
C> @param      Y        Stores binomial coefficients.
C> @param      NX       Length of Y.
C> @param      INDEX    Integral position array.
C> @param      NSYM     Number of symmetry labels.
C> @param      IOB      Stores irreps of the orbitals.
C> @param      LBOX1 -> LBOX5  Scratch storage of electron space occupations.
C> @param      LGMUL    Symmetry multiplication table.
C> @param      KTAB     Stores symmetry-opposite element.
C> @param      IACON1 -> IBCON2 Scratch orbital occupation data.
C> @param      LANDET -> IDIM2 String symmetry data.
C> @param      IDWEIGH  ID of ground state for dynamically determined weights.
C> @param      DWPARM   Dynamically weighted energy parameter.
C> @param      REFDM1   Reference 1-electron density.
C> @param      REFDM2   Reference 2-electron density.
C> @param      NREFA2   Length of REFDM1.
C> @param      NREFA4   Length of REFDM2.
C> @param      AEXT     Weight of external CEPA density.
C> @param      AREF     Weight of refernce CEPA density.
C>
      SUBROUTINE CEPDM2(IW,NPRINT,IWTS,WSTATE,SPINS,IPURES,S,K,GRPDET,
     *     NCORSV,
     *     DM1,DM2,M2,M4,NACT,NCI,NA,NB,CI,AB,
     *     Y,NX,INDEX,NSYM,IOB,
     *     LBOX1,LBOX2,LBOX3,LBOX4,LBOX5,
     *     LGMUL,KTAB,IACON1,IACON2,IBCON1,IBCON2,
     *     LANDET,LBNDET,NAST,NBST,LSYMA,LSYMB,LGCOM,
     *     LSPA,LSPB,LDISB,LSAS,LSBS,LSAC,LSBC,
     *     ITGA,ITGB,IAST,IBST,
     *     IPOSA,IPERA,IIND1,IGROA,IMMC,
     *     NB1EX,JB1GR,JB1PE,JB1IN,JB1PO,JB1ST,IDIM1,IDIM2,IDWEIGH,
     *     DWPARM,
     *     REFDM1,REFDM2,NREFA2,NREFA4,AEXT,AREF)
C     ----------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL SOME,GOPARR,DSKWRK,MASWRK,FDIRCT,QCORR,PACK2E
C
      PARAMETER (MXRT=100, MXATM=2000)
      PARAMETER (ZERO=0.0D+00)
C
      COMMON /CIFILS/ NFT11,NFT12,NFT13,NFT14,NFT15,NFT16,IDAF20,NEMEMX
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,STOT,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FCCWFN/ NSPACE,MSTA(51),MNUM(51),MINI(51),MAXI(51),
     *                IAMI(51),IAMA(51),IBMI(51),IBMA(51),IDIM(51),
     *                LBST(51),NREF0,FDIRCT,QCORR,C0SQ
      COMMON /FUNCT / E,EGRAD(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,MA,MB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /FMCOM / X(1)
      COMMON /OUTPUT/ NPRINTX,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C
      DIMENSION IWTS(MXRT),WSTATE(MXRT),SPINS(MXRT)
      DIMENSION DM1(M2),DM2(M4)
      DIMENSION CI(NCI,K),AB(NCI,K),Y(NX)
      DIMENSION INDEX((NACT*(NACT+1))/2+1),IOB(NACT)
      DIMENSION LBOX1(NSPACE),LBOX2(NSPACE),LBOX3(NSPACE)
      DIMENSION LBOX4(NSPACE),LBOX5(NSPACE)
      DIMENSION LGMUL(NSYM,NSYM),KTAB(NSYM)
      DIMENSION IACON1(NA),IACON2(NA),IBCON1(NA),IBCON2(NA)
      DIMENSION LANDET(NSPACE,ITGA),LBNDET(NSPACE,ITGB)
      DIMENSION NAST(ITGA+1),NBST(ITGB+1)
      DIMENSION LSYMA(IAST),LSYMB(IBST),LGCOM(ITGB,ITGA)
      DIMENSION LSPA(IAST),LSPB(IBST),LDISB(NSYM,ITGB,ITGA)
      DIMENSION LSAS(NSYM+1,ITGA),LSBS(NSYM+1,ITGB)
      DIMENSION LSAC(IAST),LSBC(IBST)
      DIMENSION IPOSA(NA*(NACT-NA),NSYM)
      DIMENSION IPERA(NA*(NACT-NA),NSYM)
      DIMENSION IIND1(NA*(NACT-NA),NSYM)
      DIMENSION IGROA(NA*(NACT-NA),NSYM)
      DIMENSION IMMC(NSYM)
      DIMENSION JB1GR(NB1EX),JB1PE(NB1EX),JB1IN(NB1EX),JB1PO(NB1EX)
      DIMENSION JB1ST(IDIM1,IDIM2)
      DIMENSION REFDM1(NREFA2),REFDM2(NREFA4)
C
      DATA CHECK/8HCHECK   /
C
C  ----  STATE-AVERAGED 1E- AND 2E- DENSITY MATRIX  ----
C
      L1 = NUM
      M1 = NACT
      NOCC1 = NCORSV + NACT
      NOCC2 = (NOCC1*NOCC1+NOCC1)/2
      SOME = MASWRK  .AND.  NPRINT.NE.-5
      IF(SOME) WRITE(IW,9310)
C
      MXSTAT=0
      MXNZW=0
C
      DO 100 I=MXRT,1,-1
         IF(WSTATE(I).GT.ZERO) THEN
            IF(MXSTAT.EQ.0) MXSTAT=I
            MXNZW=MXNZW+1
         END IF
  100 CONTINUE
C
      IF(MXSTAT.EQ.0) THEN
         IF(SOME) THEN
          WRITE(IW,*) 'OOPS, IN -MASDM2-, SOMETHING HAPPENED TO WSTATE'
         END IF
         CALL ABRT
      END IF
C
      IF (SOME) WRITE(IW,9320) MXNZW
C
C        SET STATE AVERAGED ENERGY, PRINT ROOT INFORMATION
C
      NXTR=0
      DO 110 IDWREF=1,K
         IF(IPURES.EQ.1  .AND.  ABS(SPINS(IDWREF)-S).GT.0.03D+00)
     *        GO TO 110
         NXTR=NXTR+1
         IF(NXTR.EQ.IDWEIGH.AND.WSTATE(NXTR).GT.ZERO)THEN
            IF(SOME)WRITE(IW,9330)IDWREF,DWPARM
            GOTO 120
         END IF
 110  CONTINUE
 120  CONTINUE
      E = ZERO
      NXTR=0
      DO 310 IST=1,K
         IF(IPURES.EQ.1  .AND.  ABS(SPINS(IST)-S).GT.0.03D+00) GO TO 310
         NXTR=NXTR+1
         IF(WSTATE(NXTR).GT.ZERO) THEN
            E = E + WSTATE(NXTR) * ESTATE(IST)
            IF(SOME) WRITE(IW,9340) IST,ESTATE(IST),
     *                              WSTATE(NXTR),SPINS(IST)
         END IF
         IF(NXTR.GT.MXSTAT) GO TO 320
  310 CONTINUE
C
C        CROAK THE JOB IF WE DIDN'T CALCULATE ENOUGH ROOTS WITH THE
C        DESIRED SPIN MULTIPLICITY DURING THE CI DIAGONALIZATION.
C        IF THIS HAPPENS ON THE 1ST MCSCF ITER, WE'VE ALREADY GOT
C        THE CI EXPANSIONS PRINTED OUT, AND SHOULD NOT REPEAT IT.
C
      IF(NXTR.LT.MXSTAT) THEN
         IF(MASWRK) WRITE(IW,9350) NXTR,S,MXSTAT
         IF(MASWRK  .AND.  .NOT.SOME) CALL ORMPRT(IW,NFT12,MASWRK)
         IF(GOPARR) CALL DDI_SYNC(9205)
         CALL ABRT
      END IF
C
  320 CONTINUE
C
C  COPY CI COEFFICIENTS FOR ALL STATES WITH NON-ZERO WEIGHTS INTO AB
C
      NXTW=1
      NXTR=0
      DO 620 IST=1,K
         IF (IPURES.EQ.1) THEN
            IF (ABS(SPINS(IST)-S).GT.0.03D+00) GO TO 620
            NXTR=NXTR+1
         ELSE
            NXTR=IST
         ENDIF
C
         IF (NXTR.EQ.IWTS(NXTW)) THEN
            CALL CICOPY(CI(1,IST),AB(1,NXTW),NCI)
            NXTW = NXTW + 1
         ENDIF
  620 CONTINUE
      NXTW = NXTW - 1
C
      DO II=1,M2
         DM1(II) = 0.0D+00
      ENDDO
      DO II=1,M4
         DM2(II) = 0.0D+00
      ENDDO
C
      IF(EXETYP.EQ.CHECK) GO TO 9000
C
C  ---------  NOW TO DETERMINE STATE AVERAGED DENSITY MATRICES ---------
C
C  --- BIG LOOP OVER ALL ALPHA STRINGS. ---
C
      IF (GOPARR) THEN
         CALL DDI_DLBRESET()
         CALL DDI_DLBNEXT(MY_TASK)
      ENDIF
C
      CALL RESETCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5)
C
      DO 5000 IGA=1,ITGA
C
         CALL RESETDE(LBOX1,NSPACE,NA,MSTA,IACON1)
C
C  KKA GIVES THE ACTUAL POSITION OF THE ALPHA STRING IACON1 IN
C  THE FULL ALPHA STRING LIST.
C
         DO 4900 KKA=NAST(IGA)+1,NAST(IGA+1)
            IF (GOPARR.AND.KKA-1.NE.MY_TASK) GOTO 4899
            JPZA1 = LSPA(KKA)
            JASYM = LSYMA(KKA)
            KSYM=KTAB(JASYM)
            DO II=1,NSYM
               IMMC(II)=0
            ENDDO
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEAS = NA+1
            DO 4890 ISPA1=NSPACE,1,-1
               IOC1 = LBOX1(ISPA1)
               IEAE = IEAS - 1
               IEAS = IEAS - IOC1
               IF (IOC1.EQ.0) GO TO 4890
               LBOX2(ISPA1) = LBOX2(ISPA1)-1
C
C  LOOP ELECTRONS IN SPACE ISPA1.
C  IEAS, IEAE ARE THE ELECTRONS IN SPACE ISPA1.
C
               DO 4885 IA1=IEAE,IEAS,-1
                  IO1 = IACON1(IA1)
                  IGAE = IEAE - LBOX1(ISPA1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 4880 ISPA2=ISPA1,NSPACE
C
C  IGAS, IGAE ARE ELECTRONS SPECIFYING ISPA2 SPACE ELECTRON LIMITS.
C
                  IGAS = IGAE + 1
                  IGAE = IGAE + LBOX1(ISPA2)
C
                  LBOX2(ISPA2) = LBOX2(ISPA2) + 1
                  IF (LBOX2(ISPA1).LT.IAMI(ISPA1)) GO TO 4870
C
C  MAKE GAP INFORMATION HERE.
C
                  IGAA = MAX(IA1+1,IGAS)
                  IF (LBOX1(ISPA2).EQ.0) THEN
                     ISTA = MSTA(ISPA2)
                     IEND = MSTA(ISPA2+1)-1
                  ELSEIF (ISPA2.EQ.ISPA1) THEN
                     ISTA = IO1+1
                     IEND = IACON1(IGAA)-1
                     IF (IA1.EQ.IEAE) IEND=MSTA(ISPA1+1)-1
                  ELSE
                     ISTA = MSTA(ISPA2)
                     IEND = IACON1(IGAA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 4860 IGAP=IGAA,IGAE+1
C
                     DO 4850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IP1 = LGMUL(IS1,IS2)
C
                     IND = INDEX(JJ) + IO1
C
              CALL REDE00(IACON1,IACON2,NA,IA1,IGAP-1,JJ,JPERA)
              IF (LBOX2(ISPA2).GT.IAMA(ISPA2)) GO TO 4800
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX2,IGA2)
           NIAS = NAST(IGA2)
C
              CALL IDPOST(IACON2,NA,LBOX2,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LANDET(1,IGA2),IBCON1,JPOSA)
              KAPOS = JPOSA + NIAS
              JPZA2 = LSPA(KAPOS)
              KASYM = LSYMA(KAPOS)
              KPER1 = ((-1)**JPERA)*2
              IMMC(KASYM) = IMMC(KASYM) + 1
              JSPO = IMMC(KASYM)
              IPOSA(JSPO,KASYM) = JPZA2
              IPERA(JSPO,KASYM) = KPER1
              IIND1(JSPO,KASYM) = IND
              IGROA(JSPO,KASYM) = IGA2
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP TO DOUBLES.
C
              IF (IS1.NE.IS2) GO TO 4800
C
C  LOOP OVER APPROPRIATE BETA DETS AND UPDATE THE 1E DM1
C
              DO 1700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 1700
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              DO 1680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
                 ENDDO
                 FC = FC*KPER1
                 DM1(IND) = DM1(IND) + FC
 1680         CONTINUE
C
 1700         CONTINUE
C
C   DETERMINE THE ALPHA STRING CONTRIBUTION TO THE MATRIX ELEMENT.
C
              DO 4712 IK=1,NA
                 IF (IK.EQ.IA1) GO TO 4712
                 ION = IACON1(IK)
                 J1 = INDEX(ION+1)
                 JMA = MAX(J1,IND)
                 JMI = MIN(J1,IND)
                 JJ1 = INDEX(JMA) + JMI
                 JMA = MAX(ION,JJ)
                 JMI = MIN(ION,JJ)
                 J1 = INDEX(JMA)+JMI
                 JMA = MAX(IO1,ION)
                 JMI = MIN(IO1,ION)
                 J2 = INDEX(JMA)+JMI
                 JMA = MAX(J1,J2)
                 JMI = MIN(J1,J2)
                 INX = INDEX(JMA)+JMI
C
C  LOOP OVER APPROPRIATE BETA DETS AND UPDATE THE 1E DM2
C
              DO 1705 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 1705
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              DO 1685 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
                 ENDDO
                 FC = FC*KPER1
                 DM2(JJ1) = DM2(JJ1) + FC
                 DM2(INX) = DM2(INX) - FC
 1685         CONTINUE
C
 1705         CONTINUE
C
 4712         CONTINUE
C
C  LOOP OVER BETA DETS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4)
C
              DO 4700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA2).NE.1) GOTO 4690
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI2 = JPZA2 + LDISB(KSYM,IGB,IGA2)
C
              CALL RESETDE(LBOX3,NSPACE,NB,MSTA,IBCON1)
              ISTB = 1
              DO 4680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 IENB = LSBC(KKB)
                 DO IIZ=ISTB,IENB-1
                    CALL MOVEUP2(LBOX3,NSPACE,NB,MSTA,IBCON1)
                 ENDDO
                 ISTB = IENB
                 JCI1 = JCI1 + 1
                 JCI2 = JCI2 + 1
C
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
                 ENDDO
                 FC = FC*KPER1
C
                 DO 4670 IK=1,NB
                    ION = IBCON1(IK)
                    J1 = INDEX(ION+1)
                    JMA = MAX(J1,IND)
                    JMI = MIN(J1,IND)
                    JJ1 = INDEX(JMA) + JMI
                    DM2(JJ1) = DM2(JJ1) + FC
 4670            CONTINUE
C
 4680         CONTINUE
C
 4690         CALL PUSHCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4,IEND)
 4700         CONTINUE
C
C --  DOUBLE ALPHA EXCITATIONS START HERE  ---
C
 4800         CONTINUE
C
            IF (IA1.EQ.NA) GOTO 4850
            IF (JJ.EQ.NACT) GOTO 4850
C
            DO II=1,NSPACE
               LBOX3(II) = LBOX2(II)
            ENDDO
            IAES3 = 1
            DO KK=1,ISPA1-1
               IAES3 = IAES3 + LBOX2(KK)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRONS FROM, MUST BE GE THAN
C  SPACE OF FIRST EXCITATION, ISPA1.
C
            DO 3890 ISPA3 = ISPA1,NSPACE
               IF (LBOX1(ISPA3).EQ.0) GOTO 3887
               IF (ISPA3.EQ.ISPA1.AND.IA1.EQ.IEAE) GOTO 3887
               IOC3 = LBOX2(ISPA3)
               IF (IOC3.EQ.0) GOTO 3887
C
               IAEE3 = IAES3 + LBOX2(ISPA3)-1
               LBOX3(ISPA3) = LBOX3(ISPA3)-1
C
C  LOOP OVER ELECTRONS IN ISPA3, WHICH ARE LARGER THAN IA1,
C  MAKING SURE IT ISN'T THE ALREADY EXCITED ELECTRON.
C
               JSTA3 = IAES3
               IF (ISPA3.EQ.ISPA1) THEN
                  JSTA3=IA1
                  IF (IGAP-1.EQ.IA1) JSTA3=JSTA3+1
               ENDIF
C
               DO 3880 IA3=JSTA3,IAEE3
                  IF (IA3.EQ.IGAP-1) GOTO 3880
                  IO3 = IACON2(IA3)
                  IS3 = IOB(IO3)
C
C  LOOP OVER SPACES TO EXCITE ELECTRON INTO.  MUST BE GE THAN
C  SPACE FIRST ELECTRON WAS EXCITED INTO.
C
                  IGAE3 = 0
                  DO JIK=1,ISPA2-1
                     IGAE3 = IGAE3 + LBOX2(JIK)
                  ENDDO
                  DO 3850 ISPA4=ISPA2,NSPACE
C
C  IGAS3, IGAE3 ARE ELECTRONS SPECIFYING ISPA4 SPACE ELECTRON LIMITS.
C
                  LBOX3(ISPA4) = LBOX3(ISPA4) + 1
                  IGAS3 = IGAE3 + 1
                  IGAE3 = IGAE3 + LBOX2(ISPA4)
                  IF (LBOX3(ISPA3).LT.IAMI(ISPA3)) GOTO 3840
                  IF (LBOX3(ISPA4).GT.IAMA(ISPA4)) GOTO 3840
                  IF (LBOX3(ISPA2).LT.IAMI(ISPA2)) GOTO 3840
                  IF (LBOX3(ISPA2).GT.IAMA(ISPA2)) GOTO 3840
C
             IF (ISPA4.EQ.ISPA2.AND.JJ.EQ.MSTA(ISPA2+1)-1) GOTO 3840
C
C  GET GROUP NUMBER
C
               CALL POSITCO(LBOX5,NSPACE,NA,IAMA,IAMI,LBOX4,LBOX3,IGA3)
               NIAS3 = NAST(IGA3)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGAA3 = MAX(IGAS3,IGAP)
C
                  IF (LBOX2(ISPA4).EQ.0) THEN
                     ISTA3 = MSTA(ISPA4)
                     IEND3 = MSTA(ISPA4+1)-1
                  ELSEIF (ISPA4.EQ.ISPA2) THEN
                     ISTA3 = JJ+1
                     IEND3 = IACON2(IGAA3)-1
C
C  I AM SUSPECT ABOUT THIS NEXT LINE, WE'LL SEE WHAT HAPPENS.......
C
                     IF (IGAP-1.EQ.IGAE3) IEND3=MSTA(ISPA2+1)-1
C
                  ELSE
                     ISTA3 = MSTA(ISPA4)
                     IEND3 = IACON2(IGAA3)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 3830 IGAP3=IGAA3,IGAE3+1
C
                     DO 3820 JJ3=ISTA3,IEND3
                        IS4 = IOB(JJ3)
                        IP2 = LGMUL(IS3,IS4)
                        IF (IP1.NE.IP2) GOTO 3820
C
              CALL REDE00(IACON2,IBCON1,NA,IA3,IGAP3-1,JJ3,JPERA3)
              CALL IDPOST(IBCON1,NA,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LANDET(1,IGA3),IBCON2,JPOSA3)
              IPER3 = ((-1)**(JPERA3+JPERA))*2
              KAPOS3 = JPOSA3 + NIAS3
              JPZA3 = LSPA(KAPOS3)
                 JMA=MAX(JJ3,IO3)
                 JMI=MIN(JJ3,IO3)
                 I2 = INDEX(JMA) + JMI
                 INX = INDEX(I2) + IND
                 II1 = INDEX(JJ3) + IO1
                 JMA=MAX(IO3,JJ)
                 JMI=MIN(IO3,JJ)
                 II2 = INDEX(JMA) + JMI
                 JMA=MAX(II1,II2)
                 JMI=MIN(II1,II2)
                 INX2 = INDEX(JMA) + JMI
C
C  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 3700 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB,IGA3).NE.1) GOTO 3700
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
              JCI3 = JPZA3 + LDISB(KSYM,IGB,IGA3)
C
              DO 3680 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
                 JCI3 = JCI3 + 1
C
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI3,KKI)
                 ENDDO
                 FC = FC*IPER3
                 DM2(INX) = DM2(INX) + FC
                 DM2(INX2) = DM2(INX2) - FC
 3680         CONTINUE
C
 3700         CONTINUE
C
 3820                CONTINUE
C
                     ISTA3 = IACON2(IGAP3)+1
                     IEND3 = IACON2(IGAP3+1)-1
                     IF (IGAP3.EQ.IGAE3) IEND3=MSTA(ISPA4+1)-1
 3830             CONTINUE
C
 3840             LBOX3(ISPA4) = LBOX3(ISPA4) - 1
 3850             CONTINUE
C
 3880          CONTINUE
C
               LBOX3(ISPA3) = LBOX3(ISPA3)+1
 3887          IAES3 = IAES3 + LBOX3(ISPA3)
 3890       CONTINUE
C
 4850                CONTINUE
C
                  ISTA = IACON1(IGAP)+1
                  IEND = IACON1(IGAP+1)-1
                  IF (IGAP.EQ.IGAE) IEND=MSTA(ISPA2+1)-1
 4860             CONTINUE
C
 4870             LBOX2(ISPA2) = LBOX2(ISPA2) - 1
 4880          CONTINUE
C
 4885          CONTINUE
C
               LBOX2(ISPA1) = LBOX2(ISPA1)+1
 4890       CONTINUE
C
C  DIAGONAL ELEMENTS HERE
C
            DO 67 II=1,NA
               I1 = IACON1(II)
               IND1 = INDEX(I1+1)
C
C  LOOP OVER BETA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 3705 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 3705
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              DO 3685 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
C
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI1,KKI)
                 ENDDO
                 DM1(IND1) = DM1(IND1) + FC
 3685         CONTINUE
C
 3705         CONTINUE
C
              DO 64 JJ=II+1,NA
                 I2 = IACON1(JJ)
                 IND2 = INDEX(I2+1)
                 INDM = IND2 - I2 + I1
                 J1 = INDEX(INDM+1)
                 J2 = INDEX(IND2) + IND1
C
              DO 3710 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 3710
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              DO 3690 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 JCI1 = JCI1 + 1
C
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI1,KKI)
                 ENDDO
                 DM2(J1) = DM2(J1) - FC
                 DM2(J2) = DM2(J2) + FC
 3690         CONTINUE
C
 3710         CONTINUE
C
   64         CONTINUE
C
C  LOOP OVER BETA DETS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4)
C
              DO 4709 IGB=1,ITGB
              IF (LGCOM(IGB,IGA).NE.1) GOTO 4699
              JCI1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
              CALL RESETDE(LBOX3,NSPACE,NB,MSTA,IBCON1)
              ISTB = 1
              DO 4689 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                 IENB = LSBC(KKB)
                 DO IIZ=ISTB,IENB-1
                    CALL MOVEUP2(LBOX3,NSPACE,NB,MSTA,IBCON1)
                 ENDDO
                 ISTB = IENB
                 JCI1 = JCI1 + 1
C
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI1,KKI)
                 ENDDO
C
                 DO 4679 IK=1,NB
                    I2 = IBCON1(IK)
                    IND2 = INDEX(I2+1)
                    JMI = MIN(IND1,IND2)
                    JMA = MAX(IND1,IND2)
                    J2 = INDEX(JMA) + JMI
                    DM2(J2) = DM2(J2) + FC
 4679            CONTINUE
C
 4689         CONTINUE
C
 4699         CALL PUSHCO(LBOX3,NSPACE,NB,IBMA,IBMI,LBOX4,IEND)
 4709         CONTINUE
C
   67       CONTINUE
C
C  --- END OF LOOP OVER SINGLE ALPHA EXCITATIONS. ---
C      NOW TO SORT THEM BY POSITIONS WITHIN SYMMETRIES.
C
            DO II=1,NSYM
               CALL FCCSRT3(IGROA(1,II),IPERA(1,II),IIND1(1,II),
     *                   IPOSA(1,II),IMMC(II))
            ENDDO
C
C  --- END OF LOOP OVER PURE ALPHA EXCITATIONS.
C  NOW TO LOOP OVER ALL SIMULTANEOUS AB -> A'B' EXCITATIONS.
C
      IF (NSPACE.EQ.1) GOTO 3400
C
C  ***** GENERAL CASE OF MORE THAN ONE SPACE !!!!! *******
C
      IF (.NOT.FDIRCT) THEN
C
C  LOOP OVER SINGLE ALPHA EXCITES WITHIN EACH SYMMETRY.
C
      DO 3000 ISAE=1,NSYM
         KBSYM=KTAB(ISAE)
         DO 2900 JSAE=1,IMMC(ISAE)
            JPOSAE=IPOSA(JSAE,ISAE)
            JPERAE=IPERA(JSAE,ISAE)
            JINDAE=IIND1(JSAE,ISAE)
            JGROAE=IGROA(JSAE,ISAE)
C
C  IF ISAE.EQ.JASYM THEN SPECIAL CASE.
C
       IF (ISAE.EQ.JASYM.AND.IGA.EQ.JGROAE) THEN
C
C  LOOP OVER ALL RELEVANT BETAS
C
            LABPOS = JPZA1
            LABPOS2 = JPOSAE
            DO 2813 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 2813
               NIBS = NBST(IGB)
               DO 2763 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  LABPOS2 = LABPOS2 + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2613 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 2613
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
                  JCIB2=JPZA1+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
                  FC = 0.0D+00
                  FC1 = 0.0D+00
                 DO KKI=1,NXTW
           FC = FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
           FC1 = FC1 + WSTATE(IWTS(KKI))*AB(LABPOS2,KKI)*AB(JCIB2,KKI)
                 ENDDO
                  FC = FC*JPERAE*JB1PE(JBINDX)
                  FC1 = FC1*JPERAE*JB1PE(JBINDX)
                  DM2(IX) = DM2(IX) + FC + FC1
C
 2613          CONTINUE
C
 2763          CONTINUE
 2813       CONTINUE
C
       ELSE
C
C  LOOP OVER ALL RELEVANT (A-)BETA DETS.
C
            LABPOS = JPZA1
            DO 2800 IGB=1,ITGB
               IF (LGCOM(IGB,IGA).NE.1) GOTO 2800
               NIBS = NBST(IGB)
               DO 2750 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2600 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 2600
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB=JPOSAE+LDISB(KBSYM,IGB2,JGROAE)+JB1PO(JBINDX)
                  FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
                 ENDDO
                  FC = FC*JPERAE*JB1PE(JBINDX)
                  DM2(IX) = DM2(IX) + FC
C
 2600          CONTINUE
C
 2750          CONTINUE
 2800       CONTINUE
C
C  LOOP OVER ALL RELEVANT (A'-)BETA DETS.
C
            LABPOS = JPOSAE
            DO 2803 IGB=1,ITGB
               IF (LGCOM(IGB,JGROAE).NE.1) GOTO 2803
               NIBS = NBST(IGB)
               DO 2753 KKB=LSBS(KBSYM,IGB),LSBS(KBSYM+1,IGB)-1
                  LABPOS = LABPOS + 1
                  IBPOS = NIBS + LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2603 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
                  IGB2=JB1GR(JBINDX)
                  IF (LGCOM(IGB2,IGA).NE.1) GOTO 2603
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB=JPZA1+LDISB(KSYM,IGB2,IGA)+JB1PO(JBINDX)
                  FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
                 ENDDO
                  FC = FC*JPERAE*JB1PE(JBINDX)
                  DM2(IX) = DM2(IX) + FC
C
 2603          CONTINUE
C
 2753          CONTINUE
 2803       CONTINUE
C
      ENDIF
C
 2900    CONTINUE
 3000 CONTINUE
C
      ELSE
C
C  ***** DIRECT METHOD BELOW *****
C
      DO 4000 ISAE=1,NSYM
         KBSYM = KTAB(ISAE)
C
C  ANALYSE EXCITED A' GROUPS FOR COMPATIBILITY WITH B.
C
      NGRPS = 0
      DO 1976 II=1,IMMC(ISAE)
         ICGR = IGROA(II,ISAE)
         DO JJ=1,NGRPS
            IF (JB1GR(JJ).EQ.ICGR) GOTO 1976
         ENDDO
         NGRPS = NGRPS + 1
         JB1GR(NGRPS) = ICGR
 1976 CONTINUE
C
C FIRST TYPE OF BETAS, KSYM -> KBSYM
C
          CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
          DO 7400 IGB=1,ITGB
             IF (LGCOM(IGB,IGA).NE.1) GOTO 7399
             LAB1 = JPZA1 + LDISB(KSYM,IGB,IGA)
C
             CALL RESETDE(LBOX2,NSPACE,NB,MSTA,IBCON1)
             NIBS = NBST(IGB)
             ISTB = 1
             DO 7300 KKB=LSBS(KSYM,IGB),LSBS(KSYM+1,IGB)-1
                IENB = LSBC(KKB)
                DO IIZ=ISTB,IENB-1
                   CALL MOVEUP2(LBOX2,NSPACE,NB,MSTA,IBCON1)
                ENDDO
                ISTB = IENB
C
                IBPOS = NIBS + LSBC(KKB)
                LABPOS = LAB1 + LSPB(IBPOS)
C
C LOOP OVER SINGLE BETA EXCITES FROM IBPOS WHICH ARE OF SYMMETRY KBSYM
C
                MESYM1 = LGMUL(KSYM,KBSYM)
                DO II=1,NSPACE
                   LBOX3(II) = LBOX2(II)
                ENDDO
                IEBS = NB + 1
                DO 7290 ISPB1=NSPACE,1,-1
                   IOC1 = LBOX2(ISPB1)
                   IEBE = IEBS - 1
                   IEBS = IEBS - IOC1
                   IF (IOC1.EQ.0) GO TO 7290
                   LBOX3(ISPB1) = LBOX3(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
                DO 7285 IB1 = IEBE,IEBS,-1
                   IO1 = IBCON1(IB1)
                   MESYM2 = LGMUL(MESYM1,IOB(IO1))
                   IGBE = IEBE - LBOX2(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
                DO 7280 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                   IGBS = IGBE + 1
                   IGBE = IGBE + LBOX2(ISPB2)
C
                   LBOX3(ISPB2) = LBOX3(ISPB2) + 1
                   IF (LBOX3(ISPB1).LT.IBMI(ISPB1)) GO TO 7270
                   IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GO TO 7270
C
C  GET GROUP NUMBER
C
          CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB2)
          NIAS = NBST(IGB2)
C
C CHECK FOR A' GROUP COMPATIBILITY
C
             DO II=1,NGRPS
                IAGRP = JB1GR(II)
                IF (LGCOM(IGB2,IAGRP).EQ.1) GOTO 7555
             ENDDO
             GOTO 7270
 7555        CONTINUE
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX2(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7260 IGAP=IGBA,IGBE+1
C
                     DO 7250 JJ=ISTA,IEND
C
C CHECK TO SEE IF EXCITED BETA IS OF RIGHT SYMMETRY (KBSYM)
C
            IF (IOB(JJ).NE.MESYM2) GOTO 7250
C
            IND1 = INDEX(JJ) + IO1
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON2,IPOSB)
            QJPER = ((-1)**IPER)
            JB1P = LSPB(IPOSB + NIAS)
C
            DO 3900 JSAE=1,IMMC(ISAE)
               JGROAE=IGROA(JSAE,ISAE)
               IF (LGCOM(IGB2,JGROAE).NE.1) GOTO 3900
C
               JPOSAE=IPOSA(JSAE,ISAE)
               JCIB = JB1P + JPOSAE + LDISB(KBSYM,IGB2,JGROAE)
C
               JINDAE=IIND1(JSAE,ISAE)
               JMA=MAX(JINDAE,IND1)
               JMI=MIN(JINDAE,IND1)
               IX=INDEX(JMA)+JMI
C
               JPERAE=IPERA(JSAE,ISAE)
C
             FC=0.0D+00
             DO KKI=1,NXTW
            FC = FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
             ENDDO
             FC = FC*JPERAE*QJPER
             DM2(IX) = DM2(IX) + FC
C
 3900       CONTINUE
C
 7250                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7260             CONTINUE
C
 7270              LBOX3(ISPB2) = LBOX3(ISPB2) - 1
 7280           CONTINUE
C
 7285           CONTINUE
C
                   LBOX3(ISPB1) = LBOX3(ISPB1) + 1
 7290           CONTINUE
C
 7300        CONTINUE
C
 7399        CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
 7400     CONTINUE
C
C
C SECOND TYPE OF BETAS, KBSYM -> KSYM
C
          CALL RESETCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3)
          DO 7801 IGB=1,ITGB
C
C CHECK FOR A' GROUP COMPATIBILITY
C
             DO II=1,NGRPS
                IAGRP = JB1GR(II)
                IF (LGCOM(IGB,IAGRP).EQ.1) GOTO 7655
             ENDDO
             GOTO 7799
 7655        CONTINUE
C
             CALL RESETDE(LBOX2,NSPACE,NB,MSTA,IBCON1)
             NIBS = NBST(IGB)
             ISTB = 1
C
             DO 7701 KKB=LSBS(KBSYM,IGB),LSBS(KBSYM+1,IGB)-1
                IENB = LSBC(KKB)
                DO IIZ=ISTB,IENB-1
                   CALL MOVEUP2(LBOX2,NSPACE,NB,MSTA,IBCON1)
                ENDDO
                ISTB = IENB
C
                IBPOS = NIBS + LSBC(KKB)
                LAB1 = LSPB(IBPOS)
C
C LOOP OVER SINGLE BETA EXCITES FROM IBPOS WHICH ARE OF SYMMETRY KSYM
C
                MESYM1 = LGMUL(KSYM,KBSYM)
                DO II=1,NSPACE
                   LBOX3(II) = LBOX2(II)
                ENDDO
                IEBS = NB + 1
                DO 7691 ISPB1=NSPACE,1,-1
                   IOC1 = LBOX2(ISPB1)
                   IEBE = IEBS - 1
                   IEBS = IEBS - IOC1
                   IF (IOC1.EQ.0) GO TO 7691
                   LBOX3(ISPB1) = LBOX3(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1
C
                DO 7686 IB1 = IEBE,IEBS,-1
                   IO1 = IBCON1(IB1)
                   MESYM2 = LGMUL(MESYM1,IOB(IO1))
                   IGBE = IEBE - LBOX2(ISPB1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
                DO 7681 ISPB2=ISPB1,NSPACE
C
C  IGBS,IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                   IGBS = IGBE + 1
                   IGBE = IGBE + LBOX2(ISPB2)
C
                   LBOX3(ISPB2) = LBOX3(ISPB2) + 1
                   IF (LBOX3(ISPB1).LT.IBMI(ISPB1)) GO TO 7671
                   IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GO TO 7671
C
          CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB2)
          IF (LGCOM(IGB2,IGA).NE.1) GOTO 7671
          JCIBS = JPZA1 + LDISB(KSYM,IGB2,IGA)
          NIAS = NBST(IGB2)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBA = MAX(IB1+1,IGBS)
                  IF (LBOX2(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBA)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBA)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7660 IGAP=IGBA,IGBE+1
C
                     DO 7650 JJ=ISTA,IEND
C
C CHECK TO SEE IF EXCITED BETA IS OF RIGHT SYMMETRY (KBSYM)
C
            IF (IOB(JJ).NE.MESYM2) GOTO 7650
C
            IND1 = INDEX(JJ) + IO1
            CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,IPER)
            CALL IDPOST(IBCON2,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON2,IPOSB)
            QJPER = ((-1)**IPER)
            JCIB= JCIBS + LSPB(IPOSB + NIAS)
C
            DO 4300 JSAE=1,IMMC(ISAE)
               JGROAE=IGROA(JSAE,ISAE)
               IF (LGCOM(IGB,JGROAE).NE.1) GOTO 4300
C
               JPOSAE=IPOSA(JSAE,ISAE)
               LABPOS = LAB1 + JPOSAE + LDISB(KBSYM,IGB,JGROAE)
C
               JINDAE=IIND1(JSAE,ISAE)
               JMA=MAX(JINDAE,IND1)
               JMI=MIN(JINDAE,IND1)
               IX=INDEX(JMA)+JMI
C
               JPERAE=IPERA(JSAE,ISAE)
               FC = 0.0D+00
               DO KKI=1,NXTW
            FC = FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
               ENDDO
               FC = FC*JPERAE*QJPER
               DM2(IX) = DM2(IX) + FC
C
 4300       CONTINUE
C
 7650                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7660             CONTINUE
C
 7671              LBOX3(ISPB2) = LBOX3(ISPB2) - 1
 7681           CONTINUE
C
 7686           CONTINUE
C
                   LBOX3(ISPB1) = LBOX3(ISPB1) + 1
 7691           CONTINUE
C
 7701        CONTINUE
C
 7799        CALL PUSHCO(LBOX2,NSPACE,NB,IBMA,IBMI,LBOX3,IEND)
 7801     CONTINUE
C
 4000 CONTINUE
C
      ENDIF
C
C  ***** END OF DIRECT OPTION *****
C
C  **** END OF GENERAL CASE OF MORE THAN ONE SPACE ******
C
      GOTO 4898
C
 3400 CONTINUE
C
C ***** SPECIAL CASE OF ONE SPACE !!!!! ******
C
C  LOOP OVER SINGLE ALPHA EXCITES WITHIN EACH SYMMETRY.
C
       DO 2901 ISAE=1,NSYM
          KBSYM=KTAB(ISAE)
          DO 2801 JSAE=1,IMMC(ISAE)
                JPOSAE=IPOSA(JSAE,ISAE)
                JPERAE=IPERA(JSAE,ISAE)
                JINDAE=IIND1(JSAE,ISAE)
                JGROAE=IGROA(JSAE,ISAE)
C
C  IF ISAE.EQ.JASYM THEN SPECIAL CASE.
C
       IF (ISAE.EQ.JASYM) THEN
C
C  LOOP OVER ALL RELEVANT BETAS
C
             LABPOS=JPZA1
             LABPOS2=JPOSAE
                DO 2721 KKB=LSBS(KSYM,1),LSBS(KSYM+1,1)-1
                    LABPOS = LABPOS + 1
                    LABPOS2 = LABPOS2 + 1
                    IBPOS =  LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2621 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB = JPOSAE+JB1PO(JBINDX)
                  JCIB2 = JPZA1+JB1PO(JBINDX)
                  FC = 0.0D+00
                  FC1 = 0.0D+00
                 DO KKI=1,NXTW
          FC = FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
          FC1 = FC1 + WSTATE(IWTS(KKI))*AB(LABPOS2,KKI)*AB(JCIB2,KKI)
                 ENDDO
                  FC = FC*JPERAE*JB1PE(JBINDX)
                  FC1 = FC1*JPERAE*JB1PE(JBINDX)
                  DM2(IX) = DM2(IX) + FC + FC1
C
 2621          CONTINUE
C
 2721          CONTINUE
C
      ELSE
C
C  LOOP OVER ALL RELEVANT (A-)BETA DETS.
C
                LABPOS = JPZA1
                DO 2751 KKB=LSBS(KSYM,1),LSBS(KSYM+1,1)-1
                    LABPOS = LABPOS + 1
                    IBPOS =  LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2601 JBINDX=JB1ST(KBSYM,IBPOS),JB1ST(KBSYM+1,IBPOS)-1
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB=JPOSAE+JB1PO(JBINDX)
                  FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
                 ENDDO
                  FC = FC*JPERAE*JB1PE(JBINDX)
                  DM2(IX) = DM2(IX) + FC
C
 2601          CONTINUE
C
 2751          CONTINUE
C
C  LOOP OVER ALL RELEVANT (A'-)BETA DETS.
C
               LABPOS = JPOSAE
               DO 2761 KKB=LSBS(KBSYM,1),LSBS(KBSYM+1,1)-1
                  LABPOS = LABPOS + 1
                  IBPOS = LSBC(KKB)
C
C  LOOP OVER SINGLE BETA EXCITES FROM IBPOS
C
               DO 2611 JBINDX=JB1ST(KSYM,IBPOS),JB1ST(KSYM+1,IBPOS)-1
C
                  JMA=MAX(JINDAE,JB1IN(JBINDX))
                  JMI=MIN(JINDAE,JB1IN(JBINDX))
                  IX=INDEX(JMA)+JMI
                  JCIB=JPZA1+JB1PO(JBINDX)
                  FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(LABPOS,KKI)*AB(JCIB,KKI)
                 ENDDO
                  FC = FC*JPERAE*JB1PE(JBINDX)
                  DM2(IX) = DM2(IX) + FC
C
 2611          CONTINUE
C
 2761          CONTINUE
C
      ENDIF
C
 2801       CONTINUE
 2901   CONTINUE
C
C  **** END OF SPECIAL CASE OF ONE SPACE *******
C
 4898       CONTINUE
            IF (GOPARR) CALL DDI_DLBNEXT(MY_TASK)
 4899       CONTINUE
            CALL MOVEUP2(LBOX1,NSPACE,NA,MSTA,IACON1)
 4900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NA,IAMA,IAMI,LBOX5,IEND)
 5000 CONTINUE
C
C           --- THIS ENDS LOOP OVER ALPHA STRINGS ---
C          --- NOW LOOP OVER PURE BETA EXCITATIONS ---
C
      IF (GOPARR) THEN
         CALL DDI_DLBRESET()
         CALL DDI_DLBNEXT(MY_TASK)
      ENDIF
C
      CALL RESETCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5)
C
      DO 8000 IGB=1,ITGB
C
         CALL RESETDE(LBOX1,NSPACE,NB,MSTA,IBCON1)
C
C  KKB GIVES THE ACTUAL POSITION OF THE BETA STRING IBCON1 IN
C  THE FULL BETA STRING LIST.
C
         DO 7900 KKB=NBST(IGB)+1,NBST(IGB+1)
            IF (GOPARR.AND.KKB-1.NE.MY_TASK) GOTO 7899
            JPZB1 = LSPB(KKB)
            KBSYM = LSYMB(KKB)
            KSYM=KTAB(KBSYM)
C
            DO II=1,NSPACE
               LBOX2(II) = LBOX1(II)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRON FROM.
C
            IEBS = NB+1
            DO 7890 ISPB1=NSPACE,1,-1
               IOC1 = LBOX1(ISPB1)
               IEBE = IEBS - 1
               IEBS = IEBS - IOC1
               IF (IOC1.EQ.0) GOTO 7890
               LBOX2(ISPB1) = LBOX2(ISPB1)-1
C
C  LOOP ELECTRONS IN SPACE ISPB1.
C  IEBS, IEBE ARE THE ELECTRONS IN SPACE ISPB1.
C
               DO 7885 IB1=IEBE,IEBS,-1
                  IO1 = IBCON1(IB1)
                  IGBE = IEBE - LBOX1(ISPB1)
                  IS1 = IOB(IO1)
C
C  LOOP OVER POSSIBLE SPACES TO EXCITE INTO.
C
               DO 7880 ISPB2=ISPB1,NSPACE
C
C  IGBS, IGBE ARE ELECTRONS SPECIFYING ISPB2 SPACE ELECTRON LIMITS.
C
                  IGBS = IGBE + 1
                  IGBE = IGBE + LBOX1(ISPB2)
C
                  LBOX2(ISPB2) = LBOX2(ISPB2) + 1
                  IF (LBOX2(ISPB1).LT.IBMI(ISPB1)) GOTO 7870
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBB = MAX(IB1+1,IGBS)
                  IF (LBOX1(ISPB2).EQ.0) THEN
                     ISTA = MSTA(ISPB2)
                     IEND = MSTA(ISPB2+1)-1
                  ELSEIF (ISPB2.EQ.ISPB1) THEN
                     ISTA = IO1+1
                     IEND = IBCON1(IGBB)-1
                     IF (IB1.EQ.IEBE) IEND=MSTA(ISPB1+1)-1
                  ELSE
                     ISTA = MSTA(ISPB2)
                     IEND = IBCON1(IGBB)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 7860 IGAP=IGBB,IGBE+1
C
                     DO 7850 JJ=ISTA,IEND
                        IS2 = IOB(JJ)
                        IP1 = LGMUL(IS1,IS2)
                        IND = INDEX(JJ) + IO1
C
              CALL REDE00(IBCON1,IBCON2,NB,IB1,IGAP-1,JJ,JPERB)
                  IF (LBOX2(ISPB2).GT.IBMA(ISPB2)) GOTO 7800
C
C   IF DEOCCUPIED AND NEWLY OCCUPIED ORBITALS ARE OF DIFFERENT SYMMETRY,
C   SKIP TO DOUBLES.
C
              IF (IS1.NE.IS2) GOTO 7800
C
C  GET GROUP NUMBER
C
           CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX2,IGB2)
           NIBS = NBST(IGB2)
C
              CALL IDPOST(IBCON2,NB,LBOX2,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB2),IACON1,JPOSB)
              KBPOS = JPOSB + NIBS
              JPZB2 = LSPB(KBPOS)
              KPER1 = ((-1)**JPERB)*2
C
C  LOOP OVER ALPHA AND UPDATE DM
C
              DO 7705 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7705
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              DO 7685 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
                 ENDDO
                 FC = FC*KPER1
                 DM1(IND) = DM1(IND) + FC
 7685         CONTINUE
C
 7705         CONTINUE
C
              DO 7712 IK=1,NB
                 IF (IK.EQ.IB1) GOTO 7712
                 ION = IBCON1(IK)
                 J1 = INDEX(ION+1)
                 JMA = MAX(J1,IND)
                 JMI = MIN(J1,IND)
                 JJ1 = INDEX(JMA) + JMI
                 JMA = MAX(ION,JJ)
                 JMI = MIN(ION,JJ)
                 J1 = INDEX(JMA)+JMI
                 JMA = MAX(IO1,ION)
                 JMI = MIN(IO1,ION)
                 J2 = INDEX(JMA)+JMI
                 JMA = MAX(J1,J2)
                 JMI = MIN(J1,J2)
                 INX = INDEX(JMA)+JMI
C
              DO 7710 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7710
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              DO 7695 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
                 ENDDO
                 FC = FC*KPER1
                 DM2(JJ1) = DM2(JJ1) + FC
                 DM2(INX) = DM2(INX) - FC
 7695         CONTINUE
C
 7710         CONTINUE
C
 7712         CONTINUE
C
C  LOOP OVER ALPHA STRINGS OF THE RIGHT GROUP AND SYMMETRY.
C
              CALL RESETCO(LBOX3,NSPACE,NA,IAMA,IAMI,LBOX4)
C
              DO 7700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB2,IGA).NE.1) GOTO 7690
                 JCIB1 = LDISB(KBSYM,IGB,IGA) + JPZB1
                 JCIB2 = LDISB(KBSYM,IGB2,IGA) + JPZB2
                 NIAS = NAST(IGA)
C
              CALL RESETDE(LBOX3,NSPACE,NA,MSTA,IACON1)
              ISTA1 = 1
              DO 7680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA1 = LSAC(KKA)
                 DO IIZ=ISTA1,IENA1-1
                    CALL MOVEUP2(LBOX3,NSPACE,NA,MSTA,IACON1)
                 ENDDO
                 ISTA1 = IENA1
                 JCIA = LSPA(NIAS+IENA1)
                 JCI1 = JCIA + JCIB1
                 JCI2 = JCIA + JCIB2
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI2,KKI)
                 ENDDO
                 FC = FC*KPER1
C
                 DO 7670 IK=1,NA
                    ION = IACON1(IK)
                    J1 = INDEX(ION+1)
                    JMA = MAX(J1,IND)
                    JMI = MIN(J1,IND)
                    JJ1 = INDEX(JMA) + JMI
                    DM2(JJ1) = DM2(JJ1) + FC
 7670            CONTINUE
C
 7680         CONTINUE
C
 7690         CALL PUSHCO(LBOX3,NSPACE,NA,IAMA,IAMI,LBOX4,IEND)
 7700         CONTINUE
C
C  --- DOUBLE EXCITATIONS START HERE
C
 7800         CONTINUE
C
           IF (IB1.EQ.NB) GOTO 7850
           IF (JJ.EQ.NACT) GOTO 7850
C
            DO II=1,NSPACE
               LBOX3(II) = LBOX2(II)
            ENDDO
            IBES3 = 1
            DO KK=1,ISPB1-1
               IBES3 = IBES3 + LBOX2(KK)
            ENDDO
C
C  LOOP OVER SPACES TO EXCITE ELECTRONS FROM, MUST BE GE THAN
C  SPACE OF FIRST EXCITATION, ISPB1.
C
            DO 6890 ISPB3 = ISPB1,NSPACE
               IF (LBOX1(ISPB3).EQ.0) GOTO 6887
               IF (ISPB3.EQ.ISPB1.AND.IB1.EQ.IEBE) GOTO 6887
               IOC3 = LBOX2(ISPB3)
               IF (IOC3.EQ.0) GOTO 6887
C
               IBEE3 = IBES3 + LBOX2(ISPB3)-1
               LBOX3(ISPB3) = LBOX3(ISPB3)-1
C
C  LOOP OVER ELECTRONS IN ISPB3, WHICH ARE LARGER THAN IB1,
C  MAKING SURE IT ISN'T THE ALREADY EXCITED ELECTRON.
C
               JSTB3 = IBES3
               IF (ISPB3.EQ.ISPB1) THEN
                  JSTB3=IB1
                  IF (IGAP-1.EQ.IB1) JSTB3=JSTB3+1
               ENDIF
C
               DO 6880 IB3=JSTB3,IBEE3
                  IF (IB3.EQ.IGAP-1) GOTO 6880
                  IO3 = IBCON2(IB3)
                  IS3 = IOB(IO3)
C
C  LOOP OVER SPACES TO EXCITE ELECTRON INTO.  MUST BE GE THAN
C  SPACE FIRST ELECTRON WAS EXCITED INTO.
C
                  IGBE3 = 0
                  DO JIK=1,ISPB2-1
                     IGBE3 = IGBE3 + LBOX2(JIK)
                  ENDDO
                  DO 6850 ISPB4=ISPB2,NSPACE
C
C  IGBS3, IGBE3 ARE ELECTRONS SPECIFYING ISPB4 SPACE ELECTRON LIMITS.
C
                  LBOX3(ISPB4) = LBOX3(ISPB4) + 1
                  IGBS3 = IGBE3 + 1
                  IGBE3 = IGBE3 + LBOX2(ISPB4)
                  IF (LBOX3(ISPB3).LT.IBMI(ISPB3)) GOTO 6840
                  IF (LBOX3(ISPB4).GT.IBMA(ISPB4)) GOTO 6840
                  IF (LBOX3(ISPB2).LT.IBMI(ISPB2)) GOTO 6840
                  IF (LBOX3(ISPB2).GT.IBMA(ISPB2)) GOTO 6840
C
             IF (ISPB4.EQ.ISPB2.AND.JJ.EQ.MSTA(ISPB2+1)-1) GOTO 6840
C
C  GET GROUP NUMBER
C
               CALL POSITCO(LBOX5,NSPACE,NB,IBMA,IBMI,LBOX4,LBOX3,IGB3)
               NIBS3 = NBST(IGB3)
C
C  MAKE GAP INFORMATION HERE.
C
                  IGBB3 = MAX(IGBS3,IGAP)
C
                  IF (LBOX2(ISPB4).EQ.0) THEN
                     ISTA3 = MSTA(ISPB4)
                     IEND3 = MSTA(ISPB4+1)-1
                  ELSEIF (ISPB4.EQ.ISPB2) THEN
                     ISTA3 = JJ+1
                     IEND3 = IBCON2(IGBB3)-1
C
C  I AM SUSPECT ABOUT THIS NEXT LINE, WE'LL SEE WHAT HAPPENS.......
C
                     IF (IGAP-1.EQ.IGBE3) IEND3=MSTA(ISPB2+1)-1
C
                  ELSE
                     ISTA3 = MSTA(ISPB4)
                     IEND3 = IBCON2(IGBB3)-1
                  ENDIF
C
C  LOOP OVER GAPS
C
                  DO 6830 IGAP3=IGBB3,IGBE3+1
C
                     DO 6820 JJ3=ISTA3,IEND3
                        IS4 = IOB(JJ3)
                        IP2 = LGMUL(IS3,IS4)
                        IF (IP1.NE.IP2) GOTO 6820
C
              CALL REDE00(IBCON2,IACON1,NB,IB3,IGAP3-1,JJ3,JPERB3)
              CALL IDPOST(IACON1,NB,LBOX3,NSPACE,MSTA,IDIM,Y,NX,LBST,
     *                  LBNDET(1,IGB3),IACON2,JPOSB3)
              IPER3 = ((-1)**(JPERB3+JPERB))*2
              KBPOS3 = JPOSB3 + NIBS3
              JPZB3 = LSPB(KBPOS3)
C
                 JMA=MAX(JJ3,IO3)
                 JMI=MIN(JJ3,IO3)
                 I2 = INDEX(JMA) + JMI
                 INX = INDEX(I2) + IND
                 II1 = INDEX(JJ3) + IO1
                 JMA=MAX(IO3,JJ)
                 JMI=MIN(IO3,JJ)
                 II2 = INDEX(JMA) + JMI
                 JMA=MAX(II1,II2)
                 JMI=MIN(II1,II2)
                 INX2 = INDEX(JMA) + JMI
C
C  LOOP OVER ALPHA STRINGS OF RIGHT SYMMETRY AND GROUP.
C
              DO 6700 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1.OR.LGCOM(IGB3,IGA).NE.1) GOTO 6700
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              JCIB3 = JPZB3 + LDISB(KBSYM,IGB3,IGA)
              NIAS = NAST(IGA)
C
              DO 6680 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
                 JCI3 = JCIA + JCIB3
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI3,KKI)
                 ENDDO
                 FC = FC*IPER3
                 DM2(INX) = DM2(INX) + FC
                 DM2(INX2) = DM2(INX2) - FC
 6680         CONTINUE
C
 6700         CONTINUE
C
 6820                CONTINUE
C
                     ISTA3 = IBCON2(IGAP3)+1
                     IEND3 = IBCON2(IGAP3+1)-1
                     IF (IGAP3.EQ.IGBE3) IEND3=MSTA(ISPB4+1)-1
 6830             CONTINUE
C
 6840             LBOX3(ISPB4) = LBOX3(ISPB4) - 1
 6850             CONTINUE
C
 6880          CONTINUE
C
               LBOX3(ISPB3) = LBOX3(ISPB3)+1
 6887          IBES3 = IBES3 + LBOX3(ISPB3)
 6890       CONTINUE
C
C  --- END OF LOOP OVER DOUBLE BETA EXCITATIONS.
C
 7850                CONTINUE
C
                  ISTA = IBCON1(IGAP)+1
                  IEND = IBCON1(IGAP+1)-1
                  IF (IGAP.EQ.IGBE) IEND=MSTA(ISPB2+1)-1
 7860             CONTINUE
C
 7870             LBOX2(ISPB2) = LBOX2(ISPB2) - 1
 7880          CONTINUE
C
 7885          CONTINUE
C
               LBOX2(ISPB1) = LBOX2(ISPB1)+1
 7890       CONTINUE
C
C REMAINING DIAGONAL CONTRIBUTIONS HERE
C
            DO 69 II=1,NB
               I1 = IBCON1(II)
               IND1 = INDEX(I1+1)
C
              DO 6705 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1) GOTO 6705
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              NIAS = NAST(IGA)
C
              DO 6685 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI1,KKI)
                 ENDDO
                 DM1(IND1) = DM1(IND1) + FC
 6685         CONTINUE
C
 6705         CONTINUE
C
              DO 74 JJ=II+1,NB
                 I2 = IBCON1(JJ)
                 IND2 = INDEX(I2+1)
                 INDM = IND2 - I2 + I1
                 J1 = INDEX(INDM+1)
                 JMI = MIN(IND1,IND2)
                 JMA = MAX(IND1,IND2)
                 J2 = INDEX(JMA) + JMI
C
              DO 6710 IGA=1,ITGA
              IF (LGCOM(IGB,IGA).NE.1) GOTO 6710
              JCIB1 = JPZB1 + LDISB(KBSYM,IGB,IGA)
              NIAS = NAST(IGA)
C
              DO 6690 KKA=LSAS(KSYM,IGA),LSAS(KSYM+1,IGA)-1
                 IENA3 = LSAC(KKA)
                 JCIA = LSPA(NIAS+IENA3)
                 JCI1 = JCIA + JCIB1
                 FC = 0.0D+00
                 DO KKI=1,NXTW
              FC = FC + WSTATE(IWTS(KKI))*AB(JCI1,KKI)*AB(JCI1,KKI)
                 ENDDO
                 DM2(J1) = DM2(J1) - FC
                 DM2(J2) = DM2(J2) + FC
 6690         CONTINUE
C
 6710         CONTINUE
C
   74         CONTINUE
C
   69         CONTINUE
C
            IF (GOPARR) CALL DDI_DLBNEXT(MY_TASK)
 7899       CONTINUE
            CALL MOVEUP2(LBOX1,NSPACE,NB,MSTA,IBCON1)
 7900    CONTINUE
C
         CALL PUSHCO(LBOX1,NSPACE,NB,IBMA,IBMI,LBOX5,IEND)
 8000 CONTINUE
C
      IF (GOPARR) THEN
         CALL DDI_DLBRESET()
         CALL DDI_GSUMF(2901,DM2,M4)
         CALL DDI_GSUMF(2900,DM1,M2)
      ENDIF
C
C  --- END OF LOOP OVER BETA STRINGS. ---
C
 9000 CONTINUE
C
C  MAKE CEPA DENSITIES (DM1,DM2) USING REFERENCE DENSITIES (REFDM1,REFDM2)
C  AND CI-SD DENSITIES (DM1,DM2 OVERWRITTEN)
C
      DO JOE=1,NREFA2
         DM1(JOE) = AREF*REFDM1(JOE) + AEXT*DM1(JOE)
      ENDDO
      DO JOE=NREFA2+1,M2
         DM1(JOE) = AEXT*DM1(JOE)
      ENDDO
C
      DO JOE=1,NREFA4
         DM2(JOE) = AREF*REFDM2(JOE) + AEXT*DM2(JOE)
      ENDDO
      DO JOE=NREFA4+1,M4
         DM2(JOE) = AEXT*DM2(JOE)
      ENDDO
C
C        DENSITY MATRIX GENERATION FINISHED
C        OUTPUT THE 1ST AND 2ND ORDER DENSITY IN VARIOUS WAYS
C
      CALL VALFM(LOADFM)
      LXX    = LOADFM + 1
      LIXX   = LXX    + NINTMX
      LWRK   = LIXX   + NINTMX
      LLABMO = LWRK  + NOCC2
      LLBABL = LLABMO + L1
      LLBIRP = LLBABL + M1
      LSYIRP = LLBIRP + 12
      LDUM1A = LSYIRP + 12
      LDUM1B = LDUM1A + M2
      LDUM2AAAA = LDUM1B  + M2
      LDUM2BBBB = LDUM2AAAA + M4
      LDUM2AABB = LDUM2BBBB + M4
      LDUM2ABAB = LDUM2AABB + M4
      LAST      = LDUM2ABAB + M4
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      CALL DETGRP(GRPDET,X(LLABMO),X(LLBABL),PTGRP,X(LLBIRP),
     *            X(LSYIRP),NSYM,NIRRP,L1,NACT,NCORSV)
C
C            spin densities are computed only by ORMAS
      CALL VCLR(X(LDUM1A),1,M2)
      CALL VCLR(X(LDUM1B),1,M2)
      CALL VCLR(X(LDUM2AAAA),1,M4)
      CALL VCLR(X(LDUM2BBBB),1,M4)
      CALL VCLR(X(LDUM2AABB),1,M4)
      CALL VCLR(X(LDUM2ABAB),1,M4)
C
      CUTOFF = MAX(1.0D-11,10.0D+00**(-ICUT))
      IF(SOME) WRITE(IW,9370) X(LSYIRP),PTGRP
C
      CALL SEQOPN(NFT15,'WORK15','UNKNOWN',.FALSE.,'UNFORMATTED')
      CALL SEQREW(NFT15)
      CALL WTDM12(EXETYP,DM1,DM2,X(LLBABL),X(LXX),X(LIXX),
     *            NINTMX,LABSIZ,M1,M2,M4,
     *            X(LWRK),NOCC2,NCORSV,CUTOFF,NFT15,NRECO,NDM2O,
     *            X(LDUM1A),X(LDUM1B),
     *            X(LDUM2AAAA),X(LDUM2BBBB),X(LDUM2AABB),X(LDUM2ABAB))
      CALL SEQREW(NFT15)
C
      IF(SOME) WRITE(IW,9380) NDM2O,NRECO,NFT15
      CALL RETFM(NEED)
C
      IF(SOME) WRITE(IW,9390)
      IF(SOME) CALL TIMIT(1)
      RETURN
C
 9310 FORMAT(/5X,55(1H-)/
     *   5X,' ONE AND TWO PARTICLE ORMAS DENSITY MATRIX COMPUTATION'/
     *   18X,'PROGRAM WRITTEN BY JOE IVANIC'/
     *   5X,55(1H-))
 9320 FORMAT(/1X,'THE DENSITIES ARE STATE AVERAGED OVER',I4,' ROOT(S)')
 9330  FORMAT(/5X,' STATE WEIGHTS WILL BE CHOSEN DYNAMICALLY '/
     *       X,'STATE',I4,' IS THE REFERENCE STATE'/
     *       X,'DYNAMICALLY WEIGHTED ENERGY PARAMETER:',F7.3,' EV'/)
 9340 FORMAT(1X,'STATE=',I4,'   ENERGY=',F20.10,'   WEIGHT=',F8.5,
     *           '   S=',F6.2)
 9350 FORMAT(/1X,'***** ERROR *****'/
     *       1X,'THIS RUN FOUND',I5,' CI EIGENVECTORS WITH S=',F5.2,','/
     *       1X,'BUT YOU REQUESTED STATE AVERAGING OF',I5,' ROOTS.'/
     *       1X,'PLEASE EXAMINE YOUR CHOICE OF -NSTATE- INPUT DATA.'/)
 9370 FORMAT(1X,'SIEVING THE ',A4,
     *          ' SYMMETRY NONZERO DENSITY ELEMENTS IN GROUP ',A8)
 9380 FORMAT(1X,I10,' NONZERO DM2 ELEMENTS WRITTEN IN',I8,
     *          ' RECORDS TO FILE',I3)
 9390 FORMAT(1X,'..... DONE WITH 1 AND 2 PARTICLE DENSITY MATRIX .....')
C
      END
C
