C  1 Apr 16 - TN,HN,DGF - changes for FMO 5.2
C 22 Aug 14 - FZ  - PAD THE INFOTD COMMON FOR ALPHKWD
C  4 Jul 14 - FZ  - PAD THE INFOTD COMMON FOR BETA
c 12 Aug 13 - DGF - finish FMO 5.0
c 21 May 13 - DGF,HN,TN - changes for FMO 5.0
C 20 Feb 13 - MWS - synchronize SCFWFN common
C 19 Oct 12 - MWS - remove FTNCHEK warning
C  2 Oct 12 - DGF - Prevent unimplemented FMO3/D from running
C 13 Sep 12 - SRP - Addition of dispersion, exchange repulsion
C 31 Jul 12 - DGF,CHC - LAST CHANGES FOR FMO 4.3
C 24 Jul 12 - DGF - code update to finish FMO 4.3
C 21 JUN 12 - DGF,TN,HN,CHC - CHANGES FOR FMO 4.3
C  9 APR 12 - FZ  - PAD THE INFOTD COMMON FOR TPA
C 23 MAR 12 - DGF,CHC,TN - code update to finish FMO 4.2
C 28 DEC 11 - DGF,TN,CS,SRP,CHC  - FMO 4.2 AND EFMO CHANGES
C  2 Nov 11 - DGF - INIDFMO: allow FMO3 without $GDDI input
C  2 Nov 11 - BSD - FMO_MMDER: use complex double precision fxn.
C 11 Aug 11 - DGF - ensure init. of all pointers passed to EDIMER
C 15 Apr 11 - DGF,TN - frozen domain, EFP and PCM related changes
C 12 Dec 10 - DGF - FMOX: relocate DC value saving
C  1 Oct 10 - CS  - ADDED EFMO CHANGES
C  1 Oct 10 - DGF - EDIMER: correction for Grimme's dispersion option
C 11 Aug 10 - DGF,TN - changes for FMO 4.0
C 25 Mar 10 - DGF - tickles to complete FMO 3.3 release
C 14 Oct 09 - DGF,TN - changes for FMO 3.3
C 22 May 09 - DGF - fix for MCP/FMO gradients, PIEDA/PL0 printing
C  1 May 09 - NMT - change argument to Stone analysis
C 23 Jan 09 - DGF - additional changes for FMO 3.2
C 15 Dec 08 - DGF,MC,TN - various changes for FMO 3.2 release
C  1 Dec 08 - MC  - changes for FMO-TDDFT/PCM and TDDFT gradient
C 11 Apr 08 - SAN - synchronize call to STONE
c 28 aug 07 - hl  - FMOX: FMO-PCM gradients
C 20 Aug 07 - TN  - calls to do electrostatic derivative, and for MCP
C 20 Aug 07 - DGF - various changes for FMO 3.1 release
C 12 Jul 07 - MC  - add FMO-TDDFT arguments
C 24 Mar 07 - MWS - pad FRGINF common block
C 22 Dec 06 - DGF - various changes for FMO 3.0 release
C  6 Nov 06 - MWS - adjust wavefunction and GDDI common block
C 29 Mar 06 - TN  - EDIMER: fix irststp=5 logic
c 17 Jan 06 - DGF - FMOX: don't reset NEFSP
C 14 Nov 05 - DGF - various changes for FMO 2.1 release
C 19 Sep 05 - MWS - add true nuclear charge array to INFOA common
C  6 Jul 05 - DGF - FMOX: redimension for CCSD(TQ) records
C  1 Jun 05 - DGF - fixes for the 2nd release
c 15 mar 05 - dgf - major changes for the second release
c  5 Feb 05 - DGF - MONOSCF: fix parallel DDI/DFT bug
c  3 Jun 04 - DGF - FMOX: restart bug fixed
c 19 May 04 - DGF,KK - implement Fragment Molecular Orbital (FMO) method
c
C*MODULE fmo     *DECK fmox
C>
C>     @brief Main FMO driver
C>
C>     @details Setup and perform FMO calculations
C>
C>     @author Dmitri Fedorov
C>
C>     @date 10/5/12 - Spencer Pruitt
C>     - Added dispersion, charge transfer and repulsion EFP information
C>       to dynamic memory.
C>
C>    @date 25/03/13 - Casper Steinmann
C>     - Added EFMO/FD support
C>
C>    @date March, 2014 - Colleen Bertoni
C>     - Changed how the memory for the EFMO exchange repuslion term
C>       (nefmobas and efmobas) is calculated, and added the term
C>       liexrep_mem to EFMOPO which is an array that indexes into the new
C>       nefmobas and efmobas
C>     - Decreased the amount of memory for one of the EFMO charge
C>       transfer terms (lefmocf), since it only needs to hold the
C>       occupied diagonal terms of the fock matrix
C>    @date May, 2014 - Colleen Bertoni
C>     - Modified so that EFMO runs have enough memory to store
C>       EFP interaction energy for each separated dimer in the
C>       edim array
C>    @date June, 2014 - Colleen Bertoni
C>     - Modified how iexrep_offset works
C>    @date February, 2016 - Yoshio Nishimoto
C>     - FMO-DFTB3, FMO-DFTB SCZV, FMO-DFTB/PCM, FMO3-DFTB
C>    @date February, 2016 - Hiroya Nakata
C>     - FMO-DFTB Hessian
C>    @date January, 2017 - C.Bertoni
C>     - EFMO gradient changes
C>
      SUBROUTINE fmox(modeff)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK,isgddi,parout,INITGDDI,DIRSCF,FDIFF,
     *        MMONLY,QMMM,SAVDSK,AIMPAC,RPAC,PLTORB,MOLPLT,DGRIDPROG,
     *        some,orbxch,
     *        enexch,docas,dosap,dospc,atonce,correl,primul,gcorrel,
     *        squit,linear,needdm,doddcor,esdder,savgrd,forbconv,conv2mc
     *       ,savdir,modQbas,totdens,densgrid,semidyn,broadden,spargrid,
     *        densgrid0,spargrid0,inifmo0,isgddi0,grandmas,densfmo0,
     *        didcc,didmp,exclmol,dovpcm,pcmnotconv,domp,dotd,MPTEST,
     *        dopleda,doscfprp,ext2lay,fmoq,dolat,addesp,addesp0,diffesp
     *       ,TRIPLET,MFRZ,MFRZs,doclmo,doclmo1,dovlmo,dopdc,mepgrid,
     *        SG1,SG1T,projgrad,doexc,doci,totfock,skipesd,DOEFPIEA,
     *        urohf,dodistr,hopgrd,DC,DCCHG,DCABC,dodc,dodimden,
     *        MCMIN,LGLOE,LGLOEG,mulgeom,dodiff,LSCZVEC,wasgddi,TAMMD,
     *        TPA,dcsav,skipscc,outpune,QOPS,QFMM,vibcoup,outesd,hasgrad
     *       ,fullmfmo3,docns,douhf,CAMFLAG,LCFLAG,LSCZVECs,
     *        dodcesd,dopbcmd,mdxcalled,savemem,savemem2,reducee,reuses,
     *        ALPHKWD,BETAKWD,mdout,griddistr,MLGDDI,spinden,dofddpcm,
     *        urospn,savememr,skipsort,icanuse1,iused1,savenmer,
     *        fraggrid,round10,subsys,domeppcm,qmcout,dofret,mdoutmin,
     *        scfesp
CFTNC Removed LRINT
      Integer ddi_world,ddi_group
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      logical imomm,simomm,CHGEMB
      character*80 fmosym
      Parameter(ddi_world=0,ddi_group=1)
      Parameter(MXATM=2000,MXAO=8192,MXRT=100,MAXNZ=137,MaxLay=5,
     *          MXSFMO=MaxLay*40,MXGFMO=MaxLay*100,MXAFMO=MaxLay*10,
     *          MAXL=5,MXPTPT=100,MXFGPT=12000,MXFRG=1050,MXDFG=5,
     *          MXDPPT=MXFRG*MXDFG*12,MXGRID=10,MaxNp=45,MXPLATE=10)
      parameter (nstfmo=10,maxpst=10,zero=0.0D+00,one=1.0D+00,maxelm=3,
     *           nextracc=17,nedft=2)
      PARAMETER (MXEFMOPTS=50,MXEFMOPPTS=60,MXNEFMOPTS=27,
     *           MXNEFMOPPTS=15)
      PARAMETER (MXSPE=10)
      dimension mcnvfmo(nstfmo),ngrfmo(maxpst,MaxLay),nstjob(maxpst),
     *          loadbf(maxpst,MaxLay),loadgr(maxpst,MaxLay),ncvscf(2),
     *          nelm(0:maxelm),dum3(3),vdwrad(MAXNZ),extracc(nextracc,3)
     *         ,maxg(3),ngm(3),etotdft(nedft),prtdst(4),eint0(4),
     *          rappri(3),lbody(MaxLay),tabm(137),iexcit(5),
     *          eexcit(mxrt,2),texcit(3,mxrt,2),monoc(mxrt),monvr(mxrt),
     *          isumd(mxrt+1),osmd(mxrt,2),etfmo(3),edimsum(16),
     *         etrimsum(6),CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),grdpad(3)
      COMMON /BASSPH/ QMTTOL,ISPHER
      common /cnsdat/ EXREF,lcnsdat,natcns,ioover
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFTCAM/ ALPHAC,BETAC,CAMMU,CAMVWN,CAMLYP,CAMFLAG
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTDC / DC,IDCVER,DCCHG,DCABC,DCSR,DCS6,DCS8,DCALP,DCA1,
     *                DCA2
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
     *                                                    NAUXSHL
      COMMON /ECP2  / CLP(400),ZLP(400),NLP(400),KFIRST(MXATM,6),
     *                KLAST(MXATM,6),MMAX(MXATM),LPSKIP(MXATM),
     *                IZCORE(MXATM)
      COMMON /EFFMOP/ LEFLDFMO,LEFADDFMO,LDINDFMO,LDINDDFMO,
     *                LDEFEF,LDEFTF,LTORQF
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP,iefmo_agrad
      COMMON /EFMOPO/ LNEFMOPTS,LEFMOPTS,LEFMOPPTS,LEFMODPTS,LNEFMOBAS,
     *                LEFMOBAS,LEFMOLMO,LEFMOFM,LEFMOCV,LEFMOCF,
     *                LEFMODIMG,LEFMOTOTG,LEFMOIPT,LEFMOIGLOB,
     *                LEFMOESDER,MXZVWK,lefmo_fock_der, lefmodipder,
     *     lefmo_tran, lcpl_coeff, liexrep_offset, lefmo_tot_field,
     *     lefmo_f_resp, lefmo_scphf, lefmo_dyndisp, lefmo_scptdhf
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /EFPOTD/ METHOF,ISCCHG,MOVE,nfrag
      COMMON /ELPROP/ ELDLOC,ELMLOC,ELPLOC,ELFLOC,
     *                IEDEN,IEMOM,IEPOT,IEFLD,MODENS,
     *                IEDOUT,IEMOUT,IEPOUT,IEFOUT,
     *                IEDINT,IEMINT,IEPINT,IEFINT
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      COMMON /FMCOM / X(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /GLOFMO/ MCMIN,IFMOID(MXATM)
      COMMON /GRDPAR/ ORIGIN(3),XVEC(3),YVEC(3),ZVEC(3),UX(3),UY(3),
     *                UZ(3),GRDSIZ,NGRID,IGUNIT,NXG,NYG,NZG,modgrid
      COMMON /IEAMEM/ LIPFMO,LIPEFP,LIOFMO,LIOEFP,LEFPIEA,LWRKIEA,
     *                LDOCNT,LEFEFPT,LTMPOL,LIEATF,LFGINT,LNPT2FRG
      COMMON /IEACAL/ REMPOL,IEACAL,NFGIEA,NFRGIEA,NFRGI1,NFRGI2,IEADA,
     *                MXEFPT,MAXPOL,NPRIEA,NATFIEA,IEABDY,ITRLVL,
     *                LIEACNT,ieaold,DOEFPIEA
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INFOEX/ TDM(3,mxrt),MOCC(mxrt),MVIR(mxrt),MONOC1,MONVR1,
     *                IFMODIM,MONOC2,MONVR2
      COMMON /INFOTD/ CNVTOL,PFREQ(2),
     *                JANST,NRADT,NTHET,NPHIT,NLEBT,
     *                NSTAT,NTRIAL,MAXVEK,NTHST,IRECTD,ITDFG,ITDPRP,
     *                TRIPLET,SG1T,NONEQR,TAMMD,TPA,ALPHKWD,BETAKWD
      common /INT2IC/ NINTIC,iNINTIC,nxxic,lbufpic,lixic,labsix,nintix
      COMMON /INTRFC/ FRIEND,AIMPAC,RPAC,PLTORB,MOLPLT,DGRIDPROG
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /MACHSW/ KDIAG,ICORFL,IXDR,modio,mem10,lpnt10,mem10m
      COMMON /MCPFMO/ IMCPFMO,LFZCOR,LIFMPTYP,LIFMPTYP2,LMCPSW,
     *                LIZCOR2,imp0,jmp0,icorsh0,igtf0,IECPFMO
      COMMON /MFRPAR/ MFRZ,NUMFRZ,NORFRZ,IFRZ(MXAO)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NORB,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /NLRC  / LCFLAG,EMU,EMU2,LRFILE
CFTNC COMMON /NLRCF / LRINT
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
      COMMON /PCMCHG/ PB,PX,PC,UNZ,QNUC,FN,FE,UNZOR,PORT
      COMMON /PCMDIM/ mxsp,mxts,mempcm1,mempcm2,NTS
      COMMON /PCMITR/ RCUT(2),THRES,IPCMIT,IMUL,MXDIIS,NREG,MXITR1,
     *                MXITR2,MODPAP
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEFPCM,IP_F,nfmopcm,IHET
      COMMON /PCMPLY/ STOT,VOL,CCX,CCY,CCZ,RDIF,NESF,NESFP,NESFF,I_NESF,
     *                L_AST
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                mPEL,lpcmcdr,LDAI,LIDDAI,LQSND,LQSED,LEPSPCM
      COMMON /PDCPAR/ CENTER(3),DPOLE(3),QPOLE(6),RMAX,DELR,CONSTR,
     *                PTSEL,VDWSCL,PTDENS,VDWINC,NFREQ,LAYER,NPDC,ilayh
      COMMON /POINTS/ NPOINT,IPUNIT,XPOINT(MXPTPT),YPOINT(MXPTPT),
     *                ZPOINT(MXPTPT)
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /QMFM  / SIZE,EPS1,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      common /QMMM1/  IMOMM,SIMOMM,NPAIR,NSEQ,CHGEMB
      COMMON /RAIOLN/ JRECLN(10),JRECST(10)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SOLSMX/ SOLA,SOLB,SOLC,SOLG,SOLH,SOLN,ISMX
      COMMON /STNBUF/ STNPNT(4,2*MXATM),BIGEXP,NPTSTN,NBUFFM
      COMMON /TIMING/ CPU,WALL
      COMMON /TINOPT/ mparti,MMONLY, QMMM
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /ZMAT  / NZMAT,NZVAR,NVAR,NSYMC,LINEAR
      COMMON /ZMTALT/ NZMAT2,NZVAR2,NVAR2,NZMTRD,ICOORD
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmolat/ untang(3),untorg(3),respbc(4),abclat(3),anglat(3),
     *                symtra(3,24),symope(3,3,24),iatorg,nsymop,maxklms,
     *                ioporg(3),iopdir(3),iopabc(3),iopang(3)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      common /fmopmd/ fmobox(3),mdwpbc,nimgcell,imglvl,
     *                ltrvec,lfmogctr,lfmoctmp,lindatmd,lwrkdsav,lindxiu
     *               ,IPBCFST
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo,ifmobas,itmfmo(2)
      common /fmoshl/ fzan(MXAFMO),fEX(MXGFMO),fC(MXGFMO,MAXL),
     *                LSTART(MXSFMO),LATOM(MXSFMO),LTYPE(MXSFMO),
     *                LNG(MXSFMO),LMIN(MXSFMO),LMAX(MXSFMO),llay(MXAFMO)
     *               ,lmptyp(mxafmo),lzcore(mxafmo),lshell,natl,numl
      COMMON /EFPFM2/ TOTEFPC,poltot,labfldt,ldindf2,ldinddf2,ldelabfld,
     *                ldeldind,ldeldindd,LALCNT2F
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
      COMMON /SCYVEC/ IDFYVEC,LIPTYVEC,LIPTYA
      COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
      common /ppcpnt/ lddijpot,lzppcpot,lvipot,lgrdtest
      COMMON /MASSES/ ZMASS(MXATM)
      data dbgfmo/8HDBGFMO  /,debug/8HDEBUG   /
      data rnone/8HNONE    /,POINTS  /8HPOINTS  /,cochrg/8HCOCHARGE/
      data OPTMIZ /8HOPTIMIZE/, SADPT  /8HSADPOINT/,GRAD/8HGRADIENT/,
     *     OPTFMO/8HOPTFMO  /,CHECK/8HCHECK   /,
     *     rohf/8HROHF    /,energy/8HENERGY  /,
     *     fmo0/8HFMO0    /,PDC/8HPDC     /,CNONE /8HNONE    /,
     *     GLOBOP /8HGLOBOP  /,HSSIAN/8HHESSIAN /,AIRC   /8HIRC     /,
     *     FMOHESS/8HFMOHESS /,FMOMD /8HMD      /,RAMAN  /8HRAMAN   /,
     *     UHF/8HUHF     /
      data nelm/0,3,9,19/
      equivalence(enucfmo,etfmo(1)),(e1efmo,etfmo(2)),(ekinfmo,etfmo(3))
c
c     this is the main FMO driver.
c
c     Some funding for the development of this FMO code came from
C     the Next Generation SuperComputing project of MEXT, Japan.
c
c     modef: GAMESS interface mode
c     0: run single point FMO energy and optionally gradient (ENERGY,GRADIENT)
c        (no interface with the rest of GAMESS)
c     1: run optimisation or saddle point GAMESS engines(OPTIMIZE,SADPOINT)
c        (coord.+grad. are interchanged)
c     2: run optimisation or saddle point (OPTFMO) using FMO specific engines
c        (no interface with the rest of GAMESS)
c
c     modef=1 requires that the number of atoms be supported by GAMESS.
c     Coordinates will be, however, read from $FMOXYZ, not from $DATA.
c
c     parstat: parallelisation status:
c     consists of two words:
c     1st: scope: Global (all nodes), Group (one group), Node (one node)
c     2nd: parallelisation within that scope (Full,None,Bcast)
c     GroupFull implies both levels parallelisation (inter and intra-group)
c     In some cases parallelisation is changed by an input option, in which case
c     both choices are shown.
c     Bcast means the master(s) broadcast(s) accumulated data unto the plebs.
c
c     NEVALS is the ruthless wight raking weeks of debugging time.
c     Its intricate delicacy of coexisting with FMO is a tale to be told.
c     Among the victims is the RMS based convergence criteria in RHF
c     that devoured one week of exclusive debugging in October 2003.
c     Insanity will lurk in the shadow the moment you endevour touching it.
c
c     Note on FMO-ROHF: it is implemented using MCSCF drivers.
c
C     Unfortunate bit of hacking to make multiple FMO
C     calculations work with ML-GDDI.  The only way
C     I have gotten each instance of FMO to know what
C     state/group it is supposed to be working on/in is
C     to pass the state/group number through MODEFF.
C     Other suggestions are welcome.      
C
      call stopwa(10,0)
      call timit(1)
c     
      CALL DERCHK(NDER)
c     CHECKING FOR $RMD, SETTING IRMDFMO
      irmdfmo=0
      CALL CHECKRMD(NFG,IRMDFMO)

      some=(exetyp.eq.debug.or.exetyp.eq.dbgfmo).and.maswrk
      ifmostp=0
      norbproj=0
c     norbproj is the number of orbitals projected out in FMOHOP
c     we are assuming to be in the world scope now to set dimensions properly!
      nprocg=nproc
      if(isgddi) nprocg=npglob
      ngrmax=nprocg
      mfrzs=mfrz
c     Care should be taken to set ngrmax for DDI (now it works).
      natbuf=0
      nscf1=0
c
c     Pretend that FMO0 run is RUNTYP=energy from now on and save modef.
c
      tddftyps=tddftyp
      MONOC1=0
      MONVR1=0
      cityps=cityp
      ilocals=ilocal
      runtyps=runtyp
      scftyps=scftyp
c
      if(runtyp.eq.fmo0) then
        runtyp=energy
        ifgfmo0=modeff
        squit=modeff.eq.0
        modef=0
        modefb=0
        if(ifgfmo0.eq.0) maxcbs=0
c       inifmo0=nfg.eq.1
        inifmo0=maxcbs.eq.0
        if(.not.inifmo0) modefb=1
c       This is a bizarre solution to force storing $DATA's basis set in
c       fmosavb only the first time FMOX is called.
c       No ES moments
        nevsav=0
c       No restarts
        isgddi0=.false.
c       no GDDI parallelisation inside FMOX because it is done in FMO0X.
      else
        ifgfmo0=0
        inifmo0=.false.
        modef=modeff
        modefb=modeff
        nevsav=nevals
        isgddi0=isgddi
      endif
c
c     ONLY IF IRMDFMO.EQ.1 DO WE TOUCH MODEF
      if(irmdfmo.eq.1) then
         if(modef.eq.0) then
            irmdfmo=-1
            ISTLOOP=1
         elseif(modef.eq.1) then
            ISTLOOP=1
         else
            ISTLOOP=MODEFF
            MODEF=1
         endif
      endif
c
      nzmtsav=nzmat
      if(modef.ne.0) nzmat=0
c     zero out nzmat to prevent GRADX from converting the gradient into
c     internals for each fragment: it will be done later.
      savdsk=DSKWRK
      savdir=dirscf
      if(isgddi) then
        grandmas=meglob.eq.0
      else
        grandmas=maswrk
      endif
      IESDPPC = 0
      if(modef.eq.1) then
c
c         Try broadcasting the coordinates to slay the macabre converge-me-not
c         (suspected artefact of mixed node (GDDI only?) parallelisation).
c         This has to be done in the world scope (by any chosen node).
c         Note that inidfmo will broadcast initial densities/populations/
c         charges so everything will be ghastly synchronised.
c         modef=1 restricts this bcast to optimisation runs only (OPTIMIZE).
c
c        write(6,*) 'wwwbcasting',nat
         call ddi_bcast(2422,'F',C,3*nat,0)
      endif
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $STONE ',IEOF)
      IF(IEOF.EQ.0) NPTSTN=1
c     To force the calculation of Stone analysis that might be else skipped.
      dopdc=iepot.ne.0.and.ELPLOC.EQ.PDC.and.CONSTR.NE.CNONE
c     if(dopdc) call abrt
c
C      write(6,*) 'wwwscope',ISCOPE
      CALL ERIPRE
c
      if(isgddi0) call gddi_scope(ddi_group)
c
c     In some cases GDDI will call this subroutine for the first time
c     by some nodes in a group but not all, later in SCF.
c     Then the broadcasts in ERIPRE will fail.
c     So call now and avoid a deadlock later.
c
c     save integral packing options
c
      labsix=labsiz
      nintix=nintic
      IF (DFTBFL.AND.IDFTBD.NE.0) DC = .TRUE. !! UFF/SK(HP)
      IF (DFTBFL.AND.DC.AND.IDFTBD.EQ.0) IDFTBD = 3 !! DFT-D
      dcsav=dc
      idcvers=idcver
c
c     Initialize FMO-TDDFT properties
c
      call vclr(eexcit,1,mxrt*2)
      call vclr(osmd,1,mxrt*2)
      call vclr(texcit,1,3*mxrt*2)
      call viclr(monoc,1,mxrt)
      call viclr(monvr,1,mxrt)
      call viclr(isumd,1,mxrt+1)
      nstmono=0
c
c     FMO has its own coordinate and basis set input.
c     First get the dimensions.
c
      nbody=0
      maxl1c=0
c     maxbas=1
c     qmmm is set in LINKIN or OPTFMO, the latter wants to set maxbas elsewhere
      if((runtyp.ne.optfmo.and.runtyp.ne.fmohess).or..not.qmmm) maxbas=1
c     if(qmmm) call abrt
      n0bda=0
      mconvex=10
c     natl and numl are substituted by "1", since they are not used with
c     imode=1.
      icurunt=0
      nactfg=0
      call fmominp(1,nder,ifgfmo0,idum,idum,dum,idum,idum,dum,dum,dum,
     *             dum,dum,idum,dum,nacut,modmol,idum,idum,lbody,
     *             gcorrel,fmoq,iexcit,exfid,modcha,dum,idum,nactfg)
      call fmopinp(1,idum,mcnvfmo,mconvex,idum,idum,ngrfmo,prtdst,ncvscf
     *            ,1,1,idum,idum,ngrmax,savgrd,loadbf,loadgr,l1dir,ngm,
     *             vdwrad,grdpad,mpcmit,convpcm,pcmoff,imect,n0bda,0,
     *             dum,dum,dum,0,dum,eint0,rappri,irestl,naoafo,modcnv)
      nfgsav=nfg
      ntimout=0
      dopleda=ipieda.ne.0.and.irststp.eq.2.and.mxitfg.eq.1
     *        .and.n0bda.eq.0
      doscfprp=iand(ixesp,2048).ne.0
      ext2lay=iand(ixesp,64).ne.0
      if(ext2lay.and.nfmopcm.ne.0) then
c       It is quite easy to support, just set up nbody properly.
        if(maswrk) write(iw,*) 'This run is not supported.'
        call abrt
      endif
      idoprop=1
c
c     This is a weird run, that can be called
c     FMO3-RHF/FMO2-RHF:MP2, that is, correlated contribution for a part
c     of the system is added to the full uncorrelated energy.
c     Note this is not the same as FMO3-RHF:FMO2-MP2, since in the latter
c     no 3-body RHF terms are added to the 2-nd layer.
c
      ne0bda=0
      nepl0=0
      if(n0bda.ne.0) then
         ne0bda=n0bda
      else
        if(ipieda.ne.0) then
          ne0bda=nfg*2
          nepl0=nfg*3
        endif
c       it should have been nbdfg, but the latter is unknown yet.
c       guess nbdfg=nfg*2. ne0bda is only used for allocation/reading.
      endif
c
      if(ifgfmo0.ne.0.and.nbody.gt.1.and.isgddi) then
c       It is easy to do so, just replace more isgddis by isgddi0 below.
c       What one really wants to say here is why one wants to
c       run FMO0 with nbody>1 for?
        write(iw,*) 'GDDI is not permitted with FMO0 and nbody>1'
        call abrt
      endif
      if(n0bda.ne.0.and.isgddi.and.ngroups.gt.1) then
c       trap BDA runs which are not fully GDDI parallelised.
        write(iw,*) 'Set ngroups=1 and rerun.'
        call abrt
      endif
      if(n0bda.ne.0.and.nlayer.gt.1) then
        write(iw,*) 'Split layers and run separately.'
        call abrt
      endif
c
      if(nder.gt.0.and.irststp.ge.4.and..not.savgrd) then
        if(maswrk) write(iw,9410)
        call abrt
      endif
      if(nfmopcm.ne.0.and.irststp.gt.2) then
        if(maswrk) write(iw,9440)
        call abrt
      endif
C     if(dftbfl.and.nder.gt.0.and.iand(modgrd,32).ne.0) then
C       if(maswrk) write(iw,*) 'For DFTB SCZV is not available.'
C       call abrt
C     endif
      if(dftbfl.and.resppc(1).eq.0) then
        if(maswrk) write(iw,*) 'For DFTB resppc must be nonzero.'
        call abrt
      endif
C     if(dftbfl.and.modorb.ne.0.and.nder.gt.0) then
C       if(maswrk) write(iw,*) 'For DFTB set modorb=0'
C       call abrt
C     endif
      if(dftbfl.and.nbody.eq.3.and.iand(modesd,6).ne.0) then
        if(maswrk) write(iw,*) 'THE MODESD OPTION CANNOT BE COMBINED',
     *                         ' WITH FMO3.'
        if(maswrk) write(iw,*) 'SET MODESD=0 in $DFTB.'
        call abrt
      endif
      LGLOE  = .NOT.MCMIN.AND.RUNEFP.EQ.GLOBOP
      LGLOEG = MCMIN.AND.RUNEFP.EQ.GLOBOP
c
      nfthes=38
      if(runtyp.eq.OPTMIZ.or.savgrd.or.LGLOEG.or.
     *   runtyp.eq.hssian.or.runtyp.eq.sadpt) then
        if(savgrd) dskwrk=.true.
c       This is a somewhat dangerous practice of not opening a file
c       on slaves.
        if(meglob.eq.0.or.savgrd) then
          CALL SEQOPN(NFThes,'HESSIAN','UNKNOWN',.FALSE.,'UNFORMATTED')
          CALL SEQREW(NFThes)
        endif
        if(savgrd) dskwrk=savdsk
      endif
      mulgeom=runtyp.eq.OPTMIZ.or.runtyp.eq.sadpt.or.runtyp.eq.optfmo
     *        .OR.RUNEFP.EQ.FMOMD.OR.LGLOEG.OR.RUNTYP.EQ.FMOHESS
     *        .OR.runtyp.eq.AIRC.OR.RUNTYP.EQ.RAMAN
c     We cannot check if doing not analytic Hessian here (but it is implied).
      mdout=iand(modio,16).eq.0
c     mdout=runefp.ne.fmomd.or.iand(modio,16).eq.0
      mdoutmin=iand(nprfmo,3).ne.3
c     mdoutmin=runefp.ne.fmomd.or.iand(modio,1024).eq.0
c     mdout and mdoutmin are called MD for historic reasons.
c
c     nbasis=1
      ifmobas=0
c
c     Scan $FMOXYZ to find natfmo.
c
cnb   Do only for the first point during optimisation (maxbas?)
c
      if(.not.qmmm .or. runtyp .ne. optfmo ) then
         if(.not.(runtyp.eq.fmohess.and.qmmm)) then
          if(qmmm) then
           CALL TINKIN(IR,IW)
           ICOORD=5
           CALL LINKIN(1)
           CALL TOPTIN
           natfmo=nseq+npair
c          write(6,*) "www check fmoxyz",QMMM
          else
           call fmoxyz(' $FMOXYZ',1,natfmo,dum,dum3,idum)
          end if
         end if
c        if(ndualb.ne.0) maxbas=nbasis
      endif
c     write(6,*) 'Prescan',natfmo,maxbas
c     ifgfmo0=0 is a special run to read in constant array size options in $FMO.
      if(runtyps.eq.fmo0.and.ifgfmo0.eq.0) goto 5556
c     if(ifgfmo0.gt.nfg) goto 5556
c
      dosap=respap(1).ne.zero.or.respap(2).ne.zero
      dospc=resppc(1).ne.zero.or.resppc(2).ne.zero
      esdder=nder.gt.0.and.iand(ixesp,32).eq.0.and.resdim.ne.0
      modQbas=nfg.ne.0.and.iand(ixesp,128).ne.0
      atonce=iand(modpar,4).ne.0
      broadden=iand(modpar,64).ne.0.and..not.savgrd
c     broadden does not work with MFMO?! -> bug?
      dodistr=iand(modpar,512+1024).ne.0
      dodiff=iand(modesp,128).ne.0
      if(dodiff.and.dosap) call abrt
      primul=dospc.and.iand(nprfmo,8).ne.0
      outesd=iand(nprfmo,128).eq.0
      outpune=(.not.mulgeom.or.iand(nprfmo,3).eq.0).and.maswrk
c     PLEDA runs do not produce meaningful Mulliken populations
c     however, CT is OK? So stop printing just the charges.
      orbxch=mod(modorb,2).ne.0
      enexch=mod(modorb/2,2).ne.0
      totdens=iand(modprp,1).ne.0
      densgrid=iand(modprp,4).ne.0
      spargrid=iand(modprp,8).ne.0
      mepgrid=iand(modprp,32).ne.0
      spinden=iand(modprp,128).ne.0
      totfock=iand(mofock,1).ne.0
      domeppcm=mepgrid.and.nfmopcm.ne.0.and.iand(modprp,2048).ne.0
     * .and.densgrid
      LSCZVEC = NDER.GT.0.AND.IAND(MODGRD,32).NE.0
      if(totfock.and.iand(modesp,32).ne.0.and.iand(mofock,2).ne.0) then
        write(iw,*) 'modesp=32 and mofock=2 cannot be used together.'
        call abrt
      endif
      if(totfock.and.nbdfg.ne.0) call abrt
      if(densgrid.and.spargrid) then
        write(iw,*) 'Either bit 4 or 8 may be set in modprp, not both!'
        call abrt
      endif
      densgrid0=densgrid.and.nbody.eq.0
      spargrid0=spargrid.and.nbody.eq.0
      round10=iand(modprp,1024).ne.0
      if(spargrid.and.nbody.gt.2) call abrt
      if(modfd.ne.0.and.(nlayer.ne.2.or..not.mulgeom.or.broadden)) then
         if(maswrk) write(iw,*) 'Unsupported FD run.'
         call abrt
      endif
      if(modfd.ne.0.and.dodistr.and.runtyp.eq.hssian) call abrt
c     broadden for FMO/FD would require a separate exchange of layer 2 densities
      exclmol=iand(modmol,2).ne.0
      subsys=iand(modmol,8).ne.0
      if(subsys.and.nbsse.ne.0) call abrt
      needr=0
c     If(dosap.or.dospc.or.resdim.ne.zero) needr=1
      If(dosap.or.dospc.or.resdim.ne.zero.or.rcorsd.ne.0) needr=1
      needr2=0
c     If(dosap.or.dospc) needr2=1
c     The definition below ignores the secret 2nd option but is suitable
c     for delivering 3-body Mulliken charges.
      if(respap(1).ne.zero.and.respap(1).lt.1.0D+03.or.
     *   resppc(1).ne.zero.and.resppc(1).lt.1.0D+03) needr2=1
      if(nbody.gt.2.and.(restri(1).ne.0.or.restri(2).ne.0.or.
     *   restri(3).ne.0.or.restri(4).ne.0)) needr=1
      if(modfd.ne.0.and.needr.eq.0) then
         if(maswrk)
     *     write(iw,*) 'Use some threshold, e.g., RESDIM=1000'
         call abrt
      endif
      mbody=max(nbody,1)
      nfg2=(nfg*nfg-nfg)/2
      nfg3=(nfg*nfg*nfg-3*nfg*nfg+2*nfg)/6
      if(nbody.lt.2) nfg2=0
      if(nbody.lt.3) nfg3=0
c     For exclmol the total properties and even delta-E info is probably
c     not valid (except some limit cases). At present avoid allocating
c     any nfg3 storage for nbody=3 and exclmol, although the same can be
c     done for nbody=2 too.
      if(exclmol.and.iand(modmol,4).ne.0) nfg3=0
c     nfg2 and nfg3 ARE NOT always larger than nfg (nfg2)!!
      nnfg=nfg
      if(nbody.ge.2) nnfg=max(nnfg,nfg2)
      if(nbody.ge.3) nnfg=max(nnfg,nfg3)
      nc1=natfmo*3
      nfcrec=4
      needdm=nfg3.ne.0.and.needr2.ne.0.and.iand(IXESP,2).eq.0.and.
     *       iand(IXESP,8192).ne.0
c     check if we need to exchange dimer densities.
c     the purpose to use needr2 rather than needr is to force dimer density
c     exchange only when it is really needed, that is, when monomer and
c     dimer approximations are used, but not when only trimer ones are in use.
c     needr forces computation of distances for any approximation.
c     Do not use density matrices for the economy mode (exclmol+nbody=3),
c     which is probably reasonable.
c
      loadhf=mod(modpar,2)
      savemem2=iand(modpar,32).ne.0.and.nfmopcm.eq.0
     *         .and.ndualb.eq.0.and.nbody.eq.2.and..not.ext2lay
     *         .and.ipieda.eq.0.and.nbsse.eq.0.and.irststp.le.2
c    *       .and.ndualb.eq.0.and..not.(dolat.or.dopbcmd).and.nbody.eq.2
      savemem=iand(modpar,32).ne.0.and..not.needdm.and.nfmopcm.eq.0
     *         .and.nbody.eq.3
c    *        .and.ndualb.eq.0
      savememr=needr.ne.0.and.maxrij.gt.0.and.nbody.eq.2.and.resdim.ne.0
     *         .and.(resdim.eq.resppc(1).or.resppc(1).eq.0)
     *         .and.(resdim.eq.respap(1).or.respap(1).eq.0)
     *         .and.(resdim.eq.rcorsd.or.rcorsd.eq.0)
c    *         .and.(resdim.eq.rcorsd.or.rcorsd.eq.0).and.loadhf.eq.0
c     if(savemem.and.loadhf.eq.1) loadhf=2
      skipsort=nacut.ne.0
      if(savememr.and.loadhf.eq.1.and.nlayer.gt.1) call abrt
      outpune=outpune.and..not.savemem2
      if(maswrk.and.(savemem.or.savemem2).and.mdoutmin)
     *  write(iw,*) 'Memory will be saved in energy arrays.'
      if(maswrk.and.savememr.and.mdoutmin)
     *  write(iw,*) 'Memory will be saved in distance arrays.'
c
      addesp=iand(modesp,4).ne.0
      addesp0=addesp.and.(iand(modesp,8).ne.0.or.needr.eq.0)
c     If distances are unavailable, use ADDESP for all dimers.
      diffesp=iand(modesp,16).ne.0
      iskipesp=0
      if(iand(ixesp,16384).ne.0) iskipesp=2
c
      if(nzmtsav.GT.0) then
        NC1 = NVAR
        nfcrec=43
      endif
      if (IEFPFMO.NE.0.AND.MOVE.NE.0) NC1 = NC1 + 6*NFRG
      mfg2=(nfg*nfg-nfg)/2
c     nfg2 cannot be used for NBODY=1, although distances may be needed, NFG2=0
      if(savememr) mfg2=(maxrij*nfg-1)/nwdvar+1
c     mfg2=nfg2
c     if(dolat) mfg2=0
c     dolat is undefined, and rij is allocated some space which is wasted
c     for lattice runs (as it is reallocated below).
c
c
c
      CALL VALFM(LOADFM)
      llibish=LOADFM+1
      llibnsh=llibish+(MAXNZ*maxbas*nlayer-1)/nwdvar+1
      llibng=llibnsh+(MAXNZ*maxbas*nlayer-1)/nwdvar+1
      last=llibng+(MAXNZ*maxbas*nlayer-1)/nwdvar+1
      NEED0 = LAST- LOADFM -1
c     write(6,*) 'wwwmem0',need0,MAXNZ,maxbas,nlayer,nwdvar
      CALL GETFM(NEED0)
c       assume single-zeta up to d (s+p+d=9)
c     if (dftbfl) maxcbs=9
      call fmosavb(modefb,x(llibish),x(llibnsh),x(llibng))
      maxgrs=inamax(maxpst*nlayer,loadgr,1)
      semidyn=isgddi0.and.loadhf.ne.0.and.jbtyp.gt.0
     *        .and.loadgr(maxgrs,1).ne.0
      nlmoset=1
      if(modQbas) nlmoset=3
c     one element of lfmoc is used for the centre of the molecule
c     nhybnam=nlayer+1
      nhybnam=nlayer
      if(ndualb.gt.0) nhybnam=nlayer*2
      if(ndualb.gt.0.and.nbody.gt.2.and.needdm) call abrt
      if(ndualb.gt.0.and.IEFPFMO.gt.1) call abrt
c     It seems that vacuum runs cannot be used with IEFPFMO=2.
c     One could design a mixed mode, IEFPFMO=1 for vacuum and
c     IEFPFMO=2 for embedded?
c     if(rflmo(1).ne.0) nhybnam=0
c
      CALL VALFM(LOADFM)
      lichfg=LOADFM+1
      lmulfg=lichfg+(nfg-1)/nwdvar+1
      lnumfrg=lmulfg+(nfg-1)/nwdvar+1
      if(SCFTYP.eq.UHF.or.SCFTYP.eq.rohf)
     *   lnumfrg=lmulfg+(2*nfg-1)/nwdvar+1
      lfrgnam=lnumfrg+(nfg+1-1)/nwdvar+1
      llayfrg=lfrgnam+nfg
      lindat=llayfrg+(nfg*2-1)/nwdvar+1
c     lindat gets extra nfg+1 data to accomodate 0-terminated style.
c     It seems that for some extravagant use this extra grace space is
c     insufficient...
      lindtmp=lindat+(natfmo+nfg*2+1-1)/nwdvar+1
c     last=lindtmp+(natfmo-1)/nwdvar+1
c     indtmp is used also as real (hardness)
      last=lindtmp+natfmo
      LNQMTFG = LAST
      LAST    = LNQMTFG + (NFG-1)/NWDVAR + 1
      if(runtyp.ne.optfmo.AND.RUNTYP.NE.FMOHESS.and.
     *   (RUNefp.ne.fmomd.or.modef.eq.0)) then
        lfmozan=last
        lfmoc=lfmozan+natfmo
        lfmomas=lfmoc+3*(natfmo+1)
        lizbas=lfmomas+natfmo
        last=lizbas+(natfmo-1)/nwdvar+1
c       Otherwise the memory is allocated in OPTFMOX, FMOHESSX and MDX.
      endif
c     lnCBS=lidxCAO+(MaxBnd*(nlayer+1)-1)/nwdvar+1
      liaglob=last
      liabdfg=liaglob+(MXATM-1)/nwdvar+1
      ljabdfg=liabdfg+(MaxBnd-1)/nwdvar+1
      lidxCAO=ljabdfg+(MaxBnd-1)/nwdvar+1
      lnCBS=lidxCAO+(MaxBnd*(nhybnam+2)-1)/nwdvar+1
      lnCAO=lnCBS+(MaxKnd-1)/nwdvar+1
      liaprjo=lnCAO+(nlmoset*MaxKnd-1)/nwdvar+1
      ljaprjo=liaprjo+(MaxCAO*MaxKnd-1)/nwdvar+1
      lCoreAO=ljaprjo+(MaxCAO*MaxKnd-1)/nwdvar+1
      lOccCor=lCoreAO+MaxCBS*MaxCAO*nlmoset*MaxKnd
      lshiftb=lOccCor+MaxCAO*MaxKnd
c          2's permit true-f77 style character/hidden length storage
      ltaotyp=lshiftb+2*MaxCAO*MaxKnd
      ltaotypi=ltaotyp+2*MaxKnd
      ljobgrp=ltaotypi+nhybnam
      lemon=ljobgrp+(nfg+1-1)/nwdvar+1
      lglocon=lemon+nfg*4*nlayer
      lidmrec=lglocon+ngrmax
      lmpfmo=lidmrec+(nlayer-1)/nwdvar+1
      lfmodft=lmpfmo+(nlayer-1)/nwdvar+1
      lmaxl30=lfmodft+nlayer
      litrlay=lmaxl30+(nfg-1)/nwdvar+1
      lscffrg=litrlay+(nlayer-1)/nwdvar+1
      lfmoscf=lscffrg+nfg
      lfmoci=lfmoscf+nlayer
      lfmocc=lfmoci+nlayer
      lfmotd=lfmocc+nlayer
      llcorrel=lfmotd+nlayer
      lijvec=llcorrel+(nlayer-1)/nwdvar+1
      lmannod=lijvec+(5*maxvec-1)/nwdvar+1
      lmolfrg=lmannod+(ngrmax*maxpst*nlayer-1)/nwdvar+1
      lmastid=lmolfrg+(nfg-1)/nwdvar+1
      lmconfg=lmastid+nprocg
      libfconv=lmconfg+(nfg+mconvex*4-1)/nwdvar+1
      lmapconv=libfconv+(2*natl-1)/nwdvar+1
      lnprfrg=lmapconv+(natl*numl-1)/nwdvar+1
c     lmapconv's real dimensions are unknown. At most natl*numl will be
c     read and processed.
      lr0bda=lnprfrg+(nfg-1)/nwdvar+1
      le0bda=lr0bda+ne0bda
      lefmo0=le0bda+4*ne0bda*nlayer
      lepl0ds=lefmo0+ne0bda*nlayer
      latchrg=lepl0ds+nepl0
      leaip=latchrg+natfmo+nbdfg
      lrwrk=leaip+nfg*2
      last=lrwrk+nfg
      if(savememr) last=lrwrk+nfg*2
      lloadm=last
      reuses=irststp.lt.4.and.needr.ne.0.and.loadhf.eq.1.and.nbody.eq.2
     *       .and.nfg.gt.2.and.nlayer.eq.1.and.ndualb.eq.0
     *       .and..not.savememr
c     reuses=irststp.lt.4.and.needr.ne.0.and..not.semidyn.and.nbody.le.2
c    *       .and.nfg.gt.2..and.dftbfl
      reducee=iand(nprfmo,3).ge.2.and.iand(nprfmo,128).ne.0.and.dftbfl
     *        .and..not.savemem2.and.nbody.ne.3
     *        .and.(nfmopcm.eq.0.and.iand(modesd,2).eq.0)
c     if(maswrk) write(6,*) 'reuse sort array',reuses,reducee
      if(savememr.and.loadhf.eq.1) then
        nloadd=maxrij*nfg
        nloaddw=nfg*2+maxrij*nfg*2
c       a big overkill; both should be nscf
        if(skipsort) nloaddw=nfg*2
      else if(loadhf.eq.1) then
        nloadd=nfg2
        nloaddw=nnfg
      else
        nloadd=0
        nloaddw=0
      endif
      if(loadhf.gt.0) then
        lloadd=lloadm+(nfg-1)/nwdvar+1
        liwrkd=lloadd+(nloadd-1)/nwdvar+1
        last=liwrkd+(nloaddw-1)/nwdvar+1
        if(reuses) then
          last=liwrkd
        endif
      else
        lloadd=last
        liwrkd=last
      endif
      lrij=last
      if(needr.ne.0) then
        last=lrij+mfg2
      else
c       lrwrk=last
      endif
      lifgbuf=last
      if(atonce) then
        lnfgbuf=lifgbuf+(2*nfg*ngrmax-1)/nwdvar+1
        last=lnfgbuf+(2*ngrmax-1)/nwdvar+1
      else
        lnfgbuf=last
      endif
      lloadt=last
      if(nbody.gt.2.and.loadhf.eq.1) last=lloadt+(nfg3-1)/nwdvar+1
c
      lnoffg=last
      if(spargrid) then
        lindgrd=lnoffg+(nfg-1)/nwdvar+1
        last=lindgrd+(6*nfg-1)/nwdvar+1
      else
        lindgrd=last
      endif
c     emocdr has three parts: emocdr(7,nfg)
c     emocdr(1) is the monomer cavitation energy
c     emocdr(2) is the monomer dispersion energy
c     emocdr(3) is the monomer repulsion energy
c     emocdr(4) is the monomer cavitation surface
c     emocdr(5) is the monomer dispersion (repulsion) surface
c     emocdr(6) is the monomer electrostatic surface
c     emocdr(7) is the cavity monomer induced charge (ASC)
c     and emocdr(2,nfg2)
c     emocdr(1) is the dispersion contribution to PIE of dimer IJ
c     emocdr(2) is the repulsion contribution to PIE of dimer IJ
c     and emocdr(3,natfmo)
c     emocdr(1) is the surface area of atomic cavity
c     emocdr(2) is the surface coverage of atomic cavity
c     emocdr(3) is the charge of atomic cavity
c
      lemocdr=last
      necdr=7*nfg
      if(nbody.gt.1) necdr=necdr+2*nfg2
      if(nfmopcm.eq.0) necdr=0
      lemocdra=lemocdr+necdr
      if(nfmopcm.ne.0) necdr=necdr+3*natfmo
      if(nfmopcm.ne.0) last=lemocdr+necdr

      liactfg=last
      last=liactfg+(nfg*2-1)/nwdvar+1
      liactat=last
      lenucfg=last
      if(modfd.ne.0) then
        lenucfg=liactat+(natfmo-1)/nwdvar+1
        last=lenucfg+nfg
      end if
c     if(modfmm.ne.0) call abrt
      lylmfrgq=last
      lylmfrgq2=last
c
c     We should set Np, the highest angular momentum l of multipole
c     calculation on the basis of accuracy requirements.
c
c     The proper number of Np requires some thoughts.
c     The convergence of multipole expansion strongly depends on SD
c     (shortest distance between fragments) and CD (the center to center
c     distance between fragments). As SD/CD gets smaller, the multipole
c     expansion converges more quickly requiring less terms for multipole
c     calculations.
c     If SD/CD is less than 1/2, Np=20 is good enough to have the accuracy
c     of 1D-10 or less.
c
c     np=20
      lesdi=last
      if(modfmm.ne.0) then
c       if(iand(modfmm,4+16+32).ne.0) call abrt
        if(resdim.eq.0.and.nbody.gt.1) then
          if(maswrk) write(iw,*) 'RESDIM=0 is not implemented.'
          call abrt
c         ESDDERZ does not work with it.
        endif
        if(iand(modfmm,4).ne.0.and.(respap(1).ne.0.or.resppc(1).ne.0))
     *  then
          if(maswrk) write(iw,*) 'Set RESPAP=0 and RESPPC=0'
          call abrt
        endif
        if(iand(modfmm,8).ne.0.and.(respap(1).gt.0.or.resppc(1).gt.0))
     *  then
         if(maswrk) write(iw,*) 'Use uniform (.le.0) RESPAP and RESPPC.'
          call abrt
        endif
        call qfmmin
c       lylmfrg=lcrfrg+4*ncentm*nfg
c       lzlmfrg=lylmfrg+(NP+1)*(NP+2)*ncentm*nfg
c       lesdi=lzlmfrg+(NP+1)*(NP+2)*ncentm*nfg
        last=lesdi+nfg
        if(iand(modfmm,8).ne.0) then
          lylmfrgq=last
          lylmfrgq2=lylmfrgq+(NP+1)*(NP+2)*nfg
          last=lylmfrgq2+(NP+1)*(NP+2)*nfg
        endif
        lf_mm=last
        lg_mm=lf_mm+((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1))*8
        last= lg_mm+((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1))*8
      else
        lf_mm=last
        lg_mm=last
      endif
c
      LDEFTF=last
      LTORQF=last
      ndbfac=1
      if(IEFPFMO.NE.0) then
        if(ndualb.ne.0) ndbfac=2
        call efpmem(nder,last,needefp,ndbfac)
      else
        labfldt=last
        ldindf2=last
        ldinddf2=last
      endif
c
c     docns=wacns.ne.0
      CALL SEQREW(IR)
      CALL FNDGRP(IR," $CNS   ",IEOF)
      docns=ieof.eq.0
      exref=0
      lcnsdat=last
      if(docns) last=lcnsdat+3*natfmo
C     LFZCOR=last
c
C     CALL MCPFALOC(LAST)
      IF (IEACAL.EQ.1) CALL IEAMEM1(LAST)
c
      NEED = LAST- LOADFM -1
c     write(6,*) 'wwwmem',need
      CALL GETFM(NEED)
c
c     Electrostatic moments for all n-mers will be calculated for all points
c     the user asked for (if any) plus the centre of mass/charge of the
c     molecule. However, the total moments for the molecule will be computed
c     only for the last point.
c     Finally, for now there are no masses so only the centre of charge is
c     available!
      iwhere=0
      if(elmloc.eq.cochrg) iwhere=1
      if(iemom.eq.0) iwhere=-1
c     if(iwhere.eq.0) then
c       if(maswrk)
c    *    write(6,*) 'No masses available! using charges for $ELMOM.'
c       iwhere=1
c     endif
      ELMLOCs=ELMLOC
      ELMLOC=points
      if(modef.eq.0.and.(ifgfmo0.eq.0.or.inifmo0)) npoint=npoint+1
      if(npoint.gt.MXPTPT) then
        write(6,*) 'Too many ES points',MXPTPT
        call abrt
      endif
      if(modfmm.ne.0) then
c
c       Pre-computed values.
c
        CALL GETCLM(CLM)
        CALL GETFLM(FLM)
        call vclr(x(lesdi),1,nfg)
        if(iand(modfmm,8).ne.0)
     *    call vclr(x(lylmfrgq2),1,(NP+1)*(NP+2)*nfg)
      endif
c
      call fmominp(2,nder,ifgfmo0,x(lichfg),x(lmulfg),x(lfrgnam),
     *             x(llayfrg),x(lindat),x(lscffrg),x(lfmoscf),x(lfmoci),
     *             x(lfmodft),x(lfmocc),x(lmpfmo),x(lfmotd),nacut,modmol
     *            ,x(lmolfrg),x(lnprfrg),lbody,gcorrel,fmoq,iexcit,
     *             exfid,modcha,x(latchrg),x(liactfg),nactfg)
      call fmopinp(2,x(lmannod),mcnvfmo,mconvex,x(lmconfg),x(lijvec),
     *            ngrfmo,prtdst,ncvscf,natl,numl,x(libfconv),x(lmapconv)
     *            ,ngrmax,savgrd,loadbf,loadgr,l1dir,ngm,vdwrad,grdpad,
     *             mpcmit,convpcm,pcmoff,imect,n0bda,ne0bda,x(lr0bda),
     *             x(le0bda),x(lefmo0),nepl0,x(lepl0ds),eint0,rappri,
     *             irestl,naoafox,modcnv)
      mp2run=0
      if(gcorrel) mp2run=2
c     This is to pass gcorrel to FMO0X.
c     if(iand(modgrd,32).ne.0.and.
c    *  (gcorrel.or.nfmopcm.ne.0.or.IEFPFMO.ne.0)) call abrt
c
      if(iexcit(1).ne.0) then
        vibcoup=.false.
        do i=1,nfg
          if(iand(ixftch(x(lnprfrg),i),512).ne.0) vibcoup=.true.
        enddo
        if(vibcoup.and.maswrk) write(iw,*) 'Vibronic coupling...'
      endif
      qmcout=iand(nfmopal,8).ne.0
      nftqmc=ip
C
C     SRP: IF WE ARE DOING RMD DYNAMICS WE NEED TO GET THE
C          RELEVANT FRAGMENTATION SCHEME AND CHARGES
C
c     IF(MODEF.NE.0) THEN
      IF(MODEF.NE.0.AND.IRMDFMO.GT.0) then
        CALL GETRMDDAT(NATfmo,NFG,X(LINDAT),X(LICHFG),IRMDFMO,ISTLOOP)
      ENDIF
C
      if(nacut.ne.0) call fmoauto(nacut,x(lindat))
c
      if(qmmm) then
        if(runtyp .ne. optfmo.and.runtyp.ne.fmohess) then
         CALL TIN2fmo(natfmo,x(lfmozan),x(lfmoc),x(lizbas))
        end if
        if(ixftch(x(lindat),1).ne.0) then
c         in qmmm, only gaussian format of indat is allowed
          write(iw,9800)
          call abrt
        else
c         renumber atoms and generate indat data for LINK atoms
          call fmommind(natfmo+nfg*2+1,x(lindat),x(lindtmp))
        endif
      else
        if(ixftch(x(lindat),1).eq.0)
     *    call fmogind(natfmo+nfg*2+1,x(lindat),x(lindtmp))
      endif
      if(domeppcm) call abrt
      if(modfd.ne.0.and.nfmopcm.ne.0) call abrt
      if(qmmm.and.nder.eq.2) call abrt
c     Only layer 1 is checked whereas all should be.
      scfesp=iand(ixesp,8).ne.0
      if(scfesp.and.(iand(modpar,512+1024).eq.0.or.resppc(1).ne.0.or.
     *   ngrfmo(1,1).ne.0.and.ngrfmo(1,1).ne.nfg.or.nfmopcm.ne.0)) 
     *   call abrt
c
c     Convert van der Waals radii to Angstrom
c
      UNITS=0.52917724924D+00
      if(iand(nfmopal,1).ne.0) UNITS=0.529177249D+00
      call dscal(MAXNZ,one/UNITS,vdwrad,1)
c
      if(iand(modmol,1).ne.0.and.nder.gt.0) modmol=modmol-1
      if(RUNTYP.ne.GRAD) savgrd=.false.
c
c     check input consistency
c
      call fmocheck(nder,x(lmulfg),x(lscffrg),x(lfmoscf),x(lfmoci),
     *              x(lfmodft),x(lfmocc),x(lmpfmo),x(lfmotd),x(llcorrel)
     *             ,domp,dotd,doci,urohf,douhf,mpcmit,fmosym,nfmosym)
      doexc=dotd.or.doci
      dofddpcm=modfd.ne.0.and.nfmopcm.ne.0 
      dofret=dotd.and.iexcit(1).lt.0
c     write(6,*) 'wwwiii',modfd,nfmopcm,dofddpcm
      if(dofret) call abrt
c
      if(ext2lay) then
c       check if this run should be allowed.
        if(lbody(1).ne.3.or.lbody(2).ne.2.or.
     *     iand(ixftch(x(llcorrel),1),1).ne.0.or.
     *     iand(ixftch(x(llcorrel),2),1).ne.1) then
          if(maswrk) write(iw,*) 'Only FMO3-RHF/FMO2-MP2 is allowed.'
          call abrt
        endif
      endif
c
c     read MP2 group to get MPPROP if not done yet.
c
      MPTEST=.FALSE.
      if(mplevl.eq.0.and.domp) then
        if(runtyp.eq.OPTMIZ.or.runtyp.eq.sadpt.or.runefp.eq.fmomd) then
c         the ugly hack to pacify MP2INP during FMO-MP2 opt
          ne=int(ddot(nat,zan,1,one,0)+0.1D+00)
          na=ne/2
          nb=na
c         total charge and multiplicity are not used but
c         they are irrelevant as we care to have more NA orbitals than NACORE
          num=na+1
          nqmt=num
        endif
        CALL MP2INP(mptest)
      endif
c
c     if(nevsav.gt.0.and.iand(nguess,128).eq.0.or.i0bda.gt.1) irststp=2
c     if(nevsav.gt.0) coroff=0
      if(nevsav.gt.0) call dacopy(9,one,espsca,1)
c     Force monomer restart for geometry optimisations
c     Forbid using ESPSCA from the second geometry during optimisations
      if(MMONLY.or.QMMM) ICOORD =  5
      LINEAR=.false.
      if(modef.eq.0) then
        if(MMONLY.or.QMMM) then
          if(runtyp.ne.optfmo.and.nder.ne.2) then
c           if(maswrk) CLOSE(UNIT=IDAF,STATUS='DELETE')
c           call CLOSDA('DELETE')
c           CALL OPENDA(0)
c           CALL TIN2fmo(natfmo,x(lfmozan),x(lfmoc),x(lizbas))
            call analyze
            if(mmonly) return
          endif
c         LINEAR=.false.
        else
          call fmoxyz(' $FMOXYZ',0,natfmo,x(lfmozan),x(lfmoc),x(lizbas))
c         if(ndualb.ne.0) maxbas=nbasis
c         convert charges to populations
c         if(nbdfg.ne.0) call abrt
c         It is a small work to allow this. One should mend ghost charges.
          do iat=1,natfmo
            x(latchrg-1+iat)=x(lfmozan-1+iat)-x(latchrg-1+iat)
          enddo
        endif
      endif
      if(modfd.ne.0) call setmapfa(x(llayfrg),x(lindat),x(liactat),
     *                             x(liactfg),runtyp.ne.optmiz.or.
     *                             nevsav.eq.0.and.modef.eq.0,natbuf)
C
      CALL RAMS(TABM,2)
      if(modef.eq.0) then
        call fmorams(natfmo,x(lfmozan),TABM,x(lfmomas),0)
      endif
C    If you are calling FMO repeatedly from outside, use FMOX(1)
C    And the coordinate transfer is taken care of
C    The array of atom assignments to fragments is in IFMOID in GLOFMO
      if(modef.ne.2) then
          call gmsxyz(modef,nfthes,nc1,natfmo,x(llayfrg),x(lindat),
     *              x(lfmozan),x(lfmoc),x(lfmomas),x(lizbas),x(liactfg),
     *              nfcrec,nevsav,grandmas,nactfg,fmosym,nfmosym,squit,
     *              mdoutmin)
      else
c      if(runtyp.eq.optfmo) that is always true for modef=2
       squit=.false.
      endif
c     DO IAT=1,NATfmo
c        AU2ANG = 0.52917724924D+00
c        Xccc = AU2ANG * x(lfmoC+(IAT-1)*3)
c        Yccc = AU2ANG * x(lfmoC+(IAT-1)*3+1) 
c        Zccc = AU2ANG * x(lfmoC+(IAT-1)*3+2)
c        if(maswrk) WRITE(IW,3456) Xccc,Yccc,Zccc
c3456 FORMAT(1X,3F15.10)
c     ENDDO
c
      call shiftxyz(x(lindat),x(lfmozan),x(lfmoc),x(lnprfrg),nprfmo)
c
c     call prsq(x(latchrg),natfmo,1,1)
c
      if(modef.ne.0) then
c       CALL RAMS(TABM,2)
        call fmorams(natfmo,x(lfmozan),TABM,x(lfmomas),0)
      endif
      call fmocinp(x(lfmozan),x(lfmoc),x(lfmomas),dolat)
C
      IF(modef.eq.0.and.(runtyp.eq.AIRC.OR.RUNTYP.EQ.RAMAN)) THEN
        IF(modfd.eq.0) then
          call dcopy(natfmo,x(lfmomas),1,zmass,1)
        ELSE
          natm=0
          DO IATM=1,natfmo
            ifg=ixftch(x(lindat),iatm)
c           write(6,'("check=",3I4)') iatm,
c    *        ixftch(x(lindat),iatm),ixftch(x(llayfrg),ifg)
            if(ixftch(x(llayfrg),ifg).gt.1) then
              natm=natm+1
              zmass(natm)=x(lfmomas+iatm-1)
            end if
          END DO
c         write(6,*) "natm =",natm
        END IF
      END IF
C
C
      IF (IEACAL.EQ.1) THEN
        CALL EFFMOIN(2,X(LIPFMO),X(LIPEFP),X(LIOFMO),X(LIOEFP))
      END IF
c
c     read $FMOMD group and check if PBC is applied.
      call fmomdin(dopbcmd,mdxcalled,0)
      if(dopbcmd) call fmoboxmk(x(lfmoc),x(lindat),natfmo,nfg)
      if(dolat.and.dopbcmd) call abrt
      if((dolat.or.dopbcmd.or.IEFMORUN.ne.0).and.savemem2) call abrt
      if((dolat.or.dopbcmd.or.semidyn).and.savememr) call abrt
c
      if(dolat.and.loadhf.eq.1) call abrt
c     if(dolat) call abrt
      if(dolat.and.addesp) call abrt
c     DOLAT does basically the same thing as ADDESP, but the two may not be set
c     together.
      if(iand(modesp,3).ne.0.and.(dolat.or.addesp)) call abrt
c     Likewise, no point of doing n-mer consistent distances: that is
c     automatic with the either other option.
      if(resppc(1).gt.resdim.and.addesp) call abrt
c     This is a program limitation (in fmoatfrg charges are not engaged in
c     computing VI(J)+VJ(I)). Strictly speaking, resppc = resdim is also
c     forbidden (but for reals the equality of distances "never" holds).
      if(addesp.and.ngroups.gt.1) call abrt
c     One should exchange the monomer potentials between groups.
      emp2s=0
c
c     BDA loop
c
      i0bda=0
   80 continue
      i0bda=i0bda+1
      if(n0bda.ne.0) then
        call bdaxyz(x(lr0bda+i0bda-1)/UNITS,x(lindat),x(lfmoc))
        call viclr(x(lmolfrg),1,nfg)
      endif
      if(nevsav.gt.0.and.iand(nguess,128).eq.0.and.ndualb.eq.0.
     *   or.i0bda.gt.1.and.irmdfmo.eq.0) irststp=2
      if(nevsav.gt.0.and.irststp.ge.2) then
        coroff=0
c       ncvscf(1)=9999
c       ncvscf(2)=9999
      endif
      ihaveq0=0
c     if(irststp.ge.2) ihaveq0=2
      if(squit) goto 5555
C
C     EFP PARALLELIZATION SHOULD BE INITIALIZED FOR NON-GDDI JOBS
C
      IF (.NOT.ISGDDI.AND.IEFPFMO.NE.0) CALL EFPPARL
c
      if(docns) call cnsx(x(lfmozan),x(lfmoc),x(lcnsdat))
c
c     Form cavity around the whole molecule.
c     Do this is the global scope.
c
c     IF(IPCM.EQ.1.OR.IP_F.EQ.1) THEN
      lesolv2=last
      lesolv3=last
      IF(nfmopcm.ne.0) then
        call vclr(x(lemocdr),1,necdr)
c       replace NESFP that was not available in PCMINP.
c       if(NESFP.lt.0) NESFP = NATfmo
C       if(isgddi) call gddi_scope(ddi_world)
        if(isgddi) THEN
          call gddi_scope(ddi_world)
          IF (IEFPFMO.NE.0) CALL EFPPARL
        END IF
        nprints=nprint
        if(iand(nprfmo,3).eq.3) nprint=817
C
c       read PCM input (not done yet!) and allocate PCM memory
C       FIX FOR MULTISCALE solvation in FMO
        call inppcm(nder,natfmo+NMTTPT,natfmo)
C       call inppcm(nder,natfmo,natfmo)
c       call inppcm(nder,MXATM,natfmo)
c       CAVITM and DISRPM retesserate so they have to be called before
c       (or after) starting FMO-PCM.
c       817 is the secret pass phrase to silence PCM.
        IF(IFIELD.NE.0) CALL EFIELDM
        IF(ICAV.EQ.1) CALL CAVITM
        IF(IDISP.EQ.1) CALL DISRPM
        CALL PEDRAM
        IF(ISMX.NE.0) then
          CALL CDSSET(ISMX)
c         CALL SMDPRT
        endif
        nprint=nprints
        call ddi_gsumf(2416,x(lemocdr),necdr)
c       NTSPAR must be set in world scope !! (or use NPROCG or npglob)
        if(isgddi) then
          NTSPAR=(NTS-1)/npglob+1
        else
          NTSPAR=(NTS-1)/NPROC+1
        endif
        if(nts.lt.nproc.and.maswrk)
     *    write(iw,*) 'Too many cores for too few tesserae',nts,nproc
C       if(isgddi) call gddi_scope(ddi_group)
        if(isgddi) THEN
          call gddi_scope(ddi_group)
          IF (IEFPFMO.NE.0) CALL EFPPARL
        END IF
C
        UNZ=zero
c
c       QSE and QSN have to be zeroed here, because SOLVNT is not called (QSN)
c       and QSE calues are used before charges are set to something at the
c       end of the first monomer SCF iteration.
c
        nesolv=nfg*2
        if(nbody.ge.2) nesolv=nesolv+nfg2*2
        if(nbody.ge.3) nesolv=nesolv+nfg3
c
c       ESOLV has the structure of
c       esolv(1...nfg) Ees(I), total ES due to PCM on I
c       esolv(1+nfg...2*nfg) sum{J}(EesI(J)), sum of two-body ES corr. on I
c       esolv(2*nfg+1,2*nfg+nfg2) Ees(IJ), total ES due to PCM on IJ
c       esolv(2*nfg+nfg2+1...2*nfg+2*nfg2) Ees2(IJ), screening for IJ
c       esolv(2*nfg+2*nfg2+1...2*nfg+2*nfg2+nfg3) total ES due to PCM on IJK
c
        call vclr(x(lQSE),1,NTS)
        call vclr(x(lQSN),1,NTS)
        if(nder.gt.0) then
          call vclr(x(lQFS),1,NTS)
          call vclr(x(lQIND),1,NTS)
        endif
c
        CALL VALFM(lfmasc)
c       ichfmo is unknown and unneeded at this point, use 0.
        call calcasc(0,NTSPAR,0,0,lfmasc,needasc,lesolv,nesolv,lpel,
     *               lvnuc,lqpot,lqtmp,dum,ihaveq0,nprfmo)
        CALL GETFM(needasc)
c       write(6,*) "www before mltfmopcm=",irststp
        ijob=0
        if(irststp.eq.2) ijob=-1
C       ntspre is tesserae for high-layer.
        ntspre=0
C       If nserch>=2, ntespre!=0, that is to reconstruct ASC
        call mltfmopcm(ijob,lfmasc,needasc,needmul,idum,ntspre)
C
C
        if(nbody.ge.2) lesolv2=lesolv+nfg*2
        if(nbody.ge.3) lesolv3=lesolv2+nfg2*2
        if(I_NESF.ne.natfmo) then
          if(maswrk) write(iw,*) 'Detected dummy spheres in PCM:',
     *                           I_NESF,natfmo
          if(nder.gt.0) call abrt
c         Only energy runs are allowed with dummy spheres.
        endif
      else
        lfmasc=0
        needasc=0
        needmul=0
        nesolv=0
        lesolv=last
        NTSPAR=0
c       These are actually NOT set in FMOX (see PCMMEM1 etc).
c       As an extra precaution only set values if zero.
        if(laxyzct.eq.0) laxyzct=last
        if(lqse.eq.0) lqse=last
        if(lisphe.eq.0) lisphe=last
        lpel=last
        lvnuc=last
        lqtmp=last
        lqpot=last
      END IF
c
c     nelm gives the number of electrostatic moments
c     (maxelm is up to octopoles).
c     iemom=0 none
c     iemom=1 dipole+point coordinates (one point max) 3+3
c     iemom=2 the above plus quadrupole (5)
c     iemom=3 the above plus octopole (10)
c     fmoelm(*,1-nfg) are used for the moments of each fragment
c     fmoelm(*,nfg+1) are used for the 2nd order moments
c     fmoelm(*,nfg+2) are used for the 3rd order moments
c     fmoelm(*,nfg+3) are used for the 1st order moments
c     fmoelm(*,nfg+4) are used as temporary storage for 3-body
c     (the reason for the funny order is the global sum up to nfg+1 or nfg+2).
      if(iemom.lt.0.or.iemom.gt.3) call abrt
      if(irststp.ge.4.and..not.savgrd.and.iemom.ne.0) then
        if(maswrk) write(iw,9420)
        iemom=0
      endif
      if(domp.and.nder.gt.0.and.iand(modgrd,32).ne.0.and.
     *   iand(ixesp,1048576).eq.0 .and. iefmorun .le. 0) then
c       Printing multipoles is only programmed for CODE=IMS.
        iemom=0
        if(maswrk) write(6,*) 'Multipole print-out is turned off.'
      endif
      if(irststp.ge.4.and.primul) then
        if(maswrk) write(iw,9422)
        primul=.false.
c       The problem of turning off both ES moments and Mulliken charges is that
c       the number of trimers present will be printed as zero.
      endif
c     if(dopleda) then
c       Perhaps there is a meaning to these ES moments?
c       if(maswrk) write(iw,9422)
c       iemom=0
c     endif
      nfmoelm=nelm(iemom)
      if(nfmoelm.gt.0) call fndcntr(natfmo,x(lfmozan),x(lfmoc),
     *  x(lfmomas),iwhere,XPOINT(npoint),YPOINT(npoint),ZPOINT(npoint))
c     for now, enforce COORD=TINKER for all FMO-MOMM runs.
c     compute MM energy
c     if(qmmm.and.modef.eq.0) CALL ANALYZE
c     if(squit) goto 5555
      if(modQbas.and.(runtyp.eq.OPTMIZ.or.runtyp.eq.OPTFMO)) call abrt
      if(modQbas) call oneei
      doclmo=rflmo(1).ne.0.and.iand(modlmo,3).gt.0
      doclmo1=rflmo(1).ne.0.and.iand(modlmo,3).gt.1
      dovlmo=rflmo(1).ne.0.and.iand(modlmo,16).ne.0
c     dofdo=iand(modlmo,8388608).ne.0
      nafo=iand(modlmo,3)
      if(doclmo.and.(nlayer.gt.1.or..not.dospc)) call abrt
c    *               irststp.gt.0)) call abrt
c    *               irststp.gt.0.and..not.doclmo1)) call abrt
c     Multilayer runs do not set all charges; for restarts also not initialised
c     restart can be easily only supported for SCC LMOs
c     (process charges in inidfmo).
      call fmolmo(' $FMOHYB',' $FMOLMO',x(ltaotyp),x(liaprjo),x(ljaprjo)
     *           ,x(lCoreAO),x(lOccCor),x(lnCBS),x(lnCAO),x(lshiftb),
     *            x(llibish),modQbas)
      call fmobon(' $FMOBND',nhybnam,x(lindat),x(ltaotyp),x(ltaotypi),
     *            x(liabdfg),x(ljabdfg),x(lidxcao),rflmo(1).ne.0)
c     renumber bda and baa
      if(qmmm) call fmommbon(x(lindat),x(liabdfg),x(ljabdfg))
c     if(nacut.ne.0) call fmoauto(nacut,x(lindat))
      if(iand(ixesp,128+256).ne.0.and.nbdfg.eq.0) then
        write(iw,*) 'Please reset 128+256 flags in ixesp in $FMO'
        call abrt
      endif
c     if(totfock.and.nbdfg.ne.0.and.rflmo(1).ne.0) then
c       write(iw,*) 'Total Fock matrix cannot be done for FMO/AFO.'
c       call abrt
c     endif
      IF( IEFMORUN.GT.0.AND.IEFPFMO.NE.0 ) THEN
        WRITE(IW,*) "EFMO and FMO/EFP are not compatible."
        CALL ABRT
      ENDIF
      IF(IEFMORUN.GT.0) CALL EFMOSCREENSETUP(nbdfg)
      IF(nder.gt.0 .and. iefmorun.gt.0.and.IAND(IMODEFE,16).NE.0) then
        write(iw,*) "Gradients are not derived for bond midpoints - yet"
        call abrt
      endif
c
c     Full MFMO3 is such run when there are dimers in several layers.
c     In other words, the only case when MFMO3 is not full is when only one
c     fragment is in layer 2 and there are 2 layers (this is a common case).
c     The present code is a "hack" - only allow the energy and no other
c     property for a full MFMO3; to fully support this one has to develop
c     the bookkeeping coefficients like ndtfrg.
      fullmfmo3=nlayer.gt.1.and.nbody.gt.2
      nfglay1=0
      do ifg=1,nfg
        if(ixftch(x(llayfrg),ifg).gt.1) nfglay1=nfglay1+1
      enddo
      fullmfmo3=fullmfmo3.and.nfg-nfglay1.gt.1
c     write(6,*) 'wwwfl',fullmfmo3
c     there are many other restrictioins not checked here.
      if(fullmfmo3.and.(primul.or.nder.gt.0.or.iemom.gt.0.or.
     *                  nfmopcm.gt.0)) then
        if(maswrk) write(iw,9130)
        call abrt
      endif
c
c     check the above guess of ne0bda=(nbdfg)=2*nbdfg
      if(n0bda.eq.0.and.ipieda.ne.0.and.ne0bda.lt.nbdfg) call abrt
c
      if(nbdfg.ne.0) call bdapun(units,x(lfmoc),x(liabdfg),x(ljabdfg),
     *                           n0bda.eq.0.and.ipieda.ne.0,x(lr0bda))
c
      if(rcorsd.ne.0.and..not.gcorrel) then
        write(iw,9200)
        rcorsd=0
c       having non-zero rcorsd creates a bug below (edim? overused)
      endif
      dodc=dc
c     if(gcorrel) dodc=.false.
      dodcesd=dodc.and.iand(ixesp,131072).ne.0.and..not.DFTBFL
      if(dodcesd.and.nbody.gt.2) call abrt
c     dodcesd conflicts with DFTB storage of dispersion data.
c
      if(gcorrel.and.dodc.and.nder.gt.0.and.rcorsd.ne.resdim) call abrt
c     dodc is used below in processing pair corrections.
c     Only purely non-correlated runs can save them separately, otherwise only
c     bulk values containing DC are stored.
      if(gcorrel.and.dodc.and.nbody.gt.2) call abrt
c     It seems that bookkeeping will not work for mixing MP2 with DC in FMO3.
      nenc=0
      if(gcorrel) nenc=2
      nen=nenc+2
      if(reducee) nen=nenc+1
      if(.not.gcorrel.and.dodc) nen=nen+1
      if(reducee.and..not.gcorrel.and.dodc) nen=nen-1
      if(.not.gcorrel.and.dopleda) nen=nen+2
c     dopleda=.t. with RHF actually needs just one extra element, but the
c     indexing becomes sandwiched (see the usage of the 4th element in edimer).
c     namely, elements 1,2,4,4,5 are used (overwriting the 4th)...
      if(nbsse.ne.0) nen=4+2+nenc
      if(ipieda.ne.0) nen=nen+2
c     for EFMO dimer EFP print out (4 EFP terms: es,exrep,disp,ct)
      if(iefmorun .ne. 0) nen = nen+4
c     should not add 2 if .not.gcorrel.and.dopleda ??
c     ES+EX
c     nedimdc=nen-2
      nedimes=nen-1
      nedimex=nen
      nfg2e=nfg2*nen
      if(dolat.or.dopbcmd) nfg2e=0
      if(savemem2) nfg2e=0
      nfg2l=nfg2
      if(dolat.or.dopbcmd.or.nbody.le.1.or..not.primul) nfg2l=0
      nent=2
      if(needdm) nent=3
      if(gcorrel) nent=nent+1
      if(savemem.and.needdm) call abrt
      if(savemem) nent=0
      nfg3e=nfg3*nent
      natfmob=natfmo+nbdfg
      nappri=0
      if(rappri(3).ne.0)
     *  nappri=int((rappri(2)-rappri(1))/rappri(3))+1
      CALL VALFM(LOADFM)
      liatfrg=LOADFM+1
      lindfrg=liatfrg+(natfmob-1)/nwdvar+1
      lindgfrg=lindfrg+(nfg-1)/nwdvar+1
      lnatfrg=lindgfrg+(nfg-1)/nwdvar+1
      lnat0frg=lnatfrg+(nfg-1)/nwdvar+1
      lianfrg=lnat0frg+(nfg-1)/nwdvar+1
      lzanfrg=lianfrg+(natfmob-1)/nwdvar+1
      lcfrg=lzanfrg+natfmob
      lialoc=lcfrg+3*natfmob
      ledim=lialoc+(natfmob-1)/nwdvar+1
      lerapp=ledim+nfg2e
      lnrapp=lerapp+nappri*2
      lctdim=lnrapp+(nappri*2-1)/nwdvar+1
      last=lctdim+nfg2l
      letrim=last
      if(nfg3e.ne.0) last=letrim+nfg3e
      lindatg=last
      if(nbdfg.ne.0) last=lindatg+(natfmo*maxabd-1)/nwdvar+1
      if(reuses) liwrkd=ledim
c     lialoc stores fragment and atomic numbers (iat,ifg)
c     separately for all "verite" atoms and ghost atoms.
c     lindatg contains shadow indat, which means secondary, tertiary etc
c     fragment indices that arise because ghost atoms belong to 2 or more
c     fragments.
      lklms=last
      if(dolat) last=lklms+(4*maxklms-1)/nwdvar+1
      leexfg=last
      if(doexc.and.nbody.ge.2) last=leexfg+2*nfg*mxrt
c
      ledimlow=last
      if(fullmfmo3) last=ledimlow+nfg2*3
c     edim(ij,1) EIJ, default correlated
c     edim(ij,2) Tr(delta(DIJ)*VIJ), uncorrelated
c     edim(ij,3) EIJ, uncorrelated
c
C     LFZCOR=last
      IF (DFTBFL) THEN
C       IF (DFTB3) THEN
C         IF (MASWRK)
C    *      WRITE (IW,'("  FMO-DFTB3 IS NOT CURRENTLY AVAILABLE")')
C         CALL ABRT
C       END IF
        IF (SRSCC) THEN
          IF (MASWRK)
     *      WRITE (IW,'("  SRSCC IS NOT AVAILABLE IN FMO-DFTB")')
          CALL ABRT
        END IF
        IF (ETEMP.NE.0.0D+00.AND.ETEMP.NE.-1.0D+00) THEN
          IF (MASWRK) WRITE (IW,'("  ELECTRONIC TEMPERATURE IS NOT ",
     *                            "AVAILABLE IN FMO-DFTB")')
          CALL ABRT
        END IF
        LGAMMA = LAST
        IF (SCC) THEN
          MODGAM = ABS(MODGAMMA)
          modgam = iand(modgam,3)
          IF (IAND(MODGAM,3).EQ.3) THEN
            IF (MASWRK)
     *        WRITE (IW,'("  IAND(MODGAM,3) SHOULD NOT BE 3")')
            CALL ABRT
          END IF
          IF (NDER.EQ.2.AND.MODGAM.NE.0) THEN
            IF (MASWRK) WRITE (IW,*) "RUNTYP=FMOHESS DOES NOT WORK ",
     *        "WITH MODGAM OPTION."
            CALL ABRT
          END IF
          IF (IAND(MODGAM,3).EQ.0) THEN
            LAST = LGAMMA + 12*NSPE*NSPE
          ELSE IF (IAND(MODGAM,1).NE.0) THEN
            LAST = LGAMMA + NATFMO*(NATFMO+1)/2
          ELSE IF (IAND(MODGAM,2).NE.0) THEN
            LAST = LGAMMA + NATFMOB*NATFMOB
          END IF
          IF (DFTB3) THEN
            LGAMMA3 = LAST
            IF (IAND(MODGAM,3).EQ.0) THEN
              LAST = LGAMMA3 + 10*NSPE*NSPE
            ELSE IF (IAND(MODGAM,1).NE.0) THEN
              LAST = LGAMMA3 + NATFMO*NATFMO
            ELSE IF (IAND(MODGAM,2).NE.0) THEN
              LAST = LGAMMA3 + 2*NATFMOB*NATFMOB
            END IF
          ELSE
            LGAMMA3 = LAST
          END IF
        ELSE
          LAST = LGAMMA
        END IF
        LZREF  = LAST
        LISPE  = LZREF + NATFMO + NBDFG
        LAST   = LISPE + NATFMO
        IF (NDER.GT.0.AND.SCC) THEN
          LGAMMAD  = LAST
          LSHIFTG  = LGAMMAD + 10*NSPE*NSPE
          LSHIFTCT = LSHIFTG + (NATFMO + NBDFG)*2
          LAST     = LSHIFTCT + NATFMO + NBDFG
          IF (DFTB3) THEN
            LGAMMA3D = LAST
            LAST = LGAMMA3D + 11*NSPE*NSPE
          END IF
          LCTMUL = LAST
          IF (DFTB3) THEN
            LAST = LCTMUL + NATFMOB*2
          ELSE
            LAST = LCTMUL + NATFMOB
          END IF
        END IF
        IF (DC) THEN
          LDCTMP = LAST
          IF (MODGAMMA.LT.0.AND.NDER.GE.1) THEN
            MODGAMMA = ABS(MODGAMMA)
            WRITE (IW,*) "MODGAM.LT.0 (DC IS STORED FOR ALL ATOMS)"
            WRITE (IW,*) "IS NOT SUPPORTED FOR GRADIENT"
          END IF
          IF (MODGAMMA.LT.0) THEN
            LAST = LDCTMP + NATFMO*(NATFMO+1)/2
          ELSE
            LAST = LDCTMP + 3*NSPE*NSPE
          END IF
          LNBOND = LAST
          IF (IDFTBD.EQ.4) LAST = LNBOND + NATFMOB
        END IF
        IF (IAND(MODESD,6).NE.0) THEN
          IF (IAND(MODESD,6).EQ.6) THEN
            if(maswrk) WRITE (IW,*) "USE ONLY ONE LUMP ESD OPTION"
            CALL ABRT
          END IF
          IF (IAND(MODESD,1).NE.0) THEN
            if(maswrk) WRITE (IW,*) "LUMP AND EREP ESD OPTIONS",
     *        " ARE NOT COMPATIBLE."
            CALL ABRT
          END IF
          LESDIMTMP = LAST
          LAST      = LESDIMTMP + NATFMOB
          IF (NDER.EQ.2) THEN
            if(maswrk) WRITE (IW,*) "RUNTYP=FMOHESS DOES NOT WORK",
     *        "WITH MODESD=2 OR 4 OPTION"
            CALL ABRT
          END IF
        END IF
      END IF
      CALL MCPFALOC(LAST)
      IF (DODC.AND.(.NOT.DFTBFL.OR.IDFTBD.EQ.3)) CALL DFTDSM(LAST)
C
      NEED2= LAST- LOADFM -1
c     write(6,*) 'wwwmem2',need2
      CALL GETFM(NEED2)
      IF (DODC.AND.(.NOT.DFTBFL.OR.IDFTBD.EQ.3)) 
     *  CALL DFTD3(-1,DUMMY,DUMMY)
c     lindfrg is used as temporary storage.
c     if(ixftch(x(lindat),1).eq.0)
c    *  call fmogind(natfmo+nfg*2+1,x(lindat),x(lindfrg))
c
c     Generate asymmetric units around the central one.
c
      if(dolat) then
        call genklms(0,0,0,1,nunint,nunesp,nunptc,x(lklms))
      else if (dopbcmd) then
        nunint = nimgcell
        nunesp = nimgcell
        nunptc = nimgcell
      else
        nunint=0
        nunesp=0
        nunptc=0
      endif
c
c     Create the grid around the total molecule. The monomer density will
c     not be evaluated on the grid in this case.
c
      if(iand(modprp,16).ne.0) then
        if(densgrid.and.ifgfmo0.ne.0) then
          write(6,9430)
          call abrt
        endif
       call totgrid(natfmo,x(lfmozan),x(lfmoc),vdwrad,grdpad(1),round10)
      endif
      if(nappri.ne.0) call vclr(x(lerapp),1,nappri*2)
      if(nappri.ne.0) call viclr(x(lnrapp),1,nappri*2)
      NDAR30c=1+nfg*2*2
c
c     Initialise FMO0
c
      if(ifgfmo0.ne.0) then
        call viclr(maxg,1,3)
        if(spargrid.and.grandmas)
     *    call makescube(0,0,ifgfmo0,0,x(llayfrg),x(lindat),x(lfmozan),
     *                   x(lfmoc),x,x(lnoffg),x(lindgrd),maxg)
c       In the above call grid array is not used so a dummy argument is passed
c       liatfrg is used as a temporary array of approximate size
c       maxnat+maxabd*2 (cannot exceed natfmo).
c       lnat0frg is used as temporary array of size nfg
c       lianfrg is used as temporary array of size natfmo
c       lialoc is used as a temporary array of size natfmo
        call pullfrg(ifgfmo0,x(liatfrg),x(lnat0frg),x(lianfrg),x(lialoc)
     *              ,x(lindat),x(liabdfg),x(ljabdfg),x(lfmozan),x(lfmoc)
     *              ,x(lizbas),x(lichfg),x(lmulfg),x(lfrgnam),x(llayfrg)
     *              ,x(lscffrg),x(lmconfg),x(lmolfrg),x(lnprfrg))
      endif
c
      call makefg(x(lindat),x(liabdfg),x(ljabdfg),x(lfmozan),x(lfmoc),
     *            x(lialoc),x(liatfrg),x(lindfrg),x(lindgfrg),x(lnatfrg)
     *           ,x(lnat0frg),x(lianfrg),x(lzanfrg),x(lcfrg),nacut,
     *            mdoutmin)
c
      IF (IMCPFMO.EQ.1) CALL MCPPRPR(X(LFMOZAN),X(LINDFRG),X(LNAT0FRG),
     *       X(LNATFRG),X(LIATFRG),X(LFZCOR),X(LIZCOR2),X(LIFMPTYP),
     *       X(LIFMPTYP2),X(LMCPSW))
c
      if(nbdfg.eq.0.and.mod(nguess/4,2).eq.1) nguess=nguess-4
      nat1e=natfmo*(nunesp+1)
cnb   fill numfrg array and avoid one DDI op.
c     skip framents if not in the layer?
c
cnb
c     nstjob is set up based on loadbf and loadgr for the first layer.
c     Other layers use the same nstjob (as the order of n-mers is the
c     same, just some of lower layers are skept.
      call viclr(nstjob,1,maxpst)
      nocctdm=0
      nvirtdm=0
      nocctdb=0
      nvirtdb=0
      itdfrg=iexcit(1)
      call fillind(nfg2,nfg3,loadhf,x(lnumfrg),x(liwrkd),x(lloadm),
     *             x(lloadd),x(lloadt),x(lmaxl30),x(llayfrg),x(lindat),
     *             x(lindatg),x(liabdfg),x(ljabdfg),x(lmulfg),x(lscffrg)
     *            ,x(lichfg),X(LNQMTFG),ichfmo,nefmo,mulfmo,
     *             l0fmo,l1fmo,m1fmo,orbxch,enexch,docas,loadbf(1,1),
     *             loadgr(1,1),nstjob,semidyn,spargrid,x(lnoffg),
     *             x(lindgrd),vdwrad,grdpad(2),nxyzg,maxg,itdfrg,nocctdm
     *            ,nvirtdm,nocctdb,nvirtdb,mixlbas,maxnath,needr,
     *             savememr,maxld,maxlt,some)
C
      natprp=natbuf
      if(modfd.ne.0) call setacta(x(llayfrg),x(lindat),x(liabdfg),
     *                            x(ljabdfg),x(liactat),natprp)
      if(docas.and..not.orbxch) then
        write(6,*) 'Please set orbital exchange flag in MODORB'
        call abrt
      endif
      if(nevsav.gt.0.and.irststp.ge.2.and.mixlbas.gt.0.and.modfd.eq.0)
     *  then
        if(maswrk) write(6,*) 'Restarts not allowed: add 128 to nguess?'
c       Some single point MFMO runs may be allowed if restarted from
c       the highest layer.
        call abrt
      endif
c     CAS can be easily added to dodimden.
      dodimden=iand(nguess,8).ne.0.and.nbody.gt.1.and..not.docas.and.
     *         (runtyp.eq.optmiz.or.runtyp.eq.optfmo)
      m1efmo=m1fmo
      if(irststp.gt.2.or.nlayer.gt.1.or..not.totfock) m1efmo=0
      if(totfock.and.maswrk)
     *  call fockhead(ichfmo,nefmo,mulfmo,l0fmo,l1fmo)
c     if(ifgdon.eq.0.and.ifgacc.ne.0.or.ifgdon.ne.0.and.ifgacc.eq.0)then
c       write(iw,*) 'Donor/acceptor choice is wrong',ifgdon,ifgacc
c       call abrt
c     endif
      maxl2=(maxl1*maxl1+maxl1)/2
      maxl3=maxl1*maxl1
      LDAR30=maxl2
      if(orbxch) LDAR30=maxl3
      if(docas)  LDAR30=maxl2+maxl3
      if(enexch) LDAR30=LDAR30+maxl1
      maxrecsiz=LDAR30
c
      forbconv=irststp.eq.2.and.maxl1c.ne.0
      densfmo0=ifgfmo0.ne.0.and.maxl1c.ne.0
      conv2mc=forbconv.and.maxl1.eq.maxl1c
      if(forbconv) then
        ierr=0
        if(conv2mc) then
c         This means converting RHF -> MCSCF, require modorb=3 for both.
          if(modorb.ne.3) ierr=1
        else
c         Otherwise present code requires modorb=0 or modorb=1.
c         if(modorb.ne.0) ierr=1
          if(enexch) ierr=1
        endif
c       Request sequential unilayer code
        if(nlayer.gt.1.or.ngroups.gt.1) ierr=1
        if(ierr.ne.0) then
          if(maswrk) write(iw,9010)
          call abrt
        endif
      endif
c     Compute only the nbody-th density for densgrid, but each ibody-th for
c     spargrid.
      if(.not.spargrid) nxyzg=nzg*nyg*nxg
      ngbody=0
      if(densgrid) ngbody=1
      if(spargrid) ngbody=mbody
      nxyzgm=ngm(3)*ngm(2)*ngm(1)
      if((densgrid.or.spargrid).and.nxyzg.eq.0) then
        write(iw,9400) nxg,nyg,nzg
        call abrt
      endif
      nfraggr=0
      do i=1,nfg
        if(iand(ixftch(x(lnprfrg),i),4).ne.0) then
          nfraggr=nfraggr+1
        endif
      enddo
c
      nxyzgm0=nxyzgm
      if(nbody.ne.0) nxyzgm0=0
      nsetgrid=1
      if(mepgrid) nsetgrid=2
c     write(6,*) 'wwwabc',nxyzgm,nxyzg
c
c     Read the fortune: do we qualify for DDI?
c     Prerequisites: no MEP, no FMO0, no sparse.
c
c     griddistr=nsetgrid.eq.1.and.densgrid.and.ifgfmo0.eq.0.and.
      griddistr=densgrid.and.ifgfmo0.eq.0.and.iand(modprp,512).ne.0
c     if(maswrk.and.griddistr) 
c    *  write(iw,*) 'Using DDI memory to store total density.'
      fraggrid=nxyzgm.eq.0.and.nfraggr.gt.0.and..not.griddistr
      if(fraggrid.and.needr.eq.0) grdpad(3)=0
c     If distances are not available, set to 0.
      if(fraggrid) 
     * call totgrid(natfmo,x(lfmozan),x(lfmoc),vdwrad,grdpad(1),round10)
c
      l2fmo=(l1fmo*l1fmo+l1fmo)/2
c     Set up record size for the total density
c     if(iand(l1fmo,2).eq.0) then
c       ndrecsiz=l1fmo+1
c       ndrec=l1fmo/2
c     else
c       ndrecsiz=l1fmo
c       ndrec=(l1fmo+1)/2
c     endif
      l1fmoc=0
c
c     if(forbconv.or.densfmo0) then
      if(forbconv) then
        maxl2c=(maxl1c*maxl1c+maxl1c)/2
        maxl3c=maxl1c*maxl1c
        LDAR30c=maxl2c
        if(orbxch) LDAR30c=maxl3c
        if(docas)  LDAR30c=maxl2c+maxl3c
        if(enexch) LDAR30c=LDAR30c+maxl1c
      endif
c     auxiliary density file
      IDAcFMO=30
      savenmer=iand(ixesp,524288).ne.0
      if(maswrk.and.savenmer)
     *  write(iw,*) 'Running experimental code to save memory (n).'
c     note: suffix d is obsolete. Now it applies to n-mers (not just dimers).
      if(savenmer) then
        maxl1d=maxl1
        if(mbody.eq.2) maxl1d=maxld 
        if(mbody.eq.3) maxl1d=maxlt 
        if(maswrk) write(iw,*) 'Using',maxl1d,' instead of',maxl1*mbody
      else
        maxl1d=maxl1*mbody
      endif
      maxl2d=(maxl1d*maxl1d+maxl1d)/2
      maxl3d=maxl1d*maxl1d
      maxm2d=maxl2d
      if(orbxch.or.ixftch(x(lijvec),1).ne.0) maxm2d=maxm2d+maxl3d
c     maxl3d can be used for reading $VECs even if orbxch is false
      maxm2d=maxm2d+maxl3d
      if(enexch) maxm2d=maxm2d+maxl1d
cnb   enexch should double the size for ROHF
      if(dosap) maxm2d=maxm2d+maxl1
      if(dospc) maxm2d=maxm2d+maxl1
      if(douhf) maxm2d=maxm2d*2
c     should be if(dospc) maxm2d=maxm2d+maxnat, but dmexch uses maxl1
c     dosap and dospc values are used only in dmexch.
c     maxl1 is for monomers, double for dimers.
c     for DA and DB LDAR30 is enough except for NBSSE.ne.0 runs
c     if memory request grows to be too large that can be used.
c     lwrk is used as maxl2 + maxl1(enexch) + maxl3(orbxch)
c     NDAR30 allocates one record for record indexing.
c     n30ex allocates some space for restart check
      n30ex=6+nlayer
      n30exf=0
      if(nfmopcm.ne.0) n30exf=nts
      if(nfmopcm.ne.0.and.icomp.ne.0) n30exf=nts*4
      if(iand(modpap,4).eq.0) n30exf=0
c     if(iand(modpap,4).ne.0.and.dodistr) call abrt
c     This prohibits saving PCM charges unless $pcm modpar|=4 $end
      NDAR30=1+nfg*2*2
      if(addesp.or.diffesp) NDAR30=NDAR30+nfg*2
c     ndrecoff=NDAR30-1
c     if(totdens) NDAR30=NDAR30+ndrec
      NDAR30i=(NDAR30+n30ex-1)/nwdvar+1
      NDAR30f=NDAR30i+n30exf
      NDAR30ci=(NDAR30c+n30ex-1)/nwdvar+1
      LDAR30=max(LDAR30,NDAR30i)
c     if(totdens) LDAR30=max(LDAR30,ndrecsiz)
c     if(forbconv.or.densfmo0) LDAR30c=max(LDAR30c,NDAR30ci)
      if(forbconv) LDAR30c=max(LDAR30c,NDAR30ci)
      NDAR30q=nfg2*2
      LDAR30q=maxl2d
c     this is somewhat stupid: better alter maxl30 instead.
c
      nfrgmul=0
      if(ivmul.gt.1) nfrgmul=nfrgmul+3
      if(ivmul.gt.2) nfrgmul=nfrgmul+6
      if(ivmul.gt.3) nfrgmul=nfrgmul+10
      needmd=0
      if((nfmoelm.gt.0.or.primul.or.nder.gt.0).and.nbody.gt.1) needmd=1
c     should one add .and.rcorsd.ne.0?
      CALL VALFM(LOADFM)
      lfmoda=LOADFM+1
      lfmodb=lfmoda+maxm2d
      lfmoespa=lfmodb+maxm2d
      lfmoespb=lfmoespa+maxl2d
      liodfmo=lfmoespb+maxl3d
      if(runtyp.eq.FMOHESS) liodfmo=lfmoespb+maxl3d*3
      if(douhf.and.dotd)    liodfmo=lfmoespb+maxm2d
      lisdrec=liodfmo+NDAR30f
      llocfmo=lisdrec+NDAR30i
      lwrk=llocfmo+(2*2*nbdfg-1)/nwdvar+1
      lwrk1=lwrk+maxl1d+maxl2d+maxl3d
      if(urohf.or.runtyp.eq.fmohess) lwrk1=lwrk1+maxl3d+maxl1d
      if(urohf.and.runtyp.eq.fmohess)
     *     lwrk1=lwrk1+maxl3d*2+maxl1d*2+maxl2d*2
      lwrk2=lwrk1+maxl1d*8
      if(urohf.or.runtyp.eq.fmohess) lwrk2=lwrk2+maxl3d*2+maxl2d
      if(urohf.and.runtyp.eq.fmohess)
     *     lwrk2=lwrk2+maxl3d*2+maxl2d
c     lwrk2=lwrk1+maxl1d*2
      lmapi=lwrk2+maxl2d
      lmapj=lmapi+(maxl1d-1)/nwdvar+1
      lfmoelm=lmapj+(maxl1d-1)/nwdvar+1
      lstonep=lfmoelm+nfmoelm*(nfg+4)
c     3 above is really nbody but to replace one needs to check carefully
      leigfmo=lstonep+maxnat*nbody*(nfrgmul+1)
      libfmo=leigfmo+m1efmo
      lfrgmul=libfmo+(m1efmo-1)/nwdvar+1
      last=lfrgmul
      if(nfrgmul.gt.0) last=lfrgmul+3*natfmob+nfrgmul*natfmob*2
      if(ifgfmo0.eq.0) liodcfmo=last
      if(forbconv) then
        lorbconv=liodcfmo+NDAR30ci
        last=lorbconv+maxl3c+maxl2c+maxl1c
      else
        lorbconv=last
      endif
c     if(densfmo0) then
c       liodcfmo=last
c       last=liodcfmo+NDAR30ci
c     endif
      if(fmoq) then
        ledimq=last
        last=ledimq+nfg2
      else
        ledimq=last
      endif
      lemonpl=last
      ledimmixd=last
      letrimmixd=last
      ldepl=last
      lelmpl=last
      if(ndualb.ne.0) then
        ledimmixd=lemonpl+nfg*2
        letrimmixd=ledimmixd+nfg2*3
        ldepl=letrimmixd+nfg3e
        lelmpl=ldepl+natfmo*3
        latqpl=lelmpl+nfmoelm
        last=latqpl+natfmo
      endif
      if(fmoq.or.needdm) then
        liodcfmo=last
        ljob2grp=liodcfmo+(NDAR30q-1)/nwdvar+1
        last=ljob2grp+(nfg2-1)/nwdvar+1
      else
        ljob2grp=last
      endif
      if(dodistr) then
c       write(6,*) 'wwwallocating in FMOX',NDAR30
        if(.not.mulgeom) then
          lidmpnt=last
          last=lidmpnt+(NDAR30-1)/nwdvar+1
        endif
      else
        lidmpnt=last
        liptlg=last
      endif
      if(dodiff) then
c       if(.not.mulgeom) then
          livmpnt=last
          last=livmpnt+(nfg*3-1)/nwdvar+1
c         write(6,*) 'wwwallocating',nfg*3
c       endif
      else
        livmpnt=last
      endif
      if(.not.dodimden) liddpnt=last
c     if(dodimden) last=liddpnt+(nfg2-1)/nwdvar+1
c     write(6,*) 'wwwddpnt',liddpnt
c     liddpnt should be allocated externally.
      lfmobuf(1)=lwrk
      lfmobuf(2)=lwrk2
      lfmobuf(3)=0
c     if(dftbfl.and.scc)  lfmobuf(3)=ledij
c     stash away allocated memory
      lindbd=last
      if(nbdfg.ne.0) then
        last=lindbd+(maxabd*natfmo-1)/nwdvar+1
c       maxabd sets the maximum number of bonds broken at a single atom.
c       at present it is 4 (since precision is lost, normally only 1 bond
c       at most is broken).
      endif
      lwrkc=last
c     ljob2grp=last
c     lwrkc stores density+orbitals+energy for the 3rd fragment in trimers
      if(nbody.gt.2) then
        ndc=maxl2
        if(orbxch) ndc=ndc+maxl3
        if(enexch) ndc=ndc+maxl1
        lmap3 = lwrkc+ndc
        if(urohf) lmap3 = lwrkc + ndc*2
        last=lmap3+(maxl1d*3-1)/nwdvar+1
c       if(needdm) then
c         ljob2grp=last
c         last=ljob2grp+(nfg2-1)/nwdvar+1
c       endif
      else
        lmap3=last
      endif
      lqini=liodfmo+ndar30i
      lpopmat=last
      lpopmul=last
      lddijpot = last
      lzppcpot = last
      LVIPOT   = LAST
      LGRDTEST = LAST
c
c     2 in popmul and popmat below refer to 2 iterations to save data
      if(dosap.or.dospc) then
        last=lpopmul+maxl1*nfg*2
        if(dospc) then
          lpopmat=last
          last=lpopmat+maxnat*nfg*2
          if (iand(modesp,512).ne.0) then
            LVIPOT = LAST
            LAST   = LVIPOT + MAXNAT*NFG*2
          end if
          IF (NDER.GT.0.and.IAND(MODGRD,8).NE.0) THEN
            LDDIJPOT = LAST
            LAST     = LDDIJPOT + MAXNAT*NFG
            IF (IAND(MODGRD,32).NE.0) THEN
              LZPPCPOT = LAST
              LAST     = LZPPCPOT + MAXNAT*NFG
              LGRDTEST = LAST
              LAST     = LGRDTEST + NATFMO*3
            END IF
          END IF
        endif
      endif
C     for mulliken spin analysis (2-body only!)
      lpmulspin=last
      lctspin  =last
      urospn=urohf.and.nder.eq.0
      if(urospn) then
        lctspin = lpmulspin + natfmo*2
        last    = lctspin   + nfg2
      end if
C     12/08/09 FOR FMO CPHF LAGRANGIAN TERM
      LZVLAG = LAST
      LZVWRK = LAST
      IF (LSCZVEC .and. iefmo_agrad .le. 0 ) THEN
        CALL ZVLGMEM1(NZVLG,MXZVWK,X(LNQMTFG),x(lscffrg),x(lmulfg),
     *                x(llayfrg))
        LAST = LZVWRK + MAX(MAXL2D,MXZVWK)
        IF (DODISTR) THEN
          IF (.NOT.MULGEOM) THEN
            LIPTZVEC = LAST
            LIPTLG   = LIPTZVEC + 2*NFG/NWDVAR + 1
            LAST     = LIPTLG   +   NFG/NWDVAR + 2
          END IF
        ELSE
c         IF (MPLEVL.NE.0) THEN
c           WRITE(6,*) 'MP2 density with local memory allocation'
c           WRITE(6,*) 'is under construction'
c           call abrt
c         END IF
          ! Z-vector is defined in ESDCPHFX
          ! So only Lagrangian is defined here
          LZVLAG = LAST
          LIPTLG = LZVLAG   + NZVLG
          LAST   = LIPTLG   + NFG/NWDVAR + 2
        END IF
      END IF
C
C
C     2012/10/03
C     For hessian calculation
C     we approximately use the response terms U_{mi}
C     by independently solving each set of CPHF equation
C     in monomer or dimer fragment respectively.
C     (This may be no problem for HF/UHF/ROHF/DFT...).
      LYALAG = LAST
      LYAWRK = LAST
      LIPTYA = LAST
      if(RUNTYP.EQ.FMOHESS) then
        CALL YALGMEM1(NYALG,MXYAWK,X(LNQMTFG),x(lscffrg),x(lmulfg),
     *       x(lnatfrg),x(llayfrg))
        LYALAG= LYAWRK + maxl3d*MXYAWK
        IF(urohf)  LYALAG=LYAWRK + maxl3d*MXYAWK*2
        IF(DFTBFL) LYALAG=LYAWRK + maxl3d*MXYAWK+INT(MXYAWK*MXYAWK/3)
        LIPTYA= LYALAG + NYALG
c       write(*,*) " NWDVAR = ", NWDVAR
        LAST  = LIPTYA + NFG/NWDVAR + 1
      end if
      if(dofddpcm) then
c       write(6,*) "pcmfddgmem1"
        CALL PCMFDDGMEM1(ndim,maxdim,x(lnumfrg),x(llayfrg),nfg)
        LYALAG = LYAWRK + ntspre
        LIPTYA = LYALAG + ndim
        LAST   = LIPTYA + NFG/NWDVAR + 1
      end if
C
      lzsave=last
      if(nbsse.ne.0) then
        last=lzsave+maxnat*mbody
      endif
      lfmode=last
      lfmopg=last
      if(nder.gt.0) then
        lfmopg=lfmode+3*natfmo*mbody
        last=lfmopg
        if(nfmopcm.gt.0) last=lfmopg+3*natfmo
      endif
      lfmohard=last
      if(iahard.gt.0) last=lfmohard+natfmo*nbody
C
      LFMOFCM = LAST
      LFCMWRK = LAST
      lfmoddm = LAST
      IF (NDER.EQ.2) THEN
        ndim = nc1*nc1
        if (dftbfl) ndim = 0
        LFCMWRK= LFMOFCM + ndim
C       for Second derivative of ESP
        ndim    = max(9*maxnat*mbody*maxnat*mbody,nc1*nc1)
        ndim    = ndim + max(nc1*3,natfmo)
        ! temporary array for FMODEH
        if (dftbfl) ndim = ndim + 9*maxnat*maxnat*mbody*mbody
        lfmoddm = LFCMWRK + ndim
C       In FMO-DFTB Hessian, FCMWRK is identical to FMOFCM.
        if (dftbfl) lfmofcm = lfcmwrk
        last    = lfmoddm+3*nc1
      END IF
C
      latmulq=last
      if(primul) then
        latmulqi=latmulq+natfmo*mbody
        last=latmulqi+natfmo*mbody
      else
        latmulqi=last
      endif
c     lindd=last
      if(totdens) then
c       ldbuff=lindd+(ndrec*2-1)/nwdvar+1
c       lloctat=ldbuff+ndrecsiz
        lloctat=last
        liaoglob=lloctat+(natfmo-1)/nwdvar+1
        ltotd=liaoglob+(maxl1d-1)/nwdvar+1
        last=ltotd+l2fmo
c       l2fmo is often a huge buffer. While it is easy to split it in FMO,
c       the same buffer will have to be used in GAMESS when reading this
c       density so for now put everything in-core.
      else
c       ldbuff=last
        lloctat=last
        liaoglob=last
        if(totfock) then
          liaoglob=lloctat+(natfmo-1)/nwdvar+1
          last=liaoglob+(maxl1d-1)/nwdvar+1
        endif
      endif
      if(densgrid.and.ifgfmo0.ne.0) then
c       Allocate nothing for non-sparse density in FMO0.
      else
        ldgrid=last
        if(densgrid.and.ifgfmo0.eq.0 .or.spargrid) then
          if(griddistr) then
c           Sanity check: we break nxyzg=nzg*nyg,nxg into the components.
            if(nzg*nyg*nxg.ne.nxyzg) call abrt
c           Get 1 slab even if doing MEP (as updating is done in a loop 1,2).
            last=ldgrid+nzg*nyg
c           Allocate global z,y-slab (it will be used for each x). 
            if(isgddi) call gddi_scope(ddi_world)
c           The usage of nxg in the 2nd dimension means the max reduction
c           of memory in parallel is the factor of 1/nxg.
            call ddi_create(nzg*nyg,nxg*ngbody,itmfmo(1))
            if(nsetgrid.eq.2)
     *        call ddi_create(nzg*nyg,nxg*ngbody,itmfmo(2))
            if(isgddi) call gddi_scope(ddi_group)
          else
            last=ldgrid+nxyzg*ngbody*nsetgrid
          endif
        endif
      endif
      ldgridm=last
      last=ldgridm+nxyzgm*nsetgrid
c     Properties become a bit messy for multilayer runs. We accumulate
c     the properties for the current layer in latmulqi and then add to latmulq.
      lnmdfrg=last
      lnmtfrg=last
      lndtfrg=last
      if(nbody.gt.1) then
        last=lnmdfrg+(nfg*2-1)/nwdvar+1
        if(nbody.gt.2) then
          lnmtfrg=last
          lndtfrg=lnmtfrg+(nfg*2-1)/nwdvar+1
          last=lndtfrg+(nfg2*2-1)/nwdvar+1
        endif
        lnmmfrg=last
        lnddfrg=last
        if(ext2lay) then
          lnddfrg=lnmmfrg+(nfg-1)/nwdvar+1
          last=lnddfrg+(nfg2-1)/nwdvar+1
        endif
      endif
c     nmdfrg(*,1) tells how many times monomer I enters into total dimer
c     properties sum(IJ) { PIJ-PI-PJ }. Without approximations this number is
c     always nfg-2, however it becomes smaller if resdim is active or for
c     multilayer runs.
c     nmdfrg(*,2) stores the same value for explicitly correlated monomers.
c     (nmdfrg(*,1) is equal to nmdfrg(*,2) if rcorsd is large enough so that
c     it does not exclude correlation from any dimer and molfrg is not used).
      luntxyz=last
      if(dolat) then
        call fmon123(x(lnumfrg),n1fmo,n2fmo,n3fmo)
        lunitnr=luntxyz+3*natfmob*(nunptc+1)
        lnsymeq=lunitnr+nunptc
        luntrot=lnsymeq+(nunptc-1)/nwdvar
        lesplat=luntrot+3*3*(nunptc+1)
        lmapsu=lesplat+n2fmo*nsymop
        last=lmapsu+(nunptc-1)/nwdvar
      else if (dopbcmd) then
        call fmon123(x(lnumfrg),n1fmo,n2fmo,n3fmo)
c       use "+2" because untxyz has dimension of (3,natfmob,0:nunptc+1)?
        lunitnr  = luntxyz  + 3*natfmob*(nimgcell+2)
        lnsymeq  = lunitnr
        luntrot  = lnsymeq  + (nimgcell-1)/nwdvar + 1
        lesplat  = luntrot  + 3*3*(nimgcell+1)
        lmapsu   = lesplat
        ltrvec   = lmapsu   + (nimgcell-1)/nwdvar + 1
        lfmoctmp = ltrvec   + 3*nimgcell
        lwrkdsav = lfmoctmp + 3*natfmo
        lindxiu  = lwrkdsav + max(maxl2d,nfg)
        last     = lindxiu  + nfg*nfg
c       once -mdx- is called, lfmogctr and lindatmd are defined there.
        if(.not.mdxcalled) then
          lfmogctr = last
          last     = lfmogctr + 3*nfg
        endif
      else
        lunitnr=last
        lnsymeq=last
        luntrot=last
        lesplat=last
        lmapsu=last
      endif
      lesp1i=last
      if(dolat.or.addesp) then
        lesp1j=lesp1i+maxl2
        lczi=lesp1j+maxl2
        lczj=lczi+maxnat*4
        last=lczj+maxnat*4
      else
        lesp1j=last
        lczi=last
        lczj=last
      endif
      lCTDM=last
      if(dotd.and.iexcit(4).eq.2) then
        if(NSTAT.eq.0) then
          if(maswrk) write(iw,*) 'Define TDDFT in $CONTRL'
          call abrt
        endif
        last=lCTDM+nocctdm*nvirtdm*NSTAT
c       This requires TDDFT!=NONE in $CONTRL.
        if(douhf) then
           L7=max(nocctdm*nvirtdm,nocctdb*nvirtdb)
           nread=L7*2*NSTAT
           last=lCTDM+nread
        end if
      endif
C     FRET calc.
      lexcit2 =last
      ltexcit2=last
      NSTAT1  =0
      if(dofret) then
c      write(6,*) " nstat = ",NSTAT
       if(NSTAT.eq.0) then
         if(maswrk) write(iw,*) 'Define TDDFT in $CONTRL'
         call abrt
       endif
       ltexcit2 = lexcit2  + nfg*NSTAT
       last     = ltexcit2 + nfg*NSTAT*3
       CALL ZVLGMEM1(NZVLG,MXZVWK,X(LNQMTFG),x(lscffrg),x(lmulfg),
     *               x(llayfrg))
       LZVWRK = LAST
       if(iexcit(1).eq.-2) NSTAT1 = NSTAT
       LZVLAG = LZVWRK   + MXZVWK * (NSTAT1 + 2)
       LIPTLG = LZVLAG   + NZVLG  * (NSTAT1 + 2)
       LAST   = LIPTLG   + NFG/NWDVAR + 1
      endif
c
      maxlmo=maxcao
      if(rflmo(1).eq.0) maxlmo=0
c     maxabd2 is the max number of atoms over which LMOs are expanded.
c     maxabd2=maxabd*2-1
c     maxabd2=maxabd*2
      maxabd2=maxabd*2
      lclmo=last
      lialmo=lclmo+maxbbd*maxabd2*maxlmo*nbdfg
      lindlmo=lialmo+(2*maxabd2*maxlmo*nbdfg-1)/nwdvar+1
      last=lindlmo+(2*nbdfg-1)/nwdvar+1
      liwlmo=last
      latclmo=last
      lfgflmo=last
      lnfglmo=last
      llmobdf=last
      llfglmo=last
      lpfglmo=last
      maxslo=maxcao
      ldafo=last
c     maxslo is the number of saved LMO per fragment
c     It assumes just one broken bond per fragment.
      if(.not.doclmo1) naoafo=0
      naoafo3=naoafo*naoafo
      naoafod=(naoafo*naoafo+naoafo)/2
      if(orbxch) naoafod=naoafo3
c     write(6,*) 'wwwnao',naoafo,naoafo3,naoafod
c     MCSCF is not supported here!
      if(docas.and.naoafo.ne.0) call abrt
      if(rflmo(1).ne.0) then
        latclmo=liwlmo+(natfmo-1)/nwdvar+1
        llmobdf=latclmo+natfmo
        last=llmobdf+(MXAO-1)/nwdvar+1
        lfgflmo=last
        if(dovlmo) then
          lnfglmo=lfgflmo+maxl1*maxslo*nfg
          llfglmo=lnfglmo+(nfg-1)/nwdvar+1
          lpfglmo=llfglmo+(maxslo*nfg-1)/nwdvar+1
          last=lpfglmo+maxnat*maxslo*nfg
        endif
        ldafo=last
        if(naoafo.gt.0) last=ldafo+naoafo3+naoafod*nbdfg
      endif
      nbndfg=1
c     nbndfg is the number of fractioned bonds per fragment.
      if(iand(modlmo,4096).ne.0) then
        lfgflmo=last
        lnfglmo=lfgflmo+maxl1*nbndfg*nfg
        last=lnfglmo+(nfg-1)/nwdvar+1
        maxslo=nbndfg
c       maxslo is reset here so that the leading dimensions in monoscf are
c       correct.
      endif
      lcrfrg=last
      lylmfrg=last
      lzlmfrg=last
      lylmfrgv=last
      lzlmfrgv=last
      ncentm=0
      if(modfmm.ne.0) then
        mmextra=2
        mmbody=1
        if(iand(modfmm,4).ne.0) then
          mmbody=mbody
          mmpair=1
          if(mmbody.gt.2) mmpair=3
c         in trimer IJK there are 3 pairs: IJ, IK and JK.
c         4 is fixed because it is a circle represented by 4 points.
c         MXPLATE is an estimate of how many plates (circles) are put
c         between the centers of two fragments.
          if(mbody.gt.1) mmextra=mmextra+4*MXPLATE*mmpair
        endif
        ncentm=1
        if(iand(modfmm,16).ne.0) ncentm=maxnath*mmbody+mmextra
        if(iand(modfmm,32).ne.0) ncentm=maxnat*mmbody+mmextra
c       2 records are reserved:
c       (1) for the whole fragment, (ncentm) for the number of centers.
        lylmfrg=lcrfrg+4*ncentm*nfg
        lzlmfrg=lylmfrg+(NP+1)*(NP+2)*ncentm*nfg
        last=lzlmfrg+(NP+1)*(NP+2)*ncentm*nfg
c       Note that ylmfrg and zlmfrg are complex-valued.
        if(iand(modfmm,4).ne.0) then
          lylmfrgv=last
          lzlmfrgv=lylmfrgv+(NP+1)*(NP+2)*ncentm*nfg
          last=lzlmfrgv+(NP+1)*(NP+2)*ncentm*nfg
        endif
      endif
      lemolfrg=last
      lsubprp=last
      nsubsys=0
      if(subsys) then
        do ifg=1,nfg
          nsubsys=max(nsubsys,ixftch(x(lmolfrg),ifg))
        enddo
        write(6,*) 'Found',nsubsys,' subsystems'
        if(nsubsys.le.0) call abrt
c       One should also check if any subsystem is missing, e.g., 1,2,4, no 3 
         lsubprp=lemolfrg+nfg*nsubsys*2
c        sumI Eint(I,J) C+U,U (connected/unconnected)
c        last=lsubprp+nsubsys*3+(nsubsys*nsubsys+nsubsys)/2
         last=lsubprp+nsubsys*3+nsubsys*nsubsys
c        CT(charge),Epart,EBB,EU,int
c        sum PIEs (corr) to subsystems.
      else if(modmol.ne.0) then
         last=lemolfrg+nfg*3
c        sum PIE corr, uncorr and ES.
      endif
C
      IF (IEACAL.EQ.1) THEN
        CALL IEAMEM2(LAST,X(LIOEFP),X(LIOFMO),X(LIEATF),X(LINDAT),
     *               X(LIEACNT))
      END IF
C
      NEED1 = LAST- LOADFM -1
c     write(6,*) 'wwwmem1',need1
      CALL GETFM(NEED1)
c
c     efmo memory
C
C   SRP: CHANGES FOR DISP, XR AND CT MEMORY
C
      IF( IEFMORUN.GT.0 ) THEN
        MXBSFN=0
        MXMOS=0
        MXMO2=0
        LTWO=0
        mxatm_efmo=0
        DO I=1,NFG
           MXBSFN=MAX(MXBSFN,NBSFN(I))
           MXMOS=MAX(MXMOS,NMXMO(I))
           mxatm_efmo=max(mxatm_efmo,ixftch(x(lnatfrg),i))
        ENDDO
        MXMO2=(MXMOS*MXMOS+MXMOS)/2
        LTWO=(MXBSFN*MXBSFN+MXBSFN)/2
        if( mxatm_efmo .gt. mxefmopts ) then
           write(*,'(A,I2,A)') 'you can only have fragments with <=',
     *          mxefmopts, 'atoms'
           call abrt
        endif
C
c     clearing out values for response equations
        lzvwrk = 0
        lzvlag = 0
        liptlg = 0
        CALL ZVLGMEM1(NZVLG,MXZVWK,X(LNQMTFG),x(lscffrg),
     *       x(lmulfg),x(llayfrg))
C
        ncpl_mem = 0
        nocc_tot = 0
c being precise in how much cpl memory is needed.
        do i=1,nfg
           ncpl_mem = ncpl_mem + nmxmo(i)*(nmxmo(i)+1)/2
           nocc_tot = nocc_tot + nmxmo(i)
        enddo

        if( mxmos .gt. mxefmoppts ) then
           write(*,'(A,I2,A)') 'you can only have fragments with <=',
     *          mxefmoppts, 'occupied orbitals'
           call abrt
        endif

c       calculate the memory for exrep terms. this calculates the
c       total number of shells and gaussians needed, and puts
C       them in nsh_tot and ng_tot, respectively
        call efmo_calc_exrep_mem( x(llibnsh), x(llibng), nsh_tot,
     *       ng_tot,x(lizbas), x(liatfrg), x(lnatfrg), x(lianfrg),
     *       maxbas,maxnz, nfg, dummy,.false., x(llayfrg))

        CALL VALFM(LOADFM)
        liexrep_offset = LOADFM + 1
        lnefmopts = liexrep_offset + 2*(nfg+1)
        lefmopts = lnefmopts + (7*nfg-1)/NWDVAR + 1
        lefmoppts = lefmopts + nfg*MXNEFMOPTS*MXEFMOPTS
        lefmodpts = lefmoppts + nfg*MXNEFMOPPTS*MXEFMOPPTS
        lnefmobas = lefmodpts + 12*nfg*MXNEFMOPPTS*MXEFMOPPTS
        lefmobas =  lnefmobas + nsh_tot*7
        lefmolmo = lefmobas + ng_tot*10
        lefmofm = lefmolmo + nfg*MXBSFN*MXMOS
        lefmocv = lefmofm + nfg*MXMO2
        lefmocf = lefmocv + nfg*MXBSFN*MXBSFN
        lefmodimg = lefmocf + nfg*MXMOS
c       this next definition is a bit wierd for lefmodimg, but we
c       need to store ALL of the efp gradient, i.e. the number
c       of atoms + whatever common atoms that the fragments have.
        lefmototg = lefmodimg + 3*natfmo+3*nbdfg
        lefmoipt = lefmototg + 3*natfmo
        lefmoiglob = lefmoipt + (nfg-1)/NWDVAR + 1

        lefmoesder = lefmoiglob + (MXATM-1)/NWDVAR+1
c       the 10 is due to 1 charge deriv + 3 dipole derivs +
c       6 quad derivs
        lefmo_fock_der = lefmoesder + nfg*mxefmopts*10*3*mxefmopts
c     this is for polarization. it collects the coefficients of the
c     dipole derivatives
        lefmodipder = lefmo_fock_der + nfg*ltwo
c     this is for saving the LMO transform for each fragment
        lefmo_tran = lefmodipder + nfg * 3 * mxefmoppts 
c     this is for the cpl lagrangian
        lcpl_coeff = lefmo_tran + nfg*mxmos*mxmos
c     this is for the alpha polarizability tensor-holding the total field on each pol point
        lefmo_tot_field = lcpl_coeff + ncpl_mem
c     this is for the alpha polarizability tensor-holding field response
        lefmo_f_resp = lefmo_tot_field + 3*3*nocc_tot 
c     this is for the dynamic and static responses (3 for x,y,z, 13 for 1 static
c     and 12 dynamic)
        lefmo_scphf = lefmo_f_resp + 3*13*NZVLG
c$$$        last = lefmo_scphf + 3*NZVLG
        lefmo_dyndisp = lefmo_scphf + 3*NZVLG
c     this is for the dynamic polarizability tensor coefficient
        lefmo_scptdhf = lefmo_dyndisp + 12*nocc_tot
c     this is for the dynamic polarizability tensor derivative
        last = lefmo_scptdhf + 36*nzvlg

c     for CPHF. allocates memory for multipole derivatives.
        if( lsczvec .and. iefmo_agrad .gt. 0 ) then
           lzvwrk = last
           lzvlag = lzvwrk + 10*nfg*mxefmopts*mxzvwk
           liptlg = lzvlag + nzvlg
c$$$ additional one for even/odd gradient issues
           last   = liptlg + NFG/NWDVAR + 1 + 1
c$$$           last   = liptlg + (NFG)/NWDVAR + 1
        endif

        NEEDEFMO = last - loadfm -1
        CALL GETFM(NEEDEFMO)
c       fills the iexrep_offset array, which allows
c       the nefmobas and efmobas array to be indexed into by fragment
        call efmo_calc_exrep_mem( x(llibnsh), x(llibng), nsh_tot,
     *       ng_tot,x(lizbas), x(liatfrg), x(lnatfrg), x(lianfrg),
     *       maxbas,maxnz,nfg, x(liexrep_offset),.true., x(llayfrg))
        call viclr(x(lnefmopts),1,7*nfg)
        call vclr(x(lefmopts),1,nfg*MXNEFMOPTS*MXEFMOPTS)
        call vclr(x(lefmoppts),1,nfg*MXNEFMOPPTS*MXEFMOPPTS)
c$$$        call vclr(x(lefmoesder),1,nfg*MXATM*10*3*mxefmopts)
        call vclr(x(lefmoesder),1,nfg*mxefmopts*10*3*mxefmopts)
        call vclr(x(lefmodpts),1,12*nfg*MXNEFMOPPTS*MXEFMOPPTS)
        call viclr(x(lnefmobas),1,nsh_tot*7)
        call vclr(x(lefmobas),1,ng_tot*10)
        call vclr(x(lefmolmo),1,nfg*MXBSFN*MXMOS)
        call vclr(x(lefmofm),1,nfg*MXMO2)
        call vclr(x(lefmocv),1,nfg*MXBSFN*MXBSFN)
        call vclr(x(lefmocf),1,nfg*MXMOS)
        call vclr(x(lefmodimg),1,3*natfmo+3*nbndfg)
        call vclr(x(lefmototg),1,3*natfmo)
        call viclr(x(lefmoipt),1,nfg)
        call viclr(x(lefmoiglob),1,MXATM)
        call vclr(x(lefmo_fock_der),1,nfg*2*ltwo)
        call vclr(x(lefmodipder),1,nfg*3*mxefmoppts)
        call vclr(x(lefmo_tran),1,nfg*mxmos*mxmos)
        call vclr(x(lcpl_coeff),1,ncpl_mem)
        call vclr(x(lefmo_tot_field),1,3*3*nocc_tot)
        call vclr(x(lefmo_f_resp),1,3*13*nzvlg)
        call vclr(x(lefmo_scphf),1,3*nzvlg)
        call vclr(x(lefmo_dyndisp),1,12*nocc_tot)
        call vclr(x(lefmo_scptdhf),1,36*nzvlg)
        if( lsczvec .and. iefmo_agrad .gt. 0 ) then
        call vclr(x(lzvwrk),1,10*nfg*mxefmopts*mxzvwk)
        call vclr(x(lzvlag),1,nzvlg)
        call vclr(x(liptlg),1,NFG/NWDVAR + 1)
        end if
        if(nevsav.eq.0) IEFMONFRG=nfg
        if (nder.gt.0 .and. nevsav.gt.0.and.maswrk) then
          if(modfd.ne.0) then
          call efmoread(nfg,x(lnefmopts),x(lefmopts),x(lefmoppts),
     *                  x(lefmodpts),x(lefmoipt))
          call efmoclact(nfg,x(llayfrg))
          endif
        endif
c       fills the iexrep_offset array, which allows
c       the nefmobas and efmobas array to be indexed into by fragment
        call efmo_calc_exrep_mem( x(llibnsh), x(llibng), nsh_tot,
     *       ng_tot,x(lizbas), x(liatfrg), x(lnatfrg), x(lianfrg),
     *       maxbas,maxnz,nfg, x(liexrep_offset),.true., x(llayfrg))
      ENDIF
      if(modfmm.ne.0) call setmcent(ncentm,x(lcrfrg),x(llayfrg),units)
c
c     if(dftbfl.and.scc) call vclr(x(ledij),1,nfg*nfg)
      if(nder.gt.0) call vclr(x(lfmode),1,3*natfmo*mbody)
      if(iahard.gt.0) call vclr(x(lfmohard),1,natfmo*nbody)
      if(esdder)   call viclr(x(lisdrec),1,NDAR30)
      if(dopleda) call vclr(x(lepl0ds),1,nepl0)
      if(primul) call vclr(x(lstonep),1,maxnat*nbody)
      if(nfrgmul.gt.0) call vclr(x(lfrgmul),1,(3+nfrgmul*2)*natfmob)
      if(iand(modlmo,4096).ne.0)call vclr(x(lfgflmo),1,maxl1*nbndfg*nfg)
      if(iand(modlmo,4096).ne.0)call viclr(x(lnfglmo),1,nfg)
      if(dosap.and.dodistr) call vclr(x(lpopmul),1,maxl1*nfg*2)
      if(dospc.and.dodistr) call vclr(x(lpopmat),1,maxnat*nfg*2)
      if(modfd.ne.0) call vclr(x(lenucfg),1,nfg)
      call vclr(x(leaip),1,nfg*2)
c
      if(ndualb.ne.0) then
        call vclr(x(lemonpl),1,nfg*2)
        if(nbody.gt.1) call vclr(x(ledimmixd),1,nfg2*3)
        if(nbody.gt.2.and.nfg3e.ne.0) call vclr(x(letrimmixd),1,nfg3e)
        call vclr(x(ldepl),1,natfmo*3)
        call vclr(x(lelmpl),1,nfmoelm)
        call vclr(x(latqpl),1,natfmo)
      endif
c     clear popmul and popmat because of the global sum in dmexch to avoid NAN
c
      if(nfrgmul.gt.0) then
        if(dolat.or.dopbcmd) call abrt
c       To implement, use lattice's UNTXYZ in stone multipole integrals.
        luntxyz=lfrgmul
        lfrgmul=lfrgmul+3*natfmob
      endif
c
c     This is needed to avoid strange artefacts.
      NEEDL=0
      if(dolat) then
        call vclr(x(lesplat),1,n2fmo*nsymop)
c       call vclr(x(lespl1i),1,n2fmo*nunesp)
c       call vclr(x(lespli1),1,n2fmo*nunesp)
c       Save the unit coordinates for FMO/PBC.
        call dcopy(natfmob*3,x(lcfrg),1,x(luntxyz),1)
c       write(6,6666)((x(luntxyz-1+jj+(kk-1)*3),jj=1,3),kk=1,nat)
c6666 format(100(3F12.5,/))
        call RUNITV(3,3,x(luntrot))
        do iu=1,nunptc
          ik=ixftch(x(lklms),(iu-1)*4+1)
          il=ixftch(x(lklms),(iu-1)*4+2)
          im=ixftch(x(lklms),(iu-1)*4+3)
          ig=ixftch(x(lklms),(iu-1)*4+4)
          luntxyzi=luntxyz+3*natfmob*iu
          luntroti=luntrot+3*3*iu
c         write(6,*) 'wwklms',iu,ik,il,im,ig
          call symolcc(ik,il,im,ig,natfmob,x(luntxyz),x(luntxyzi),
     *                 x(luntroti))
c         write(6,6666)((x(luntxyzi-1+jj+(kk-1)*3),jj=1,3),kk=1,nat)
        enddo
        if(nbody.gt.1) then
          call uniqpair(x(lfmozan),x(luntxyz),x(lunitnr),x(lnsymeq),
     *                  natfmob,nunptc,1,nunint,nsuint)
          call uniqpair(x(lfmozan),x(luntxyz),x(lunitnr),x(lnsymeq),
     *                  natfmob,nunptc,nunint+1,nunesp,msuesp)
          if(nunesp+1.le.nunptc) then
            call uniqpair(x(lfmozan),x(luntxyz),x(lunitnr),x(lnsymeq),
     *                    natfmob,nunptc,nunesp+1,nunptc,msuptc)
          else
            msuptc=0
          endif
          nsuesp=nsuint+msuesp
          nsuptc=nsuesp+msuptc
          inext=0
          do iu=1,nunptc
            ju=ixftch(x(lnsymeq),iu)
            if(ju.gt.0) then
              inext=inext+1
              ku=inext
            else
              ku=ixftch(x(lmapsu),-ju)
            endif
            call ixstor(x(lmapsu),iu,ku)
          enddo
c         write(6,*) 'wwwnse',(ixftch(x(lnsymeq),i),i=1,nunptc)
c         write(6,*) 'wwwnSE',(ixftch(x(lmapsu),i),i=1,nunptc)
        endif
        if(nbody.gt.1) then
          nfg2e=(nfg2+nfg*nfg*nsuptc)*nen
          nfg2l=nfg2+nfg*nfg*nsuint
          if(.not.primul) nfg2l=0
          if(needr.ne.0) mfg2=nfg2+nfg*nfg*nsuptc
c         rij, edim and ctdim are not allocated yet!
c         CT is only for SCF dimers, E and R are for all.
          CALL VALFM(LOADFM)
          ledim=LOADFM+1
          lctdim=ledim+nfg2e
          lrij=lctdim+nfg2l
          last=lrij+mfg2
          NEEDL = LAST- LOADFM -1
          CALL GETFM(NEEDL)
        endif
      else if (dopbcmd) then
        if(mdxcalled) call dcopy(natfmo,x(lindat),1,x(lindatmd),1)
        call dcopy(natfmob*3,x(lcfrg),1,x(luntxyz),1)
        call supcell(natfmob,x(luntxyz),x(ltrvec),x(lnsymeq))
        do iu=0,nimgcell
          call RUNITV(3,3,x(luntrot+3*3*iu))
        enddo
        if(nbody.gt.1) then
          inext=0
          do iu=1,nimgcell
            ju=ixftch(x(lnsymeq),iu)
            if(ju.gt.0) then
              inext=inext+1
              ku=inext
            else
              ku=ixftch(x(lmapsu),-ju)
            endif
            call ixstor(x(lmapsu),iu,ku)
          enddo
c
c         write(6,'("wwwnse",30i4)') (ixftch(x(lnsymeq),i),i=1,nunptc)
c         write(6,'("wwwnSE",30i4)') (ixftch(x(lmapsu),i),i=1,nunptc)
c
          nfg2e=(nfg2+nfg*nfg*nimgcell)*nen
          nfg2l=nfg2+nfg*nfg*nimgcell
          if(.not.primul) nfg2l=0
          if(needr.ne.0) mfg2=nfg2+nfg*(nfg*nimgcell)
c         rij, edim and ctdim are not allocated yet!
c         CT is only for SCF dimers, E and R are for all.
          CALL VALFM(LOADFM)
          ledim=LOADFM+1
          lctdim=ledim+nfg2e
          lrij=lctdim+nfg2l
          last=lrij+mfg2
          NEEDL = LAST- LOADFM -1
          CALL GETFM(NEEDL)
        endif
      endif
      nfg2d=nfg2e/nen
c
      IF (LSCZVEC.AND..NOT.DODISTR .or.dofret) THEN
        CALL ZVLGMEM2(X(LIPTLG),X(LNQMTFG),x(lscffrg),x(lmulfg),
     *                x(llayfrg),dofret,NSTAT1)
      END IF
      if(RUNTYP.EQ.FMOHESS) then
        CALL YALGMEM2(X(LIPTYA),X(LNQMTFG),x(lscffrg),x(lmulfg),
     *       x(lnatfrg),x(llayfrg))
      end if
      if(dofddpcm) then
c       write(6,*) "pcmfddgmem2"
        CALL PCMFDDGMEM2(X(LIPTYA),X(lnumfrg),x(llayfrg),nfg)
        if(ntspre.ne.0) then
          lenrec=ixftch(x(liptya),1+nfg)
          call readASCFMOFDD(X(LYALAG),lenrec)
        end if
c       write(6,*) "end pcmfddgmem2"
      end if
C
C     entire EFP calculation, including I/O, runs in world scope.
C
      IF (IEFPFMO.NE.0) THEN
        totefpc = zero
        if (isgddi) then
          call gddi_scope(ddi_world)
          CALL EFPPARL
        end if
        CALL EFPFMOIO(0)
        IF (NDER.GT.0) THEN
          CALL VCLR(X(LDEFTF),1,3*NFRG*NBODY)
          CALL VCLR(X(LTORQF),1,3*NFRG*NBODY)
          CALL VCLR(X(LDEFEF),1,6*NFRG)
        END IF
        CALL EFPFMODER(NDER,X(LDEFTF),X(LTORQF),X(LDEFEF))
        if(isgddi) then
          call gddi_scope(ddi_group)
          CALL EFPPARL
        end if
        if(ndbfac.eq.2.and.NDER.GT.0) then
          call dcopy(3*NFRG*NBODY,x(lDEFTF),1,x(lDEFTF+3*NFRG*NBODY),1)
          call dcopy(3*NFRG*NBODY,x(lTORQF),1,x(lTORQF+3*NFRG*NBODY),1)
          call dcopy(6*NFRG,x(lDEFEF),1,x(lDEFEF+6*NFRG),1)
        endif
      ENDIF
c     if(iefpfmo.ne.0)
c    *  call INIFMOEFP(nder,ndbfac,X(LDEFTF),X(LTORQF),X(LDEFEF))
c
      NFTDFTB=23
      IDAFMO=40
      DSKWRK=.true.
      call vclr(x(liodfmo),1,NDAR30f)
      icanuse1=.true.
      iused1=.false.
c     CALL RAOPEN(IDAFMO,x(liodfmo),0,NDAR30,LDAR30,NPRINT)
      if(.not.dodistr) then
        call RAOPEN2(IDAFMO,x(liodfmo),0,NDAR30,LDAR30,0,NPRINT)
      else
        call viclr(x(liodfmo),1,NDAR30)
        call ixstor(x(liodfmo),1,1)
c       Simulate file structure for restarts.
      endif
c     if(forbconv.or.densfmo0)  then
      if(forbconv)  then
        call viclr(x(liodcfmo),1,NDAR30c+n30ex)
        call RAOPEN2(IDAcFMO,x(liodcfmo),0,NDAR30c,LDAR30c,0,NPRINT)
c       It is vital to reserve the first record on IDAcFMO for indexing.
c       This is accomplished by writing something not very meaningful yet.
c       Such dummy writing also ensures that JRECST is correct later.
c       For FMO0 do a restart of the density file.
c       if(forbconv.or.inifmo0) then
          if(.not.icanuse1) iused1=.true. 
          call rawrites(IDAcFMO,x(liodcfmo),x(liodcfmo),NDAR30ci,
     *                  NDAR30ci,1,0)
c       else
c         here is a potentially dangerous part (if iolib is later altered)
c         (see fmorst for more comments).
c         call ixstor(x(liodcfmo),1,1)
c         call raread(IDAcFMO,x(liodcfmo),x(liodcfmo),NDAR30ci,1,0)
c         JRECST(IDAcFMO/10)=ixftch(x(liodcfmo),NDAR30c+5)
c       endif
      endif
      if(fmoq.or.needdm) then
        if(forbconv) call abrt
        call RAOPEN2(IDAcFMO,x(liodcfmo),0,NDAR30q,LDAR30q,0,NPRINT)
      endif
      DSKWRK=savdsk
c
c     Note on RAWRIT vs RAWRITE.
c     RAWRIT can be used if nlayer is 1. Otherwise one writes the same record
c     with different size and this cannot be done by RAWRIT (since later
c     writing has usually larger size). Therefore RAWRITE is used throughout.
c     Note that RAWRITE by allocating more phys records
c     makes the file size larger as well. An
c     economic solution is to set LEN1 argument in RAWRITE to the max
c     size for a given record, not to the max size for the whole file.
c     Such max size is stored in MAXL30.
C     for one layer use RAWRIT style (0 arg)??
c
      ioptdm=ishft(iand(modpar,512+1024),-9)
c     write(6,*) 'wwwaaa',ioptdm
      if(ioptdm.eq.3) call abrt
      if(dodistr) then
        if((addesp.or.diffesp).and.mulgeom) then
          write(6,*) 'addesp/diffesp not supported yet'
c         Will be easy
          call abrt
        endif
        if(nevsav.eq.0) then
          nsetdm=2
          if(esdder) nsetdm=3
          nexrst=NDAR30f
          if(ioptdm.ne.1) then
            nexrst=1
            if(maxrecsiz.lt.NDAR30f) then
             if(maswrk) write(iw,*) 'Switch to modpar=512 for restarts.'
c             to store record 1 of size NDAR30f for restarts
c             call abrt
              icanuse1=.false. 
              if(iused1.or.maxrecsiz.lt.NDAR30f-NDAR30) call abrt
            endif
          endif
          if(isgddi) call gddi_scope(ddi_world)
          call setdmpnt(ioptdm,esdder,x(lmaxl30),x(lidmpnt),nexrst,
     *                  ndmsiz)
          if(ioptdm.eq.1) then
c           supervector (row vector)
c           write(6,*) 'wwwcr',ndmsiz,nsetdm,nexrst,ndmsiz*nsetdm+nexrst
            call ddi_create(1,ndmsiz*nsetdm+nexrst,idmfmo)
            ndmsizp=ndmsiz*nsetdm+nexrst
          else
c           matrix
            call ddi_create(maxrecsiz,ndmsiz*nsetdm+nexrst,idmfmo)
            ndmsizp=maxrecsiz*(ndmsiz*nsetdm+nexrst)
          endif
         if(maswrk) write(iw,*) 'created M1',ioptdm,idmfmo,nexrst
          if(idmfmo.eq.-1) call abrt
c         if(esdder) call ddi_zero(idmfmo)
c         Actually, we need to zero out only the last third of the matrix
c         (which contains the RESDIM data to be accumulated).
          if(isgddi) call gddi_scope(ddi_group)
        else
          if(ioptdm.ne.1.and.maxrecsiz.lt.NDAR30f) icanuse1=.false.
        endif
      else
        nsetdm=0
        ndmsiz=0
        ndmsizp=0
        idmfmo=-1
c       if(dftbfl) idmfmo=-2
      endif
      if(dodiff) then
c       if(nevsav.eq.0) then
          ioptvm=1
          nsetvm=3
          call setvmpnt(x(lnumfrg),x(livmpnt),nvmsiz)
          if(nevsav.eq.0) then
            if(isgddi) call gddi_scope(ddi_world)
            if(ioptvm.eq.1) then
c             supervector (row vector)
              call ddi_create(1,nvmsiz*nsetvm,ivmfmo)
              nvmsizp=nvmsiz*nsetvm
            else
c             matrix
              call abrt
c             call ddi_create(maxl2,nvmsiz*nsetvm,ivmfmo)
c             nvmsizp=maxl2*nvmsiz*nsetvm
            endif
            if(maswrk) write(iw,*) 'created M2',ioptvm,nvmsizp,ivmfmo
            if(isgddi) call gddi_scope(ddi_group)
          endif
          if(ivmfmo.eq.-1) call abrt
c       endif
      else
        nvmsiz=0
        ivmfmo=-1
      endif
c
c     emon structure: (for monomer I), 3+4 are used for BSSE.
c     emon(i,1) E(I) FMO with default correlation
c     emon(i,2) E(I) FMO without correlation
c     emon(i,3) E(I) free monomer with correlation
c     emon(i,4) E(I) free monomer without correlation
c
c     edim structure: for dimer IJ
c     edim(ij,1) EIJ, default correlated
c     edim(ij,2) Tr(delta(DIJ)*VIJ), uncorrelated
c     edim(ij,3) EIJ, uncorrelated
c     edim(ij,4) Tr(delta(DIJ)*VIJ), def. correlated
c     edim(ij,5) E'I+E'J, BSSE(1,2,3), in the dimer basis, default correlated
c     edim(ij,6) Tr(delta(DIJ)*VIJ), BSSE(1,2), from monomers, uncorrelated
c     edim(ij,7) E'I+E'J, BSSE(1,2,3), in the dimer basis, uncorrelated
c                (reserved but not yet used).
c     edim(ij,8) Tr(delta(DIJ)*VIJ), BSSE(1,2), def. corelated
c                (reserved but not yet used).
c     edim(ij,3 or 5) delta-EIJ, electrostatic (ES).
c     edim(ij,4 or 6) delta-EIJ, exchange-repulsion (EX).
c     for EFMO, to store the EFP interaction energy.
c     edim(ij,5 or 7) delta-EIJ, charge-transfer (CT).
c     edim(ij,6 or 8) delta-EIJ, dispersion (DISP).
c     ES or EX options are really incompatible with BSSE now.
c     Note that D and E have different order of correlated/uncorrelated.
c     It comes from corr. D being an extravagance.
c     For DC, the dispersion is stored in edim(ij,3), and ES/EX are stored in
c     4/5.
c
c     etrim structure: for trimer IJK
c     etrim(ijk,1) EIJK, default correlated
c     etrim(ijk,2) Tr(delta(DIJK)*VIJK)
c     etrim(ijk,3) Tr(delta*delta(DIJK)*VIJK)
c     etrim(ijk,4) EIJK, uncorrelated
c     Depending on the option needdm, EIJK, uncorrelated can be stored in
c     etrim(ijk,3).
c
c     BSSE with correlation is not entirely finished and needs a good check.
c
c     extracc holds extra (by-product) CC energies, such as MP2 or
c     lower order CC.
c     etotdft will probably not work in multilayer FMO if DFT is mixed with
c     some other wavefunction.
      call vclr(etotdft,1,nedft)
      call vclr(x(lemon),1,nfg*4*nlayer)
      if(nbody.gt.1.and.nfg2e.ne.0) call vclr(x(ledim),1,nfg2e)
      if(nfg3e.ne.0) call vclr(x(letrim),1,nfg3e)
      if(nbody.gt.1) call vclr(edimsum,1,16)
      if(nbody.gt.2) call vclr(etrimsum,1,6)
      if(fullmfmo3) call vclr(x(ledimlow),1,nfg2*3)
      if(fmoq) call vclr(x(ledimq),1,nfg2)
      if(nfmoelm.ne.0) call vclr(x(lfmoelm),1,nfmoelm*(nfg+nbody-1))
      call viclr(x(lidmrec),1,nlayer)
      if(doexc.and.nbody.ge.2) then
        call vclr(x(leexfg),1,2*nfg*mxrt)
        if(iexcit(4).eq.2) call vclr(x(lctdm),1,nocctdm*nvirtdm*NSTAT)
        if(dofret) call vclr(x(lexcit2),1,nfg*nstat)
        if(dofret) call vclr(x(ltexcit2),1,nfg*nstat*3)
      endif
c     edimsum(1-8)- correspond to regular edim
c     edimsum(9-16)- correspond to the polarisation contributions to edim in AP
c     etrimsum(1) - delta E"IJK correlated
c     etrimsum(2) - delta DIJK uncorrelated
c     etrimsum(3) - delta E"IJK uncorrelated
c     For AP runs, 1-3 are for the current basis set in the loop of 1,2,3.
c                  4-6 are the polarisation energy contributions from 1,2.
c
      if(isgddi0) then
        call gddi_mastid(x(lmastid))
      else
        call ixstor(x(lmastid),1,master)
c       mastid(0)=master
      endif
      if(nbdfg.ne.0) call setindbd(x(liabdfg),x(ljabdfg),x(lindbd))
      if(totdens.or.totfock) then
      call glolat(x(lloctat),x(llibish),x(llibnsh),x(lizbas),x(lfmozan))
      endif
c
c     process restart initialisation
c
c     if(.not.dodistr)
      NDAR30a=NDAR30
      NDAR30fa=NDAR30f
      if(.not.icanuse1) then
c       do not read/write F40 record indexing
        NDAR30a=0
        NDAR30fa=NDAR30f-NDAR30
      endif
      call fmorst(nfg2,nfg3,nen,nent,l1fmo,NDAR30a,NDAR30fa,x(liodfmo),
     *            x(llayfrg),x(lemon),x(ledim),x(letrim),x(lidmrec),
     *            ifgfmo0,broadden.and.(mygroup.ne.0.or..not.maswrk),
     *            irestl,ntsread,n30exf,outpune,icanuse1,some)
c
c     Enforce restarting from layer 1 for FMO optimisations.
      if(nevsav.gt.0) irstlay=1
c     write(6,*) 'old modrst',modrst
c     if(nevsav.gt.0) modrst=mod(modrst,2)+2
      if(irststp.ge.2) modrst=mod(modrst,2)+2
c     write(6,*) 'new modrst',modrst
c     Adjust interation count (it also points out at the orbital location)
c
      ngrdsiz=3*natfmo*mbody
      nelmsiz=nfmoelm*(nfg+nbody)
      nesdsiz=0
      if(esdder) nesdsiz=NDAR30
      if(savgrd) call grdrst(0,nfthes,ngrdsiz,x(lfmode),nelmsiz,
     *                       x(lfmoelm),nesdsiz,x(lisdrec),.false.,
     *                       IDAFMO,ndar30,NDAR30f,x(liodfmo),icanuse1)
c
      needm=need0+need+need1+need2+needl
c     write(6,*) 'wwwmem',need0,need,need1,need2,needl
      if(maswrk.and.nevsav.eq.0)
     *  call fmoout(nder,needm,lbody,x(lfmozan),
     *              x(lfmoscf),x(lfmoci),x(lfmodft),x(lfmocc),x(lmpfmo),
     *              x(lfmotd),modmol,x(lmolfrg),nstfmo,ncvscf,mcnvfmo,
     *              ngrfmo,loadbf,loadgr,nstjob,ichfmo,mulfmo,nacut,
     *              savgrd,nxg,nyg,nzg,ngm,vdwrad,grdpad,spargrid,nxyzg,
     *              ifgfmo0,iexcit,nafo,naoafo,ndmsizp,natbuf,natprp,
     *              nactfg,gcorrel,fmosym,nfmosym,modcnv,docns,dodcesd,
     *              maxld,maxlt,fraggrid,nfraggr,nsubsys,imect)
c
c     efmo banner
      IF( IEFMORUN.GT.0.and.nevsav.eq.0.and.maswrk ) THEN
        CALL EFMOOUT(NEEDEFMO)
      ENDIF

      if(modmol.ne.0) then
        if(.not.subsys) call moldim(x(lmolfrg),x(lemolfrg))
c       emolfrg is used as temporary buffer. Note that moldim should be called
c       after fmoout to have the original array printed out.
      else
        call icopy(nfg,-1,0,x(lmolfrg),1)
      endif
c
      needr0=needr
c
c     PFTYP is not stored in any common block so we do not use PFTYP
c
      PFTYP=rnone
      runtype=runtyp
      if(runtyp.eq.OPTMIZ.or.runtyp.eq.sadpt.or.runtyp.eq.OPTFMO.or.
     *   runtyp.eq.HSSIAN) runtype=grad
      IF(RUNTYP.EQ.FMOHESS) RUNTYPE=HSSIAN
c     if(needdm) call gddi_create(nfg2,iddm)
c       the actual number of used elements is nscf (defined below)
      didcc=.false.
      didmp=.false.
c
c     The PCM loop is hidden inside monoscf for unilayer nfmopcm=1.
c     the explicit loop here is used otherwise.
c
      nbodysav=nbody
      nfg3sav=nfg3
      nfg3esav=nfg3e
C XXX
      if(nfmopcm.gt.1.or.
     *   nfmopcm.gt.0.and.nlayer.gt.1.and.modfd.eq.0) then
        iterpcm=1
        eprev=zero
c       overwrite nbody with the value in nfmopcm to converge the density
c       and apparent charges at that level.
        if(nfmopcm.lt.nbody) nbody=nfmopcm
        if(nbody.lt.3) then
          nfg3=0
          nfg3e=0
        endif
        if(nbody.ne.nbodysav) then
          nextra=1
        else
          nextra=0
        endif
      else
        iterpcm=0
        nextra=0
      endif
      if(nfmopcm.gt.1.and.mpcmit.gt.2.and.nder.gt.0) nextra=1
      if(nfmopcm.gt.1.and.mpcmit.gt.2.and.doexc) nextra=1
c
c     dual basis loop
c
      nbloop=1
      dadb=-one
      if(ndualb.ne.0) then
        ifmobas=1
        nbloop=3
      endif
c     coroffs=coroff
c     swoffs=swoff
      modgrds=modgrd
      LSCZVECs=LSCZVEC
      do ibloop=1,nbloop
c
      if(nbloop.ne.1) then
        if(ibloop.ne.2) then
c         turn off ESP
          ixesp=ior(ixesp,16384)
          iskipesp=2
c         irststp=0
c         regenerate initial orbitals
c         if(coroff.ne.0) swoff=coroff
c         coroff=0
c         For bare monomer runs we use COROFF as SWOFF.
          modgrd=1
          if(iand(modgrds,16).ne.0) modgrd=modgrd+16
          LSCZVEC=.false.
c         Turn off all ESP-related bits in modgrd.
        endif
        if(ibloop.eq.2) then
c         turn on ESP
          ixesp=ixesp-16384
          iskipesp=0
c         irststp=2
c         use gas-phase orbitals
          dadb=one
c         coroff=coroffs
c         swoff=swoffs
c         Use coroff for the embedded runs (SWOFF may not be used).
          modgrd=modgrds
          LSCZVEC=LSCZVECs
        endif
        if(ibloop.eq.3) ifmobas=2
        call vclr(x(lemon),1,nfg*4*nlayer)
        if(nbody.gt.1.and.nfg2e.ne.0) call vclr(x(ledim),1,nfg2e)
        if(nbody.gt.2.and.nfg3e.ne.0) call vclr(x(letrim),1,nfg3e)
        if(nbody.gt.1) call vclr(edimsum,1,8)
        if(nbody.gt.2) call vclr(etrimsum,1,3)
        if(nfmoelm.ne.0) call vclr(x(lfmoelm),1,nfmoelm*(nfg+nbody-1))
        if(nder.gt.0) call vclr(x(lfmode),1,3*natfmo*mbody)
        if(esdder) call viclr(x(lisdrec),1,NDAR30)
        if(IEFPFMO.NE.0.and.ibloop.gt.1) then
c         call INIFMOEFP(nder,X(LDEFTF),X(LTORQF),X(LDEFEF))
c         restore pure EFP gradients
          call dcopy(3*NFRG*NBODY,x(lDEFTF+3*NFRG*NBODY),1,x(lDEFTF),1)
          call dcopy(3*NFRG*NBODY,x(lTORQF+3*NFRG*NBODY),1,x(lTORQF),1)
          call dcopy(6*NFRG,x(lDEFEF+6*NFRG),1,x(lDEFEF),1)
        endif
      endif
c
      enucfmos=zero
      nextra0=nextra
      runtype0=runtype
      runtyp0=runtyp
      call stopwa(10,1)
      if(exetyp.eq.check) goto 110
c     The PCM[n] loop, n>1 (for MFMO n>=1).
   90 continue
      if(maswrk.and.ndualb.ne.0) write(iw,9720) ibloop,ifmobas,iskipesp
c     hui li - do not run properties in pcm iterations
      runtype=runtype0
      if(nfmopcm.gt.1.and.iterpcm.lt.mpcmit.and.runtype.eq.grad)
     *  runtype=energy
      if(nfmopcm.gt.1.and.mpcmit.gt.2.and.nextra.lt.nextra0)
     *  runtype=runtype0
c     This patches the PCM problem and other improper gradient treatment.
      runtyp=runtype
      CALL DERCHK(NDER)
      dovpcm=nextra.eq.nextra0.and.iterpcm.lt.mpcmit
      skipesd=iterpcm.eq.1.and.mpcmit.eq.2.and.nfmopcm.ge.2.and.
     *        iand(modpap,8).eq.0
      hopgrd=iand(modgrd,16).eq.0.and.nder.gt.0.and.nbdfg.ne.0.and.
     *       runtyp.ne.energy.and.(modfd.eq.0.or.nder.eq.1)
      if(dftbfl.and.nder.eq.2.and.hopgrd) hopgrd=.false.
c
      call vclr(etfmo,1,3)
c     enucfmo=zero
      e1efmo=zero
      ekinfmo=zero
c     if(nfg3e.ne.0) call vclr(x(letrim),1,nfg3e)
      call vclr(extracc,1,nextracc*mbody)
      if(primul) call vclr(x(latmulq),1,natfmo*mbody)
      if(nfmopcm.gt.0) call vclr(x(lesolv),1,nesolv)
      if(irststp.eq.2.and.dofddpcm) call fddpcmesolv(X(lesolv),nfg,0)
      call i0copy(nfg,x(llayfrg),0,x(llayfrg),nfg)
      if(nbody.gt.1.and.primul) call vclr(x(lctdim),1,nfg2l)
      if(doclmo) call vclr(x(latclmo),1,natfmo)
c
      do 100 ilay=irstlay,nlayer
        call stopwa(10,0)
        icurlay=ilay
c       if(rflmo(1).ne.0) then
c         call makelmo(icurlay,x(lfmozan),x(lfmoc),x(liaglob),
c    *                 x(liabdfg),x(ljabdfg),x(lidxcao),x(lclmo),
c    *                 x(lialmo),x(lindlmo),x(liwlmo))
c       endif
c
        scftypi=x(lfmoscf-1+ilay)
        mplevli=IXFTCH(x(lmpfmo),ilay)
        DFTYPE=x(lfmodft-1+ilay)
        if(DFTYPE.ne.rnone) then
          NDFTFG=1
          call INPGDFT(DFTYPE,PFTYP)
        else
          NDFTFG=0
          DFTTYP(3)=ONE
          LCFLAG=.FALSE.
          camflag=.false.
        endif
        CITYPi=x(lfmoci-1+ilay)
        CCTYPi=x(lfmocc-1+ilay)
        TDDFTi=x(lfmotd-1+ilay)
        if(nfmopcm.eq.0) nbody=lbody(ilay)
c       That means that setting different nbody in MFMO will not work in
c       FMO/PCM.
        if(nfmopcm.ne.0.and.gcorrel.and.
     *     mpcmit.eq.2.and.iterpcm.eq.1) then
c         during the first iteration in FMO/PCM[1(n)] one only
c         wants to get the density and dynamic correlation is a waste.
c         Note that during FMO/PCM[n] one needs correlation, as the
c         total correlated energy must converge.
          mplevli=0
          CITYPi=rnone
          CCTYPi=rnone
          TDDFTi=rnone
          if(maswrk) write(iw,*) 'Turning off correlation...'
        endif
c
c       for fmo-tddft/pcm[2]
c
        if(doexc.and.nfmopcm.eq.2.and.mpcmit.ne.2.and.
     *   nextra.eq.nextra0) then
          TDDFTi=rnone
          citypi=rnone
          if(maswrk) write(iw,*) 'Turning off TDDFT/CI...'
        endif
        dc=dcsav
        idcver=idcvers
        if((DC.or.idcver.gt.0).and.(mplevli.ne.0.or.CCTYPi.ne.rnone))
     *  then
          dc=.false.
          idcver=0
          if(maswrk) write(iw,*) 'Turning off DC...'
c         MP2 or CC with DC is nonsense
        endif
        if(maswrk.and.mdoutmin) then
          write(iw,9100) ilay,nbody,scftypi,mplevli,dftype,CITYPi,
     *                   CCTYPi,TDDFTi
        endif
        if(CCTYPi.ne.rnone) didcc=.true.
        if(mplevli.ne.0) didmp=.true.
c       Scan for ROHF and replace it by MCSCF
        moncor=0
        if(scftypi.eq.rohf) then
c         Signal to MCSCF that active space will be hadrwired to ROHF.
c         moncor=-1
c         scftypi=rmc
        endif
c
        correl=mplevli.ne.0 .or. CITYPi.ne.rnone .or. CCTYPi.ne.rnone
     *         .or.tddfti.ne.rnone
c       add other corrl
        if(correl.and..not.ext2lay.and.
     *     (rcorsd.gt.resdim.or.rcorsd.eq.0.and.resdim.ne.0)) then
          write(6,*) 'Invalid rcorsd and resdim',rcorsd,resdim
          call abrt
        endif
        if(citypi.ne.rnone.and.nder.gt.0) then
c         See below what needs to be done.
          write(6,*) 'FMO-CI gradient is not finished yet.'
c         call abrt
        endif
        if(ext2lay) then
          if(ilay.eq.1) then
c           Set each fragment to layer 1.
            call icopy(nfg,1,0,x(llayfrg),1)
          else
c           Restore layer assignment
            call i0copy(nfg,x(llayfrg),nfg,x(llayfrg),0)
            resdim=1.0D+06
c           Input should have resdim=0, to which resdim=1.0D+06 is equivalent,
c           but the correlated code must not have resdim=0.
          endif
        endif
c       Clear the old potential derivatives.
        if(dodistr.and.esdder) call clrvesd(ioptdm,idmfmo,x(lwrk),
     *                                      x(lmaxl30),x(lidmpnt))
C       CALCULATE GAMMA VALUES FOR DFTB BEFOREHAND
        IF (DFTBFL) THEN
          MODGAM = ABS(MODGAMMA)
          IF (SCC) THEN
            IF (IAND(MODGAM,3).EQ.0) THEN
              CALL VCLR(X(LGAMMA),1,12*NSPE*NSPE)
              IF (DFTB3) CALL VCLR(X(LGAMMA3),1,10*NSPE*NSPE)
            ELSE IF (IAND(MODGAM,1).NE.0) THEN
              CALL VCLR(X(LGAMMA),1,NATFMO*(NATFMO+1)/2)
              IF (DFTB3) CALL VCLR(X(LGAMMA3),1,NATFMO*NATFMO)
            ELSE IF (IAND(MODGAM,2).NE.0) THEN
              CALL VCLR(X(LGAMMA),1,NATFMOB*NATFMOB)
              IF (DFTB3) CALL VCLR(X(LGAMMA3),1,2*NATFMOB*NATFMOB)
            END IF
          END IF
          CALL VCLR(X(LZREF),1,NATFMOB)
          CALL VCLR(X(LISPE),1,NATFMO)
          IF (NDER.GT.0.AND.SCC) THEN
            CALL VCLR(X(LGAMMAD),1,10*NSPE*NSPE)
            IF (DFTB3) CALL VCLR(X(LGAMMA3D),1,11*NSPE*NSPE)
            CALL VCLR(X(LGAMMAD),1,10*NSPE*NSPE)
            CALL VCLR(X(LSHIFTG),1,NATFMOB*2)
            CALL VCLR(X(LSHIFTCT),1,NATFMOB)
            IF (DFTB3) THEN
              CALL VCLR(X(LCTMUL),1,2*NATFMOB)
            ELSE
              CALL VCLR(X(LCTMUL),1,NATFMOB)
            END IF
          END IF
          IF (DC.AND.IDFTBD.EQ.4) CALL VCLR(X(LNBOND),1,NATFMOB)
          CALL DFTB_GAMFMO(ABS(MODGAMMA),NDER,X(LINDFRG),
     *         X(LIANFRG),X(LIATFRG),X(LNATFRG),X(LISPE),X(LFMOZAN),
     *         X(LZANFRG),X(LGAMMA),X(LGAMMAD),X(LZREF),X(LFMOC),
     *         X(LGAMMA3),X(LGAMMA3D),X(LNBOND),MDOUT)
          IF (DC.AND..NOT.IDFTBD.EQ.3) THEN
            IF (MODGAMMA.LT.0) THEN
              CALL VCLR(X(LDCTMP),1,NATFMO*(NATFMO+1)/2)
            ELSE
              CALL VCLR(X(LDCTMP),1,3*NSPE*NSPE)
            END IF
            CALL DFTB_DCFMO(MODGAMMA,NATFMO,X(LDCTMP),X(LISPE),X(LFMOC))
          END IF
        END IF
c
c       Step 1: initial density matrices
c
        liemon=lemon+(ilay-1)*4*nfg
c
c       One of those FTNCHECK things
c
        ilay1=ilay
c
        if(isgddi0.and.ngrfmo(1,ilay).ne.0)
     *    call fmopre(ilay1,1,ngrfmo,x(lmannod),x(lmastid),irmdfmo)
c       write(6,*) 'mastids',(mastid(i),i=0,ngroups-1)
c
        doddcor=((MPLEVLi.gt.0.and.(MPPROP.ne.0.or.nder.gt.0)).or.
     *           citypi.ne.rnone.or.tddfti.ne.rnone.and.nder.gt.0).and.
     *          .not.doscfprp
        if(doddcor.and.nbody.gt.2.and.
     *     (resdim.ne.rcorsd.or.restri(3).ne.restri(4))) then
c         Only energy can be obtained. Properties need both uncorr. and corr.
c         dimer runs.
          write(iw,9120)
          call abrt
        endif
        e0centr=0
        icurit=0
        if(dopbcmd) then
          call vclr(x(lrij),1,mfg2)
          call viclr(x(lindxiu),1,nfg*nfg)
          call makeindexiu(ilay1,loadhf,x(lloadm),x(lindat),x(lfmozan),
     *                     x(lfmoc),x(liabdfg),x(ljabdfg),x(lscffrg),
     *                     needr0,x(lrij),x(lrwrk),mfg2,vdwrad,
     *                     x(lnprfrg),isgddi0,nunptc,natfmob,x(luntxyz),
     *                     units,x(lindxiu),.true.)
        end if
c
        if(iterpcm.le.1.or.nlayer.gt.1) then
c       inidfmo has to be called with the correct nbody/nfg3/nfg3e
c       (to fill in indexing arrays and sum them up in parallel).
        nbodys2=nbody
        nbody=nbodysav
        skipscc=modfd.ne.0.and.ilay.eq.1.and.irststp.ge.2
        jbsav=jbtyp
        if(scfesp) jbtyp=0
        call inidfmo(ilay1,loadhf,x(ljobgrp),x(lloadm),x(lloadd),
     *               x(lloadt),x(lichfg),x(llayfrg),x(lindat),x(lnumfrg)
     *              ,x(lnat0frg),x(lnatfrg),x(liaglob),x(lfmozan),
     *               x(lfmoc),x(lizbas),x(liabdfg),x(ljabdfg),x(liodfmo)
     *              ,x(lmaxl30),x(lidmrec),x(lfmoda),x(lfmodb),
     *               x(liemon+nfg*2),x(lglocon),x(llocfmo),x(lwrk),
     *               x(lmolfrg),x(lmulfg),x(lfrgnam),x(lscffrg),mcnvfmo,
     *               x(lmconfg),x(lijvec),correl,scftypi,mplevli,CITYPi,
     *               CCTYPi,tddfti,orbxch,enexch,atonce,dodistr,dosap,
     *               dospc,docas,nactfmo,ncasfmo,x(lmastid),needr0,
     *               x(lrij),x(lrwrk),nfg2,mfg2,nfg3sav,x(liwrkd),
     *               enucfmo,x(lpopmul),x(lpopmat),needmd,x(lnmdfrg),
     *               x(lnmtfrg),x(lndtfrg),prtdst,x(lifgbuf),x(lnfgbuf),
     *               nscf,nemc,forbconv,conv2mc,l1fmoc,IDAcFMO,
     *               x(liodcfmo),x(libfconv),x(lmapconv),x(lorbconv),
     *               loadbf(1,ilay),loadgr(1,ilay),nstjob,semidyn,
     *               broadden,vdwrad,exclmol,densgrid0,nxyzg,x(ldgrid),
     *               ngm,nxyzgm0,x(ldgridm),grdpad,spargrid0,x(lnoffg),
     *               x(lindgrd),x(lnprfrg),ifgfmo0,isgddi0,m0fmo,doddcor
     *              ,dolat,nunptc,natfmob,x(luntxyz),x(lnsymeq),
     *               x(lstonep),nfrgmul,x(lfrgmul),iexcit,modcha,e0centr
     *              ,x(latchrg),nafo,doclmo,x(latclmo),ilocals,nbndfg,
     *               x(lfgflmo),x(lnfglmo),irec0ini,dopdc,nsetgrid,
     *               iwhere,units,ntsread,n30exf,ihaveq0,x(lqini),
     *               x(lQSE),x(lQSN),X(LNQMTFG),gcorrel,skipscc,
     *               x(liactfg),nevsav,x(lenucfg),X(LVIPOT),dopbcmd,
     *               nimgcell,griddistr,x(LAXYZCT),x(lPEL),x(lVNUC),
     *               ichfmo,nefmo,nesolv,lfmasc,needasc,NTSPAR,dofddpcm,
     *               needmul,x(lfmasc+needasc+1),x(LYALAG),x(LIPTYA),
     *               X(LYAWRK),ntspre,savememr,x(lrij),skipsort,nacut,
     *               ngbody,qmcout,nftqmc,mdoutmin,x(lfzcor))
        jbtyp=jbsav 
c         Perhaps one should use layer-specific gcorrel?
          nbody=nbodys2
          if(ndualb.eq.0.or.ibloop.eq.3) l0fmo=l0fmo-m0fmo
          if(modfd.ne.0.and.ilay.eq.1) nscf1=nscf
          if(modfd.ne.0.and.ilay.gt.1) nscf=nscf1
          if(nbody.gt.1.and.nfg2e.ne.0.and.reuses) 
     *      call vclr(x(ledim),1,nfg2e)
        endif
        if(ext2lay.and.ilay.eq.1.and.nbody.eq.3) then
          call adjprp(2,x(llayfrg),x(lnmmfrg),x(lnddfrg))
        endif
c       write(6,*) 'wwwe0bda=',(x(le0bda-1+i),i=1,4*ne0bda*nlayer)
c       if(ilay.lt.irstlay) goto 100
        if(nbody.lt.1) goto 105
        if(forbconv) goto 105
c       if(needdm) then
c         if the value below exceeds integers that means the memory will not
c         work anyway. needmddi is an upper bound, exactly true for
c         molecular clusters but usually about 2 times an overestimate.
c         needmddi=(nscf*maxl2+(nfg2-1)/nwdvar)/1000000+1
c         if(maswrk) write(6,9110) needmddi
c       endif
c
        if(dodimden) then
          if(nevsav.eq.0.and.
     *      (ilay.eq.1.and.modfd.eq.0.or.modfd.ne.0.and.ilay.eq.2)) then
            if(isgddi) call gddi_scope(ddi_world)
            call setddpnt(orbxch,x(lnumfrg),x(llayfrg),x(liactfg),
     *                    x(liddpnt),nddsiz)
            if(orbxch) then
              ndextra=maxl1d*maxl1d
            else
              ndextra=(maxl1d*maxl1d+maxl1d)/2
            endif
c           nddleft=ndextra*5
            nddleft=ndextra*0
c           This feature at present works only with 1 group.
            iddcur=nddsiz+1
c           plan for at most 5 extra dimers
            call ddi_create(1,nddsiz+nddleft,iddfmo)
            if(isgddi) call gddi_scope(ddi_group)
            if(maswrk) write(6,*) 'created M3',nddsiz,nddleft,iddfmo
          endif
        else
          iddfmo=-1
          nddleft=0
          iddcur=0
        endif
       if(skipscc) then
         if(maswrk) write(iw,*) 'Skipping frozen layer in FMO/FD.'
         call ixstor(x(litrlay),1,0)
c        copy atomic charges/populations, as inidfmo only creates a single copy
c        in the first set.
         if(dosap.or.dospc) then
           call dcopy(maxl1*nfg,x(lpopmul),1,x(lpopmul+maxl1*nfg),1)
           if(dospc)
     *       call dcopy(maxnat*nfg,x(lpopmat),1,x(lpopmat+maxnat*nfg),1)
         endif
         goto 105
       endif
C
C       FOR SCZV
C
        IF (LSCZVEC.AND.DODISTR.AND.NEVSAV.EQ.0) THEN
          IF (ISGDDI) CALL GDDI_SCOPE(DDI_WORLD)
          CALL SETDZVEC(NZVSZ,X(LIPTZVEC),X(LIPTLG),X(LNUMFRG),
     *                  X(LNQMTFG),X(LMAXL30),x(llayfrg))
          CALL DDI_CREATE(1,NZVSZ,IDFZVEC)
          IF (ISGDDI) CALL GDDI_SCOPE(DDI_GROUP)
        END IF
C
        IF( IEFMORUN.GT.0 ) IEFMORT = 1
C
C     RESTORE FMO-DFTB CHARGES FOR GEOMETRY OPTIMIZATION
C
      IF (DFTBFL.AND.SCC) THEN
        CALL DFTB_PREVMUL(NFTDFTB,MAXNAT*NFG*2,0,X(LPOPMAT),RUNTYP)
      END IF
c
c       Now the big monomer SCF iterations start
c
c      write(6,*) 'wwwrij',(x(lrij+ij-1),ij=1,nfg2)
c
c      nder1=nder
c      runtyp1=runtype
c      if(modfd.ne.0.and.ilay.eq.1) then
c        runtyp1=energy
c        nder1=0
c      endif
       call stopwa(10,1)
       call stopwa(11,0)
       jbsav=jbtyp
       if(scfesp) jbtyp=0
       call monoscf(ilay1,nder,runtype,loadhf,ndar30a,ndar30fa,
     *              x(ljobgrp),x(lloadm),x(lichfg),x(llayfrg),x(lnumfrg)
     *             ,x(lnatfrg),x(liaglob),x(lindat),x(lfmozan),x(lfmoc),
     *              x(liabdfg),x(ljabdfg),x(lidxcao),ichfmo,nefmo,
     *              x(liodfmo),x(lmaxl30),x(lidmrec),x(lfmoda),x(lfmodb)
     *             ,x(lfmoespa),x(lwrk),x(lwrk1),x(lwrk2),x(liemon),
     *              x(lrwrk),x(lglocon),x(lfmode),x(lfmopg),x(latmulq),
     *              x(latmulqi),mbody,nfmoelm,x(lfmoelm),needmd,
     *              x(lnmmfrg),x(lnmdfrg),x(lnmtfrg),x(lmolfrg),
     *              x(lscffrg),correl,scftypi,mplevli,CITYPi,CCTYPi,
     *              tddfti,mcnvfmo,ncvscf,x(lmconfg),dosap,dospc,docas,
     *              primul,orbxch,enexch,atonce,dodistr,x(litrlay),
     *              nfglay,x(lpopmul),x(lpopmat),x(lifgbuf),x(lnfgbuf),
     *              ngrfmo,x(lmannod),x(lmastid),x(lnprfrg),totdens,
     *              totfock,l2fmo,x(ltotd),x(liaoglob),exclmol,densgrid,
     *              nxyzg,x(ldgrid),ntimout,loadgr(1,ilay),nstjob(1),
     *              l1dir,ngm,nxyzgm,x(ldgridm),grdpad,vdwrad,spargrid,
     *              x(lnoffg),x(lindgrd),ifgfmo0,isgddi0,grandmas,
     *              densfmo0,IDAcFMO,x(liodcfmo),extracc,nextracc,lfmasc
     *             ,needasc,x(lesolv),nesolv,iterpcm,NTSPAR,dovpcm,
     *              pcmoff,etotdft,nedft,x(LAXYZCT),x(lPEL),x(lVNUC),
     *              x(lqini),n30exf,ihaveq0,dopleda,x(lepl0ds),
     *              x(lefmo0+(ilay-1)*nfg*2),doscfprp,ext2lay,dolat,
     *              n2fmo,x(lklms),x(luntrot),x(lesplat),addesp,diffesp,
     *              x(lstonep),natfmob,nfrgmul,x(lfrgmul),iexcit,eexcit,
     *              texcit,monoc,monvr,nstmono,nocctdm,nvirtdm,nocctdb,
     *              nvirtdb,x(lctdm),modcha,x(latchrg),doclmo,doclmo1,
     *              x(lclmo),x(lialmo),x(lindlmo),x(liwlmo),x(latclmo),
     *              dovlmo,x(llmobdf),x(lfgflmo),x(lnfglmo),x(llfglmo),
     *              x(lpfglmo),ilocals,X(LDDIJPOT),naoafo3,naoafod,
     *              x(ldafo),nbndfg,irec0ini,dopdc,nsetgrid,iwhere,
     *              gcorrel,doddcor,e1efmo,ekinfmo,m1efmo,x(leigfmo),
     *             X(LEFPIEA),X(LFGINT),x(lfmoddm),X(LFMOFCM),X(LFCMWRK)
     *             ,X(LABFLDT),X(LDINDF2),X(LDINDDF2),X(LZVLAG),
     *              X(LIPTLG),X(LZVWRK),X(LNQMTFG),hopgrd,dodc,
     *              x(lindtmp),x(lfmohard),x(leaip),X(LVIPOT),nevsav,
     *              modcnv,x(lcrfrg),clm,flm,x(lf_mm),x(lg_mm),
     *              x(lylmfrgv),x(lzlmfrgv),x(lylmfrgq),x(lylmfrgq2),
     *              X(LALCNT2F),x(LYALAG),x(LIPTYA),x(LYAWRK),nhybnam,
     *              ibloop,dopbcmd,enucfmo,x(llocfmo),mdout,mdoutmin,
     *              x(liactfg),NC1,dofddpcm,needmul,x(lfmasc+needasc+1),
     *              griddistr,urospn,X(lpmulspin),spinden,irmdfmo,
     *              fraggrid,subsys,ngbody,qmcout,nftqmc,dofret,
     *              x(lexcit2),x(ltexcit2),scfesp, x(lefmo_scphf))
        jbtyp=jbsav
C       IF (DFTBFL) CALL DFTB_GIVEEAIP(LEAIP)
c       call fmogout(1,maswrk,x(lindat),x(lfmozan),x(lfmode),x(lDEFTF),
c    *               x(lTORQF))
c       call fmogout(2,maswrk,x(lindat),x(lfmozan),x(lfmode),x(lDEFTF),
c    *               x(lTORQF))
c
c       if(dodistr) then
c         do ifg=1,nfg
c        call rawrites(idafmo,x(liodfmo),x(lwrk),ixftch(x(lmaxl30),ifg),iitmp,
c    *                 ii+nfg*2+1,0)
c         enddo
c       endif
c       write(6,*) 'NI stat: ',(nni(i),i=1,9),'NJ stat: ',(nnj(i),i=1,9)
C
C     SRP: PREVENT CALLING RMD_PROP LATER IF WE FAILED
C          TO CONVERGE THE MONOMER SCC DURING RMD RUNS     
C
        if(irmdfmo.gt.0.and.ntimout.eq.2) then
          irmdfmo=irmdfmo + ntimout
        endif
c       Reset nbody to show results for the the first unconverged nbody level.
        if(ntimout.gt.1) nbody=1
        if(ntimout.gt.1.and.iterpcm.gt.0) iterpcm=0
c       For unconverged SCC in PCM[1(n)] or PCM[n], n>1, break the PCM loop.
        call stopwa(11,1)
        if(ntimout.ne.0) goto 110
c
c       if(dolat) then
c         do iu=1,nunesp
c           do ifg=1,nfg
c             ind=lespl1i+(iu-1)*n2fmo+(ifg-1)*maxl2
c             write(6,*) 'ESP1(I),1e',ifg,iu
c             call prtri(x(ind),maxl1)
c           enddo
c         enddo
c         do iu=2,nunesp
c           ind2=lespl1i+(iu-1)*n2fmo+(ifg-1)*maxl2
c           call daxpy(n2fmo,one,x(ind2),1,x(lespl1i),1)
c         enddo
c         do ifg=1,nfg
c           write(6,*) 'ESP1,1e',ifg
c           ind=lespl1i+(ifg-1)*maxl2
c           call prtri(x(ind),maxl1)
c         enddo
c         call genlatv(ilay1,natfmob,maxklms,n2fmo,nunptc,x(lklms),
c    *            x(luntxyz),x(luntrot),x(lcfrg),x(lfmoespa),x(lesplat))
c       endif
c
c      save monomer energies for restarts
c
        if(nfglay.ne.0) call eminout(1,ilay1,ifgfmo0,x(llayfrg),x(lemon)
     *                              ,outpune,some)
c
c      START EFMO EVAULATION OF THE TOTAL POLARIZATION ENERGY
C      ONLY DO TOTAL EFP EVALUATION WHEN WE HAVE TOTAL PROPERTIES
C      FROM ALL LAYERS
       EFMOPCMG=0.0D+00
       IF( IEFMORUN.GT.0.AND.IEFMORT.EQ.1.AND.ILAY.EQ.NLAYER) THEN
         IEFMORT = 4
         CALL EFMOTOT(x(lfmode),x(lfrgnam))
         IEFMORT = 3
       ENDIF
c
        if(nbody.lt.2.or. modfd.ne.0.and.ilay.eq.1) goto 105
c
c       compute all dimer energies and BBSE corrections if requested.
c
        if(nfglay.ne.0) then
          if(isgddi0.and.ngrfmo(2,ilay).ne.0)
     *      call fmopre(ilay1,2,ngrfmo,x(lmannod),x(lmastid),irmdfmo)
c     It is an annoying artifact of ngrfmo(1) and ngrfmo(2) division in which
c     a master can become a slave and vice versa.
          lfmoelmd=lfmoelm+nfmoelm*nfg
          lfmoelmt=lfmoelm+nfmoelm*(nfg+1)
c         CIS properties can be added similar to MPPROP
c         GUGA CI gradients are not quite working. One has to sort out
c         densities (CI and SCF, getting both properties at the same time etc).
c         The real question is: how to do FMO-CI?
c         Two approaches seem meaningful:
c         1. Define only one fragment as CI. This makes FMO-RHF:CI and is
c            well defined (not fully programmed yet).
c         2. Define some fragments as CI and study local excitation energies
c            while abandoning all other properties (-all- is really meant here,
c            including pair interaction energies)..
c         if(doddcor.and.nlayer.gt.1) call abrt
c     multi-layer runs need sophisticated setup of MP2/RHF densities
c     doddcor tells whether to do delta-DIJ terms for RHF and dynamic
c     correlation (if false, do only RHF delta-DIJ terms).
c     At present only MP2 is supported.
c         will doddcor be proper for restarts?
c         irec0cor=idmrec0(ilay)
          irec0cor=ixftch(x(lidmrec),ilay)
c         this is a bit of a hack to get irec0rhf
          irec0rhf=1
          if(irec0cor.eq.1) irec0rhf=nfg*2+1
          irec0=irec0cor
          if(doddcor) irec0=irec0rhf
c$$$ for efmo, this is the right record, even if it's an MP2 run.
c$$$ otherwise we don't get the right orbital energies. It has something
c$$$ to do with EFMO only needing one iteration of monoscf.
          if(iefmorun .gt. 0) irec0=irec0cor
          if(dopleda) irec0cor=irec0rhf
          if(nbloop.ne.1.and.ibloop.ne.2) irec0=irec0cor
c         For dual basis, this is actually a bummer.
c         The two dry runs (no ESP) store only correlated density on F40.
c         We use it as initial guess of dimers/trimers in RHF.
c         if(iand(modlmo,16384).ne.0) irec0cor=irec0rhf
c         For PL0, irec0cor points to PL0  monomer densities DI
c         For PL0, irec0    points to free monomer densities DI
          if(fmoq.or.needdm) call viclr(x(ljob2grp),1,nfg2)
c         ifmoqit=0
c         nfmoqit=20
c  95     continue
c         ifmoqit=ifmoqit+1
          icurit=1
c
          if(modfmm.ne.0) call fmmfrg(ilay1,nder,loadhf,x(lloadm),
     *      x(llayfrg),x(lscffrg),x(liactfg),x(liodfmo),x(lmaxl30),
     *      orbxch,x(lfmoda),x(lfmodb),x(lwrk1),irec0,clm,flm,x(lf_mm),
     *      x(lg_mm),x(lcrfrg),x(lylmfrg),x(lzlmfrg),x(lylmfrgq),
     *      x(lpopmat),x(lfmode+3*natfmo),x(lfmopg),x(liaglob),
     *      x(lisdrec),x(lesdi),dodistr,savgrd)
c
          call stopwa(14,0)
          call edimer(ilay1,nder,runtype,loadhf,x(ljobgrp),x(lloadm),
     *                x(lloadd),x(lmulfg),x(llayfrg),x(lnumfrg),x(lcfrg)
     *              ,x(liodfmo),x(lmaxl30),x(lindat),x(lfmoc),x(liaglob)
     *               ,x(lidmrec),needr.gt.0,x(lfmoda),x(lfmodb),x(lwrk),
     *               x(lwrk1),x(lwrk2),x(lzsave),x(lfmoespa),x(lfmoespb)
     *               ,x(liemon),x(ledim),x(lfmode),x(lfmopg),enucfmo,
     *              e1efmo,ekinfmo,x(latmulq+natfmo),nfmoelm,x(lfmoelmd)
     *               ,x(lfmoelmt),x(lnddfrg),x(lndtfrg),x(liabdfg),
     *                x(ljabdfg),x(llocfmo),x(lmolfrg),x(lscffrg),
     *                x(lmapi),x(lmapj),mcnvfmo,mconvex,x(lmconfg),
     *                x(lijvec),correl,scftypi,mplevli,CITYPi,CCTYPi,
     *                tddfti,nfg2d,nfg2,nen,nactfmo,ncasfmo,primul,
     *                orbxch,enexch,ntimout,nscf,nemc,docas,nedimes,
     *                nedimex,x(ljob2grp),needdm,ngrfmo,x(lmannod),
     *                x(lmastid),x(lnprfrg),x(lisdrec),nfthes,ngrdsiz,
     *                nelmsiz,nesdsiz,x(lfmoelm),ndar30,NDAR30f,savgrd,
     *               modmol,exclmol,totdens,totfock,x(ltotd),x(liaoglob)
     *               ,densgrid,nxyzg,x(ldgrid),loadgr(2,ilay),nstjob(2),
     *                l1dir,grdpad,vdwrad,spargrid,x(lnoffg),x(lindgrd),
     *                extracc,nextracc,irec0,irec0cor,doddcor,x(lesolv),
     *                dovpcm,etotdft,nedft,x(LAXYZCT),x(lPEL),x(lVNUC),
     *                x(lQSE),X(LISPHE),x(lqtmp),imect,x(lctdim),
     *               x(lpopmat),x(lialoc),x(lindbd),ext2lay,fmoq,IDAcFMO
     *               ,x(liodcfmo),dopleda,dolat,nunint,nunptc,
     *                natfmob,x(luntxyz),x(luntrot),x(lesp1i),x(lesp1j),
     *                x(lczi),x(lczj),x(lnsymeq),maxl2,n2fmo,x(lklms),
     *                x(lesplat),addesp,addesp0,x(lstonep),iexcit,eexcit
     *               ,texcit,monoc,monvr,nstmono,isumd,x(leexfg),
     *                nocctdm,nvirtdm,nocctdb,nvirtdb,x(lctdm),exfid,
     *                dopdc,modcha,iwhere,gcorrel,skipesd,dodistr,
     *                x(lfmoddm),X(LFMOFCM),X(LFCMWRK),X(LABFLDT),
     *                X(LDINDF2),X(LDINDDF2),X(LZVLAG),X(LIPTLG),
     *                X(LNQMTFG),X(LZVWRK),hopgrd,dodc,dodimden,
     *                x(liddpnt),nevsav,x(lindtmp),x(lfmohard),
     *                x(lefmodimg),x(liactfg),x(lemon),outpune,
     *                x(lenucfg),clm,flm,x(lf_mm),x(lg_mm),x(lcrfrg),
     *                x(lylmfrg),x(lylmfrgq),x(lylmfrgq2),x(lfrgnam),
     *                x(lefmoiglob),X(LVIPOT),outesd,fullmfmo3,
     *                x(ledimlow),X(LALCNT2F),x(LYALAG),x(LIPTYA),
     *                x(LYAWRK),NC1,dodcesd,nsetgrid,x(lfmobuf(1)),
     *                dopbcmd,x(lfmozan),needr0,x(lrwrk),mfg2,units,
     *                x(lindxiu),x(lrij),X(LESDIMTMP),reducee,mdout,
     *                mdoutmin,griddistr,urospn,X(lpmulspin),spinden,
     *               lfmasc,needasc,needmul,x(lfmasc+needasc+1),savemem2
     *               ,savememr,edimsum,x(liwrkd),icanuse1,irmdfmo,
     *                qmcout,nftqmc,dofret,some)
c       call fmogout(1,maswrk,x(lindat),x(lfmozan),x(lfmode),x(lDEFTF),
c    *               x(lTORQF))
c       call fmogout(2,maswrk,x(lindat),x(lfmozan),x(lfmode),x(lDEFTF),
c    *               x(lTORQF))
          if(ntimout.gt.1) nbody=2
          if(ntimout.ne.0) goto 110
c      write(6,*) '2NI stat: ',(nni(i),i=1,9),'NJ stat: ',(nnj(i),i=1,9)
          if(fmoq) then
c           if(fmoq) call viclr(x(ljob2grp),1,nfg2)
            call efmoq(ilay1,loadhf,x(lloadd),x(llayfrg),x(lmolfrg),
     *                IDAcFMO,x(liodcfmo),modmol,exclmol,x(ledimq))
c           call vclr(x(ledimq),1,nfg2)
c           e1sum=ddot(nfg,x(lemon),1,one,0)
c           e2sum=ddot(nfg2*2,x(ledim),1,one,0)
c           write(6,*) 'FMOQ iter=',ifmoqit,' E=',-(nfg-2)*e1sum+e2sum
c           if(ifmoqit.lt.nfmoqit) then
c             call vclr(x(ledim),1,nfg2e)
c             if(nfmoelm.ne.0) call vclr(x(lfmoelm+nfg*nfmoelm),1,
c    *                                   nfmoelm)
c             goto 95
c           endif
          endif
          call stopwa(14,1)
          if(nbody.lt.3) goto 105
c
          if(isgddi0.and.ngrfmo(3,ilay).ne.0)
     *      call fmopre(ilay1,3,ngrfmo,x(lmannod),x(lmastid),irmdfmo)
          call stopwa(17,0)
          call etrimer(ilay1,nder,runtype,loadhf,x(lloadt),x(lmulfg),
     *                 x(llayfrg),x(lnumfrg),x(liodfmo),x(lindat),
     *                 x(lfmoc),x(liaglob),x(lfmoda),x(lfmodb),x(lwrkc),
     *                 x(lwrk),x(lwrk1),x(lwrk2),x(lfmoespa),x(letrim),
     *                 x(lfmode),x(lfmopg),x(latmulq+natfmo*2),nfmoelm,
     *                 x(lfmoelmt),x(liabdfg),x(ljabdfg),x(llocfmo),
     *                 x(lmolfrg),x(lscffrg),x(lmapi),x(lmapj),x(lmap3),
     *                 mcnvfmo,mconvex,x(lmconfg),x(lijvec),correl,
     *                 scftypi,mplevli,CITYPi,CCTYPi,tddfti,nfg3,nent,
     *                 nactfmo,maxl1d,primul,orbxch,enexch,ntimout,
     *                 x(ljob2grp),needdm,x(lnprfrg),totdens,totfock,
     *                 x(ltotd),x(liaoglob),modmol,exclmol,densgrid,
     *                 x(ldgrid),l1dir,grdpad,vdwrad,extracc,nextracc,
     *                 irec0,doddcor,x(lesolv3),dovpcm,etotdft,nedft,
     *                 x(LAXYZCT),x(lPEL),x(lVNUC),IDAcFMO,x(liodcfmo),
     *                 x(luntrot),x(lstonep),dopdc,modcha,iwhere,gcorrel
     *                ,e1efmo,ekinfmo,x(lfmoddm),X(LFMOFCM),X(LFCMWRK),
     *                 X(LABFLDT),X(LDINDF2),X(LDINDDF2),X(LZVLAG),
     *                X(LIPTLG),hopgrd,x(lindtmp),x(lfmohard),X(LIDMREC)
     *                ,X(LNQMTFG),X(LLOADM),NGRFMO,X(LMANNOD),X(LMASTID)
     *               ,NEVSAV,outpune,clm,flm,x(lf_mm),x(lg_mm),x(lcrfrg)
     *                ,x(lYlmfrgq),x(lylmfrgq2),dodc,nsetgrid,x(LYALAG),
     *                x(LIPTYA),x(LYAWRK),dopbcmd,savemem,etrimsum,
     *                mdout,mdoutmin,griddistr,irmdfmo,x(lpopmat),
     *                x(lialoc),x(lindbd),qmcout,nftqmc,some)
          call stopwa(17,1)
        endif
c
  105   continue
c         reset for the next layer. If layers have the same basis set (size),
c         previous layer's orbitals/densities can be read.
        if(modfd.eq.0) then
          modrst=0
          irststp=0
        endif
        if(iand(nguess,32768).ne.0) then
c         MP2 density??
          modrst=1
          irststp=2
        endif
        if(irststp.eq.0) broadden=.false.
        needr0=0
c       rij is computed for layer 1 that is supposed to include all atoms!!
c       (that gibberish means that rij are not recomputed for layers beyond 1)
        if(esdder) call viclr(x(lisdrec),1,NDAR30)
  100 continue
      if(domeppcm) then
        ldgrid1=ldgrid
c       Point to MEP
        if(.not.griddistr) ldgrid1=ldgrid1+nxyzg*ngbody
        call pcmmep(1,x(ldgrid1),1,NXG,1,NYG,1,NZG,
     *              1,NXG,1,NYG,1,NZG,ORIGIN,UX,UY,UZ,x(LQSE),X(LAXYZCT)
     *           ,X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),X(LISPHE),griddistr)
c    *             ,X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),griddistr)
      endif
c
  110 continue
      if(nfmopcm.eq.0) nbody=lbody(inamax(MaxLay,lbody,1))
c
c     RESDIM runs alter iodfmo and it has to be saved now.
c
      if(esdder) then
c      icanuse1
       call ixstor(x(liodfmo),NDAR30a+5,JRECST(IDAFMO/10))
       call rawrites(IDAFMO,x(liodfmo),x(liodfmo),NDAR30fa,NDAR30fa,1,0)
      endif
c
c     if(needdm) call gddi_destroy(iddm)
      ndata=0
      if(isgddi0) then
        CALL TSECND(TIMe0)
        wall0=wall
c       if(.not.maswrk) call vclr(x(ledim),1,nfg2e)
        call gddi_scope(ddi_world)
        if(nfmoelm.ne.0) then
          call ddi_gsumf(2416,x(lfmoelm),nfmoelm*(nfg+nbody-1))
          ndata=ndata+nfmoelm*(nfg+nbody-1)
        endif
        if(nfg2e.ne.0) then
          call ddi_gsumf(2415,x(ledim),nfg2e)
          ndata=ndata+nfg2e
        else if(savemem2) then
          call ddi_gsumf(2415,edimsum,8)
c         write(6,*) 'wwwEd',edimsum(1),edimsum(2)
          ndata=ndata+8
        endif
        call ddi_gsumf(2415,etfmo,3)
        ndata=ndata+3
        if(m1efmo.ne.0) then
          call ddi_gsumf(2415,x(leigfmo),m1efmo)
          ndata=ndata+m1efmo
        endif
        if(fmoq) then
          call ddi_gsumf(2415,x(ledimq),nfg2)
          ndata=ndata+nfg2
        endif
        if(fullmfmo3) then
          call ddi_gsumf(2415,x(ledimlow),nfg2*3)
          ndata=ndata+nfg2*3
        endif
        if(nfg3e.ne.0) then
          call ddi_gsumf(2415,x(letrim),nfg3e)
          ndata=ndata+nfg3e
        else if(nbody.gt.2.and.savemem) then
          call ddi_gsumf(2415,etrimsum,3)
c         call ddi_gsumf(2415,etrimsum,6)
          ndata=ndata+3
        endif
        if(ndftfg.eq.1) then
          call ddi_gsumf(2415,etotdft,nedft)
          ndata=ndata+nedft
        endif
        if(didcc.or.didmp) then
          call ddi_gsumf(2415,extracc,nextracc*mbody)
          ndata=ndata+nextracc*mbody
        endif
        if(doexc.and.nbody.ge.2) then
          call ddi_gsumi(2415,isumd,mxrt+1)
          call ddi_gsumf(2415,eexcit(1,2),mxrt)
          call ddi_gsumf(2415,texcit(1,1,2),3*mxrt)
          call ddi_gsumf(2415,x(leexfg),2*nfg*mxrt)
          ndata=ndata+4*mxrt+mxrt+1+2*nfg*mxrt
        endif
        if(primul) then
          call ddi_gsumf(2416,x(latmulq),natfmo*mbody)
          ndata=ndata+natfmo*mbody
        endif
        if(nder.gt.0) then
          call ddi_gsumf(2416,x(lfmode),3*natfmo*mbody)
          ndata=ndata+3*natfmo
        endif
        if(totdens) then
          call ddi_gsumf(2416,x(ltotd),l2fmo)
          ndata=ndata+l2fmo
        endif
        if((densgrid.and.ifgfmo0.eq.0 .or.spargrid).and..not.griddistr) 
     *  then
          call ddi_gsumf(2416,x(ldgrid),nxyzg*ngbody*nsetgrid)
          ndata=ndata+nxyzg*ngbody*nsetgrid
        endif
        if(nfmopcm.ne.0) then
          call ddi_gsumf(2416,x(lesolv+nfg),nesolv-nfg)
c         The first nfg elements are exchanged in monoscf.
          ndata=ndata+nesolv-nfg
          if(iterpcm.gt.0.and.dovpcm) then
            call ddi_gsumf(2418,x(lPEL),NTS)
            call ddi_gsumf(2418,x(lVNUC),NTS)
            ndata=ndata+NTS*2
          endif
        endif
        if(nbody.gt.1.and.primul) then
          call ddi_gsumf(2415,x(lctdim),nfg2l)
          ndata=ndata+nfg2l
        endif
        if(dopleda) then
c         Sum upper two monomer energies.
c         no MFMO here! Easy to change (add ilay loop).
c         call ddi_gsumf(2415,x(lemon+nfg*2),nfg*2)
          call ddi_gsumf(2415,x(lepl0ds),nepl0)
          ndata=ndata+nepl0
        endif
        if(IEFPFMO.NE.0) then
          if(IEFPFMO.EQ.2) then
            call ddi_gsumf(2415,poltot,1)
            call ddi_gsumf(2415,X(LALCNT2F),NFG)
            ndata=ndata+1+nfg
          end if
          if(NDER.GT.0) then
            call ddi_gsumf(2415,x(LDEFTF),3*NFRG*NBODY)
            call ddi_gsumf(2415,x(LTORQF),3*NFRG*NBODY)
            ndata=ndata+3*NFRG*NBODY*2
          endif
        endif
        IF (IEACAL.EQ.1) THEN
          IF (IAND(NPRIEA,10).NE.0) THEN
            call ddi_gsumf(2415,X(LEFPIEA),MXEFPT*NFRGI1*NATFIEA*8)
            ndata=ndata+MXEFPT*NFRGI1*NATFIEA*8+1
          END IF
          IF (IAND(NPRIEA, 5).NE.0) THEN
            call ddi_gsumf(2415,X(LFGINT),NFGIEA*NFRGI2*8)
            ndata=ndata+NFGIEA*NFRGI2*8+1
          END IF
          CALL DDI_GSUMF(2415,REMPOL,1)
        END IF
        if(urospn) then
          CALL DDI_GSUMF(2415,X(lpmulspin+natfmo),natfmo+nfg2)
          ndata=ndata+natfmo+nfg2
        end if
        IF (NDER.EQ.2) THEN
          CALL DDI_GSUMF(2415,X(LFMOFCM),NC1*NC1)
          CALL DDI_GSUMF(2415,X(LFMOddm),3*NC1)
          ndata=ndata+NC1*NC1+3*NC1
        END IF
        if(iahard.gt.0.and.nbody.ne.0) then
          CALL DDI_GSUMF(2415,X(lfmohard),natfmo*nbody)
          ndata=ndata+natfmo*nbody
        endif
        if(iand(modfmm,2).ne.0) then
          CALL DDI_GSUMF(2415,X(lesdi),nfg)
          ndata=ndata+nfg
        endif
        CALL DDI_GSUMF(2415,X(leaip),nfg*2)
        ndata=ndata+nfg*2
        call gddi_scope(ddi_group)
        CALL TSECND(TIMe1)
        if(maswrk.and.mdoutmin) write(iw,9600) ndata,wall-wall0
      else
        if(nder.gt.0) call ddi_gsumf(2416,x(lfmode),3*natfmo*mbody)
        if((densgrid.and.ifgfmo0.eq.0 .or.spargrid).and..not.griddistr)
     *    call ddi_gsumf(2416,x(ldgrid),nxyzg*ngbody*nsetgrid)
        if(IEFPFMO.NE.0) then
          if(IEFPFMO.EQ.2) then
            call ddi_gsumf(2415,poltot,1)
            call ddi_gsumf(2415,X(LALCNT2F),NFG)
          end if
          if(NDER.GT.0) then
            call ddi_gsumf(2416,x(LDEFTF),3*NFRG*NBODY)
            call ddi_gsumf(2416,x(LTORQF),3*NFRG*NBODY)
          end if
        endif
        if(nfmopcm.ne.0.and.iterpcm.gt.0.and.dovpcm) then
          call ddi_gsumf(2418,x(lPEL),NTS)
          call ddi_gsumf(2418,x(lVNUC),NTS)
        endif
        IF (IEACAL.EQ.1) THEN
          IF (IAND(NPRIEA,10).NE.0)
     *    call ddi_gsumf(2418,X(LEFPIEA),MXEFPT*NFRGI1*NATFIEA*8)
          IF (IAND(NPRIEA, 5).NE.0)
     *    call ddi_gsumf(2418,X(LFGINT),NFGIEA*NFRGI2*8)
          CALL DDI_GSUMF(2418,REMPOL,1)
        END IF
        IF (NDER.EQ.2) THEN
          CALL DDI_GSUMF(2418,X(LFMOFCM),NC1*NC1)
          CALL DDI_GSUMF(2418,X(LFMOddm),3*NC1)
        END IF
      endif
c     write(6,*) 'wwwdgrid2',(x(ldgrid+i-1),i=1,nxyzg)
c     For DFT or PCM, project out transl+rot degrees of freedom from the
c     gradient each ibody separately.
c     Note that it should be done only after global summing the gradient.
      projgrad=NDFTFG.EQ.1.OR.DFTTYP(1).NE.0.0D+00.or.nfmopcm.ne.0
      if(iand(modgrd,64).ne.0) projgrad=.not.projgrad
      IF(iterpcm.gt.0.and.dovpcm) then
c
c     Finish off some FMO-PCM properties.
c
        if(isgddi) call gddi_scope(ddi_world)
c       2 in calcasc means 2nd iteration (skipping initial guess formation).
        call calcasc(2,NTSPAR,ichfmo,nefmo,lfmasc,needasc,idum1,nesolv,
     *               idum2,idum3,idum4,idum5,x(lqini),ihaveq0,nprfmo)
        if(isgddi) call gddi_scope(ddi_group)
c       New PCM charges are NOT saved on F40 here. Instead, they are saved in
c       the next call to monoscf, for FMO/PCM[n], n>1.
c       This, however, still saves the latest set of charges, because the
c       charges are not updated during the last iteration of FMO/PCM[n], n>1.
      endif
      IF(nfmopcm.ne.0) then
        call surfes(nfg2,x(lindat),X(LISPHE),X(LAXYZCT+MXTS*3),
     *              X(LXYZRE+MXSP*3),X(LAXYZCT),x(LXYZRE+MXSP*2),x(LQSE)
     *             ,x(lqpot),x(lemocdr),x(lemocdr+7*nfg),x(lemocdra),
     *              x(lfmasc+needasc+1),dofddpcm)
      endif
      if(nfmopcm.ne.0.and.dofddpcm) call fddpcmesolv(X(lesolv),nfg,1)
c
c       Step 6: Compute total energy and properties
c
      nenm=1
      if(gcorrel.or.dodc) nenm=nenm+1
      if(ntimout.gt.1) then
        if(modef.ne.0) nfmoelm=0
        enucfmo=0
c       For diverged runs during geometry optimisation dipole moments are
c       not accumulated.
c       For other RUNTYPs some dipole moments may be available, some are
c       zero (unconverged ones).
c       enucfmo is not properly computed either (it can be got; but why?).
      endif
c     Enucfmo is not computed correctly for 1-body FMO with fractioned bonds or
c     MFMOn-PCM[1], n>1. Zero out for the latter case rather that try to get it.
      if(nfmopcm.eq.1.and.nlayer.gt.1.and.nbody.eq.1.and.nbodysav.gt.1)
     *  enucfmo=zero
c     FMO-PCM[2] does not call inidfmo for iterpcm>1, this enucfmo gets wrong
c     values. Recover by saving the value for iterpcm=1 and then reusing it.
c     Do not do it for multilayer runs.
      if(nlayer.eq.1) then
        if(iterpcm.eq.1) enucfmos=enucfmo
        if(iterpcm.gt.1) enucfmo=enucfmos
      endif
c     if(maswrk)
c     if(exetyp.ne.check)
c
      if(irststp.eq.2.and.ispher.eq.1) l0fmo=0
c     l0fmo is definitely wrong for restarts (because QMTSYM is not called in
c     GUESS). For now just zero out. It seems possible to save l0fmo on F40...
c
C
C     COPY TO DEFT AND TORQ FOR NEXT CALCULATIONS (FMO/EFP)
C
      IF (IEFPFMO.NE.0.AND.NDER.GT.0) THEN
        CALL DCOPY(NFRG*3,X(LDEFTF+(NBODY-1)*NFRG*3),1,DEFT,1)
        CALL DCOPY(NFRG*3,X(LTORQF+(NBODY-1)*NFRG*3),1,TORQ,1)
      END IF
C
C     PCMCDR IS MOVED FROM CCMBEM
c
      IF (NDER.GT.0.AND.NFMOPCM.GT.0.AND.(ICAV.EQ.1.OR.IDISP.EQ.1)) THEN
        NATF3 = NATFMO*3
        DO IB = 1, NBODY
          CALL DAXPY(NATF3,ONE,X(LPCMCDR),1,X(LFMODE+(IB-1)*NATF3),1)
        END DO
      END IF
C
C     As of 10/6/15, the gradient projection is done after all PCM terms are added.
c
      IF(nder.gt.0.and.projgrad) then
        CALL TSECND(TIMe0)
        wall0=wall
c       we must cheat RAMS subroutine because it is not smart enough to have
c       NAT as its argument. RAMs is also treacherously called from PRJGRD,
c       thus nat restore we must after all is done.
        natsav=nat
        nat=natfmo
        do ibody=1,nbody
          call grdprj(x(lfmode+(ibody-1)*3*natfmo),x(lfmoc),x(lfmomas),
     *                natfmo)
        enddo
        nat=natsav
        CALL TSECND(TIMe1)
        if(maswrk) write(iw,9610) wall-wall0
      endif
c
      IF (IEACAL.EQ.1) THEN
        IF (IEFPFMO.EQ.2) THEN
          REMPOL = REMPOL - EFPEFP
          REMPOL = REMPOL*2625.5D+00
        END IF
        CALL EFPIEAOUT(X(LINDAT))
      END IF
      IF (IEFPFMO.EQ.2) REPNUCEFP = REPNUCEFP + POLTOT
      IF (IEACAL.EQ.1.AND.ITRLVL.EQ.2) REPNUCEFP = ZERO
      if (IEFPFMO.ne.0.and.maswrk) write(iw,*) 'POLTOT=', POLTOT
c
      if(modfd.ne.0) then
c       call fmogout(1,maswrk,x(lindat),x(lfmozan),x(lfmode),x(lDEFTF),
c    *               x(lTORQF))
c       call fmogout(2,maswrk,x(lindat),x(lfmozan),x(lfmode),x(lDEFTF),
c    *               x(lTORQF))
        call clrinact(x(liactat),x(lfmode))
c       call fmogout(1,maswrk,x(lindat),x(lfmozan),x(lfmode),x(lDEFTF),
c    *               x(lTORQF))
c       call fmogout(2,maswrk,x(lindat),x(lfmozan),x(lfmode),x(lDEFTF),
c    *               x(lTORQF))
      endif
C
c       write(6,*) 'wwwe0bda2=',(x(le0bda-1+i),i=1,4*ne0bda*nlayer)
c     hasgrad=runtyps.ne.fmohess.or.resdim.eq.0
      hasgrad=runtyps.ne.fmohess
c     For RUNTYP=FMOHESS and nonzero RESDIM the Hessian code computing the
c     gradient as well should be extended into adding ES gradients (see TVDER).
c     At present the 2-body gradient is garbage (if wanted, it should be got in
c     a separate run).
      scftyp=scftyps
c
      call fmoprop(nder,ichfmo,nefmo,mulfmo,l0fmo,l1fmo,nfg2d,nfg2,nfg3,
     *             nenm,nen,nent,needdm,x(lichfg),x(lfrgnam),x(llayfrg),
     *             x(lindat),x(liabdfg),x(ljabdfg),x(litrlay),x(lfmozan)
     *            ,x(lscffrg),x(lfmoscf),x(llcorrel),modmol,exclmol,
     *             x(lmolfrg),x(lemolfrg),x(lemon),x(ledim),x(letrim),
     *             x(ledimq),x(lesolv),x(lemocdr),x(lfmode),fmoq,primul,
     *             enucfmo,e1efmo,ekinfmo,x(latmulq),nfmoelm,x(lfmoelm),
     *             nelm,modef,gcorrel,nedimes,nedimex,ifgfmo0,doddcor,
     *             isgddi0,extracc,nextracc,didcc,didmp,etotdft,nedft,
     *             x(lctdim),n0bda,i0bda,x(le0bda),x(lefmo0),x(lepl0ds),
     *             eint0,dopleda,rappri,nappri,x(lerapp),x(lnrapp),
     *             ext2lay,x(LDEFTF),x(LTORQF),dolat,nunint,x(lnsymeq),
     *             iexcit,eexcit,texcit,nstmono,osmd,isumd,x(leexfg),
     *             modcha,e0centr,dopdc,TDDFTi.ne.rnone,citypi.ne.rnone,
     *             x(LFZCOR),totfock,x(lnumfrg),m1efmo,x(leigfmo),
     *             x(libfmo),skipesd,urohf,dodc,x(lfmohard),x(leaip),
     *             x(liactfg),x(liactat),modfd.ne.0.and.irststp.ge.2,
     *             nevsav,prtdst,x(lemocdra),x(lesdi),hasgrad,fullmfmo3,
     *             x(ledimlow),needmd,docns,x(lcnsdat),X(LALCNT2F),
     *             runtyps,dodcesd,dopbcmd,savemem,etrimsum,reducee,
     *             x(lctspin),x(lpmulspin),savemem2,edimsum,urospn,
     *             subsys,nsubsys,x(lsubprp),dofret,x(lexcit2),
     *             x(ltexcit2),mdoutmin)
c
      if(iterpcm.gt.0) then
        econv=etot-eprev
        if(maswrk.and.nextra.eq.nextra0) write(iw,9700) iterpcm,econv
        eprev=etot
        pcmnotconv=abs(econv).ge.convpcm.and.iterpcm.lt.mpcmit.and.
     *             nextra.eq.nextra0 .or. skipesd
c       Force continuing iterations for PCM[1(n)] with SKIPESD.
        iterpcm=iterpcm+1
        if(pcmnotconv.or.nextra.gt.0) then
c         if(.not.pcmnotconv) then
          if(.not.pcmnotconv.or.mpcmit.eq.2.and.nextra.gt.0) then
            nextra=nextra-1
            nbody=nbodysav
            nfg3=nfg3sav
            nfg3e=nfg3esav
          endif
          call vclr(x(lemon),1,nfg*4*nlayer)
          if(nbody.gt.1.and.nfg2e.ne.0) call vclr(x(ledim),1,nfg2e)
          if(nfg3e.ne.0) call vclr(x(letrim),1,nfg3e)
          if(nbody.gt.1) call vclr(edimsum,1,16)
          if(nbody.gt.2) call vclr(etrimsum,1,6)
          if(nfmoelm.ne.0) call vclr(x(lfmoelm),1,nfmoelm*(nfg+nbody-1))
c         fmode was zeroed out by H. Li and this was commented out because
c         in FMO/PCM iterations the gradient is not computed.
c         if(nder.gt.1) call vclr(x(lfmode),1,3*natfmo*mbody)
          goto 90
        endif
        if(iterpcm.ge.mpcmit) then
          if(mpcmit.eq.2) then
c           FMOn/PCM[m(l)] at present can only be run for m=1.
            if(maswrk) write(iw,9710) nbody,1,nfmopcm
          else
            if(maswrk) write(iw,*) 'PCM[2] did not converge!'
c           call abrt
          endif
        endif
c       if(etot.eq.0.and.maswrk)
c    *      write(iw,*) 'FMO did not converge, stopping PCM iterations.'
      endif
c
      nbody=nbodysav
      nfg3=nfg3sav
      nfg3e=nfg3esav
      runtyp=runtyp0
c
      if(ndualb.ne.0) then
        if(etot.eq.0) then
          if(maswrk) write(iw,*) 'Divergence detected, quitting...'
          goto 5550
        endif
        lfmodel=lfmode+3*natfmo*(mbody-1)
        lfmoelml=lfmoelm+nfmoelm*nfg
        if(nbody.eq.3) lfmoelml=lfmoelm+nfmoelm*(nfg+1)
        if(nbody.eq.1) lfmoelml=lfmoelm+nfmoelm*(nfg+2)
        if(ibloop.ne.3) then
        call addpropdb(gcorrel.or.dodc,primul,nder,dadb,nfg2,nfg3,nfg3e,
     *                 nfmoelm,x(lemonpl),x(ledimmixd),x(letrimmixd),
     *                 x(ldepl),x(lelmpl),x(latqpl),x(lemon),x(ledim),
     *                 x(letrim),x(lfmodel),x(lfmoelml),
     *                 x(latmulq+natfmo*(mbody-1)),savemem,etrimsum)
        else
c       call prpropdb(gcorrel.or.dodc,primul,nder,nfg2,nfmoelm,
c    *              x(lemonpl),x(ledimmixd),x(ldepl),x(lelmpl),x(latqpl)
c    *             ,x(lemon),x(ledim),x(lfmodel),x(lfmoelm+nfmoelm*nfg),
c    *              x(latmulq+natfmo*(mbody-1)))
        call propdb(isgddi0,gcorrel,dodc,primul,nder,nfg2,nfg3,
     *              nfmoelm,modcha,x(lfrgnam),x(lindat),x(lfmozan),
     *              x(lfzcor),x(ldeftf),x(ltorqf),x(lfmode),x(latmulq),
     *              x(lemonpl),x(ledimmixd),x(letrimmixd),x(ldepl),
     *              x(lelmpl),x(latqpl),savemem,etrimsum)
        endif
        if(isgddi0) then
c         CALL DDI_SYNC(1147)
          call gddi_scope(ddi_world)
          call gddi_scope(ddi_group)
c         Switch scopes to do a global sync. It seems that such a sync
c         is actually needed for any FMO run, especially with
c         multiple geometries, to handle bad ngrfmo (more groups than
c         tasks)?
        endif
      endif
      enddo
c     ibloop
 5550 continue
c     coroff=coroffs
c     swoff=swoffs
      modgrd=modgrds
      LSCZVECs=LSCZVEC
c
c     Silly way to pass some results to FMO0.
c
      if(ifgfmo0.ne.0) then
        icurlay=ixftch(x(llayfrg),1)
        espscf=x(lfrgnam)
        num=ixftch(x(lnumfrg),1)
        nat=ixftch(x(lnatfrg),1)
        SCFTYP=x(lscffrg)
        nat1e=ixftch(x(lmaxl30),1)
      endif
c
      lfmodel=lfmode+3*natfmo*(mbody-1)
c     if(runtyp.eq.OPTMIZ.or.runtyp.eq.sadpt)
      if(modef.ne.2) call gmsprop(modef,nfthes,nc1,x(llayfrg),x(lindat),
     *           x(lfmodel),x(lfmomas),x(liactfg),nfcrec,grandmas,LGLOE,
     *           dofddpcm,X(lesolv))
c     restore coordinates
c     check gradient
c     if(maswrk) then
c      write(6,*) "check gradient"
c      CALL EGOUT(x(lfmodel),natfmo)
c     end if
C
C     SRP: SAVE THE GRADIENT FOR THIS STATE,
C
      if(irmdfmo.gt.0) then
         call rmd_prop(x(lfmodel),natfmo,ISTLOOP,irmdfmo)
       endif

      if(modef.eq.1) then
        call gmsxyz(0,nfthes,nc1,natfmo,x(llayfrg),x(lindat),x(lfmozan),
     *              x(lfmoc),x(lfmomas),x(lizbas),x(liactfg),nfcrec,
     *             nevsav,grandmas,nactfg,fmosym,nfmosym,squit,mdoutmin)
        squit=.false.
      endif
C
      IF (NDER.EQ.2) THEN
c       if (maswrk) then
c         write(6,*) 'FMO HESSIAN',nc1
c         call prsq(X(LFMOFCM),nc1,nc1,nc1)
c       end if
        IF(modfd.eq.0) then
          natm=natfmo
        ELSE
          natm=0
          DO IATM=1,natfmo
            ifg=ixftch(x(lindat),iatm)
c           write(6,'("check=",3I4)') iatm,
c    *        ixftch(x(lindat),iatm),ixftch(x(llayfrg),ifg)
            if(ixftch(x(llayfrg),ifg).gt.1) then
              natm=natm+1
              zmass(natm)=x(lfmomas+iatm-1)
            end if
          END DO
          call dcopy(natm,zmass,1,x(lfmomas),1)
          call dcopy(natm,  zan,1,x(lfmozan),1)
          call dcopy(natm*3,  c,1,x(lfmoc),1)
        END IF
        CALL FMODDMNUC(NFG,x(lfmozan),x(lfmomas),NATM,
     *       X(lichfg),X(LFMOddm))
C
C       PROJECT OUT Frozen element
        if(modfd.ne.0) then
          LDDMWRK=LFCMWRK+nc1*nc1
          CALL PRJFMOHSS(X(LFMOFCM),X(LFCMWRK),X(LFMOddm),X(LDDMWRK),
     *         NC1,natfmo,x(llayfrg),x(lindat),0) 
        end if
C
        call CLOSDA('DELETE')
        CALL OPENDA(0)
        CALL DAWRIT(IDAF,IODA,X(LFMODE),NC1,3,0)
        CALL DAWRIT(IDAF,IODA,X(LFMOFCM),NC1*NC1,4,0)
c       this is not used with totdens (see below)
        CALL DAWRIT(IDAF,IODA,X(LFMOddm),3*NC1,34,0)
      END IF
c
c     Save the total electron density
c
      if(totdens) then
        call CLOSDA('DELETE')
        CALL OPENDA(0)
        CALL dawrit(IDAF,IODA,x(ltotd),l2fmo,16,0)
c       write(6,*) 'wwwcurdt'
c       call prtri(x(ltotd),21)
      endif
c     Only the global master dumps cube
c     if(densgrid.and.grandmas)
      if(densgrid.and.ifgfmo0.eq.0) then
        IF(ISGDDI.and.griddistr) CALL GDDI_SCOPE(DDI_WORLD)
c       The sole purpose of the scope switch is to do a global sync...
c       But we do need to work in the global scope...
        if(grandmas) then
c       masw=maswrk
c       maswrk=.true.
          write(iw,*) 'Punching cube data...'
          do iset=1,nsetgrid
            call makecube(iset,0,nbody,natfmo,x(lfmozan),x(lfmoc),
     *                    x(ldgrid+(iset-1)*nxyzg*ngbody),
     *                    NXG,NYG,NZG,ORIGIN,UX,UY,UZ,GRDSIZ,griddistr)
          enddo
          call timit(1)
c       maswrk=masw
        endif
        IF(ISGDDI.and.griddistr) CALL GDDI_SCOPE(DDI_GROUP)
      endif
      if(spargrid.and.(ifgfmo0.ne.0.and.maswrk.or.grandmas)) then
        write(iw,*) 'Punching sparse cube data...'
        do iset=1,nsetgrid
          do ibody=1,mbody
            iibody=ibody
            if(nbody.eq.0) iibody=0
            call makescube(iset,1,ifgfmo0,iibody,x(llayfrg),x(lindat),
     *                     x(lfmozan),x(lfmoc),
     *                  x(ldgrid+(ibody-1)*nxyzg+(iset-1)*nxyzg*ngbody),
     *                     x(lnoffg),x(lindgrd),maxg)
        enddo
        enddo
        call timit(1)
      endif
c
c     Save the energy gradient
c
c     if(runtyp.eq.optfmo) call dcopy(natfmo*3,x(lfmodel),1,x(lfmoge),1)
      if(runtyp.eq.optfmo.or.(runefp.eq.fmomd.and.modfd.eq.0)) 
     *  call dcopy(natfmo*3,x(lfmodel),1,x(lfmoge),1)
c
c     not possible here - need to preserve between geometries.
c     destroy in an external driver if iddfmo >=0.
c     if(dodimden) then
c       call gddi_scope(ddi_world)
c       call ddi_destroy(iddfmo)
c       call gddi_scope(ddi_group)
c     endif
c
      if(dodiff.and..not.mulgeom) then
        if(isgddi) call gddi_scope(ddi_world)
        call ddi_destroy(ivmfmo)
        if(isgddi) call gddi_scope(ddi_group)
        ivmfmo=-1
      endif
      if(dodistr.and..not.mulgeom) then
        IF (LSCZVEC) CALL RETZVEC
        if(isgddi) call gddi_scope(ddi_world)
        call ddi_destroy(idmfmo)
        if(isgddi) call gddi_scope(ddi_group)
        idmfmo=-1
c       to prevent further possible erroneous operations
      endif
      if(griddistr) then
        if(isgddi) call gddi_scope(ddi_world)
        if(nsetgrid.eq.2) call ddi_destroy(itmfmo(2))
        call ddi_destroy(itmfmo(1))
        if(isgddi) call gddi_scope(ddi_group)
      endif
c
      DSKWRK=.true.
      if(fmoq.or.needdm) then
        call RACLOS(IDAcFMO,'DELETE')
      endif
c     if(forbconv.or.densfmo0) then
      if(forbconv) then
c       if(densfmo0) l1fmo=0
        call bconvrec(x(lfmozan),x(lizbas),x(liabdfg),NDAR30c,
     *                x(liodcfmo),l1fmo,l1fmoc,IDAcFMO,x(libfconv),
     *                maxl1.ne.maxl1c)
        if(.not.icanuse1) call abrt
        call rawrites(IDAcFMO,x(liodcfmo),x(liodcfmo),NDAR30ci,NDAR30ci,
     *                1,0)
        CALL RACLOS(IDAcFMO,'KEEP')
      endif
      if(.not.dodistr) CALL RACLOS(IDAFMO,'KEEP')
      DSKWRK=savdsk
c
c     Dump MOLPLT data for external program.
c
      IF(MOLPLT) then
        if(natfmo.le.MXATM) then
          nat=natfmo
          call dcopy(nat,x(lfmozan),1,zan,1)
          call dcopy(3*nat,x(lfmoc),1,c,1)
          call viclr(izcore,1,nat)
c         FMOZAN has the true nuclear charge.
          CALL MOLMEM
        else
          if(maswrk) write(iw,*) 'Too many atoms for MOLPLT.'
        endif
      endif
C
C     SAVE FMO-DFTB CHARGES FOR GEOMETRY OPTIMIZATION
C
      IF (DFTBFL.AND.SCC) THEN
        CALL DFTB_PREVMUL(NFTDFTB,MAXNAT*NFG*2,1,X(LPOPMAT),RUNTYP)
      END IF
c
c
      if(dolat.or.dopbcmd) CALL RETFM(NEEDL)
      IF( IEFMORUN.GT.0 ) CALL RETFM(NEEDEFMO)
      CALL RETFM(NEED1)
      CALL RETFM(NEED2)
c
      IF (IEFPFMO.NE.0) then
         IF (ISGDDI) CALL GDDI_SCOPE(DDI_WORLD)
         CALL EFPFMOIO(1)
         IF (ISGDDI) CALL GDDI_SCOPE(DDI_GROUP)
      END IF
c
c5555 continue
      IF(nfmopcm.ne.0) then
        CALL RETFM(needasc+needmul)
c       memPCM1 and memPCM2 are allocated in INPPCM.
        CALL RETFM(memPCM2)
        CALL RETFM(memPCM1)
      endif
 5555 continue
      if(i0bda.lt.n0bda) goto 80
      if(n0bda.ne.0.and.maswrk) call bdaeout(n0bda,x(le0bda))
      if(dopleda) call eplout(x(lepl0ds),eint0)
c
c
      CALL RETFM(NEED)
      CALL RETFM(NEED0)
c
c     restore SCF settings that are likely to have been overwritten
c     during SCF and would otherwise have been erroneously used as the
c     default values during any goemtry optimisation.
c     Since calling NAMEIO involves a broadcast, it is probably better done
c     in the current group scope.
      if(modef.ne.0) CALL SCFIN
c
      if(.not.squit) then
        nevals=nevsav+1
c       if(maswrk) write(iw,9000)
c            Print timing on slaves
        if(maswrk.or.parout) then
           iptim0=iptim
           iptim=1
           if(mdoutmin) call timit(1)
           iptim=iptim0
        end if
        nzmat=nzmtsav
      else
c       call gddi_scope(ddi_world)
c       It is needed just to get NPROC next time FMOX is called.
c       Or should we do it always?
      endif
 5556 continue
      if(runtyp.eq.OPTMIZ.or.savgrd.OR.LGLOEG) then
         if(savgrd) dskwrk=.true.
         if(meglob.eq.0.or.savgrd)
     *   CALL SEQCLO(NFThes,'KEEP')
         if(savgrd) dskwrk=savdsk
      endif
      if(isgddi0) call gddi_scope(ddi_world)
C
C     SRP: FOR RMD DYNAMICS, WE JUST DROP ANY STATE THAT DOES
C          NOT CONVERGE A MONOMER SCC
C
      if(irmdfmo.gt.0.and.ntimout.eq.2) then
         if(maswrk) write(iw,9299)        
C         call rmd_coord(x(lindat))
         goto 999
      endif
C
      if(ntimout.gt.1) then
        if(maswrk) write(iw,9300)
        call abrt
      endif
 999  continue
      IF (DODC) CALL DFTDSMI
      ELMLOC=ELMLOCs
c     Restore integral packing options. Important!
      labsiz=labsix
      nintic=nintix
c     FMO can now set DIRSCF to .true. whereas it was .false. before calling
c     FMOX. This leads to memory leaks because in core integral buffer
c     is not returned, therefore, restore the pristine value.
      DIRSCF=savdir
      norbproj=0
      nfg=nfgsav
      runtyp=runtyps
      ilocal=ilocals
      cityp=cityps
      tddftyp=tddftyps
      mfrz=mfrzs
      dc=dcsav
      idcver=idcvers
c
c     Set up INFOA data for the whole system - in some cases, it affects
c     the results, e.g.,
c     for RUNTYP=FMOHESS. If squit, the values like mulfmo are not set.
c
      if(ifgfmo0.eq.0.and..not.squit) then
        ich=ichfmo
        mul=mulfmo
        NE=nefmo
        NB=(ne-mul+1)/2
        na=nb+mul-1
      endif
c
c      DESTROY FMO COMMS/RESTORE ORIGINAL ML-GDDI COMMS
C      if(irmdfmo.gt.0) then
C         call flshbf(6)
C         call mlgddi_clean(irmdfmo,mastid)
C      endif
      return
c9000 format(//1x,'Successfully finished FMO calculation.',/)
 9010 format(/1x,'Orbital conversion requires unilayer sequential run',
     *       /1x,'with modorb=3 for RHF->MCSCF and modorb=0 otherwise.')
 9100 format(//1x,'Starting layer',I2,' nbody=',I1,/1x,'SCFTYP=',A8,
     *         'MPLEVL=',I1,' DFTTYP=',A8,'CITYP=',A8,'CCTYP=',A8,
     *         'TDDFT=',A8//)
c9110 format(/1x,'The average amount of MEMDDI you need is ',I4,
c    *       /1x,'At least double of that value is recommended.',/)
 9120 format(/1x,'FMO3 correlated properties require RCORSD=RESDIM and',
     *           ' RITRIM(3)=RITRIM(4).')
 9130 format(/1x,'This full multilayer FMO3 run requires:',
     *       /3x,'RUNTYP=ENERGY, in $FMOPRP NPRINT without 8 added, ',
     *       /3x,'$ELMOM IEMOM=0, i.e., no property other than the ',
     *           'energy.',/)
 9200 format(/1x,'Rcorsd is reset to zero: no electron correlation.',/)
 9299 format(//1x,'Dropping state from RMD, printing coordinates ',
     *             'and fragmentation scheme.'/)
 9300 format(//1x,'Aborting due to an unrecoverable error.',/)
 9400 format(//1x,'No or invalid grid defined in $GRID: ',3I6)
 9410 format(/1x,'To restart gradient from dimers, add 1024 to irest',
     *       /1x,'and provide a gradient restart file.',/)
 9420 format(/1x,'No ES moments will be computed because property',
     *            ' restart is off.',/)
 9422 format(/1x,'No Mulliken charges will be printed because property',
     *            ' restart is off.',/)
c9422 format(/1x,'No ES moments will be computed during a PL0 run.',/)
 9430 format(//1x,'Automatic non-sparse grid is not programmed for ',
     *            'FMO0. Remove 16 from modprp.',/)
 9440 format(/1x,'FMO-PCM restarts not supported.')
 9600 format(/1x,'Data exchange of',I11,' words took',F8.1,' s.')
 9610 format(/1x,'DFT gradient projection took',F8.1,' s.')
 9700 format(/1x,'PCM iteration',I4,', convergence=',F15.9)
 9710 format(/1x,'The FMO',I1,'/PCM[',I1,'(',I1,')] finished.')
 9720 format(/1x,'Dual basis run: loop =',I2,' current basis =',I2,
     *           ' iesp=',I2)
 9800 format(/1x,'Only 0-terminated style of INDAT works in FMO/MM.')
      end
C*MODULE fmo     *DECK inidfmo
      SUBROUTINE inidfmo(ilay,loadhf,jobgrp,loadm,loadd,loadt,ichfg,
     *                   layfrg,indat,numfrg,nat0frg,natfrg,iaglob,
     *                   fmozan,fmoc,izbas,iabdfg,jabdfg,iodfmo,maxl30,
     *                   idmrec0,da,db,emon,glocon,locfmo,vec,molfrg,
     *                   mulfg,frgnam,scffrg,mcnvfmo,mconfg,ijvec,correl
     *                  ,scftypi,mplevli,CITYPi,CCTYPi,tddfti,orbxch,
     *                   enexch,atonce,dodistr,dosap,dospc,docas,nactfmo
     *                  ,ncasfmo,mastid,needr0,rij,rwrk,nfg2,mfg2,nfg3,
     *                  iwrkd,enucfmo,popmul,popmat,needmd,nmdfrg,nmtfrg
     *                  ,ndtfrg,prtdst,ifgbuf,nfgbuf,nscf,nemc,forbconv,
     *                   conv2mc,l1fmoc,IDAcFMO,iodcfmo,ibfconv,mapconv,
     *                   orbconv,loadbf,loadgr,nstjob,semidyn,broadden,
     *                   vdwrad,exclmol,densgrid,nxyzg,dgrid,ngm,nxyzgm,
     *                   dgridm,grdpad,spargrid,noffg,indgrd,nprfrg,
     *                   ifgfmo0,isgddi0,m0fmo,doddcor,dolat,nunptc,
     *                   natfmob,untxyz,nsymeq,stonep,nfrgmul,frgmul,
     *                   iexcit,modcha,e0centr,atchrg,nafo,doclmo,atclmo
     *                  ,ilocals,nbndfg,fgflmo,nfglmo,irec0,dopdc,
     *                   nsetgrid,iwhere,units,ntsread,n30exf,ihaveq0,
     *                   qini,QSE,QSN,NQMTFG,gcorrel,skipscc,iactfg,
     *                   nevsav,enucfg,VIPOT,dopbcmd,nimgcell,griddistr,
     *                   XYZCTS,PEL,VNUC,ichfmo,nefmo,nesolv,lfmasc,
     *                   needasc,NTSPAR,dofddpcm,needmul,mappcm,yalag,
     *                   iptya,yawrk,ntspre,savememr,irij,skipsort,
     *                   nacut,ngbody,qmcout,nftqmc,mdoutmin,FZCOR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Parameter (MXATM=2000,MXAO=8192,MXRT=100,one=1.0D+00)
      PARAMETER (MXSPE=10)
      integer ddi_world,ddi_group,ddi_masters
      character*1 letexc(2),letfd(0:3)
      Parameter(ddi_world=0,ddi_group=1,ddi_masters=2)
      logical myjob,isgddi,parout,INITGDDI,GOPARR,DSKWRK,MASWRK,orbxch,
     *        enexch,atonce,dodistr,odexch,docas,dosap,dospc,fmodscf,
     *        fmodtrf,inirev,correl,parhop,forbconv,conv2mc,ijmc,semidyn
     *       ,semidyno,broadden,densgrid,spargrid,isgddi0,doddcor,
     *        dolat,exclmol,skipc,doclmo,didatc,dopdc,gcorrel,skipscc,
     *        highdim,wasgddi,dopbcmd,griddistr,MLGDDI,savememr,skipsort
     *       ,qmcout,mdoutmin
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      LOGICAL dofddpcm
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /GRDPAR/ ORIGIN(3),XVEC(3),YVEC(3),ZVEC(3),UX(3),UY(3),
     *                UZ(3),GRDSIZ,NGRID,IGUNIT,NXG,NYG,NZG,modgrid
      COMMON /GSSORD/ IORDER(MXAO),JORDER(MXAO),NORDER
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      COMMON /MCPFMO/ IMCPFMO,LFZCOR,LIFMPTYP,LIFMPTYP2,LMCPSW,
     *                LIZCOR2,imp0,jmp0,icorsh0,igtf0,IECPFMO
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMDIM/ mxsp,mxts,mempcm1,mempcm2,NTS
      COMMON /PCMITR/ RCUT(2),THRES,IPCMIT,IMUL,MXDIIS,NREG,MXITR1,
     *                MXITR2,MODPAP
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEFPCM,IP_F,nfmopcm,IHET
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,npreo(4)
      COMMON /STNBUF/ STNPNT(4,2*MXATM),BIGEXP,NPTSTN,NBUFFM
      COMMON /SYMREP/ IRPNAM(14),IPP(14),LAMBDA(14),LAMBD0(14),
     *                IADDR1(14),IADDR2(14),IADDR3(14)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo,ifmobas,itmfmo(2)
      dimension jobgrp(*),loadm(*),loadd(*),loadt(*),ichfg(*),layfrg(*),
     *          indat(*),numfrg(*),nat0frg(*),natfrg(*),iaglob(*),
     *          fmozan(*),fmoc(3,*),izbas(*),iabdfg(*),jabdfg(*),
     *          iodfmo(*),maxl30(*),idmrec0(*),da(*),db(*),emon(nfg,2),
     *          glocon(*),locfmo(2,2,*),vec(*),molfrg(*),mulfg(*),
     *          frgnam(*),scffrg(*),mcnvfmo(*),mconfg(*),ijvec(5,*),
     *          mastid(*),rij(*),rwrk(*),iwrkd(*),popmul(maxl1,nfg,*),
     *          popmat(maxnat,nfg,*),nmdfrg(nfg,2),nmtfrg(nfg,2),
     *          ndtfrg(nfg2,2),ifgbuf(*),nfgbuf(*),iodcfmo(*),
     *          ibfconv(2,*),mapconv(*),orbconv(*),loadbf(*),loadgr(*),
     *          nstjob(*),vdwrad(*),dgrid(nxyzg,*),ngm(3),
     *          dgridm(nxyzgm,*),noffg(*),indgrd(6,*),nprfrg(*),
     *          prtdst(4),ORIGM(3),UXM(3),UYM(3),UZM(3),
     *          untxyz(3,natfmob,*),nsymeq(*),stonep(*),
     *          frgmul(nfrgmul,*),iexcit(5),atchrg(*),atclmo(*),
     *          fgflmo(maxl1,nbndfg,*),nfglmo(*),qini(*),QSE(*),QSN(*),
     *          NQMTFG(*),iactfg(*),enucfg(*),VIPOT(maxnat,nfg,*),t(3),
     *          XYZCTS(mxts,3),PEL(*),VNUC(*),mappcm(*),yalag(*),
     *          iptya(*),yawrk(*),irij(maxrij,*),grdpad(2),fzcor(*)
C
      data rhf/8HRHF     /,uhf/8HUHF     /,
     *     RMC/8HMCSCF   /,RNONE/8HNONE    /,energy/8HENERGY  /
      data letexc/'E','G'/,letfd/' ','F','B','A'/
c
c     compute initial density for all monomers
c     parstat: GlobalFull
cnb   what to do with not recomputing the distances in layers?
c
      ifmostp=1
      idoprop=0
      call viclr(jobgrp,1,nfg)
c     call viclr(numfrg,1,nfg)
      CALL VICLR(NQMTFG,1,NFG)
C     for restrat of PCM
cdgf  some problems, added dofddpcm
c     if(nfmopcm.ne.0.and.irststp.ge.2) then
      if(nfmopcm.ne.0.and.irststp.ge.2.and.dofddpcm) then
         call vclr(VNUC,1,NTS)
         call vclr(PEL,1,NTS)
         if(dofddpcm) call vclr(yawrk,1,ntspre) 
      end if
      if(nbdfg.ne.0) call viclr(locfmo,1,2*2*nbdfg)
c     if(dosap) call viclr(ialoc,1,natfmo+nbdfg)
      if(needmd.ne.0) call viclr(nmdfrg,1,nfg*2)
      if(needr0.ne.0) then
        if(savememr) then
          call viclr(irij,1,maxrij*nfg)
        else
          call vclr(rij,1,mfg2)
        endif
      endif
      IF (IAND(MODESP,512).NE.0.AND.DOSPC) THEN
        CALL VCLR(VIPOT,1,NFG*MAXNAT*2)
      END IF
      inirev=iand(modpar,8).ne.0
      parhop=iand(modpar,16).eq.0.and.goparr
      if(densgrid.and.ifgfmo0.eq.0.or.spargrid) then
        if(griddistr) then
          call ddi_zero(itmfmo(1))
          if(nsetgrid.eq.2) call ddi_zero(itmfmo(2))
        else
          call vclr(dgrid,1,nxyzg*ngbody*nsetgrid)
        endif
      endif
      didatc=.false.
      m0fmo=0
      ilocal=ilocals
c
      icurpops=icurpop
      icurpop=1
c
      if(docas) then
        maxitsav=maxit
        call mcin
        maxit=maxitsav
      endif
      ncasfmo=0
      nactfmo=0
c     ncasfmo is the number of CAS active orbitals
c     nactfmo is the number of CAS core+active orbitals for the CAS monomer
c
      if(nbsse.eq.3.and.correl) then
c       run free monomers with correlation
        mplevl=mplevli
        cctyp=cctypi
        cityp=citypi
        tddftyp=tddfti
      else if(iand(nguess,1).ne.0) then
c       run free monomers with correlation, but no excited states.
        cityp=rnone
        tddftyp=rnone
      endif
      nconv=-1
      nfge=nfg
      if(gcorrel) nfge=nfg*2
c
c     Broadcast all densities for the broadden option. The global master will
c     do this.
c
      irec0=1
      if(broadden) then
        if(maswrk) write(iw,*) 'Broadcasting the densities...'
c       dosap and dospc are set to .false. to prevent brodcasting Mulliken
c       charges+populations. Note that RAWRITE will allocate maxl30 space
c       on F40 so that it is fine to write only densities now.
c       It is faster to broadcast everything at once, but that would require
c       huge amounts of memory (because only the grandmaster has to send
c       everything at once), so turn it off.
c       For correlation the program assumes having both SCF and correlated
c       densities, so for a shortcut just broadcast both.
        nloop=0
        if(doddcor) nloop=1
c       To avoid using different densities on the grandmaster and slaves,
c       synchronise modrst.
        if(isgddi0) call gddi_scope(ddi_world)
        CALL DDI_BCAST(2421,'I',modrst,1,0)
        if(nfmopcm.ne.0) CALL DDI_BCAST(2421,'I',ntsread,1,0)
        if(isgddi0) call gddi_scope(ddi_group)
        do iloop=0,nloop
         if(nloop.eq.0) then
           irec0=mod(modrst-1,2)*2*nfg+1
         else
           irec0=iloop*2*nfg+1
c          If both records are needed, one will be for modrst.
         endif
         call vclr(rwrk,1,nfg)
         call dmexch(ilay,nfge,jobgrp,layfrg,numfrg,natfrg,scffrg,idafmo
     *              ,iodfmo,maxl30,emon,rwrk,glocon,nconv,irec0,.false.,
     *               .false.,orbxch,enexch,.false.,.false.,mastid,
     *               popmul(1,1,icurpop),popmat(1,1,icurpop),ifgbuf,
     *               nfgbuf,skipscc,0,mdoutmin)
        enddo
      endif
      if(nfmopcm.ne.0.and.iand(MODPAP,4).ne.0) then
        if(ntsread.eq.n30exf) then
c         iefpcm.eq.3 requires two/four sets of charges for a proper restart
c         (i.e., two for ICOMP=0 and four for ICOMP=2). It is not hard to add
c         this restart. Some "fiddling" with the initial guess for the first
c         set can produce a guess for the second set...
          ihaveq0=1
c         Various cases can happen:
c         reading initial guess from a different NTS or ICOMP, or even from
c         gas phase. NTS can change during geometry optimisation!
c         Even if the number of tesserae is the same, it can be a trap (some
c         destroyed and some created)!
          if(maswrk) write(iw,9050)
c         if(maswrk.and.iefpcm.eq.3) write(iw,9060)
          call dcopy(nts,qini,1,QSE,1)
          if(icomp.ne.0) call dcopy(nts,qini(1+nts),1,QSN,1)
          write(6,*) 'wwwahaZ',(QSE(i),i=1,nts)
        else
          if(maswrk) write(iw,9055) ntsread,n30exf
        endif
      endif
      if(ilay.gt.1.and.nopden.gt.0) then
        icurpop=3-icurpops
        irec0=1
        if(idmrec0(1).eq.1) irec0=nfg*2+1
        write(6,*) 'saving layer 2 ini dens to',irec0
c       point to layer 1 densities
      endif
      if(irststp.gt.ifmostp) then
c       modrst points to the next iteration density. Shift more for MP2.
c       Shift is mean here only in the sense between 0 and 1, so that
c       modrst-2 is the same as modrst.
        modrst0=modrst-1
c       if(doddcor) modrst0=modrst-2
        if(doddcor) modrst0=modrst
        if(maswrk) write(iw,*) 'Monomer restart dens record is',modrst0
      endif
cpbc
c     save fmoc
c---  if(dopbcmd) call genfrgmic(0,-1)
      if(dopbcmd) call genimagefg(0,0)
c
c     by setting icurfg and jcurfg to zero we avoid computing 2e ESP
c     when forming Huckel guess.
c
      jcurfg=0
      kcurfg=0
c     point to the Huckel guess HMO (hybrid MO).
c     icurlay=nlayer+1
      icurlay=ilay
      net=0
      netc=0
      if(isgddi0) call GDDICOUNT(-1,lgroup,myjob)
c     natcur=1
      do 100 iifg=1,nfg
        ifg=iifg
        if(loadhf.gt.0) ifg=loadm(iifg)
        if(inirev) ifg=nfg-iifg+1
c       if(ifg.gt.1) natcur=natcur+natfrg(ifg-1)
        if(layfrg(ifg).lt.ilay) then
c         To avoid double counting, zero out numfrg for previous layers
c         except one group. For DDI no gsum is done so no zeroing out.
          if(isgddi0.and.mygroup.ne.0) numfrg(ifg)=0
          goto 100
        endif
cpbc
c       generate fragments around the fragment ifg accoording to
c       the minimum image convention. fmoc, cfrg, and untxyz are
c       destroyed (fmoc is stored in fmoctmp), and so they must
c       be restored later using fmoctmp.
c---    if(dopbcmd) call genfrgmic(ifg,0)
        if(dopbcmd) call genimagefg(2,ifg)
c
        numfrg(ifg)=0
        icurfg=ifg
        if(isgddi0) then
          call GDDICOUNT(0,lgroup,myjob)
          if(.not.myjob) goto 100
        endif
        if(maswrk.and.mdoutmin) write(6,9000) ifg
        jobgrp(ifg)=mygroup
        imxl30=maxl30(ifg)
        SCFTYP=scffrg(ifg)
        if(scftyp.eq.rmc) scftyp=rhf
c       SCFTYP alters behaviour of HUCKEL in a way we are not ready for.
c       SCFTYPi=scffrg(ifg)
c       if(urohf) SCFTYP=SCFTYPi
c       odexch=SCFTYP.eq.rmc
        odexch=scffrg(ifg).eq.rmc
c
c       destroy DA. Molecules have different size -> DA should be reopened.
c
c       if(maswrk) CLOSE(UNIT=IDAF,STATUS='DELETE')
        call CLOSDA('DELETE')
        CALL OPENDA(0)
        NEVALS=0
        call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0,scffrg(ifg).ne.rnone)
        l1=num
        l2=(l1*l1+l1)/2
        l3=l1*l1
        NQMTFG(IFG) = IPP(1) + ISHFT(NA,16)
C
        if(IECPFMO.eq.1) then
         do iat=1,nat
c          write(6,'("wwwchk Znuc=",I3,2F10.7)')
c    *       iat,zan(iat),fmozan(iaglob(iat))
           fzcor(iaglob(iat)) = fmozan(iaglob(iat)) - zan(iat)
         end do
        end if
C
        if(dftbfl)  NQMTFG(IFG) = num + ISHFT(NA,16)
        if(layfrg(ifg).eq.ilay.and.maswrk) then
          if(modfd.eq.0) then
            if(nbody.le.1) then
              enucfmo=enucfmo+enucr
            else
              enucfmo=enucfmo-(nfg-2)*enucr
              if(dopbcmd) enucfmo=enucfmo-nfg*nimgcell*enucr
            endif
          else
            if(ilay.eq.2) enucfmo=enucfmo+enucr
          endif
        endif
        if(modfd.ne.0.and.ilay.eq.1.and.maswrk) enucfg(ifg)=enucr
        if(maswrk.or..not.isgddi0) numfrg(ifg)=num+ishft(na,16)
cnb     for restart jobs save RIJ??
        if(needr0.ne.0.and.ifg.gt.1) then
          if(savememr) then
            call monor(.true.,ifg,indat,fmozan,fmoc,iabdfg,jabdfg,
     *                 rwrk(nfg+1),irij(1,ifg),rwrk,vdwrad,
     *                 iand(nprfrg(ifg),256).ne.0,units,mdoutmin)
          else
            idum=0
            call monor(.true.,ifg,indat,fmozan,fmoc,iabdfg,jabdfg,
     *                 rij((ifg*ifg-3*ifg)/2+2),idum,rwrk,vdwrad,
     *                 iand(nprfrg(ifg),256).ne.0,units,mdoutmin)
          endif
        endif
c       Fill in additional distances for lattice runs.
c       (between the central cell and the rest).
        if((dolat.or.dopbcmd).and.needr0.ne.0)
     *    call latrij(ifg,indat,fmozan,natfmob,untxyz,iabdfg,jabdfg,rij,
     *                rwrk,vdwrad,nunptc,nsymeq)
c
        if(needmd.ne.0) then
c         nmdfrg(ifg)=nfg-2
          imdfrg=0
          ifglay=layfrg(ifg)
c         the reason why nmdfrg can be computed here and nmtfrg cannot is that
c         for dimers one only needs one row of rij (with fixed i) that is
c         guaranteed to have been computed on this very node, but for trimers
c         one needs not only rij (and rik) but also rjk that may not be there.
c         Funnily in the sequential case it is guaranteed that ifg>jfg>kfg
c         and thus one can fill trimer arrays here.
          iunitmax=0
C
C         This dosen't affect the result,
C         and it is not necessary
c         if(dopbcmd) then
c           iunitmax=nimgcell
c           icurunts=icurunt
c         end if
          do 111 iunit=0,iunitmax
          njfg=ifg-1
          if(iunit.gt.0) then
            icurunt=iunit
            njfg=nfg
            if(nsymeq(iunit).le.0) goto 111
          endif
c         do jfg=1,ifg-1
          do jfg=1,njfg
            jfglay=layfrg(jfg)
c           if doing ifg,jfg SCF dimer in the current layer ilay
            if((ifglay.eq.ilay.or.jfglay.eq.ilay).and.
     *         ifglay.ge.ilay.and.jfglay.ge.ilay) then
c             if(resdim.eq.0) then
c               imdfrg=imdfrg+1
c               nmdfrg(jfg,1)=nmdfrg(jfg,1)+1
c             else
                rrij=fmodist(ifg,0,0,jfg)
            highdim=modfd.eq.0.or.layfrg(ifg)+layfrg(jfg).ge.4
            if(iand(modfd,2).ne.0) highdim=highdim.and.
     *                                     iactfg(ifg)+iactfg(jfg).gt.0
c               ES dimer approx. MUST be applied to dimer
c               formed by (ifg,0) and (jfg,iu>0)
c                if(dopbcmd.and.iunit.gt.0.and.rrij.le.resdim) then
c                  if(maswrk) then
c                    write(iw,'("Error: ES dimer approx. may be ",
c     *                         "invalid for ifg,jfg,iu= ",
c     *                         3i8,3x,2f7.3)')
c     *                 ifg,jfg,iunit,rrij,resdim
c                  endif
c                  call abrt
c                endif
c               if(rrij.le.resdim.or.resdim.eq.0) then
                if((rrij.le.resdim.or.resdim.eq.0).and.highdim) then
                  imdfrg=imdfrg+1
                  nmdfrg(jfg,1)=nmdfrg(jfg,1)+1
                  if(gcorrel) then
                    ires=molfrg(ifg)+molfrg(jfg)
                    if(exclmol) then
                      skipc=ires.ge.0.and.ires.ne.2
                    else
                      skipc=ires.eq.0.or.ires.eq.2
                    endif
                    if(iexcit(1).ne.0.and.iexcit(2).lt.2) skipc=.true.
                    if((rrij.le.rcorsd.or.rcorsd.eq.0).and..not.skipc)
     *              then
                      if(iexcit(1).ne.0) then
                      if(iexcit(1).eq.ifg) nmdfrg(ifg,2)=nmdfrg(ifg,2)+1
                      if(iexcit(1).eq.jfg) nmdfrg(jfg,2)=nmdfrg(jfg,2)+1
                      else
                        nmdfrg(ifg,2)=nmdfrg(ifg,2)+1
                        nmdfrg(jfg,2)=nmdfrg(jfg,2)+1
c                       (*,1) keeps coefficients for no correlation
c                       (*,2) keeps coefficients for correlation
c                       A monomer contribution is assigned to either of the two
c                       nmdfrg(jfg,1)=nmdfrg(jfg,1)-1
c                       imdfrg=imdfrg-1
                      endif
                    endif
                  endif
                endif
c             endif
            endif
          enddo
 111      continue
c         if(dopbcmd) icurunt=icurunts
          nmdfrg(ifg,1)=nmdfrg(ifg,1)+imdfrg
c         if(doddcor) nmdfrg(ifg,1)=nmdfrg(ifg,1)-nmdfrg(ifg,2)
c         get SCF factors by subtracting MP2 from total
        endif
c       Set populations to nuclear charges so that atomic charges are zero.
        if(dftbfl) call dcopy(nat,zref,1,popmat(1,ifg,icurpop),1)
c       if(scffrg(ifg).eq.rnone) goto 100
        if(dftbfl.or.
     *     (scffrg(ifg).eq.rnone.and.iand(nprfrg(ifg),64).eq.0)) then
c       save empty density for SCFFRG(i)=NONE unless charges are set in ATCHRG.
c         write(6,*) 'Saving empty density'
          lenrec = 0
          if(.not.orbxch.or.odexch) then
            lenrec=lenrec+l2
c           if(urohf) then
c             lenrec=lenrec+l2
c           endif
          endif
          if(orbxch.or.odexch) then
            lenrec=lenrec+l3
            if(scffrg(ifg).eq.UHF) then
               lenrec=lenrec+l3
            end if
          endif
          if(enexch) then
            lenrec=lenrec+l1
            if(scffrg(ifg).eq.UHF) then
               lenrec=lenrec+l1
            end if
          endif
          call vclr(da,1,lenrec)
          if(dftbfl) then
            CALL rawrites(IDAFMO,iodfmo,da,imxl30,lenrec,irec0+ifg,0)
          else
c           Write out empty data for both sets
            CALL rawrites(IDAFMO,iodfmo,da,imxl30,lenrec,1+ifg,0)
            CALL rawrites(IDAFMO,iodfmo,da,imxl30,lenrec,nfg*2+1+ifg,0)
          endif
          goto 100
        endif
        if(scffrg(ifg).eq.rnone) goto 100
c
c       Read in the orbitals, overwriting restart data.
c
c       l0=nqmt
        igot=0
        call fmorvec(ifg,0,0,ilay,ijvec,l1,da(l2+1),igot)
c
c       restart: save numfrg and quit. If any broken bonds are there, one
c       has to fill locfmo which is done in ONEEI (FMOHOP).
c       change FMOHOP to save locfmo during monomer SCF?
c       For restart jobs with IJVEC set for the current monomer ifg process
c       ifg not as restart but as usual initial guess.
c
        if(irststp.gt.ifmostp.and.igot.eq.0) then
c
c         First do orbital conversion if needed.
c
          iirec=mod(modrst0,2)*2*nfg+1+ifg
          iirecc=1+ifg
          if(forbconv) then
            if(conv2mc) then
              nread=l3+l1
              ist=1
              if(odexch) ist=ist+l2
              CALL rareads(IDAFMO,iodfmo,da(ist),nread,iirec,0)
              nwrite=nread
              imxl30c=imxl30
              if(odexch) then
                nwrite=nwrite+l2
                imxl30c=nwrite
c               using nwrite instead of the proper value prohibits multilayers
c
c               possibly reorder the active orbitals for MCSCF
c               GUESS in $GUESS must be MODAF (or SKIP)!
                CALL GUESMO(GUESS)
                if(norder.eq.1) then
                  call REORDR(da(ist),IORDER,l1,l1)
                  if(maswrk) write(6,*) 'Reordered the orbitals'
                endif
                call DMTX2(da,da(l2+1),na,l1,l1,nb)
c               call prsq(da(ist),l1,l1,l1)
                write(ip,*) 'Active orbitals for the MCSCF monomer'
                write(ip,*) '$VEC1'
                call PUSQL(da(ist),l1,l1,l1)
                write(ip,*) '$END'
              endif
              CALL rawrites(IDAcFMO,iodcfmo,da,imxl30c,nwrite,iirecc,0)
c             write(6,*) 'conving',ifg,nread,nwrite,l1,iirecc
              l1fmoc=l1fmoc+l1
            else
              call readmond(da,orbxch.and..not.odexch,.false.,
     *                      na,nb,l1,iodfmo,iirec,scffrg(ifg).eq.uhf)
              call convorb(ifg,l1,orbxch,da,l1c,orbconv,ibfconv,mapconv,
     *                     iaglob,izbas)
              l1fmoc=l1fmoc+l1c
              l2c=(l1c*l1c+l1c)/2
              l3c=l1c*l1c
              m2c=l2c
              if(orbxch) m2c=l3c
              imxl30c=m2c
c               Such imxl30c assumes one layer!
             CALL rawrites(IDAcFMO,iodcfmo,orbconv,imxl30c,m2c,iirecc,0)
            endif
          else
c
c           if skipping altogether monomer runs one must fill locfmo now.
c           it is possible not to call filloc if irststp eq 2 but then
c           parallel summing of locfmo should be done after monoscf
c           also read in $MCSCF and active space groups
c           write(6,*) 'wwwreading',iirec
            if(dosap.or.dospc) then
              call oneei
              if(doclmo.and.nafo.eq.1) then
c               write(6,*) 'Toiling Huckel'
c               This is a rather painful situation: must run Huckel to
c               get Huckel charges. Only AFOH needs this.
                CALL GUESMO(GUESS)
c               CALL daread(IDAF,IODA,da,l2,16,0)
                call DENDD1(DA,da(1+l2),L2)
                CALL daread(IDAF,IODA,db,l2,12,0)
                call mulpop(num,da,db,popmul(1,ifg,icurpop))
                if(dospc) call mulpopa(popmul(1,ifg,icurpop),
     *                                 popmat(1,ifg,icurpop))
                if(maswrk) then
                  do i=1,nat
                    ig=iaglob(i)
                    atclmo(ig)=atclmo(ig)+zan(i)-popmat(i,ifg,icurpop)
                  enddo
                endif
                didatc=.true.
c               Now proceed to the monomer charges from the prev iteration.
              endif
              call readmond(da,orbxch.and..not.odexch,.false.,
     *                      na,nb,l1,iodfmo,iirec,scffrg(ifg).eq.uhf)
              CALL daread(IDAF,IODA,db,l2,12,0)
              call mulpop(num,da,db,popmul(1,ifg,icurpop))
              if(dospc) then
                if(NPTSTN.ne.0) then
c                 Stone for the restart density (save it first).
                  CALL dawrit(IDAF,IODA,da,l2,16,0)
                  call stone(ip,rnone,0)
                  call dcopy(nat,stonep,1,popmat(1,ifg,icurpop),1)
                  if(nfrgmul.gt.0.and.maswrk) call storemul(1,ifg,nat,
     *                     nfrgmul,untxyz,frgmul,natfrg,c,stonep(1+nat))
                else if(dopdc) then
                  CALL dawrit(IDAF,IODA,da,l2,16,0)
                  CALL ELEPOTC(iwhere)
                  call dcopy(nat,stonep,1,popmat(1,ifg,icurpop),1)
                else
               call mulpopa(popmul(1,ifg,icurpop),popmat(1,ifg,icurpop))
C
C                 FOR VARIATIONAL FMO; potential due to electron densities
C
                  IF (IAND(MODESP,512).NE.0) then
                    CALL GETDDIJPOT(1,0,DA,L2,VIPOT(1,1,icurpop))
c                   CALL compvipot(IFG,0,0,indat,fmoc,VIPOT(1,1,icurpop))
                  END IF
                endif
              endif
              if(odexch) call readcas(nactfmo,ncasfmo)
            else
c             if(nbdfg.ne.0.and.irststp.ge.2) call filloc(odexch,nactfmo)
              if(irststp.ge.2) then
                if(nbdfg.ne.0) call filloc
                if(odexch) call readcas(nactfmo,ncasfmo)
              endif
            endif
          endif
cdgf      some problems, added dofddpcm
          if(nfmopcm.ne.0.and.dofddpcm) then
c          write(6,'("Reconstruct V for restart PCM")') 
           call readmond(da,orbxch.and..not.odexch,.false.,
     *                   na,nb,l1,iodfmo,iirec,scffrg(ifg).eq.uhf)
           call pcmnup(1,vnuc)
           if(dofddpcm.and.layfrg(ifg).eq.2.and.ilay.eq.1) then
            lpnt=iptya(ifg)
C
c           call prtri(yalag(lpnt),l1)
C
            call EPOTEN(-one,XYZCTS(1,1),XYZCTS(1,2),
     *                     XYZCTS(1,3),PEL,yalag(lpnt),NTS,L2)
C           For ASC in B
            call pcmnup2(1,yawrk,mappcm)
            call EPOTEN3(-one,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),
     *                   yawrk,yalag(lpnt),NTS,L2,mappcm)
           else if(dofddpcm.and.layfrg(ifg).eq.2.and.ilay.eq.2) then
C           Only for ASC in B
            call pcmnup2(1,yawrk,mappcm)
            call EPOTEN3(-one,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),
     *                   yawrk,da,NTS,L2,mappcm)
           else if(ilay.eq.1) then
            call EPOTEN(-one,XYZCTS(1,1),XYZCTS(1,2),
     *                     XYZCTS(1,3),PEL,da,NTS,L2)
           end if
          end if
          m0fmo=m0fmo+(num-nqmt)
          goto 100
        endif
        if(odexch) call readcas(nactfmo,ncasfmo)
c
c       mod(nguess,2).eq.1 is a semi-abandoned option. LABSIZ and DIRSCF
c       are not adjusted here.
c
        if(mod(nguess,2).eq.1.or.nbsse.eq.3) then
          if(maswrk) write(6,9010) ifg
          call fmoconv(mcnvfmo(ifmostp),mconfg(ifg),l1,vec,enexch,orbxch
     *                ,.true.,.false.,.false.)
          call fmosdir(0,fmodscf,fmodtrf)
          CALL BRNCHX(energy)
          call fmosdir(1,fmodscf,fmodtrf)
c
c         if(iand(modlmo,4096).ne.0) then
          if(ilocal.ne.0) then
            CALL LMOINP
            CALL LMOX
            if(iand(modlmo,4096).ne.0) then
              call getflmo(ifg,l1,l2,l3,na,indat,iaglob,db,vec,
     *                     nbndfg,fgflmo,nfglmo)
            endif
          endif
c
c         save the vaccuum energies for BSSE
c         nbdfg=nbdfgs
          if(nbsse.eq.3) then
             emon(ifg,1)=etot
             if(gcorrel) emon(ifg,2)=escf
c            MP2; note that other correlation methods should be added
          endif
          if(iand(modcha,4).ne.0) e0centr=etot
c         Density is overread in this subroutine. Perhaps it could be read
c         more sparingly.
c         call DENDD1(DA,da(1+l2),L2)
          CALL daread(IDAF,IODA,da,l2,16,0)
c         Compute the monomer density on a grid
          if(nxyzgm.ne.0.and.iand(nprfrg(ifg),4).ne.0) then
            call mongrid(NGm,ORIGM,UXM,UYM,UZM,vdwrad,grdpad(1))
            call vclr(dgridm,1,nxyzgm*nsetgrid)
            kdum=-2
            ldum=-2
            call fmoprc(1,1,l2,da,dgridm,1,NGm(1),1,NGm(2),1,NGm(3),
     *                  1,NGm(1),1,NGm(2),1,NGm(3), 0,0,0,0,0,0,
     *                 ORIGM,UXM,UYM,UZM,nsetgrid,griddistr,0,kdum,ldum)
            call ddi_gsumf(2416,dgridm,nxyzgm*nsetgrid)
            do iset=1,nsetgrid
              call makecube(iset,ifg,0,nat,zan,c,dgridm(1,iset),
     *          NGm(1),NGm(2),NGm(3),ORIGM,UXM,UYM,UZM,GRDSIZ,griddistr)
            enddo
          endif
          if(densgrid) then
c           Compute the total density on a grid
            call grdbox(ixmin,ixmax,iymin,iymax,izmin,izmax,vdwrad,
     *                  grdpad(2))
            kdum=-2
            ldum=-2
            call fmoprc(1,1,l2,da,dgrid,1,NXG,1,NYG,1,NZG,ixmin,ixmax,
     *                  iymin,iymax,izmin,izmax, 0,0,0,0,0,0,
     *                  ORIGIN,UX,UY,UZ,nsetgrid,griddistr,0,kdum,ldum)
          endif
          if(spargrid) then
c           Compute the total density on a sparse grid
            ioff=noffg(ifg)
            kdum=-2
            ldum=-2
            call fmoprc(1,1,l2,da,dgrid(ioff,1),indgrd(1,ifg),
     *                  indgrd(2,ifg),indgrd(3,ifg),indgrd(4,ifg),
     *                  indgrd(5,ifg),indgrd(6,ifg),indgrd(1,ifg),
     *                  indgrd(2,ifg),indgrd(3,ifg),indgrd(4,ifg),
     *                  indgrd(5,ifg),indgrd(6,ifg), 0,0,0,0,0,0,
     *                  ORIGIN,UX,UY,UZ,nsetgrid,griddistr,0,kdum,ldum)
          endif
        else if(igot.eq.0) then
          CALL ONEEI
c         possibly reorder the active orbitals for MCSCF
c         GUESS in $GUESS must be MODAF (or SKIP)!
          if(scftypi.eq.rmc.and.odexch.and.iand(nguess,512).ne.0) then
            if(maswrk) write(6,*) 'Looking for reordering'
c           write fake density to satisfy GUESS
            call vclr(da,1,l2)
            CALL dawrit(IDAF,IODA,da,l2,16,0)
            CALL GUESMO(GUESS)
            if(norder.eq.1) then
c             Assuming modorb=3
              lrecsiz=l2+l3+l1
              iirec=1+ifg
c             iirec=irec0+ifg
c             iirec is hardwired to the first set.
              CALL rareads(IDAFMO,iodfmo,da,lrecsiz,iirec,0)
              call icopy(l1,IORDER,1,db,1)
              call REORDR(da(l2+1),db,l1,l1)
              call REORDR(da(l2+l3+1),IORDER,l1,1)
c             CALL rawrites(IDAFMO,iodfmo,da,imxl30,lrecsiz,iirec,0)
              CALL dawrit(IDAF,IODA,da(1),l2,16,0)
              CALL dawrit(IDAF,IODA,da(l2+1),l3,15,0)
              CALL dawrit(IDAF,IODA,da(l2+l3+1),l1,17,0)
              if(maswrk) write(6,*) 'Reordered the orbitals+energies'
            endif
          else
            CALL GUESMO(GUESS)
          endif
c       else if(orbxch) then
        else
          if(scffrg(ifg).eq.uhf) then
c           write(6,*) 'wwwnewUHF'
            call DMTX2(da,da(l2+1),0,l1,l1,na)
            CALL dawrit(IDAF,IODA,da,l2,16,0)
            call DMTX2(da,da(l2+l3+1),0,l1,l1,nb)
            CALL dawrit(IDAF,IODA,da,l2,20,0)
          else
            call DMTX2(da,da(l2+1),na,l1,l1,nb)
            CALL dawrit(IDAF,IODA,da,l2,16,0)
          endif
          if(enexch) then
c           this is probably not a good idea. What can be done instead?
c           The user only provided the orbitals, no energies.
            call vclr(da(l2+l3+1),1,l1)
            CALL dawrit(IDAF,IODA,da(l2+l3+1),l1,17,0)
            if(scffrg(ifg).eq.uhf)
     *        CALL dawrit(IDAF,IODA,da(l2+l3+1),l1,21,0)
          endif
          if(dosap.or.dospc) call oneei
        endif
        if(dosap.or.dospc) then
          call DENDD1(DA,da(1+l2),L2)
c         CALL daread(IDAF,IODA,da,l2,16,0)
          CALL daread(IDAF,IODA,db,l2,12,0)
          call mulpop(l1,da,db,popmul(1,ifg,icurpop))
          if(NPTSTN.ne.0) then
c           Stone for the guess (e.g., Huckel(!!)) density.
            call stone(ip,rnone,0)
            call dcopy(nat,stonep,1,popmat(1,ifg,icurpop),1)
            if(nfrgmul.gt.0.and.maswrk) call storemul(1,ifg,nat,nfrgmul,
     *                             untxyz,frgmul,natfrg,c,stonep(1+nat))
          else if(dopdc) then
            CALL ELEPOTC(iwhere)
            call dcopy(nat,stonep,1,popmat(1,ifg,icurpop),1)
          else
            call mulpopa(popmul(1,ifg,icurpop),popmat(1,ifg,icurpop))
C
C           FOR VARIATIONAL FMO; potential due to electron densities
C
            IF (IAND(MODESP,512).NE.0) THEN
              CALL GETDDIJPOT(1,0,DA,L2,VIPOT(1,1,icurpop))
c             CALL compvipot(IFG,0,0,indat,fmoc,VIPOT(1,1,icurpop))
            END IF
          endif
          if(doclmo.and..not.didatc.and.maswrk) then
            do i=1,nat
              atclmo(iaglob(i))=atclmo(iaglob(i))+zan(i)-
     *                          popmat(i,ifg,icurpop)
            enddo
          endif
        endif
        call storefrg(l1,l2,l3,orbxch,odexch,enexch,.true.,scffrg,
     *                imxl30,iodfmo,irec0,ifg,da,lenrec)
c       call prtril(da,l1)
c       if(odexch) call prsq(da,1,lenrec,lenrec)
c       CALL rawrites(IDAFMO,iodfmo,da,imxl30,lenrec,ifg+1,0)
c       write(6,*) 'wwwsaving',irec0,ifg
        m0fmo=m0fmo+(num-nqmt)
  100 continue
cpbc
c     restore the original atomic coordinates
c---  if(dopbcmd) call genfrgmic(0,1)
      if(dopbcmd) call genimagefg(1,0)
      if(isgddi0) call GDDICOUNT( 1,lgroup,myjob)
c
c     exchange the basis set size for all fragments. Since it is stored
c     as an array for each fragment, the order is independent of how
c     parallel work was distributed and we can fill it once for all.
c     dmexch uses it so the array must be ready before calling dmexch.
c     Only masters sum the array to avoid double counting.
c     One can do the operation two ways: eith global sum over ALL nodes
c     or first global sum by masters and the broadcast within a group
c     the cost is M*logM +M*N*logN and M*N*log(MN). The first way usually wins
c     mathematically but practically latency can make the second way
c     faster if M*N is small. M - number of DDI groups, N - group size.
c
c     CALL gddi_gsum(2,'I',numfrg,nfg)
c     since FMOHOP is now divided into nodes locfmo must be summed within
c     the group.
c     write(6,*) 'locfmo:',(((locfmo(i,j,k),i=1,2),j=1,2),k=1,nbdfg)
      if(nbdfg.ne.0.and.parhop) call ddi_gsumi(2417,locfmo,2*2*nbdfg)
      if(isgddi0) then
        call gddi_scope(ddi_masters)
        numfrg(nfg+1)=nactfmo+ishft(ncasfmo,16)
        if(maswrk) then
          call ddi_gsumi(2417,m0fmo,1)
c         l0fmo is not broadcast to slaves because it is used for print-out only
c         no need to sum numfrg?
          call ddi_gsumi(2417,numfrg,nfg+1)
          if(nbdfg.ne.0) call ddi_gsumi(2418,locfmo,2*2*nbdfg)
          if(needr0.ne.0) then
            if(savememr) then
              call ddi_gsumi(2419,irij,maxrij*nfg)
            else
              call ddi_gsumf(2419,rij,mfg2)
            endif
          endif
          if(needmd.ne.0) then
            call ddi_gsumi(2420,nmdfrg,nfg*2)
c           if(nfg3.ne.0) then
c             call proindt(nfg2,nfg3,ilay,loadhf,layfrg,numfrg,molfrg,
c    *                     nmtfrg,ndtfrg,iwrkd,loadt,net,netc,gcorrel)
c             call ddi_gsumi(2421,nmtfrg,nfg*2)
c             call ddi_gsumi(2422,ndtfrg,nfg2*2)
c             idum=0
c             call DDI_nsumi(2423,net,netc,idum,idum,2)
c           endif
          endif
c         if(dospc) call ddi_gsumi(2420,ialoc,natfmo+nbdfg)
          if(nfrgmul.gt.0) then
            call ddi_gsumf(2419,untxyz,natfmob*3)
            call ddi_gsumf(2419,frgmul,natfmob*nfrgmul)
          endif
          if(doclmo) call ddi_gsumf(2419,atclmo,natfmo)
          CALL DDI_GSUMI(2419,NQMTFG,NFG)
          if(modfd.ne.0.and.ilay.eq.1) CALL DDI_GSUMF(2419,enucfg,NFG)
        endif
        call gddi_scope(ddi_group)
c       now masters broadcast the array within each group. It
c       is needed even on slave nodes for reading (pretending;
c       actually, accepting a broadcast) density etc.
        if(goparr) then
          CALL DDI_BCAST(2421,'I',numfrg,nfg+1,master)
         if(nbdfg.ne.0) CALL DDI_BCAST(2422,'I',locfmo,2*2*nbdfg,master)
          if(needr0.ne.0) then
            if(savememr) then
              call DDI_BCAST(2423,'I',irij,maxrij*nfg,master)
            else
              call DDI_BCAST(2423,'F',rij,mfg2,master)
            endif
          endif
c         if(dospc) CALL DDI_BCAST(2424,'I',ialoc,natfmo+nbdfg,master)
          if(needmd.ne.0) then
            call DDI_BCAST(2425,'I',nmdfrg,nfg*2,master)
c           if(nbody.gt.2) then
c             call DDI_BCAST(2426,'I',nmtfrg,nfg*2,master)
c             call DDI_BCAST(2427,'I',ndtfrg,nfg2*2,master)
c             if(loadhf.ne.0.and.nfg3.ne.0)
c    *          call DDI_BCAST(2428,'I',loadt,nfg3,master)
c           endif
          endif
c         nmdfrg is used for deciding properties etc so slaves must have it.
          if(nfrgmul.gt.0) then
            call DDI_BCAST(2419,'F',untxyz,natfmob*3,master)
            call DDI_BCAST(2419,'F',frgmul,natfmob*nfrgmul,master)
          endif
          if(doclmo) call DDI_BCAST(2419,'F',atclmo,natfmo,master)
          CALL DDI_BCAST(2419,'I',NQMTFG,NFG,MASTER)
          if(modfd.ne.0.and.ilay.eq.1)
     *      CALL DDI_BCAST(2419,'f',enucfg,NFG,MASTER)
        endif
        nactfmo=iand(numfrg(nfg+1),65535)
        ncasfmo=ishft(numfrg(nfg+1),-16)
c       write(6,*) 'wwwCAStest',nactfmo,ncasfmo
c     else
      endif
      if(nfg3.ne.0.and.needmd.ne.0) then
        if(isgddi0) call gddi_scope(ddi_world)
        call proindt(nfg2,nfg3,ilay,loadhf,layfrg,numfrg,molfrg,nmtfrg,
     *               ndtfrg,iwrkd,loadt,net,netc,gcorrel)
        if(isgddi0) call gddi_scope(ddi_group)
      endif
cdgf  some problems, added dofddpcm
c     if(nfmopcm.ne.0.and.irststp.ge.2) then
      if(nfmopcm.ne.0.and.irststp.ge.2.and.dofddpcm) then
        if(isgddi0) call gddi_scope(ddi_world)
C
        call ddi_gsumf(2418,PEL,NTS)
        call ddi_gsumf(2418,VNUC,NTS)
C
        if(ilay.eq.1)
     *  call calcasc(1,NTSPAR,ichfmo,nefmo,lfmasc,needasc,idum1,
     *               nesolv,idum2,idum3,idum4,idum5,qini,ihaveq0,nprfmo)
        if(dofddpcm) then
          call ddi_gsumf(2419,yawrk,NTSpre)
          call dcopy(ntspre,yawrk,1,pel,1)
          call vclr(vnuc,1,ntspre)
          call mltfmopcm(ilay,lfmasc,needasc,needmul,mappcm,idum)
        end if
C
        if(isgddi0) call gddi_scope(ddi_group)
      end if
c
c     redo the load balancing, shifting all separated dimers toward the end.
c     if rcorsd is active put all correlated dimers to the front.
c     scale the load by some distance factor?
c     add correlation as given by rcorsd/selected dimers?
c
c     This code for the semidynamic load balancing is active for
c     layers higher than 1
      nsdjob1=0
      nsdjob2=0
      if(needr0.eq.0.and.loadhf.eq.1.and.semidyn) then
        if(loadbf(1).ne.0.and.loadgr(1).ne.0) then
          iend=nstjob(1)
          nstjob(1)=0
c         Here, we use the fact that layers are inclusive (higher layers are
c         subsets of the lower ones). We use nstjob from the previous layer.
          do iifg=1,iend
            ifg=loadm(iifg)
            if(iand(numfrg(ifg),65535).ge.loadbf(1)) then
              nstjob(1)=nstjob(1)+1
              if(layfrg(ifg).ge.ilay) nsdjob1=nsdjob1+1
            endif
          enddo
        endif
        if(nbody.gt.1.and.loadbf(2).ne.0.and.loadgr(2).ne.0) then
          ijend=nstjob(2)
          nstjob(2)=0
          lijfg=0
          do iifg=1,nfg
            njfg=iifg-1
            do jjfg=1,njfg
              lijfg=lijfg+1
              if(lijfg.gt.ijend) goto 200
              ijfg=loadd(lijfg)
              call tribrk(ijfg,-1,ifg,jfg)
              l1ij=iand(numfrg(ifg),65535)+iand(numfrg(jfg),65535)
              if(l1ij.ge.loadbf(2)) then
                nstjob(2)=nstjob(2)+1
                if((layfrg(ifg).ge.ilay.and.layfrg(jfg).ge.ilay)
     *            .or.modfd.ne.0) nsdjob2=nsdjob2+1
c               This count is probably not correct for FD or molfrg.
              endif
            enddo
          enddo
  200     continue
        endif
        if(maswrk) write(iw,*) 'Semidynamic balancing was readjusted.'
      endif
c
      nes=0
      nem=0
      nemc=0
      nemc0=0
      nscf=0
      l2max=0
      na2max=0
      if(needr0.ne.0.and.loadhf.eq.1.and.nbody.gt.1) then
        if(savememr) then
          call setloadd(skipsort,numfrg,iwrkd,irij,loadd,iwrkd(nfg*2+1),
     *                  nes,nscf)
          nec=0
          if(gcorrel) nec=nscf
          if(maswrk) write(iw,9110) nes,nscf,nec
        else
        ishift=maxl1*2
        ij=0
c       write(6,*) 'oloadd',(loadd(i),i=1,nfg2)
        nec=0
        nstjob(2)=0
        do ifg=1,nfg
          do jfg=1,ifg-1
            ij=ij+1
            l1ij=iand(numfrg(ifg),65535)+iand(numfrg(jfg),65535)
            loo=l1ij
            rrij=rij(ij)
            ijmc=scffrg(ifg).eq.rmc.or.scffrg(jfg).eq.rmc
            if(ijmc) nemc0=nemc0+1
            semidyno=semidyn.and.loadbf(2).ne.0.and.loadgr(2).ne.0.and.
     *               l1ij.ge.loadbf(2)
            ires=molfrg(ifg)+molfrg(jfg)
            if(exclmol) then
              skipc=ires.ge.0.and.ires.ne.2
            else
              skipc=ires.eq.0.or.ires.eq.2
            endif
            if(tddfti.ne.rnone) then
             if(iexcit(1).ne.ifg.and.iexcit(1).ne.jfg.or.
     *          iexcit(2).lt.2) skipc=.true.
            endif
            highdim=modfd.eq.0.or.layfrg(ifg)+layfrg(jfg).ge.4
            if(iand(modfd,2).ne.0) highdim=highdim.and.
     *                                     iactfg(ifg)+iactfg(jfg).gt.0
            if(rrij.le.resdim.and.resdim.ne.0.and.highdim) then
              nscf=nscf+1
              loo=loo+ishift
              if((rrij.le.rcorsd.or.rcorsd.eq.0).and..not.skipc) then
                loo=loo+ishift
                nec=nec+1
              endif
c             SCF and MP2 semidynamic jobs are given higher priority.
c             ES jobs are unchanged. 4 comes from 1(RHF)+1(MP2)+1(MCSCF),
c             raised by 1 (at present MRMP2 is not yet supported).
              if(semidyno) then
                loo=loo+ishift*4
                nstjob(2)=nstjob(2)+1
              endif
            else
              if(resdim.ne.0) ijmc=.false.
              if(resdim.eq.0.and.semidyno) nstjob(2)=nstjob(2)+1
              if(highdim.or.modfd.ne.0.and.iactfg(ifg)+iactfg(jfg).ge.1)
     *        then
                nes=nes+1
                mmdim=0
c               if(modfmm.ne.0.and.ncentm.eq.1)
                if(modfmm.ne.0)
     *            call mmdist(ifg,0,0,jfg,t,radius,ty2z,ratio,mmdim)
                if(mmdim.ne.0) nem=nem+1
              endif
              if((rrij.le.rcorsd.or.rcorsd.eq.0).and..not.skipc.and.
     *           highdim)
     *          nec=nec+1
            endif
            if(ijmc) then
              loo=loo+ishift
              nemc=nemc+1
            endif
            iwrkd(ij)=loo
            if((rrij.le.resdim.or.resdim.eq.0).and.highdim) then
              l2max=max(l2max,l1ij)
              na2max=max(na2max,
     *                   ishft(numfrg(ifg),-16)+ishft(numfrg(ifg),-16))
            endif
          enddo
        enddo
        if(resdim.eq.0) then
           nes=0
           nem=0
           nscf=nfg2
        endif
c       if(.not.correl) then
        if(.not.gcorrel) then
          nec=0
          netc=0
        endif
        call indsort(nfg2,iwrkd,loadd)
c       write(6,*) 'nloadd',(loadd(i),i=1,nfg2)
        if(maswrk) then
          if(nemc0.ne.0) then
            write(iw,9100) nes,nscf,nemc
          else
            write(iw,9110) nes,nscf,nec
          endif
c         if(modfmm.ne.0.and.ncentm.eq.1) write(iw,9115) nem,nes
          if(modfmm.ne.0) write(iw,9115) nem,nes
          if(nbody.gt.2) write(iw,9120) net,netc
          write(iw,9250) l2max,na2max
        endif
c       For FMO/FD nscf is not computed correctly?
c       if(modfd.ne.0.and.semidyno) call abrt
        nsdjob1=nstjob(1)
        nsdjob2=nstjob(2)
      endif
      else
        nscf=nfg2-nes
      endif
      if(nsdjob1.ne.0.and.maswrk)
     *  write(iw,9140) ilay,nsdjob1,' monomer',loadbf(1),loadgr(1)
      if(nsdjob2.ne.0.and.maswrk)
     *  write(iw,9140) ilay,nsdjob2,'   dimer',loadbf(2),loadgr(2)
c     For multilayer runs ILAY>1 the number of static LB dimers is not
c     computed correctly, but the load balancing works.
c
c     Only the global master writes out the QMC header.
      if(qmcout.and.meglob.eq.0)
     *  write(nftqmc,9160) natfmo,nfg,nscf,net,nbody
c
      if(maswrk.and.nevsav.eq.0.and.(iand(nprfmo,3).lt.2.or.nacut.eq.0))
     *  then
        iexc=iexcit(1)
        modfd1=iand(modfd,1)
        write(iw,9200)
        write(iw,9210) (i,frgnam(i),ichfg(i),nat0frg(i),
     *                  natfrg(i)-nat0frg(i),ishft(numfrg(i),-16),
     *                  iand(numfrg(i),65535),layfrg(i),
     *                  letfd((layfrg(i)+iactfg(i))*modfd1),mulfg(i),
     *             letexc(int(abs(i-iexc)/(abs(i-iexc)+one)+0.6D+00)+1),
     *                  scffrg(i),nprfrg(i),molfrg(i),mconfg(i),i=1,nfg)
      endif
      if(maswrk.and.iand(nprfmo,3).eq.0) then
c       write(iw,*) 'nums:',(iand(numfrg(i),65535),i=1,nfg)
c       write(iw,*) 'nas:',(ishft(numfrg(i),-16),i=1,nfg)
        write(iw,*) 'locfmo:',(((locfmo(i,j,k),i=1,2),j=1,2),k=1,nbdfg)
        write(iw,*) 'nactfmo:',nactfmo
c       write(iw,9020)
c    *    (i,ishft(ialoc(i),-16),iand(ialoc(i),65535),i=1,natfmo+nbdfg)
c9020 format(1x,'iatg=',I5,' ifg=',I5,' iatl=',I5)
        if(nbody.gt.1) then
          write(6,*) 'nmdfrg1:',(nmdfrg(i,1),i=1,nfg)
          write(6,*) 'nmdfrg2:',(nmdfrg(i,2),i=1,nfg)
        endif
        if(nbody.gt.2) then
          write(6,*) 'nmtfrg1:',(nmtfrg(i,1),i=1,nfg)
          write(6,*) 'nmtfrg2:',(nmtfrg(i,2),i=1,nfg)
          write(6,*) 'ndtfrg1:',(ndtfrg(i,1),i=1,nfg2)
          write(6,*) 'ndtfrg2:',(ndtfrg(i,2),i=1,nfg2)
c         ndtfrg(*,1) how many times a dimer occurs in all SCF trimers
c         ndtfrg(*,2) how many times a corr. dimer occurs in all corr. trimers
c
        endif
      endif
      nerr=0
      if(maswrk.and.needr0.ne.0.and.(iand(nprfmo,4).ne.0.or.
     *   prtdst(1).ne.0.or.prtdst(2).ne.0.or.prtdst(3).ge.0).and.
     *   .not.savememr) call fmoprr(indat,iabdfg,jabdfg,fmozan,fmoc,
     *                       vdwrad,rij,iand(nprfmo,4).ne.0,prtdst,nerr)
      if(goparr) call DDI_BCAST(2428,'I',nerr,1,master)
      if(nerr.ne.0) call abrt
c
c     exchange density matrices
c
c     for restarts with approximations we need to exchange the recomputed
c     charges/populations. Density is also exchanged (waste). Perhaps one
c     should dump charges/populations/distances and just read them.
c
      if(isgddi0.and.(irststp.le.ifmostp.or.dosap.or.dospc)) then
        call vclr(rwrk,1,nfg)
        call dmexch(ilay,nfge,jobgrp,layfrg,numfrg,natfrg,scffrg,idafmo,
     *              iodfmo,maxl30,emon,rwrk,glocon,nconv,irec0,dosap,
     *              dospc,orbxch,enexch,atonce,dodistr,mastid,
     *              popmul(1,1,icurpop),popmat(1,1,icurpop),ifgbuf,
     *              nfgbuf,skipscc,0,mdoutmin)
      endif
C
C     FOR VARIATIONAL FMO
C
      IF (IAND(MODESP,512).NE.0.AND.DOSPC) THEN
        IF (ISGDDI0) CALL GDDI_SCOPE(DDI_WORLD)
        CALL DDI_GSUMF(2419,VIPOT(1,1,ICURPOP),MAXNAT*NFG)
        IF (ISGDDI0) CALL GDDI_SCOPE(DDI_GROUP)
      END IF
C
c     Copy charges
      if(iand(modcha,4).ne.0) then
        do ifg=2,nfg
          call dcopy(natfrg(ifg),popmat(1,1,icurpop),1,
     *                           popmat(1,ifg,icurpop),1)
        enddo
      endif
      ishift=1
      do ifg=1,nfg
        if(iand(nprfrg(ifg),64).ne.0) call dcopy(natfrg(ifg),
     *                         atchrg(ishift),1,popmat(1,ifg,icurpop),1)
        ishift=ishift+natfrg(ifg)
      enddo
c     1 indicates one reserved record (the first one) for the record indexing
      icurlay=ilay
      if(nbsse.eq.3.and.correl) then
        mplevl=0
        cctyp=rnone
        cityp=rnone
        tddftyp=rnone
      endif
      ilocal=0
      idoprop=1
C
      return
 9000 format(/1x,'Running initial guess for monomer ',I7,/)
 9010 format(/1x,'Running free monomer SCF for monomer',I7,/)
 9050 format(1x,'PCM charge restart was successful!',/)
 9055 format(1x,'PCM charge restart was not successful, the number ',
     *          'changed:',2I8,/)
 9100 format(/1x,'There are',I8,' separated and',I7,' SCF (',I6,
     *           ' of them MCSCF) dimers.')
 9110 format(/1x,'There are',I12,' separated and',I8,' SCF (',I8,
     *           ' of them correlated) dimers.')
 9115 format(1x,I10,' separated dimers out of',I12,
     *              ' are computed with multipoles.')
 9120 format(/1x,'There are',I7,' SCF (',I6,
     *           ' of them correlated) trimers.')
 9140 format(/1x,'Layer',I2,' static LB for',I6,A8,'(s) larger than ',
     *           I5,' on',I5,' group(s).',/)
 9160 format(/1x,'QMC TOTAL NUMBER OF ATOMS                   =',I10,
     *       /1x,'QMC NUMBER OF MONOMERS                      =',I10,
     *       /1x,'QMC NUMBER OF DIMERS                        =',I10,
     *       /1x,'QMC NUMBER OF TRIMERS                       =',I10,
     *       /1x,'QMC FMO METHOD                              =',I10,
     *       /1x,'QMC ',60(1H-))
 9200 format(/1x,'Fragment statistics',//6x,'I',2x,'NAME',5X,'Q',1X,
     *        'NAT0',1X,'NATB',1X,'NA',2x,'NAO',1X,'LAY',1X,
     *        'MUL',1X,'SCFTYP',8X,'NOP',5X,'MOL',4X,'CONV',/1x,78(1H=))
 9210 format(1x,I6,1x,A8,I3,I5,I4,I5,I5,I2,a1,I2,a2,1x,A8,I9,I8,I8)
 9250 format(1x,'Estimate of max dimer size:',i5,' AOs,',i5,' occ. MOs')
      end
C*MODULE fmo     *DECK monoscf
C>
C>     @brief FMO monomer SCF loop
C>
C>     @details Perform FMO monomer SCF.
C>
C>     @author Dmitri Fedorov
C>
C>     @date C.Bertoni
C>      - changes for the EFMO gradient
C>
C>     @param efmo_scphf : space for EFMO to hold the MP2 lagrangian
C>
      subroutine monoscf(ilay,nder,runtyp,loadhf,ndar30a,ndar30fa,jobgrp
     *                  ,loadm,ichfg,layfrg,numfrg,natfrg,iaglob,indat,
     *                   fmozan,fmoc,iabdfg,jabdfg,idxcao,ichfmo,nefmo,
     *                   iodfmo,maxl30,idmrec0,da,db,fmoespa,vec,wrk1,
     *                   wrk2,emon,ewrk,glocon,fmode,fmopg,atmulq,
     *                   atmulqi,mbody,nfmoelm,fmoelm,needmd,nmmfrg,
     *                   nmdfrg,nmtfrg,molfrg,scffrg,correl,scftypi,
     *                   mplevli,CITYPi,CCTYPi,tddfti,mcnvfmo,ncvscf,
     *                   mconfg,dosap,dospc,docas,primul,orbxch,enexch,
     *                  atonce,dodistr,liter,nfglay,popmul,popmat,ifgbuf
     *                  ,nfgbuf,ngrfmo,mannod,mastid,nprfrg,totdens,
     *                   totfock,l2fmo,totd,iaoglob,exclmol,densgrid,
     *                   nxyzg,dgrid,ntimout,loadgr,nstjob,l1dir,ngm,
     *                   nxyzgm,dgridm,grdpad,vdwrad,spargrid,noffg,
     *                   indgrd,ifgfmo0,isgddi0,grandmas,densfmo0,
     *                   IDAcFMO,iodcfmo,extracc,nextracc,lfmasc,needasc
     *                  ,esolv,nesolv,iterpcm,NTSPAR,dovpcm,pcmoff,
     *                   etotdft,nedft,XYZCTS,PEL,VNUC,qini,nts2,ihaveq0
     *                  ,dopleda,epl0ds,efmo0,doscfprp,ext2lay,dolat,
     *                   n2fmo,klms,untrot,esplat,addesp,diffesp,stonep,
     *                   natfmob,nfrgmul,frgmul,iexcit,eexcit,texcit,
     *                   monoc,monvr,nstmono,nocctdm,nvirtdm,nocctdb,
     *                   nvirtdb,ctdm,modcha,atchrg,doclmo,doclmo1,clmo,
     *                   ialmo,indlmo,iwlmo,atclmo,dovlmo,lmobdf,fgflmo,
     *                   nfglmo,lfglmo,pfglmo,ilocals,DDIJPOT,naoafo3,
     *                   naoafod,dafo,nbndfg,irec0ini,dopdc,nsetgrid,
     *                   iwhere,gcorrel,doddcor,e1efmo,ekinfmo,m1efmo,
     *                   eigfmo,EFPIEA,FGINT,fmoddm,FMOFCM,FCMWRK,
     *                   ABFLDT,DINDF2,DINDDF2,ZVLAG,IPTLG,ZVWRK,NQMTFG,
     *                   hopgrd,dodc,potat,fmohard,eaip,VIPOT,nevsav,
     *                   modcnv,crfrg,clm,flm,f_mm,g_mm,Ylmfrgv,Zlmfrgv,
     *                   Ylmfrgq,Ylmfrgq2,ALCNT2F,YALAG,IPTYA,YAWRK,
     *                   nhybnam,ibloop,dopbcmd,enucfmo,locfmo,mdout,
     *                   mdoutmin,iactfg,NC1,dofddpcm,needmul,mappcm,
     *                   griddistr,urospn,pmulspin,spinden,irmdfmo,
     *                   fraggrid,subsys,ngbody,qmcout,nftqmc,dofret,
     *                   excit2,texcit2,scfesp,efmo_scphf)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      integer ddi_world,ddi_group
      Parameter(ddi_world=0,ddi_group=1)
      parameter(MXATM=2000,MXAO=8192,MXRT=100,MXGRID=10,maxpst=10,
     *          zero=0.0D+00,one=1.0D+00,half=0.5D+00,MaxNp=45)
      Parameter(MXFRG=1050,MXDFG=5,MXDPPT=MXFRG*MXDFG*12)
      logical myjob,isgddi,parout,INITGDDI,GOPARR,DSKWRK,MASWRK,conv,
     *        dosap,dospc,docas,primul,orbxch,enexch,atonce,dodistr,
     *        odexch,correl,fmodscf,fmodtrf,doprop,skipc,skipci,fmajor,
     *        desperate,despread,doddcori,lbmcscf,
     *        AIMPAC,RPAC,PLTORB,MOLPLT,DGRIDPROG,
     *        totdens,totfock,clrden,densgrid,clrcow,forcedir,
     *        fordir,spargrid,isgddi0,grandmas,donor,acceptor,tightint,
     *        DIRSCF,FDIFF,densfmo0,exclmol,updpcm,dovpcm,dopleda,
     *        doscfprp,ext2lay,dolat,addesp,diffesp,lcflag,lcsav,
     *        corsav,TRIPLET,gopsav,doclmo,doclmo1,MFRZ,dovlmo,dovac,
     *        lcflags,LPOPDFLG,dopdc,SG1,SG1T,gcorrel,doddcor,DOEFPIEA,
     *        hopgrd,dodc,TAMMD,TPA,CAMFLAG,camsav,CAMFLAGs,QOPS,QFMM,
     *        wasgddi,uhfcal,dopbcmd,parhop,ALPHKWD,BETAKWD,mdout,
     *        mdoutmin,griddistr,mlgddi,spinden,dofddpcm,urospn,fraggrid
     *       ,subsys,qmcout,dofret,scfesp,conv2
CFTNC Removed LRINT
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      character*11 wfnstri
      complex*16 Ylmfrgv(((NP+1)*(NP+2))/2,nfg),
     *           Zlmfrgv(((NP+1)*(NP+2))/2,nfg),
     *           Ylmfrgq(((NP+1)*(NP+2))/2,nfg),
     *           Ylmfrgq2(((NP+1)*(NP+2))/2,nfg)
      COMMON /DFTCAM/ ALPHAC,BETAC,CAMMU,CAMVWN,CAMLYP,CAMFLAG
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,jans
      COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
     *                                                    NAUXSHL
      COMMON /DMPING/ SHIFTO,SHIFTV,DMPCUT,SWDIIS,DIRTHR
      COMMON /EFPFM2/ TOTEFPC,poltot,labfldt,ldindf2,ldinddf2,ldelabfld,
     *                ldeldind,ldeldindd,LALCNT2F
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP,iefmo_agrad
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /ELPROP/ ELDLOC,ELMLOC,ELPLOC,ELFLOC,
     *                IEDEN,IEMOM,IEPOT,IEFLD,MODENS,
     *                IEDOUT,IEMOUT,IEPOUT,IEFOUT,
     *                IEDINT,IEMINT,IEPINT,IEFINT
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),edisp
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /GRDPAR/ ORIGIN(3),XVEC(3),YVEC(3),ZVEC(3),UX(3),UY(3),
     *                UZ(3),GRDSIZ,NGRID,IGUNIT,NXG,NYG,NZG,modgrid
      COMMON /IEACAL/ REMPOL,IEACAL,NFGIEA,NFRGIEA,NFRGI1,NFRGI2,IEADA,
     *                MXEFPT,MAXPOL,NPRIEA,NATFIEA,IEABDY,ITRLVL,
     *                LIEACNT,ieaold,DOEFPIEA
      COMMON /INTRFC/ FRIEND,AIMPAC,RPAC,PLTORB,MOLPLT,DGRIDPROG
      common /INT2IC/ NINTIC,iNINTIC,nxxic,lbufpic,lixic,labsix,nintix
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INFOEX/ TDM(3,mxrt),MOCC(mxrt),MVIR(mxrt),MONOC1,MONVR1,
     *                IFMODIM,MONOC2,MONVR2
      COMMON /INFOTD/ CNVTOL,PFREQ(2),
     *                JANST,NRADT,NTHET,NPHIT,NLEBT,
     *                NSTAT,NTRIAL,MAXVEK,NTHST,IRECTD,ITDFG,ITDPRP,
     *                TRIPLET,SG1T,NONEQR,TAMMD,TPA,ALPHKWD,BETAKWD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MFRPAR/ MFRZ,NUMFRZ,NORFRZ,IFRZ(MXAO)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NORB,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /NLRC  / LCFLAG,EMU,EMU2,LRFILE
CFTNC COMMON /NLRCF / LRINT
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
      COMMON /PCMCHG/ PB,PX,PC,UNZ,QNUC,FN,FE,UNZOR,PORT
      COMMON /PCMDIM/ mxsp,mxts,mempcm1,mempcm2,NTS
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEFPCM,IP_F,nfmopcm,IHET
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /PSILVL/ IPSI,ISKPRP
      COMMON /QMFM  / SIZE,EPS1,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      COMMON /RAIOLN/ JRECLN(10),JRECST(10)
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RUNOPT/ pUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,npreo(4)
c     COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
      COMMON /SCFWFN/ AROHF(3),BROHF(3),PACAVO(6),IACAVO,IUHFNO,ICUHF,
     *                MVOQ
      COMMON /STNBUF/ STNPNT(4,2*MXATM),BIGEXP,NPTSTN,NBUFFM
      COMMON /TIMING/ CPU,WALL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmolat/ untang(3),untorg(3),respbc(4),abclat(3),anglat(3),
     *                symtra(3,24),symope(3,3,24),iatorg,nsymop,maxklms,
     *                ioporg(3),iopdir(3),iopabc(3),iopang(3)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /MLTFMO/ Q_MUL,IMLTFMO,ISWPFD,ISWNEW1
      dimension loadm(*),jobgrp(*),ichfg(*),layfrg(*),numfrg(*),
     *          natfrg(*),iaglob(*),indat(*),fmozan(*),fmoc(3,*),
     *          iabdfg(*),jabdfg(*),idxcao(MaxBnd,*),iodfmo(*),maxl30(*)
     *         ,idmrec0(*),da(*),db(*),fmoespa(*),vec(*),wrk1(*),wrk2(*)
     *         ,emon(nfg,*),ewrk(*),glocon(0:*),mcnvfmo(*),ncvscf(2),
     *         mconfg(*),fmode(3,natfmo,*),fmopg(3,*),liter(*),molfrg(*)
     *         ,scffrg(*),popmul(maxl1,nfg,2),popmat(maxnat,nfg,2),
     *          ifgbuf(*),nfgbuf(*),atmulq(*),atmulqi(*),
     *          fmoelm(nfmoelm,*),nmmfrg(*),nmdfrg(nfg,2),nmtfrg(nfg,2),
     *          ngrfmo(maxpst,*),mannod(*),mastid(*),nprfrg(*),totd(*),
     *          iaoglob(*),dgrid(nxyzg,*),ngm(3),dgridm(nxyzgm,*),
     *          vdwrad(*),noffg(*),indgrd(6,*),iodcfmo(*),ORIGM(3),
     *          UXM(3),UYM(3),UZM(3),extracc(nextracc,*),esolv(*),
     *          etotdft(nedft),XYZCTS(mxts,3),PEL(*),VNUC(*),qini(*),
     *          epl0ds(nfg,*),efmo0(nfg,2),klms(4,*),untrot(3,3,*),
     *          esplat(n2fmo,*),stonep(*),frgmul(nfrgmul,natfmob,2),
     *          iexcit(5),eexcit(mxrt,2),texcit(3,mxrt,2),
     *          monoc(mxrt),monvr(mxrt),ctdm(*),atchrg(*),
     *          clmo(maxbbd,maxabd2,maxlmo,*),ialmo(2,maxabd2,maxlmo,*),
     *          indlmo(2,*),iwlmo(*),atclmo(*),lmobdf(*),
     *          fgflmo(maxl1,maxslo,*),nfglmo(*),lfglmo(maxslo,*),
     *          pfglmo(maxnat,maxslo,*),DDIJPOT(*),dafo(*),eigfmo(*),
     *          EFPIEA(*),FGINT(*),fmoddm(*),FMOFCM(*),FCMWRK(*),
     *          potat(*),fmohard(natfmo,*),eaip(nfg,2),ABFLDT(*),
     *          DINDF2(*),DINDDF2(*),ZVLAG(*),IPTLG(*),
     *          ZVWRK(*),NQMTFG(*),VIPOT(MAXNAT,NFG,2),
     *          crfrg(4,ncentm,nfg),CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          F_mm((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G_mm((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          ALCNT2F(*),YALAG(*),IPTYA(*),YAWRK(*),locfmo(2,2,*),
     *          iactfg(*),pmulspin(*),mappcm(*),grdpad(3),excit2(nfg,*),
     *          texcit2(*)
c
      data energy/8HENERGY  /,rnone/8HNONE    /,RMC/8HMCSCF   /,
     *        UHF/8HUHF     /,ROHF/8HROHF    /
c
c     Self consistent field iterations for monomer fragments in the field
c     of other monomers.
c     parstat: GlobalFull
      ifmostp=2
      ntimout=0
      timeafo=0
      nitafo=0
c     mdout1=mdout.and.iand(nprfmo,3).ne.3
c
c     point densities to the last converged SCF
c     DGF is not sure if TDDFT gradient replaces the ground state density.
c     If it does not, the tddft clause should be removed from all similar
c     statements with tddfti.ne.rnone.and.nder.gt.0.
      if(MPLEVLi.gt.0.and.(MPPROP.ne.0.or.nder.gt.0).or.
     *   citypi.ne.rnone.or.(tddfti.ne.rnone.and.nder.gt.0)) then
        if(irststp.ge.ifmostp) modrst=modrst-1
c       if(irststp.gt.ifmostp) modrst=modrst-1
      else
        if(irststp.gt.ifmostp) modrst=modrst-1
      endif
      if(irststp.gt.ifmostp) then
        if(maswrk) write(iw,*) 'Dimer restart density record is',modrst
        idmrec0(ilay)=mod(modrst,2)*2*nfg+1
        nfglay=-1
        return
      endif
      dovac=iand(ixesp,16384).ne.0
      conv2=.false.
c
c     Turn off grid switching altogether
c
      NRADs=NRAD0
      NPHIs=NPHI0
      NTHEs=NTHE0
      swoffs=swoff
      swdiisv=swdiis
      npcmsav=nfmopcm
      coroffs=coroff
      nfglay=0
      do ifg=1,nfg
        if(layfrg(ifg).ge.ilay.and.scffrg(ifg).ne.rnone) nfglay=nfglay+1
      enddo
      if(ndualb.ne.0.and.ibloop.ne.2) then
c       For bare runs use SWOFF instead of COROFF with the same effect.
        swoff=coroff
        coroff=0
      endif
      if(coroff.ne.0.or.nevsav.gt.0) then
c       turn off grid switching for FMO monomers
        NRAD0=NRAD
        NPHI0=NPHI
        NTHE0=NTHE
        swoff=0
        if(coroff.ge.1.0D+00.or.npcmsav.gt.0.and.iterpcm.gt.1) coroff=0
c       if(coroff.ge.1.0D+00) coroff=0
c       the real usage of this is for restart jobs so that DFT is done
c       right away, but swoff is turned off.
      endif
c     Do not do switching DIIS->SOSCF during monomer SCF.
      if(nbody.gt.1.and..not.dovac) swdiis=0
c     if(nbody.gt.1) swdiis=0
c
      if(.not.dovac.and..not.scfesp) then
        RUNFMO=energy
      else
        RUNFMO=runtyp
      endif
      if(ilay.gt.1.and.nopden.gt.0) RUNFMO=runtyp
c
c     If doing any correlation beyond SCF do it only after SCF converges.
c
      if(.not.scfesp) then
      if(dopleda.or.dovac.or.ilay.gt.1.and.nopden.gt.0) then
        mplevl=mplevli
        cctyp=cctypi
        cityp=citypi
        tddftyp=tddfti
      else
        mplevl=0
        cctyp=rnone
        cityp=rnone
        tddftyp=rnone
      endif
      endif
      corsav=correl
c     MCONV=mcnvfmo(ifmostp)
c
      idad=0
      idat=0
      idad2=0
      idat2=0
      nextra=0
      if(correl.or.runtyp.ne.energy.or.densgrid.or.spargrid.or.
     *   totfock.or.iterpcm.gt.0.or.iand(modlmo,8192).ne.0.or.
     *   iand(modlmo,16384).ne.0.or.iand(nprfmo,32).ne.0.or.iahard.gt.0
     *   .or.fraggrid.or.qmcout) nextra=1
c    *   iterpcm.gt.0) nextra=1
c    *   ifgdon.ne.0.and.ifgacc.ne.0.or.iterpcm.gt.0) nextra=1
c     one can save on properties by doing them during the extra run
      if(ilocals.ne.0.and.rflmo(1).eq.0) nextra=1
      if(iand(modpar,256).ne.0) nextra=1
      do ifg=1,nfg
        if(iand(nprfrg(ifg),128).ne.0) nextra=1
      enddo
      if(scfesp) nextra=0
c     if(dftbfl.and.scc) nextra=1
      if(dftbfl) enucfmo=zero
c
c     Mulliken point charge derivatives
      LPOPDFLG=NDER.GT.0.AND.RESPPC(1).NE.ZERO.AND.IAND(MODGRD,8).NE.0
      IF (LPOPDFLG) CALL VCLR(DDIJPOT,1,maxnat*nfg)
C
C     FMO HESSIAN
C
      IF (NDER.EQ.2) then
        CALL VCLR(FMOFCM,1,NC1*NC1)
        IF (DFTBFL) CALL VCLR(FCMWRK,1,NC1*NC1)
        CALL VCLR(FMODDM,1,3*NC1)
        CALL VCLR(YALAG,1,IPTYA(NFG+1))
      endif
C     clear 1st layer density for B
      if(dofddpcm.and.ilay.eq.1) then
        CALL VCLR(YALAG,1,IPTYA(NFG+1))
      end if
C
C     clear ZVLAG
C
      IF (NDER.GT.0.AND.IAND(MODGRD,32).NE.0) THEN
        IF (.NOT.DODISTR) CALL VCLR(ZVLAG,1,IPTLG(NFG+1))
c       IF (DODISTR) CALL ddi_zero(IDFZVEC)
      END IF
      IF (dofret.and.tddfti.ne.rnone) then
c        write(6,*) "Clear zvlag"
         CALL VCLR(ZVLAG,1,IPTLG(NFG+1))
      end if
c
      if(dopleda) nextra=0
      nextra0=nextra
      if(dovac.or.ilay.gt.1.and.nopden.gt.0) nextra=nextra-1
      iemoms=iemom
c     if(nextra.ne.0.and.) iemom=0
      skipc=gcorrel.and.molfrg(1).ge.0.and..not.subsys.and.needmd.ne.0
      lbmcscf=docas.and.mod(modpar,2).ne.0.and.ngrfmo(6,ilay).ne.0.and.
     *        isgddi0
c
      mgroups=1
      if(isgddi0) mgroups=ngroups
      if(isgddi.and.tddfti.ne.rnone) nvirtdm=0
      desperate=mod(nguess/256,2).ne.0
      despread=desperate.and.iand(nguess,2048).eq.0
cnb   desperate will not work with Huckel dimers
      gdenmax=zero
      nconv=0
      conv=.false.
      fmajor=.false.
      icut0=icut
      itol0=itol
      icoroff=0
      ipcmoff=0
      gediff=zero
      CONVHF0=CONVHF
c     fmajor forces loosened convergence to become tight if otherwise converged.
      clrden=.true.
c     clear the total density only when needed.
      iter=1
      jter=1
      if(irststp.eq.ifmostp.and.modrst.ne.0) iter=modrst
      if(ilay.gt.1.and.nopden.gt.0.and.irec0ini.eq.1) iter=2
c     shift the initial record away from layer 1
      idoprop=0
      call vclr(ewrk,1,nfg)
      iter0=iter
      uhfcal=.false.
      nread=0
  200   continue
        icurit=iter-iter0+1
        ndesper=0
        nodesper=0
        call viclr(jobgrp,1,nfg)
c       IF (LPOPDFLG) CALL VCLR(POPDMAT,1,3*MAXNAT*MAXNAT*NFG)
C
        IF (IEACAL.EQ.1) THEN
          REMPOL = ZERO
          IF (IAND(NPRIEA,10).NE.0)
     *    CALL VCLR(EFPIEA,1,MXEFPT*NFRGI1*NATFIEA*8)
          IF (IAND(NPRIEA,5).NE.0)
     *    CALL VCLR(FGINT,1,NFGIEA*NFRGI2*8)
        END IF
        IF (IEFPFMO.EQ.2) THEN
          CALL VCLR(ABFLDT,1,NPTTPT*3)
          CALL VCLR(ALCNT2F,1,NFG)
          POLTOT = ZERO
        END IF
c
        e1efmoi=0
        ekinfmoi=0
C
c       At each iteration both new and old (from the previous iteration)
c       density matrices (DM) are handled. The new ones are saved after
c       each SCF iteration, the old ones are read in to obtain ESPs and
c       serve as initial guess.
c
c       The structure of file 30:
c       rec. # (N is equal to nfg)
c          1... N  alpha DM for each fragment, iteration I1
c        N+1...2N  beta  DM for each fragment, iteration I1
c       2N+1...3N  alpha DM for each fragment, iteration I2
c       3N+1...4N  beta  DM for each fragment, iteration I2
c          1... N  ESP for each fragment, iteration I1
c          1... N  ESP for each fragment, iteration I2
c
c       I1 and I2 are consequent iterations. They change like this:
c       (iteration zero denotes initial guess).
c
c       iter  0   1   2   3   4    etc
c       I1    0   0   2   2   4
c       I2        1   1   3   3
c
c       For RHF no beta matrices are stored. Alpha matrices hold the total
c       density.
c
        if(nextra.ne.nextra0.or.scfesp) idoprop=1
c       if(nextra.ne.nextra0.and.iand(modlmo,8192).ne.0) idoprop=1
c       if(nextra.ne.nextra0.and.iand(modlmo,16384).ne.0) MFRZ=.false.
        if(nextra.ne.nextra0.and.rflmo(1).eq.0) ilocal=ilocals
        irec0new=mod(iter,2)*2*nfg+1
        irec0old=mod(iter-1,2)*2*nfg+1
c       the first 2 is because two iterations, the second because alpha & beta
c       write(6,*) 'in SCC old,new:',irec0old,irec0new, irec0
        if(ilay.gt.1.and.nopden.gt.0) irec0old=irec0new
c       overwrite Huckel densities
        if(ilay.gt.1.and.nopden.gt.0) then
c         icurpop points to Huckel charges for layer 2
          inxtpop=icurpop
c         rewrite Huckel charges for layer 2
          icurpop=3-icurpop
c         use SCC charges from layer 1 for ESPs
        else
          inxtpop=3-icurpop
c         3-x changes 1 into 2 and 2 into 1.
          if(dopleda) inxtpop=icurpop
        endif
        icurpops=icurpop
        espscf=one
        if(jter.le.9) espscf=espsca(jter)
        if(fmajor) espscf=one
        if(maswrk.and.espscf.ne.one) write(6,9120) espscf
c       if(.not.dopleda) idmrec0(ilay)=irec0old
        idmrec0(ilay)=irec0old
        dftsav=DFTYPE
        lcsav=LCFLAG
        CAMsav=camflag
        cisav=cityp
        tdsav=tddftyp
        mp2sav=mplevl
        ndftsav=NDFTFG
        hfssav=DFTTYP(3)
c       moditer=mod(iter-iter0,2)
        if(isgddi0) call GDDICOUNT(-1,lgroup,myjob)
        nconv=0
        if(cnvdmp.ne.0)
     *    call adjconv(iter,gdenmax,itol0,icut0,CONVHF0,fmajor)
        gdenmax=zero
        call vclr(glocon,1,mgroups)
c       Do not zero out SCF properties for the extra iteration with selected
c       monomers.
        if(nextra0.eq.nextra.or.molfrg(1).lt.0.or.subsys) then
          if(primul) call vclr(atmulqi,1,natfmo*mbody)
          if(nfmoelm.ne.0) call vclr(fmoelm(1,nfg+3),1,nfmoelm*2)
c         clear temporary storage for 2 and 3 body terms
        endif
c       only the first half need be cleared.
c       if(totdens) call viclr(indd,1,ndrec)
        if(totdens.and.clrden) call vclr(totd,1,l2fmo)
        if(densgrid.and.ifgfmo0.eq.0.and.clrden) then
          if(griddistr) then
            call ddi_zero(itmfmo(1))
            if(nsetgrid.eq.2) call ddi_zero(itmfmo(2))
          else
            call vclr(dgrid,1,nxyzg*ngbody*nsetgrid)
          endif
        endif
        if(spargrid.and.clrden) call vclr(dgrid,1,nxyzg*ngbody*nsetgrid)
        if(ndftfg.eq.1) call vclr(etotdft,1,nedft)
        if(m1efmo.ne.0) call vclr(eigfmo,1,m1efmo)
        IF (IAND(MODESP,512).NE.0.AND.DOSPC) THEN
          CALL VCLR(VIPOT(1,1,inxtpop),1,NFG*MAXNAT)
        END IF
c       call vclr(eaip,1,nfg*2)
c
        if(coroff.ne.0) then
          if((gediff.gt.coroff.or.iter.eq.iter0.or.
     *       abs(gediff).le.1.0D-12).and.icoroff.eq.0) then
            if(maswrk.and.DFTYPE.ne.rnone)
     *        write(6,*) 'DFT is switched off!'
            DFTYPE=rnone
            NDFTFG=0
            DFTTYP(3)=1.0D+00
            LCFLAG=.FALSE.
            camflag=.false.
cnb         it is a good idea to reduce convergence.
          else
            icoroff=1
c           icoroff prevents frantic switching DFT on and off: switching on
c           is done only once, thereafter DFT is never switched off.
          endif
        endif
c       Update frozen LMOs
        if(rflmo(1).ne.0.and.iter0.eq.iter.or.
     *     doclmo1.and.gediff.gt.cnvafo) then
          if(doclmo) then
            do i=1,natfmo
c             write(6,*) 'wwwchi',i,atclmo(i)
c             write(6,9000) 'i',i,atclmo(i)
c9000 format(1x,'wwwch',A1,I6,F15.10)
            enddo
          endif
          swoffss=swoff
          dftypes=DFTYPE
          NDFTFGs=NDFTFG
          DFTTYPs=DFTTYP(3)
          LCFLAGs=LCFLAG
          CAMFLAGs=CAMFLAG
          if(.not.doclmo1.and.dftsav.ne.rnone) then
c           For AFO0 and AFOH we must turn on DFT here...
c           (it may have been turned off with coroff).
            NDFTFG=ndftsav
            dftype=dftsav
            DFTTYP(3)=hfssav
            LCFLAG=lcsav
            CAMFLAG=camsav
          endif
          if(naoafo3.eq.0) swoff=1.0D-03
c         Force swoff...
c         Convergence of model systems with DFT seems to be bad.
          npcmsav2=nfmopcm
          nfmopcm=0
c         if(iter0.eq.iter) nfmopcm=0
c         During the LMO generation just turn PCM off.
c         One could use PCM in AFO1 with some extra work to generate
c         the PCM charges (record 311).
          call makelmo(ilay,iter-iter0+1,ichfg,indat,fmozan,fmoc,iaglob,
     *                 iabdfg,jabdfg,idxcao,clmo,ialmo,
     *                 indlmo,iwlmo,ilocals,orbxch,naoafo3,naoafod,dafo,
     *                 dafo(1+naoafo3),timeafoi,l1dir,nhybnam)
          timeafo=timeafo+timeafoi
          nitafo=nitafo+1
          if(doclmo1) call vclr(atclmo,1,natfmo)
          if(dovlmo) call storelmo(ilay,lmobdf,vec,da,wrk2,wrk1,
     *                             fgflmo,nfglmo,lfglmo,pfglmo)
          nfmopcm=npcmsav2
          DFTYPE=dftypes
          NDFTFG=NDFTFGs
          DFTTYP(3)=DFTTYPs
          LCFLAG=LCFLAGs
          CAMFLAG=CAMFLAGs
          swoff=swoffss
          mfrz=.true.
          numfrz=0
        endif
c
        nfmopcm=npcmsav
        if(nlayer.eq.1.or.dofddpcm) then
          updpcm=nfmopcm.eq.1.or.nfmopcm.gt.1.and.dovpcm.and.
     *           (iterpcm.eq.1.or.nextra.ne.nextra0)
        else
          updpcm=nfmopcm.gt.0.and.dovpcm.and.
     *           (ilay.eq.1.and.iterpcm.eq.1.or.nextra.ne.nextra0)
        endif
c       if(pcmoff.ne.0.and.updpcm.and.nextra.eq.nextra0) then
        ipcmoff1=ipcmoff
        if(pcmoff.ne.0.and.updpcm) then
          if((gediff.gt.pcmoff.or.iter.eq.iter0).and.ipcmoff.eq.0) then
            nfmopcm=0
            updpcm=.false.
            if(maswrk) write(6,*) 'PCM is swithed off!'
          else
            ipcmoff=1
          endif
        endif
        gediff=zero
c
c       PCM potentials etc will be updated during unilayer FMO if:
c       1) doing PCM[1] or
c       2) doing the first PCM iteration of PCM[2]  or
c       3) computing properties in any other PCM iteration of PCM[2]
c
c       PCM potentials etc will be updated during multilayer FMO if:
c       1) doing the first PCM iteration for layer 1 or
c       2) computing properties (which means building many-body potentials)
c
c       write(6,*) "updpcm=",updpcm
c
        if(dofddpcm) then
         call vclr(VNUC,1,NTS)
         if(updpcm) then
           call vclr(PEL,1,NTS)
         endif
         if(nfmopcm.ne.0) then
           do ifg=1,nfg
             if(layfrg(ifg).ge.ilay) esolv(ifg)=zero
           enddo
         endif
        else
         if(nfmopcm.ne.0.and.ilay.eq.1) call vclr(VNUC,1,NTS)
         if(updpcm) then
           if(ilay.eq.1) call vclr(PEL,1,NTS)
         endif
         if(nfmopcm.ne.0) then
           do ifg=1,nfg
             if(layfrg(ifg).ge.ilay) esolv(ifg)=zero
           enddo
         endif
        endif
c       save fmoc
c---    if(dopbcmd) call genfrgmic(0,-1)
        if(dopbcmd) call genimagefg(0,0)
       if(nfrgmul.gt.0) call vclr(frgmul(1,1,inxtpop),1,nfrgmul*natfmob)
c
       if(iand(modfmm,4).ne.0) call fmmfrag(ilay,loadhf,loadm,
     *   layfrg,scffrg,iodfmo,orbxch,da,wrk1,irec0old,ncentm,clm,flm,
     *   f_mm,g_mm,crfrg,ylmfrgv,zlmfrgv)
c
        clrden=.false.
        jbsav=jbtyp
        ngrsav=ngroups
        clrcow=.false.
        do 230 iifg=1,nfg
          if(loadhf.gt.0) then
            ifg=loadm(iifg)
          else
            ifg=iifg
          endif
          if(scffrg(ifg).eq.uhf)  uhfcal=.true.
          if(scffrg(ifg).eq.rohf) uhfcal=.true.
          if(iefmorun .gt. 0 ) IEFMOCFRG = IFG
          if(layfrg(ifg).lt.ilay) goto 230
          if(scffrg(ifg).eq.rnone) goto 230
c         generate fragments around the fragment ifg accoording to
c         the minimum image convention. fmoc, cfrg, and untxyz are
c         destroyed (fmoc is stored in fmoctmp), and so they must
c         be restored later using fmoctmp.
c---      if(dopbcmd) call genfrgmic(ifg,0)
          if(dopbcmd) call genimagefg(2,ifg)
c         if(dopbcmd) then
c           call makeindexiu(ilay,loadhf,loadm,indat,fmozan,
c    *                       fmoc,iabdfg,jabdfg,scffrg,
c    *                       needr0,rij,rwrk,mfg2,vdwrad,
c    *                       nprfrg,.false.,nunptc,natfmob,untxyz,
c    *                       units,indxiu,.false.)
c         endif
c         Odd iteration numbers run MCSCF for the chosen one,
c         even ones run RHF for the rest, if lbmcscf is active.
c         if(lbmcscf.and.(iifg.eq.1.and.moditer.ne.0.or.
c    *                    iifg.ne.1.and.moditer.eq.0)) goto 230
          if(lbmcscf.and.iifg.le.1+1) then
c           write(6,*) 'The 6th groupie'
            igrfmo=1
c           The first (MCSCF) fragment will be done with ngrfmo(6), which
c           really can only be meaningfully 1 (or 0).
c           The rest will be done with ngrfmo(1).
            if(iifg.eq.1) igrfmo=6
            call GDDICOUNT( 1,lgroup,myjob)
            call fmopre(ilay,igrfmo,ngrfmo,mannod,mastid,irmdfmo)
            call GDDICOUNT(-1,lgroup,myjob)
          endif
          eprev=emon(ifg,1)
          if(iand(modcnv,1).ne.0) eprev=ewrk(ifg)
c         nfglay=nfglay+1
c         Check if selected correlation is active.
          skipci=skipc.and.nmdfrg(ifg,2).eq.0.or.
     *           (tddfti.ne.rnone.or.citypi.ne.rnone).and.
     *              iexcit(1).ne.ifg.and.iexcit(3).eq.0
c         Most likely, only energy will be correct if skipci is set below
c         (since for nbody=1 nmdfrg is not set and thus multiplicative
c         constants for properties are not adjusted for such skipci).
          if(nbody.eq.1.and.gcorrel.and.exclmol)
     *      skipci=molfrg(ifg).eq.0
          if(nextra0.ne.nextra.and.skipci) then
            if(maswrk) write(iw,*)'Skipping correlation for monomer',ifg
c           avoid double counting by assigning those unneeded monomers
c           as converged on the grand master.
            if(grandmas) then
              nconv=nconv+1
            else
              emon(ifg,1)=zero
              emon(ifg,2)=zero
            endif
c           do the properties only
c           dc=-nmdfrg(ifg)
c           if(nbody.gt.1.and.nfmoelm.ne.0) then
c             call daxpy(nfmoelm,dc,fmoelm(1,ifg),1,fmoelm(1,nfg+2),1)
c           endif
            goto 230
          endif
          if(nfmoelm.ne.0) call vclr(fmoelm(1,ifg),1,nfmoelm)
          emon(ifg,1)=zero
          emon(ifg,2)=zero
          eaip(ifg,1)=zero
          eaip(ifg,2)=zero
          ewrk(ifg)=zero
c
c         If doing correlation now check if the correlated energy is needed:
c         it may not be if selected fragment option is used.
c         iifg is compared because it runs through reordered jobs (job index).
c
          if(nstjob.ne.0.and.iifg.le.nstjob) then
            if(mygroup.lt.loadgr) then
              jbtyp=0
              ngroups=loadgr
              clrcow=.true.
c             temporarily switch to static load balancing and use the reduced
c             number of groups in GDDICOUNT too.
            else
c             otherwise skip the static jobs
              goto 230
            endif
          endif
c
c         reset the inner counter before switching to dynamic load balancing.
c         do not reset the global counter itself.
          if(isgddi0.and.clrcow.and.jbtyp.gt.0) then
            call GDDICOUNT(-1,lgroup,myjob)
            clrcow=.false.
          endif
c
          if(isgddi0) then
            call GDDICOUNT(0,lgroup,myjob)
            ngroups=ngrsav
            jbtyp=jbsav
            if(.not.myjob) goto 230
          endif
          jobgrp(ifg)=mygroup
c
          SCFTYP=scffrg(ifg)
          odexch=scftyp.eq.rmc
          if(scftypi.ne.rmc.and.SCFTYP.eq.rmc) SCFTYP=scftypi
c         SCFTYP must be fixed with scftypi AFTER(!!) assigning odexch
c         so that saving orbitals as controlled by odexch is done to allow
c         for the following layer's MCSCF.
c
          if(iand(nprfrg(ifg),512).eq.0.and..not.dofret) then
            if(tddftyp.ne.rnone.and.iexcit(1).ne.ifg) tddftyp=rnone
            if(cityp.ne.rnone.and.iexcit(1).ne.ifg) cityp=rnone
          endif
          if(dofret.and.iactfg(ifg).eq.0) then
            if(tddftyp.ne.rnone) tddftyp=rnone
            if(cityp.ne.rnone) cityp=rnone
          endif
c
c         if(exclmol.and.molfrg(ifg).eq.0) then
c           This resetting correlation only works for nbody=1. Otherwise
c           only energy is correct(?)
c           DFTYPE=rnone
c           NDFTFG=0
c           DFTTYP(3)=1.0D+00
c           mplevl=0
c           cityp=rnone
c           if(nextra.ne.nextra0.and.maswrk)
c    *        write(iw,*) 'No electron correlation for IFG=',ifg
c         else
c           if(maswrk) write(iw,*) 'Using DFTTYP=',DFTYPE
c         endif
          if(modfd.ne.0.and.conv2.and.nder.eq.2) then
            if(ilay.eq.nlayer.and.iactfg(ifg).ne.0) then 
              RUNFMO=runtyp
            else
              RUNFMO=energy
            end if
          end if
c
          if(maswrk.and.mdout) then
            call wfnstr(wfnstri)
            write(iw,9200) SCFTYP,ifg,wfnstri,
     *              iand(numfrg(ifg),65535),iand(nqmtfg(ifg),65535),iifg
          endif
c         if(maswrk) CLOSE(UNIT=IDAF,STATUS='DELETE')
          call CLOSDA('DELETE')
          CALL OPENDA(0)
c
          nprsav=nprint
          npusav=npunch
          if(iand(nprfrg(ifg),128).eq.0.or.nextra.ne.nextra0) then
            if(iand(nprfrg(ifg),1).ne.0) nprint=7
            if(iand(nprfrg(ifg),8).ne.0) npunch=2
          endif
          if(iand(nprfmo,32).ne.0.and.nextra.ne.nextra0) then
            nprint=7
            npunch=2
          endif
c
          icurfg=0
          call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0,.true.)
          l1=num
          l2=(l1*l1+l1)/2
          l3=l1*l1
          if(maswrk) then
c           write(iw,9200) SCFTYP,ifg,wfnstr(),l1,nqmt,iifg
            if(labsiz.ne.labsix.and.iand(nprfmo,3).eq.0) 
     *        write(iw,9205) labsiz,labsix
            if(NINTIC.ne.0.and.iand(nprfmo,3).lt.2)
     *        write(iw,9207) LABSIZ,NINTIC,ININTIC
            if(idoprop.ne.0.and.qmcout)
     *        call qmcfout(nftqmc,ifg,0,0,popmat(1,ifg,icurpop))
          endif
c         all CI runs generate CI density.
          doddcori=(MPLEVL.gt.0.and.(MPPROP.ne.0.or.nder.gt.0)).or.
     *             cityp.ne.rnone.or.(tddftyp.ne.rnone.and.nder.gt.0)
          icurfg=ifg
          iconfg=mconfg(ifg)
c         overwrite fragment specific converger with the step converger
          if(iter-iter0.ge.ncvscf(2)) iconfg=-1
          fordir=forcedir(l1dir,l1,maswrk)
          if(nintic.ne.0.and.scftyp.eq.rmc.and.goparr) fordir=.true.
          call fmoconv(mcnvfmo(ifmostp),iconfg,l1,vec,enexch,
     *                 orbxch,iter.eq.iter0,iter-iter0.ge.ncvscf(1).and.
     *                 iconfg.eq.-1,fordir)
c
          tightint=iand(nprfrg(ifg),32).ne.0.and.DIRSCF.and.FDIFF
c
c         reset icut for "poorly" converging FDIFF fragments
c
          icutifg=icut
          if(tightint) then
            icut=icut+1
            if(maswrk) write(iw,9203) icut
          endif
c
c         provide initial density from previous run
c         will not work for ROHF/UHF!
c
          donor=.false.
          acceptor=.false.
c         donor=iand(nprfrg(ifg),8).ne.0
c         acceptor=iand(nprfrg(ifg),16).ne.0
          if(.not.dftbfl) then
          lrece=0
          if(enexch) lrece=l1
c         write(6,*) 'wwwreading2',ifg+irec0old
          if(orbxch) then
            if(odexch) then
             CALL rareads(IDAFMO,iodfmo,da,l2+l3+lrece,ifg+irec0old,0)
             lenrec=l2+l3+lrece
            else
              if(scffrg(ifg).eq.uhf) lrece=l3+l1*2
            CALL rareads(IDAFMO,iodfmo,da(l2+1),l3+lrece,ifg+irec0old,0)
              if(scffrg(ifg).eq.uhf) then
                 call DMTX2(da,da(l2+1),na,l1,l1,0)
                 call DMTX2(db,da(l2+1+l3),nb,l1,l1,0)
                 call daxpy(l2,one,db,1,da,1)
              else
                 call DMTX2(da,da(l2+1),na,l1,l1,na)
              end if
            endif

c           nrecl=l3
c           if(urohf) nrecl=nrecl+nrecl
            CALL dawrit(IDAF,IODA,da(l2+1),l3,15,0)
c           if(iand(mconv,8).ne.0.and.rflmo(1).eq.0) then
c             CALL dawrit(IDAF,IODA,da(l2+1),l3,318,0)
c             write(iw,*) 'wwwsaved MOs'
c             Save orbitals for RSTRCT.
c           endif
            if(scffrg(ifg).eq.uhf)
     *        CALL dawrit(IDAF,IODA,da(1+l3+l2),L3,19,0)
c           if(urohf) then
c             CALL dawrit(IDAF,IODA,da(1+l3),L3,19,0)
c           endif
c          iter=2 has Huckel+SCF densities, and it is better not to average
           if(idoprop.eq.0.and.iand(nguess,4096).ne.0.and.icurit.gt.2
     *        .and..not.odexch) then
              if(maswrk) write(6,*) 'Averaging densities'
            CALL rareads(IDAFMO,iodfmo,db(l2+1),l3+lrece,ifg+irec0new,0)
              call DMTX2(db,db(l2+1),na,l1,l1,nb)
              call daxpy(l2,one,db,1,da,1)
              call dscal(l2,half,da,1)
            endif
            mrece=l3
          else
c           nrecl=l2+lrece
c           if(urohf) nrecl=nrecl+nrecl
c           write(6,*) 'wwwread',nrecl,l2
            CALL rareads(IDAFMO,iodfmo,da,l2+lrece,ifg+irec0old,0)
            mrece=0
            if(idoprop.eq.0.and.iand(nguess,4096).ne.0.and.icurit.gt.2
     *        ) then
              if(maswrk) write(6,*) 'Averaging densities'
              CALL rareads(IDAFMO,iodfmo,db,l2+lrece,ifg+irec0new,0)
              call daxpy(l2+lrece,one,db,1,da,1)
              call dscal(l2+lrece,half,da,1)
            endif
          endif
          CALL dawrit(IDAF,IODA,da,L2,16,0)
c         call prtril(da,l1)
c         if(urohf) then
c           CALL dawrit(IDAF,IODA,da(1+l2),L2,20,0)
c           call prtril(da(1+l2),l1)
c           compute the total density and save it to DA
c           call daxpy(l2,one,da(1+l2),1,da,1)
c         endif
c         call prtril(da,l1)
          if(scffrg(ifg).eq.uhf) mrece=l3*2
          if(enexch) call dawrit(IDAF,IODA,da(mrece+l2+1),L1,17,0)
          if(enexch.and.scffrg(ifg).eq.uhf)
     *       call dawrit(IDAF,IODA,da(mrece+l2+l1+1),L1,21,0)
          if(iand(modlmo,3).eq.1.and.iand(modlmo,4096).ne.0.and.
     *       iter.gt.iter0) then
              NUMFRZ=nfglmo(ifg)
              NORFRZ=NUMFRZ
              MFRZ=NUMFRZ.gt.0
              write(6,*) MFRZ,'wwwfreezeMO',ifg,NUMFRZ
              if(MFRZ)
     *          CALL dawrit(IDAF,IODA,fgflmo(1,1,ifg),L3,318,0)
c             we write unitialised elements after l1*NUMFRZ.
          endif
c
c         save previous density for convergence test in a work area
          call dcopy(l2,da,1,wrk2,1)
c
c         write(6,*) 'wwwInitial density'
c         call prtril(wrk2,L1)
c
          else
C         DFTB initial guess (charges) for monomer
            if (scc) call diminic(ifg,0,0,wrk1,popmat,indat,iaglob,
     *                   ialoc,indbd)
          endif
c
          icurfg=ifg
          jcurfg=0
          kcurfg=0
c
c         Fix for ROHF, works only with CI or charge transfer (donor+acceptor).
c         Alpha orbitals and density are copied to beta (as initial guess)!
c         With this fix only energy will be computed correctly here.
c         Other properties are computed correctly in ROHF, but not here
c         (such as ES moments)?
c
          if(nextra.lt.nextra0.and.(donor.or.acceptor)) then
            if(orbxch) call dawrit(IDAF,IODA,da(l2+1),L3,19,0)
            CALL dawrit(IDAF,IODA,da,L2,20,0)
            if(enexch) call dawrit(IDAF,IODA,da(mrece+l2+1),L1,21,0)
            if(mul.ne.1) call abrt
            mul=2
            if(donor) then
              ne=ne-1
              nb=nb-1
            endif
            if(acceptor) then
              ne=ne+1
              na=na-1
            endif
          endif
c         if(updpcm) then
          if(nfmopcm.ne.0) then
            ida=1
c           if(nextra.ne.nextra0) then
c             if(nfmopcm.ge.2) ida=ida-nmdfrg(ifg,1)
c             if(nfmopcm.ge.3) ida=ida+nmtfrg(ifg,1)
c           endif
            if(ilay.ne.1.and..not.dofddpcm) ida=0
c           Here we use the fact that for multilayer runs the first layer has
c           all fragments and the fact that nuclear potential has no many-body
c           corrections (so it is only computed in monoscf).
c           Note that PCMNUP must be called for all n-mers as it computes
c           the corresponding correction to the n-mer energy.
            if(dofddpcm.and.(ilay.eq.2.or.nextra.ne.nextra0)) then
c             if(.not.(ilay.eq.2.and.nextra.ne.nextra0)) then
c               if(layfrg(ifg).eq.2) write(6,*) "wwwida vnuc2"
                if(layfrg(ifg).eq.2) call pcmnup2(1,vnuc,mappcm)
c             end if
            else
              call pcmnup(ida,vnuc)
            end if
          endif
c
c         Compute energy (SCF) of monomers
c
          delescf=0
          nloop=0
c         loop twice for MP2 grad/prop: RHF and then MP2.
c
          if(dofret.and.iactfg(ifg).ne.0) NTHST=iactfg(ifg)
c
          mp2run=mplevl
          if(doddcori) nloop=1
c         a funky hack to allow for efmo to derive
c         properties based on the RHF wavefunction only
c         which works except for correlated monomers energies
c         where no hacks from fmo are made.
          if(correl.and.IEFMORUN.GT.0.and.nder.eq.0)  nloop=1
          do iloop=nloop,0,-1
            if(iloop.gt.0) then
              mplevl=0
              cityp=rnone
              tddftyp=rnone
            endif
cnb         one can save time by resetting RUNTYP to ENERGY if idad is 0?
            NEVALS=iter
c           NEVALS=NEVALS+1
c           ENERGX increments NEVALS for each fragment. This is undesired
c           because it leads to e.g. SOSCF skipping DIIS for the first time
c           some fragments run.
            call fmosdir(0,fmodscf,fmodtrf)
            mvoqsav=MVOQ
            if(iand(nprfrg(ifg),2).ne.0) MVOQ=6
            if(cisav.ne.rnone) nprint=7
            mp2runs=mp2run
            CALL BRNCHX(RUNFMO)
c           Try converging once again with an alternative converger
            if(etot.eq.0.and.desperate) then
              if(maswrk) write(iw,9300)
c             Increase accuracy of DIRSCF/FDIFF.
              if(DIRSCF.and.FDIFF) icut=icut+1
c             to reuse integrals
              irest=2
              if(despread) then
c               do not use density from the previous run that failed, use the
c               pristine one (otherwise continue converging).
                CALL dawrit(IDAF,IODA,wrk2,L2,16,0)
                if(orbxch) then
                  write(iw,*) 'Not ready yet'
                  call abrt
                endif
              endif
              call fmoconv(mcnvfmo(ifmostp),iconfg,l1,vec,enexch,
     *                     orbxch,iter.eq.iter0,.true.,fordir)
              CALL BRNCHX(RUNFMO)
c             for desperate runs abort if not converged.
              if(etot.eq.0) then
                if(maswrk) write(iw,9310)
c               call abrt
                if(maswrk) nodesper=nodesper+1
              else
                if(maswrk) ndesper=ndesper+1
              endif
            endif
            if(iand(mp2run,1024).ne.0) then
c             MP2/SCZV has to save MP2 density in a secret vault.
              call daread(IDAF,IODA,da,L2,316,0)
              call dawrit(IDAF,IODA,da,L2,16,0)
            endif
            mp2run=mp2runs
            if(iand(modlmo,3).eq.1.and.iand(modlmo,4096).ne.0.and.
     *         iter0.eq.iter) then
              ilocal=ilocals
              CALL LMOINP
              CALL LMOX
              call getflmo(ifg,l1,l2,l3,na,indat,iaglob,db,vec,
     *                     nbndfg,fgflmo,nfglmo)
              ilocal=0
            endif
            if(ilocal.ne.0) then
              CALL LMOINP
              CALL LMOX
            endif
            MVOQ=mvoqsav
            call fmosdir(1,fmodscf,fmodtrf)
            if(RUNFMO.ne.energy.and.etot.eq.0) then
              if(maswrk) write(iw,9400)
              call abrt
            endif
            if(tddftyp.ne.rnone.or.cityp.ne.rnone) then
c            if(runtyp.ne.energy) then
c             call daread(IDAF,IODA,da,L2,308,0)
c             call dawrit(IDAF,IODA,da,L2,16,0)
c            endif
              call excmono(iexcit,eexcit,texcit,MONOC,MONVR,NSTMONO,
     *                     excit2,texcit2,ifg,nfg)
              if(iexcit(4).eq.2) then
                nvirtdm=nqmt-nocctdm
                nread=nocctdm*nvirtdm*NSTAT
                if(scffrg(ifg).eq.uhf) then
                    nvirtdb=nqmt-nocctdb
                    nread2=nocctdb*nvirtdb*NSTAT
                    nread=max(nread,nread2)
                    nread=nread*2
                end if
c               The following DAREAD is "tricky", because the
c               record was saved only on the master in TDDFT.
                gopsav=goparr
                goparr=.false.
                if(maswrk) CALL DAREAD(IDAF,IODA,CTDM,nread,471,0)
                goparr=gopsav
c               Fortunately, we do not need CTDM on slaves in GDDI.
c               However, we do need it for DDI.
                if(.not.isgddi.and.goparr)
     *            CALL DDI_BCAST(2007,'F',CTDM,nread,MASTER)
                if(isgddi.and..not.maswrk) then
c                 call vclr(CTDM,1,nread)
                  nvirtdm=0
                endif
              endif
              IF (dofret) then
                NOCC  = NA
                NVIR  = NQMT - NOCC
                NOCVR = NOCC*NVIR
                ndim  = NOCVR*2
c               nread = NOCVR
                CALL DAREAD(IDAF,IODA,ZVWRK,NOCVR,472,0)
                CALL DAREAD(IDAF,IODA,ZVWRK(NOCVR+1),NOCVR,473,0)
                if(iexcit(1).eq.-2) then
                 nread = NOCVR * NSTAT
                 ndim  = NOCVR*2+nread
                 CALL DAREAD(IDAF,IODA,ZVWRK(NOCVR*2+1),nread,471,0)
                end if
c               write(6,*) "Target state is ",NTHST
                CALL DCOPY(ndim,ZVWRK,1,ZVLAG(IPTLG(IFG)),1)
              END IF
            endif
c
c           Destroy the correlated density if so asked for.
c
            if(doscfprp.and.iloop.ne.nloop) then
c             write(6,*) 'Destroying the good D.'
              CALL daread(IDAF,IODA,da,L2,308,0)
              CALL dawrit(IDAF,IODA,da,L2,16,0)
            endif
            CALL daread(IDAF,IODA,wrk1,L1,17,0)
            if(maswrk) then
              eaip(ifg,1)=wrk1(na+1)
c             EA = electron goes to unpaired electron orbitals or virtuals
              eaip(ifg,2)=-wrk1(na)
c             IP = electron is taken away from the unpaired electron orbitals
            endif
            if(scffrg(ifg).eq.uhf) then
              CALL daread(IDAF,IODA,wrk1,L1,21,0)
              if(maswrk) then
                eaip(ifg,1)=min(eaip(ifg,1),wrk1(nb+1))
                eaip(ifg,2)=-max(-eaip(ifg,2),wrk1(nb))
              endif
            endif
            if((dosap.or.dospc).and..not.dopleda) then
c             update Mulliken populations+charges. Do not update for PL0.
              call DENDD1(DA,da(1+l2),L2)
c             CALL daread(IDAF,IODA,da,l2,16,0)
              CALL daread(IDAF,IODA,db,l2,12,0)
              call mulpop(l1,da,db,popmul(1,ifg,inxtpop))
              if(dospc) then
                if(NPTSTN.ne.0) then
                if((nprint.eq.-5.or.ISKPRP.ne.0).and..not.IEFMORUN.GT.0)
     *              call stone(ip,rnone,0)
                  call dcopy(nat,stonep,1,popmat(1,ifg,inxtpop),1)
                  if(nfrgmul.gt.0.and.maswrk) call storemul(0,ifg,nat,
     *        nfrgmul,frgmul,frgmul(1,1,inxtpop),natfrg,c,stonep(1+nat))
                else if(dopdc) then
                  if(nprint.eq.-5.or.ISKPRP.ne.0) CALL ELEPOTC(iwhere)
                  call dcopy(nat,stonep,1,popmat(1,ifg,inxtpop),1)
                else
               call mulpopa(popmul(1,ifg,inxtpop),popmat(1,ifg,inxtpop))
C
C                 Variational FMO; potential due to electron densities
C
                  IF (IAND(MODESP,512).NE.0) THEN
                    CALL GETDDIJPOT(1,0,DA,L2,VIPOT(1,1,inxtpop))
c                   CALL compvipot(IFG,0,0,indat,fmoc,VIPOT(1,1,inxtpop))
                  END IF
                endif
              endif
            endif
c           Update charges for the frozen LMOs
            if(doclmo1.and.maswrk) then
              do i=1,nat
                ig=iaglob(i)
                atclmo(ig)=atclmo(ig)+zan(i)-popmat(i,ifg,inxtpop)
              enddo
            endif
c
C           IF (LPOPDFLG) THEN
C             CALL MULPOPDA(DA,da(1+l2),L1,L2,L3,POPDMAT(1,1,1,ifg))
C           ENDIF
            call DENDD1(DA,da(1+l2),L2)
            call dcopy(l2,da,1,db,1)
c           CALL daread(IDAF,IODA,da,L2,16,0)
c           write(6,*) 'wwwdens1',ifg,irec0new,da(1),da(2)
c           write(6,*) 'wwwoutdens',ifg
c           call prtril(da,l1)
            if(nextra.lt.nextra0.and.(donor.or.acceptor)) then
c            The environment is of closed shell type, so there is only one ESP.
              CALL daread(IDAF,IODA,db,L2,20,0)
              call daxpy(l2,one,db,1,da,1)
            endif
            if(scffrg(ifg).eq.UHF) then
               call daread(IDAF,IODA,VEC,l3,15,0)
               call DMTX2(da,vec,na,l1,l1,0)
               call daread(IDAF,IODA,VEC,l3,19,0)
               call DMTX2(db,vec,nb,l1,l1,0)
               call daxpy(l2,one,db,1,da,1)
               call dcopy(l2,da,1,db,1)
            end if
            if(nfmopcm.ne.0) then
              esolv(ifg)=(PC-PX)*half
c             IF (ISWNEW1.EQ.1) THEN
c               if(maswrk) esolv(ifg)= PC-PX
c             ELSE
c               if(maswrk) esolv(ifg)=(PC-PX)*half
c             END IF
c             if(ISWNEW1.EQ.1.and.etot.ne.0) then
c               etot=etot-esolv(ifg)
c               if(gcorrel) escf=escf-esolv(ifg)
c             endif
c             This is a "half" correction. The other half is in fmoprop.
              if(.not.maswrk) esolv(ifg)=0
c
c             efmo gets one many-body solvation energy
c             from the efp total polarization. clear here
              if(iefmorun.gt.0) esolv(ifg)=0
            endif
c
            if(iloop.ne.nloop) then
              dele=delescf
c
c           This is the patch that replaces delta-D (MP2) by that of RHF.
c           To get back the MP2 value just erase the if and keep the else part.
c
            else
              if(dftbfl) then
                if(scc) then
                  dele=edft(1)
                else
                  dele=zero
                endif
              else
                dele=TRACEP(da,fmoespa,l1)
              endif
            endif
c
            memon=1+iloop
            emon(ifg,memon)=etot-dele
c           check convergence for SCF only
            if(etot.eq.zero) emon(ifg,memon)=zero
            if(maswrk) ewrk(ifg)=etot
c
            if(dopleda) then
              if(maswrk) then
                epl0ds(ifg,1)=escf-dele-e0scf(1)
                epl0ds(ifg,2)=dele-e0scf(2)
              endif
            endif
C
C           POLARIZATION OF SOLUTE DUE TO DENSITY CHANGE
C
            IF (IEFPFMO.EQ.2) THEN
              CALL DAREAD(IDAF,IODA,FMOESPA(L2+1),L2,89,0)
              TMP2FOCK=TRACEP(DA,FMOESPA(L2+1),L1)
              DUM = ZERO
              DUM = DUM + ENUCC(NAT,ZAN,C)
              DUM = DUM + ENUCD(NAT,ZAN,C)
              DUM = DUM + ENUCQ(NAT,ZAN,C)
              DUM = DUM + ENUCO(NAT,ZAN,C)
              TMP2FOCK = TMP2FOCK + DUM
              IF (MASWRK) ALCNT2F(IFG) = ALCNT2F(IFG) + TMP2FOCK
            END IF
c
c           save the density or orbitals
c
            imxl30=maxl30(ifg)
c
c           if(idoprop.eq.0) 
            call storefrg(l1,l2,l3,orbxch,odexch,enexch,.false.,scffrg,
     *                    imxl30,iodfmo,irec0new,ifg,da,lenrec)
            if(addesp.or.diffesp) then
              irecv=(irec0new-1)/2+nfg*4+1+ifg
              CALL rawrites(IDAFMO,iodfmo,fmoespa,imxl30,lenrec,irecv,0)
            endif
cnb         This will not work for correlation?
c           Should we save only if converged?
c           if(densfmo0.and.ifg.eq.1) then
c             write(6,*) 'wwwsaving',ifg,ifgfmo0,lenrec
c             call prtril(da,l1)
c           endif
            if(densfmo0.and.ifg.eq.1)
     *      CALL rawrites(IDAcFMO,iodcfmo,da,imxl30,lenrec,ifgfmo0+1,0)
c
c           if(urohf) call daxpy(l2,one,da(1+l2),1,da,1)
c
c           check convergence for SCF
c
            nconv0=nconv
            if(iloop.eq.nloop) then
c           if(orbxch.and..not.odexch) CALL daread(IDAF,IODA,da,l2,16,0)
              if(dftbfl) then
                denmax=0.0D+00
                if(layfrg(ifg).eq.ilay.and.maswrk.and.iter.eq.iter0)then
                  if (iand(modesd,1).eq.0) then
                    nnucr = nmdfrg(ifg,1)-1
                  else
                    nnucr = nfg-2
                  end if
                  if(modfd.eq.0) then
                    if(nbody.le.1) then
                      enucfmo=enucfmo+enucr
                    else
                      enucfmo=enucfmo-nnucr*enucr
c                   if(dopbcmd) enucfmo=enucfmo-(nnucr+2)*nimgcell*enucr
                    endif
                  else
                    if(ilay.eq.2) enucfmo=enucfmo+enucr
                  endif
                end if
              else
                call dcopy(l2,db,1,da,1)
c               Restore density which may have been lost during writing to F40
                call DDIFF(da,wrk2,L2,denmax)
              end if
              gdenmax=max(gdenmax,denmax)
              ediff=emon(ifg,memon)-eprev
              if(iand(modcnv,1).ne.0) ediff=etot-eprev
              if(scfesp) ediff=zero
              aediff=abs(ediff)
              gediff=max(gediff,aediff)
c             write(6,*) 'wwwhaha',gediff,aediff,convfg

              conv=(jter.ge.mxitfg.or.aediff.lt.convfg.or.dopleda.or.
     *              ilay.gt.1.and.nopden.gt.0).and.etot.ne.0
              fmajor=.false.
              if(conv.and.(espscf.ne.one.or.itol0.ne.itol.or.
     *           icut0.ne.icutifg.or.CONVHF0.ne.CONVHF)) then
                conv=.false.
                fmajor=.true.
              endif
c             Force "convergence" for the extra iteration that does corr/grad
c             if(conv.and.iter.lt.mxitfg.or.nextra.lt.nextra0)
c             if((aediff.lt.convfg.or.dopleda.or.nextra.lt.nextra0)
c             Force convergence if there is only one fragment in this layer
c             (except PCM!).
c    *           iand(modcha,4).eq.0.and.IEFPFMO.ne.2.and.
              if((aediff.lt.convfg.or.dopleda.or.nextra.lt.nextra0.or.
     *           nfglay.eq.1.and..not.dolat.and..not.dopbcmd.and.
     *           iand(modcha,4).eq.0.and.
     *           nfmopcm.eq.0.and.NFG.GT.1).and.etot.ne.0.OR.
     *           (NFG.EQ.1.AND.JTER.GE.2.AND.AEDIFF.LT.CONVFG))
     *           nconv=nconv+1
C    *           nfmopcm.eq.0).and.etot.ne.0) nconv=nconv+1
c             we may violate memory if popmat was not allocated. Lest this
c             happen point to the first element.
              ifg0=ifg
              inxtpop0=inxtpop
              if(.not.primul) then
                ifg0=1
                inxtpop0=1
              endif
c             Only do properties for converged SCF and for its own layer.
c             With the present implementation some monomers will be treated
c             redundantly if SCC converges not for all monomers at the same
c             time. However, if gradient or correlation is requested we can
c             save on properties by running them during the extra run.
c             For selected monomers some correlated runs will be skipped so do
c             properties as for uncorrelated cases.
c             Add support for molfrg for RHF runs.
              if(molfrg(1).ge.0.and..not.subsys) then
c               doprop=(conv.and.skipci).or.nextra0.ne.nextra
                doprop=(conv.and.skipci).or.nextra0.ne.nextra.or.
     *                 .not.gcorrel
              else
                if(correl.or.nder.gt.0.or.densgrid.or.spargrid.or.
     *          fraggrid.or.totfock.or.idoprop.gt.0.or.iahard.gt.0) then
                  doprop=nextra0.ne.nextra.or.dopleda
                else
c                 doprop=conv
                  doprop=conv.or.nfglay.eq.1
c                 Do SCF properties only if correlation will not be run.
                endif
              endif
c             Save energies without dynamic correlation.
c             ESCF is saved by MP2 but may not be available otherwise.
              if(gcorrel.and..not.doddcori) emon(ifg,2)=escf-dele
              if(dodc) emon(ifg,2)=escf-dele-edisp
c             if(dodcesd) emon(ifg,2)=escf-dele
            endif
            if(scfesp) doprop=.true.
c
            idam=1
            if(layfrg(ifg).ne.ilay) idam=0
c           if(ilay.eq.1.and.ext2lay) idam=idam+nmmfrg(ifg)
            if(nbody.gt.1) idad=-nmdfrg(ifg,1)
            if(nbody.gt.2) idat=nmtfrg(ifg,1)
            if(iloop.ne.0) then
              if(nbody.gt.1) idad=idad+nmdfrg(ifg,2)
              if(nbody.gt.2) idat=idat-nmtfrg(ifg,2)
c             do not accumulate RHF monomer properties
              idam=0
              if(ilay.eq.2.and.ext2lay) idam=-1
              if(ilay.eq.2.and.ext2lay) idad=idad+nmmfrg(ifg)
            endif
            if(nloop.gt.0.and.iloop.eq.0) then
              if(nbody.gt.1) idad=-nmdfrg(ifg,2)
              if(nbody.gt.2) idat= nmtfrg(ifg,2)
            endif
c           if(modfd.ne.0.and.ilay.eq.1) then
c             idad=0
c             idat=0
c             For FMO/FD, run gradient of layer 1 in order to run TVDER,
c             where contributions to FMO2 gradient are computed, because
c             there is dV/da term, which for separated dimers adds
c             contributions to "a" in layer 2, for mixed layer dimers.
c             Do no accumulate FMO2 corrections from monomer gradients for
c             layer 1 (only save monomer gradients).
c           endif
C
C           DETERMINE PROPERTIES FOR EFMO FRAGMENTS
C           BUT NOT ON A CORRELATED WAVEFUNCTION
            IF((DOVAC.AND.IEFMORUN.GT.0.AND.IEFMORT.EQ.1.AND.
     *           ILAY.EQ.LAYFRG(IFG) .AND.ILOOP.EQ.NLOOP)) THEN
               IEFMOCFRG = IFG
              CALL EFMOGFRG(IAGLOB,indat)
C             CHANGE EFMO RUNTYPE TO 2 TO ALLOW FOR GRADIENT UPDATES
            IEFMORT = 2
            ENDIF
c           iloop=1 SCF nmdfrg(ifg,1)
c           iloop=0 MP2 nmdfrg(ifg,2)
c           idat=((nfg-2)*(nfg-3))/2-1
c           write(6,*) 'wwwaabc',conv,doprop
            if(doprop) then
c             extracc needs not be zeroed out at each iteration since we are
c             guaranteed to have the extra SCC iteration for correlation.
              if((mplevl.ne.0.or.cctyp.ne.rnone).and.maswrk) then
                if(nbody.gt.1) idad2=-nmdfrg(ifg,2)
                if(nbody.gt.2) idat2=nmtfrg(ifg,2)
                if(cctyp.ne.rnone)
     *            call addecc(1,idam,idad2,idat2,extracc,nextracc)
                if(mplevl.ne.0)
     *            call addemp(1,idam,idad2,idat2,extracc,nextracc)
              endif
              call addprop(1,layfrg(ifg).eq.ilay,primul,idam,idad,idat,
     *                     iaglob,popmat(1,ifg0,inxtpop0),nfmoelm,
     *                     fmoelm(1,ifg),fmoelm(1,nfg+3),fmoelm(1,nfg+4)
     *                   ,atmulqi,atmulqi(natfmo+1),atmulqi(natfmo*2+1))
              if(iloop.ne.0) call vclr(fmoelm(1,ifg),1,nfmoelm)
c             clear off RHF moments to be replaced by MP2. Note that
c             RHF moments as accumulated in fmoelm(1,ifg) contribute
c             to 2 and 3-body properties (before they are done in).
              if(totdens) then
                call fmototd(idam+idad+idat,l2,da,totd,iaoglob)
                clrden=.true.
c               one has to clear density during the next iteration
c              (if there is a next iteration).
              endif
              call dumpfock(totfock,vec,l1,l2,idam+idad+idat,da,e1efmoi,
     *                      ekinfmoi)
              if(m1efmo.ne.0) call filleig(ifg,numfrg,eigfmo,nqmt,l1)
c
c             Compute the monomer density on a grid
c             For FMO0 runs replace local ifg by global.
              if(dftbfl.and.((nxyzgm.ne.0.and.iand(nprfrg(ifg),4).ne.0)
     *           .or.(densgrid.and.(ifgfmo0.eq.0.or.ifg.eq.1))))
     *           call daread(idaf,ioda,da,l2,16,0)
              if(nxyzgm.ne.0.and.iand(nprfrg(ifg),4).ne.0) then
                call mongrid(NGm,ORIGM,UXM,UYM,UZM,vdwrad,grdpad(1))
                call vclr(dgridm,1,nxyzgm*nsetgrid)
                kdum=-2
                ldum=-2
                call fmoprc(1,1,l2,da,dgridm,1,NGm(1),1,NGm(2),1,NGm(3),
     *                      1,NGm(1),1,NGm(2),1,NGm(3), 0,0,0,0,0,0,
     *                 ORIGM,UXM,UYM,UZM,nsetgrid,griddistr,0,kdum,ldum)
                call ddi_gsumf(2416,dgridm,nxyzgm*nsetgrid)
                ifgifg=ifg
                if(ifgfmo0.ne.0) ifgifg=ifgfmo0
                if(maswrk) then
                  do iset=1,nsetgrid
                   call makecube(iset,ifgifg,1,nat,zan,c,dgridm(1,iset),
     *                           NGm(1),NGm(2),NGm(3),ORIGM,UXM,UYM,UZM,
     *                           GRDSIZ,griddistr)
                  enddo
                endif
              endif
              if(fraggrid.and.iand(nprfrg(ifg),4).ne.0) then
c               Compute data on the grid for the fragment-wise storage.
                call gridfrg(ilay,ifg,nsetgrid,db,vdwrad,grdpad,orbxch,
     *                       irec0old,iodfmo,scffrg,fmozan,iaglob)
              endif
              if((scffrg(ifg).eq.uhf.or.scffrg(ifg).eq.rohf)
     *           .and.urospn) then
                scal = IDAM+IDAD 
c               write(6,*) "wwwcheck=",scal
                call fmocalspinchg(ifg,da,db,pmulspin,l1,iaglob,indat,
     *                             scal,1,dum,-1)
              end if
              if(densgrid.and.(ifgfmo0.eq.0.or.ifg.eq.1)) then
c               Compute the total density on a grid
                call grdbox(ixmin,ixmax,iymin,iymax,izmin,izmax,vdwrad,
     *                      grdpad(2))
                idamdt=idam
                if(nbody.gt.1) idamdt=idam+idad
                if(nbody.gt.2) idamdt=idam+idad+idat
                if(spinden) then
                 if(scffrg(ifg).eq.uhf.or.scffrg(ifg).eq.rohf) then
C                 Alpha - Beta 
                  call daread(IDAF,IODA,VEC,l3,15,0)
                  call DMTX2(da,vec,na,l1,l1,0)
                  call daread(IDAF,IODA,VEC,l3,19,0)
                  call DMTX2(db,vec,nb,l1,l1,0)
                  call daxpy(l2,-one,db,1,da,1)
                  kdum=-2
                  ldum=-2
                  call fmoprc(idamdt,1,l2,da,dgrid,1,NXG,1,NYG,1,NZG,
     *                      ixmin,ixmax,iymin,iymax,izmin,izmax,
     *                      0,0,0,0,0,0, ORIGIN,UX,UY,UZ,nsetgrid,
     *                      griddistr,0,kdum,ldum)
C                 Restore Density 
                  call daread(IDAF,IODA,VEC,l3,15,0)
                  call DMTX2(da,vec,na,l1,l1,0)
                  call daread(IDAF,IODA,VEC,l3,19,0)
                  call DMTX2(db,vec,nb,l1,l1,0)
                  call daxpy(l2,one,db,1,da,1)
                  call dcopy(l2,da,1,db,1)
                  clrden=.true.
                 end if
                else
                 kdum=-2
                 ldum=-2
                 call fmoprc(idamdt,1,l2,da,dgrid,1,NXG,1,NYG,1,NZG,
     *                      ixmin,ixmax,iymin,iymax,izmin,izmax,
     *                      0,0,0,0,0,0, ORIGIN,UX,UY,UZ,nsetgrid,
     *                      griddistr,0,kdum,ldum)
                 clrden=.true.
                end if
c               one has to clear density during the next iteration
c               (if there is a next iteration).
              endif
              dam=idam
              damd=idam+idad
              damdt=idam+idad+idat
              if(spargrid.and.(ifgfmo0.eq.0.or.ifg.eq.1)) then
c               Compute the total density on a sparse grid
c               First compute with factor 1 and then scale for all n-body
c               terms.
                ioff=noffg(ifg)
                kdum=-2
                ldum=-2
                call fmoprc(1,1,l2,da,dgrid(ioff,1),indgrd(1,ifg),
     *                      indgrd(2,ifg),indgrd(3,ifg),indgrd(4,ifg),
     *                      indgrd(5,ifg),indgrd(6,ifg),indgrd(1,ifg),
     *                      indgrd(2,ifg),indgrd(3,ifg),indgrd(4,ifg),
     *                      indgrd(5,ifg),indgrd(6,ifg), 0,0,0,0,0,0,
     *                 ORIGIN,UX,UY,UZ,nsetgrid,griddistr,0,kdum,ldum)
                nxyzgi=(indgrd(2,ifg)-indgrd(1,ifg)+1)*
     *                 (indgrd(4,ifg)-indgrd(3,ifg)+1)*
     *                 (indgrd(6,ifg)-indgrd(5,ifg)+1)
                if(damd.ne.zero.and.nbody.gt.1)
     *           call daxpy(nxyzgi,damd,dgrid(ioff,1),1,dgrid(ioff,2),1)
                if(damdt.ne.zero.and.nbody.gt.2)
     *          call daxpy(nxyzgi,damdt,dgrid(ioff,1),1,dgrid(ioff,3),1)
                call dscal(nxyzgi,dam,dgrid(ioff,1),1)
                clrden=.true.
c               one has to clear density during the next iteration
c               (if there is a next iteration).
              endif
              if(iahard.gt.0) then
                CALL EPCALC(fmoc,potat,da,natfmo,L2)
c               write(6,*) dam,damd,ifg,'wwwV',(potat(i),i=1,natfmo)
                if(maswrk) then
                  if(idam.ne.0)
     *              call daxpy(natfmo,dam,potat,1,fmohard(1,1),1)
                  if(idam+idad.ne.0.and.nbody.ge.2)
     *              call daxpy(natfmo,damd,potat,1,fmohard(1,2),1)
                  if(idam+idad+idat.ne.0.and.nbody.ge.3)
     *              call daxpy(natfmo,damdt,potat,1,fmohard(1,3),1)
c                 There are two minuses for each term.
                endif
              endif
              if(dolat) then
                call genlatv(ifg,l1,l2,n2fmo,klms,untrot,fmoespa,db,vec,
     *                       wrk1,esplat)
              endif
            endif
C
C           NEW FMO/EFP
C
            IF (IEFPFMO.EQ.2) THEN
              IDAEFP = IDAM
              IF (NBODY.GT.1) IDAEFP = IDAM+IDAD
              IF (NBODY.GT.2) IDAEFP = IDAM+IDAD+IDAT
              IF (ILOOP.EQ.0) IDAEFP = IDAEFP - 1

              IRHF = 0
              IF (ILOOP.EQ.NLOOP) IRHF = 1
              CALL GETABFLDT(0,IRHF,IDAEFP,L1,L2,ABFLDT,DINDF2,DINDDF2,
     *                       DA,DB,
     *                       DOPROP.AND.NDER.GT.0.AND.RUNTYP.NE.ENERGY)
              IF (MPLEVL.EQ.2.AND.DOPROP.AND.NDER.GT.0.AND.
     *            RUNTYP.NE.ENERGY.AND.ILOOP.EQ.0) THEN
                IDAEFP =  IDAEFP + 1
                CALL GETABFLDT(1,0,IDAEFP,L1,L2,ABFLDT,DINDF2,DINDDF2,
     *                         DA,DB,.TRUE.)
              END IF
            END IF
C
C           IF (DOPROP.AND.IEACAL.EQ.1) THEN
            IF (IEACAL.EQ.1) THEN
              IF (IEABDY.EQ.1) IEADA2 = IDAM
              IF (IEABDY.GT.1) IEADA2 = IDAM + IDAD
              IF (IEABDY.GT.2) IEADA2 = IDAM + IDAD + IDAT
              IEADA = 1
              IF (ITRLVL.EQ.1) THEN
                CALL READMOND(DA,ORBXCH.AND..NOT.ODEXCH,.FALSE.,NA,NB,
     *                        L1,IODFMO,IFG+IREC0OLD,scffrg(ifg).eq.uhf)
                CALL CALCIEA(L1,L2,DA,DA,1,IEADA2)
              ELSEIF (DOPROP) THEN
                CALL CALCIEA(L1,L2,DA,DA,1,IEADA2)
              END IF
            END IF
C
c
            if(updpcm) then
              call stopwa(7,0)
              ida=idam
c             This code is not correct for PCM gradient!
              if(nextra.ne.nextra0) then
                if(nfmopcm.ge.2) ida=ida+idad
                if(nfmopcm.ge.3) ida=ida+idat
              else
                if(ilay.eq.1.and.nlayer.gt.1.and.iterpcm.eq.1) ida=1
                if(dofddpcm) ida=1
              endif
              fda=-ida
              if(dofddpcm.and.(ilay.eq.2.or.nextra.ne.nextra0)) then
                fda=-1.0D+00
                if(.not.(ilay.eq.2.and.nextra.ne.nextra0)) then
c                  if(layfrg(ifg).eq.2) write(6,*) "wwwida poten3"
                   if(layfrg(ifg).eq.2) call EPOTEN3(fda,XYZCTS(1,1),
     *             XYZCTS(1,2),XYZCTS(1,3),PEL,da,NTS,L2,mappcm)
                   if(ilay.eq.1) then
c                   write(6,*) "yalag=",IPTYA(IFG)
                    if(layfrg(ifg).eq.2) 
     *                call dcopy(L2,da,1,yalag(IPTYA(IFG)),1)
                   end if
                end if
c               write(6,'("CHK=",I4,F12.8)') 
c    *          (mappcm(its),PEL(its),its=1,nts)
              else
                if(ida.ne.0) call EPOTEN(fda,XYZCTS(1,1),XYZCTS(1,2),
     *                                   XYZCTS(1,3),PEL,da,NTS,L2)
              end if
              call stopwa(7,1)
            endif
            if(ndftfg.eq.1.and.maswrk) then
              fda=idam+idad+idat
              call daxpy(nedft,fda,edft,1,etotdft,1)
            endif
C
C           COLLECT POTENTIALS FOR FMO/PCM<1> GRADIENT
C
            IF (DOPROP.AND.NDER.GT.0.AND.RUNTYP.NE.ENERGY.AND.
     *          ISWNEW1.EQ.1) THEN
              IDAPCM1 = IDAM
              IF (NBODY.GT.1) IDAPCM1 = IDAM+IDAD
              IF (NBODY.GT.2) IDAPCM1 = IDAM+IDAD+IDAT
              IF (ILOOP.EQ.0) IDAPCM1 = IDAPCM1 - 1
              FDA = -IDAPCM1
              IF (IDAPCM1.NE.0.AND.ilay.eq.nlayer) then
c               write(6,*) "wrap potential=",IDAPCM1
                CALL WRAPEPOT(0,FDA,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),
     *                        DA,DB,NTS,L2,mappcm)
              end if
              IF (MPLEVL.EQ.2.AND.ILOOP.EQ.0) THEN
                IDAPCM1 =  IDAPCM1 + 1
                FDA     = -IDAPCM1
                IF (IDAPCM1.NE.0)
     *          CALL WRAPEPOT(1,FDA,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),
     *                        DA,DB,NTS,L2,mappcm)
              END IF
            END IF
C
C
C           HOP CONTRIBUTION TO GRADIENT
C
c           if (hopgrd.and.doprop.and.iloop.eq.0) then
            if (hopgrd.and.doprop) then
              CALL HOPDER(0,IDAM,IDAM+IDAD,IDAM+IDAD+IDAT,L1,L2,
     *                    DA,DA(L2+1),DB(L2+1),FMOFCM)
            end if
C
c           Collect the contributions to U^a bar and MP2 LAG
c
            IF (DOPROP.AND.RUNTYP.NE.ENERGY.AND.NDER.GT.0
     *        .AND.IAND(MODGRD,32).NE.0.and.layfrg(ifg).eq.nlayer) THEN
C             if(.not.uhfcal) then
                IDMP2 = IDAM
                IF (NBODY.GT.1) IDMP2 = IDAM + IDAD
                IF (NBODY.GT.2) IDMP2 = IDAM + IDAD + IDAT
c               IF (IDMP2.eq.1.5D+00) THEN
                IF (IDMP2.NE.0) THEN
                  IF (ILOOP.EQ.0.AND.MPLEVL.EQ.2.and..not.uhfcal) THEN
                    ! monomer Lag (ZVWRK) is obtained in MP2 gradient code
                    NOCC  = NA
                    NVIR  = NQMT - NOCC
                    NOCVR = NOCC*NVIR
                    if(iefmorun .gt. 0 .and. iefmo_agrad.gt.0) then
                       CALL GETMP2MLAG(IDMP2,NOCC,NVIR,efmo_scphf,
     *                      DB(L2+1))
                       call vclr( efmo_scphf, 1, nocvr )
                    else
c                   CALL PRSQ(ZVWRK,NOCC,NVIR,NVIR)
                       CALL GETMP2MLAG(IDMP2,NOCC,NVIR,ZVWRK,DB(L2+1))
                    endif
                    IF (DODISTR) THEN
                      CALL ZLAGACCGET(0,IFG,IPTLG,NOCVR,DB(L2+1))
                    ELSE
                      IF (MASWRK)  CALL DAXPY(NOCVR,ONE,DB(L2+1),
     *                   1,ZVLAG(IPTLG(IFG)),1)
                    END IF
                  END IF
c               IF (IAND(MODGRD,42).EQ.42.and..not.(resppc(1).eq.-1.and.
c    *                                                resdim.eq.0)) THEN
czcz              Takeshi changed the following IF as commented out above.
c                 It probably saves time because Ubar is zero? (Dmitri)   
                  IF (IAND(MODGRD,42).EQ.42.AND..NOT.DFTBFL) THEN
                    if (NLOOP.gt.0) then
                      if(scffrg(ifg).ne.uhf) then
                         lnum = l1*l1
                      else if(scffrg(ifg).eq.uhf) then
                         lnum = l1*l1*2
                      end if
                      CALL rareads(IDAFMO,IODFMO,DA(L2+1),lnum,
     *                     irec0old+ifg, 0)
C                     call prsq(da(l2+1),l1,l1,l1)
                    else
                      CALL DAREAD(IDAF,IODA,DA(L2+1),L3,15,0)
                      if(scffrg(ifg).eq.uhf) then
                        CALL DAREAD(IDAF,IODA,DA(L2+1+l3),L3,19,0)
                      end if
                    end if
                    call getcnt2ubar(-IDMP2,L1,L3,IFG,IPTLG,NQMTFG,
     *              DA(L2+1),FMOESPA,DB(L2+1),ZVLAG,scffrg(ifg).eq.uhf,
     *              scffrg(ifg).eq.rohf)
                  END IF
                ENDIF
c             ENDIF
            ENDIF
c
            if(DOPROP.and.RUNFMO.NE.ENERGY.and.nder.eq.2) then
              NOCC  = NA
              NVIR  = NQMT - NOCC
              NOCVR = NOCC*NVIR
              IF(scffrg(ifg).eq.uhf.or.scffrg(ifg).eq.rohf) then
                NOCCB = NB
                NVIRB = NQMT  - NOCCB
                NOCVRB= NOCCB * NVIRB
                NOCVR = NOCVR + NOCVRB
              end if
c             write(*,*) "fmo hessian save YA"
c             write(*,*) "I J CURFG",ifg
c             write(*,'(5f12.8)') (YAWRK(i),i=1,50)
c             CALL DAXPY(NOCVR*nat*3,ONE,YAWRK,
c    *            1,YALAG(IPTYA(IFG)),1)
              call dcopy(NOCVR*nat*3,YAWRK,1,YALAG(IPTYA(IFG)),1)
            end if
c
c           accumulate gradient
c
c           Gradient is run as an extra iteration after SCC converges,
c           therefore, one has nconv.
c           It is now possible that NDER>0 but the current RUNTYP is ENERGY.
c           if(doprop.and.nder.gt.0.and.maswrk) then
           if(doprop.and.nder.gt.0.and.runtyp.ne.energy.and.maswrk) then
              call fmodeg(idam,fmode,fmopg,iaglob)
              if(nbody.gt.1) call fmodeg(idam+idad,fmode(1,1,2),fmopg,
     *                                   iaglob)
              if(nbody.gt.2) call fmodeg(idam+idad+idat,fmode(1,1,3),
     *                                   fmopg,iaglob)
              if(nbody.eq.2.and.ext2lay)
     *          call fmodeg(idam+idad,fmode(1,1,3),fmopg,iaglob)
              IF (IEFPFMO.NE.0) THEN
                CALL EFPDEG(idam,1)
                if(nbody.gt.1) CALL EFPDEG(idam+idad,2)
                if(nbody.gt.2) CALL EFPDEG(idam+idad+idat,3)
              ENDIF
            endif
C
C           RESET EFMO RUNTYPE TO 1
            IF( IEFMORUN.GT.0 ) IEFMORT = 1
C
C           Hessian contribution
C
            if(doprop.and.nder.eq.2.and.runtyp.ne.energy) then
              IF(modfd.eq.0.or.
     *          (ilay.eq.nlayer.and.iactfg(ifg).ne.0)) THEN
               IEEH = IDAM
               IF (NBODY.GT.1) IEEH = IDAM + IDAD
               IF (NBODY.GT.2) IEEH = IDAM + IDAD + IDAT
               nc2 = max(nc1,nat*3)
C              call vclr(fcmwrk,1,nc1*nc1)  
               NST = 1
               IF (DFTBFL) NST = NC2*NC2+1+NAT
               CALL FMODEH(IEEH,FCMWRK(NST),fmoddm,FMOFCM,FMOPG,IAGLOB,
     *                      nc1,indat,layfrg,FCMWRK(NC2*NC2+1),-1)
              END IF
            END IF
C
C           THE CORRECTION TO ANALYTIC FMO-MP2 GRADIENT
C
            IF (DOPROP.AND.NDER.GT.0.AND.RUNTYP.NE.ENERGY.AND.
     *        IAND(MODGRD,32).NE.0.and.MPLEVL.EQ.2.AND.ILOOP.EQ.0
     *           .and. iefmorun .le. 0 ) THEN
czcz       Takeshi changed the above line into the following.
c    *        IAND(MODGRD, 2).NE.0.and.MPLEVL.EQ.2.AND.ILOOP.EQ.0) THEN
c             This possibly improves the accuracy of the approximate MP2 gradient?!
C
C             FOR ANALYTIC MP2 ENERGY GRADIENT
C
              IDMP2 = 0
              ID2B  = 0
              ID3B  = 0
              IF     (NBODY.EQ.2) THEN
                ID2B  = IDAM+IDAD
                IDMP2 = ID2B
              ELSEIF (NBODY.EQ.3) THEN
                ID3B  = IDAM+IDAD+IDAT
                IDMP2 = ID3B
              END IF
              IF (IDMP2.NE.0) THEN
                CALL FMOESDER(L1,L2,DA,LAYFRG,SCFFRG,IDMREC0,DA,DB,
     *                        mdum,mdum,mdum, 1,irec0old, ID2B,ID3B,
     *                       .false.,.false.,.false.,.false.,.false.,
     *                        ZVLAG,IPTLG,NQMTFG,loadhf,clm,flm,f_mm,
     *                        g_mm,crfrg,Ylmfrgq,Ylmfrgq2)
              END IF
            ENDIF
C
C           IF (DOPROP.AND.RUNTYP.NE.ENERGY.AND.LPOPDFLG.
C    *          and.iloop.eq.0) THEN
C             CALL MULPOPDA(DA,L1,L2,L3,POPDMAT(1,1,1,ifg))
C           ENDIF
C
            IF (IEFPFMO.NE.0.AND.NDER.GT.0) CALL DEFPCLR
            if(iloop.gt.0) then
c             mplevl=2
              mplevl=mp2sav
              cityp=cisav
              tddftyp=tdsav
c             This will not work for TDDFT gradient: need to use iexcit
              irest=5
              delescf=dele
            endif
          enddo
c         possibly dump PLTORB data for the selected fragment
          if(conv.and.npunch.ne.0.and.PLTORB) CALL PLTMEM
          npunch=npusav
          nprint=nprsav
          mplevl=mp2sav
          cityp=cisav
          tddftyp=tdsav
          irest=0
          if(maswrk.and.mdoutmin) then
            if(doprop) then
c             if(correl.and..not.dopleda) then
              if(correl.or.dodc) then
                write(6,9217) jter,ifg,emon(ifg,1),emon(ifg,2)
              else
                write(6,9215) jter,ifg,emon(ifg,1)
              endif
            else
              write(6,9210) jter,ifg,emon(ifg,1),denmax,ediff
            endif
          endif
c
c         Avoid energy double counting due to secret group switching
c         Zero out the first (MCSCF) energy on slaves
          if(lbmcscf.and.iifg.eq.1.and..not.maswrk) then
            emon(ifg,memon)=zero
            nconv=nconv0
          endif
c
c           Replace polarised monomer energies with FMO0 ones.
c           This is needed to compute dimer corrections.
c           Note that we print polarised energies as EFMOc.
c
            if(dopleda) then
c             subtract environmental potential on monomer IFG due to the rest of
c             monomers. Thus emon(ifg,) contains free monomer energies
c             (unperturbed by the env.), but with the environment subracted,
c             so that dimer corrections (E'IJ-E'I-E'J) could be estimated
c             (using E'I computed here).
              if(maswrk) then
              if(correl) then
                epl0ds(ifg,3)=emon(ifg,1)-emon(ifg,2)-
     *                        (efmo0(ifg,1)-efmo0(ifg,2))
                emon(ifg,3)=efmo0(ifg,2)+(emon(ifg,1)-emon(ifg,2))
                emon(ifg,4)=efmo0(ifg,2)
c               set correlated energy to E(FMO0,SCF)+Ecorr(PL0,MP2)
c               set uncorrelated energy to E(FMO0,SCF)
c               This is done because in FMOPROP one subtracts E(FMO0,SCF)
c               and Ecorr(PL0,MP2) from EIJ(PL0,MP2) to get energy
c               components.
              else
                emon(ifg,3)=efmo0(ifg,1)
c               set uncorrelated energy to E(FMO0,SCF)
              endif
              endif
c             if(correl) emon(ifg,2)=efmo0(ifg,2)
c             The SCF value of efmo0(ifg,*) must be equal to e0scf(1)
c             (the former is given in the input, the latter comes from SCF).
c             memon is 1 (for PL0 runs).
              memonp=1
              if(correl) memonp=2
              if(abs(efmo0(ifg,memonp)-e0scf(1)).gt.1.0D-06) then
                if(maswrk) write(6,*) 'Mismatch in E0',ifg,e0scf(1),
     *                                efmo0(ifg,memonp)
c               call abrt
              endif
c             write(6,*) 'wwwE0',emon(ifg,1),emon(ifg,2)
            endif
c
c         restore icut for "poorly" converging fragments
c
          icut=icutifg
c
  230   continue
        if(mdoutmin) call timit(1)
        call stopwa(13,0)
        CALL TSECND(TIMe0)
        wall0=wall
        if(isgddi0) call GDDICOUNT( 1,lgroup,myjob)
        CALL TSECND(TIMe1)
        call stopwa(13,1)
        if(maswrk.and.mdoutmin) 
     *    write(iw,9600) ' Monomer',jter,ilay,wall-wall0
c
c     use the latest monomer density in the dimer ESP.
c
        if(.not.dopleda) idmrec0(ilay)=irec0new
c       idmrec0(ilay)=irec0new
cpbc
c     restore the original atomic coordinates
c---    if(dopbcmd) call genfrgmic(0,1)
        if(dopbcmd) call genimagefg(1,0)
c       if(dopbcmd) then
c       call makeindexiu(ilay,loadhf,loadm,indat,fmozan,
c    *                   fmoc,iabdfg,jabdfg,scffrg,
c    *                   needr0,rij,rwrk,mfg2,vdwrad,
c    *                   nprfrg,isgddi0,nunptc,natfmob,untxyz,
c    *                   units,indxiu,.false.)
c       endif
c
        if(nfglay.ne.0) then
          if(isgddi0) then
c
c           echange density matrices
c
            nfge=nfg*2
c           if(nconv.eq.nfglay.and.gcorrel) nfge=nfg*2
c           Note that nfge is not nfglay but nfg. It is a waste of time
c           but it is required to extract data properly.
            if(maswrk) glocon(mygroup)=gediff
c
c           write(6,*) 'irec0new',irec0new
            call dmexch(ilay,nfge,jobgrp,layfrg,numfrg,natfrg,scffrg,
     *                  idafmo,iodfmo,maxl30,emon,ewrk,glocon,nconv,
     *                 irec0new,dosap,dospc,orbxch,enexch,atonce,dodistr
     *                 ,mastid,popmul(1,1,inxtpop),popmat(1,1,inxtpop),
     *                  ifgbuf,nfgbuf,.false.,modcnv,mdoutmin)
c           write(6,*) 'wwwe',(ewrk(i),i=1,nfg)
            gediff=glocon(idamax(mgroups,glocon,1)-1)
c           idamax thinks that the array starts from 1, not from 0.
c           For DDI gediff is set above and needs not be exchanged between
c           groups.
          endif
c
c         save record indexing for restarts
c
          iodfmo(NDAR30a+3)=ilay
          iodfmo(NDAR30a+4)=iter+1
          iodfmo(NDAR30a+5)=JRECST(IDAFMO/10)
          iodfmo(NDAR30a+6)=nts2
c         iter+1 means in the restart the first iteration will be iter+1
c         and densities from iter will be used.
          call icopy(nlayer,idmrec0,1,iodfmo(NDAR30a+7),1)
c         if(icanuse1)
          call rawrites(IDAFMO,iodfmo,iodfmo,NDAR30fa,NDAR30fa,1,0)
        endif
        if(dovac.or.ilay.gt.1.and.nopden.gt.0) nconv=nfglay
c       Copy charges
        if(iand(modcha,4).ne.0) then
          do ifg=2,nfg
            call dcopy(natfrg(ifg),popmat(1,1,inxtpop),1,
     *                             popmat(1,ifg,inxtpop),1)
          enddo
        endif
        ishift=1
        do ifg=1,nfg
          if(iand(nprfrg(ifg),64).ne.0) call dcopy(natfrg(ifg),
     *                         atchrg(ishift),1,popmat(1,ifg,inxtpop),1)
          ishift=ishift+natfrg(ifg)
        enddo
        if(doclmo1) then
          if(isgddi0) call gddi_scope(ddi_world)
          call ddi_gsumf(2415,atclmo,natfmo)
          if(isgddi0) call gddi_scope(ddi_group)
        endif
c
c     Do correlation if needed at the N+1 iteration (after SCF converges in
c     N iterations.
c
        conv=nconv.eq.nfglay.and.espscf.eq.one.and.
     *       (coroff.eq.0.or.NDFTFG.eq.ndftsav).and.npcmsav.eq.nfmopcm
        conv2=conv
C
C       FOR VARIATIONAL FMO
C
        IF (IAND(MODESP,512).NE.0.AND.DOSPC) THEN
          IF (ISGDDI0) CALL GDDI_SCOPE(DDI_WORLD)
          CALL DDI_GSUMF(2419,VIPOT(1,1,INXTPOP),MAXNAT*NFG)
          IF (ISGDDI0) CALL GDDI_SCOPE(DDI_GROUP)
        END IF
C
        if(dofddpcm.and.
     *   ((ilay.eq.2.and.nextra.eq.nextra0).or.
     *    (nextra.ne.nextra0.and.ilay.eq.1))) then
C
c         write(6,*) "www for the ASC in B"
C
          if(isgddi0) call gddi_scope(ddi_world)
          call ddi_gsumf(2418,PEL,NTS)
          call ddi_gsumf(2418,VNUC,NTS)
C
c         if(ilay.eq.1) modetmp=1
c         if(ilay.eq.2) modetmp=2
c         IF(isgddi0.and.IBTYP.EQ.1) CALL DDI_DLBRESET
          call mltfmopcm(ilay,lfmasc,needasc,needmul,mappcm,idum)
C
          if(isgddi0) call gddi_scope(ddi_group)
        else if((nfmopcm.eq.1.or.nfmopcm.gt.1.and.iterpcm.eq.1).and.
     *    (.not.conv.or.nextra.eq.1).and.
     *    (nlayer.eq.1.or.dofddpcm.or.ilay.eq.1.and.iterpcm.eq.1)) then
          if(isgddi0) call gddi_scope(ddi_world)
c         Do not recalculate charges if converged, because it would lead to
c         monomers and dimers having different charges. Only recalculate if
c         monomers are not converged!
c         Summing should be done in the world scope, since each node has a
c         dyo lepta contribution.
          call ddi_gsumf(2418,PEL,NTS)
          call ddi_gsumf(2418,VNUC,NTS)
          iterasc=jter
c         Do not start over from the ASC initial guess for higher layers
c         or consequent PCM iterations.
          if(ilay.gt.1.or.iterpcm.gt.1) iterasc=2
          if(pcmoff.ne.0.and.ipcmoff1.ne.ipcmoff) iterasc=1
          call calcasc(iterasc,NTSPAR,ichfmo,nefmo,lfmasc,needasc,idum1,
     *               nesolv,idum2,idum3,idum4,idum5,qini,ihaveq0,nprfmo)
          if(isgddi0) call gddi_scope(ddi_group)
        endif
        if(nfrgmul.gt.0) then
          if(isgddi0) call gddi_scope(ddi_world)
          call ddi_gsumf(2418,frgmul(1,1,inxtpop),nfrgmul*natfmob)
          if(isgddi0) call gddi_scope(ddi_group)
        endif
C
C       new FMO/EFP
C
        IF (IEFPFMO.EQ.2.AND.IEFP.EQ.1) THEN
          if(isgddi0) then
            call gddi_scope(ddi_world)
            CALL EFPPARL
          end if
          CALL MONOTPOL(XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3))
          if(isgddi0) then
            call gddi_scope(ddi_group)
            CALL EFPPARL
          end if
        END IF
C
C     SUM UP LOCFMO FOR FMO-DFTB, BECAUSE IT HAS NOT BEEN DONE YET
C     IN INITIAL GUESS LOOP
C
        if (dftbfl.and.jter.eq.1.and.nbdfg.ne.0) then
          parhop=iand(modpar,16).eq.0.and.goparr
          if(parhop) call ddi_gsumi(2417,locfmo,2*2*nbdfg)
          if(isgddi0) then
            if (.not.maswrk) call viclr(locfmo,1,2*2*nbdfg)
            call gddi_scope(ddi_world)
            call ddi_gsumi(2418,locfmo,2*2*nbdfg)
            call gddi_scope(ddi_group)
          end if
        end if
c
        if(maswrk.and.nextra.eq.nextra0) then
          if(mdoutmin) then
            write(iw,9105) jter,ilay,nconv,gdenmax,gediff
          else
            write(iw,9106) jter,ilay,nconv,gdenmax,gediff
          endif
        endif
c
        NDFTFG=ndftsav
        dftype=dftsav
        DFTTYP(3)=hfssav
        LCFLAG=lcsav
        CAMFLAG=CAMsav
        if(conv) then
           if(correl) then
             mplevl=mplevli
             cctyp=cctypi
             cityp=citypi
             tddftyp=tddfti
           endif
           RUNFMO=runtyp
           if(maswrk.and.nextra.ne.0.and.mdoutmin) write(iw,9250)
c          switch groups if needed.
           if(nextra.ne.0.and.isgddi0.and.ngrfmo(4,ilay).ne.0)
     *       call fmopre(ilay,4,ngrfmo,mannod,mastid,irmdfmo)
           nextra=nextra-1
           iemom=iemoms
        endif
        icurpop=inxtpop
        iter=iter+1
        jter=jter+1
        CALL TSECND(TYME)
        IF(TYME.GT.TIMLIM) THEN
          IF(MASWRK) WRITE(IW,9500)
          ntimout=1
        ENDIF
        if(jter.gt.mxitfg.and..not.conv) then
          IF(MASWRK) WRITE(IW,9510)
          nextra=-1
          ntimout=2
          conv=.true.
          iter=iter+1
          jter=jter+1
        ENDIF
      if((.not.conv.or.nextra.ge.0).and.TYME.le.TIMLIM) goto 200
c     if(conv) iter=iter-1-nextra0
      if(conv) iter=iter-1
      if(nfglay.eq.0) iter=0
c     liter(ilay)=iter
      liter(ilay)=jter-1
      if(ilay.gt.1.and.nopden.gt.0) liter(ilay)=1
c     Now add the contribution from this later.
c     Note that for one layer runs atmulqi/atmulq are
c     equivalent by call so that there is no need to copy.
      if(primul) call daxpy(natfmo*nbody,one,atmulqi,1,atmulq,1)
c     fmoelm(1,nfg+3) contains the sum of contribution due to this layer
cnb   at present 3-body properties will not work with layers
c     (to fix, save 2-body and 1-body sums with trimer factors)
c     add them to the total
c     add sums of 1 body terms for 2 and 3 body.
      if(nfmoelm.ne.0)
     *  call daxpy(nfmoelm*2,one,fmoelm(1,nfg+3),1,fmoelm(1,nfg+1),1)
c
c       get internal energies of monomers
      if(nfmopcm.ne.0) then
        call dcopy(nfg,esolv,1,wrk1,1)
        if(isgddi0) call gddi_scope(ddi_world)
        call ddi_gsumf(2415,wrk1,nfg)
        if(isgddi0) call gddi_scope(ddi_group)
c       this is quite silly but has to be done because esolv is scattered.
        do ifg=1,nfg
          if(layfrg(ifg).ge.ilay) then
            emon(ifg,1)=emon(ifg,1)-wrk1(ifg)
            if(gcorrel.or.dodc) emon(ifg,2)=emon(ifg,2)-wrk1(ifg)
c           write(6,*) 'wwwwe',gcorrel,ifg,emon(ifg,1), emon(ifg,2)
            esolv(ifg)=wrk1(ifg)
c           Sync esolv for the layer which is being done.
          endif
        enddo
      endif
c     write(6,*) 'wwwesolv',(esolv(ifg),ifg=1,nfg)
c
      if(rflmo(1).ne.0.and.maswrk) write(iw,9520) nitafo,timeafo
      if(dovac.or.ilay.gt.1.and.nopden.gt.0) iter=iter0
c     if(mdoutmin) then
      if(nfglay.eq.0) then
        if(maswrk) write(iw,9240)
      else
        if(nconv.eq.nfglay.and.maswrk) write(iw,9220) ilay,iter-iter0+1
        if(nconv.ne.nfglay.and.maswrk) write(iw,9230) ilay,iter-iter0+1
      endif
c     endif
      if(dopleda) liter(ilay)=min(iter,mxitfg)
      if(desperate) then
        if(isgddi0) then
          call gddi_scope(ddi_world)
          idum=0
          call DDI_nsumi(2423,ndesper,nodesper,idum,idum,2)
          call gddi_scope(ddi_group)
        endif
c       Statistics printed here is for the last iteration. It is permitted for
c       some fragments not to converge sometime before the final iteration.
        if(maswrk) write(iw,9320) ndesper,nodesper
c       if(nodesper.ne.0) call abrt
      endif
      if(dopleda.and.isgddi0) then
        call gddi_scope(ddi_world)
        call ddi_gsumf(2415,emon(1,3),nfg*2)
        call gddi_scope(ddi_group)
      endif
      if(dolat.and.nbody.gt.1) then
        call gddi_scope(ddi_world)
        call ddi_gsumf(2415,esplat,n2fmo*nsymop)
        call gddi_scope(ddi_group)
      endif
c     IF (LPOPDFLG) THEN
c       IF (ISGDDI0) THEN
c         CALL GDDI_SCOPE(DDI_WORLD)
c         CALL DDI_GSUMF(2415,POPDMAT,3*MAXNAT*MAXNAT*NFG)
c         CALL GDDI_SCOPE(DDI_GROUP)
c       ELSEIF (GOPARR) THEN
c         CALL DDI_GSUMF(2415,POPDMAT,3*MAXNAT*MAXNAT*NFG)
c       ENDIF
c     ENDIF
C
      IF (NDER.GT.0.AND.IEFPFMO.EQ.2) THEN
        if(isgddi0) then
          call gddi_scope(ddi_world)
          CALL EFPPARL
        end if
        CALL DNEWIND(DINDF2,DINDDF2)
        if(isgddi0) then
          call gddi_scope(ddi_group)
          CALL EFPPARL
        end if
      END IF
C
c     IF (GOPARR.and.nfmoelm.ne.0)
c    *  CALL DDI_BCAST(2421,'F',fmoelm,nfmoelm*(nfg+1),MASTER)
c     GAMESS does not seem to have SCF properties on slaves.
c     Broadcast is needed only if ngrfmo(2) and ngrfmo(1) divides the groups
c     unevenly in such a way that a master can become a slave after
c     switching when doing dimers. Should we do it only when needed?
c     Note that broadcasts are redundant for layers (only one is needed but
c     currently it is done nlayer times.
c
      NRAD0=NRADs
      NPHI0=NPHIs
      NTHE0=NTHEs
      swoff=swoffs
      swdiis=swdiisv
      coroff=coroffs
c
      if(modfd.eq.0.or.ilay.gt.1) then
        e1efmo=e1efmo+e1efmoi
        ekinfmo=ekinfmo+ekinfmoi
      endif
c
      IF (ISGDDI0.and.urospn) THEN
          IF(GOPARR) call dscal(natfmo,ONE/nproc,pmulspin,1)
          CALL GDDI_SCOPE(DDI_WORLD)
          CALL DDI_GSUMF(3000,pmulspin,natfmo)
          CALL GDDI_SCOPE(DDI_GROUP)
      END IF
c     IF (ISGDDI0.and.nder.eq.2) THEN
      IF (ISGDDI0.and.(nder.eq.2.or.dofddpcm.and.ilay.eq.1)) THEN
c         CALL GDDI_SCOPE(DDI_GROUP)
          IF(GOPARR) call dscal(IPTYA(NFG+1),ONE/nproc,YALAG,1)
          CALL GDDI_SCOPE(DDI_WORLD)
          CALL DDI_GSUMF(3000,YALAG,IPTYA(NFG+1))
          CALL GDDI_SCOPE(DDI_GROUP)
c         call vclr(YALAG,1,IPTYA(NFG+1))
      END IF
C
c     SAVE FMO1-TDDFT RESULTS
C
      IF (ISGDDI0.and.tddfti.ne.rnone.and.iexcit(1).lt.0) THEN
c         CALL GDDI_SCOPE(DDI_GROUP)
c         write(6,*) "gather vector"
          IF(GOPARR) call dscal(IPTLG(NFG+1),ONE/nproc,ZVLAG,1)
          CALL GDDI_SCOPE(DDI_WORLD)
          CALL DDI_GSUMF(3000,ZVLAG,IPTLG(NFG+1))
          CALL GDDI_SCOPE(DDI_GROUP)
      END IF
c
      if (tddfti.ne.rnone.or.cityp.ne.rnone) then
        if(isgddi) then
          call gddi_scope(ddi_world)
          idum=0
          call DDI_nsumi(2423,nstmono,nvirtdm,nvirtdb,idum,3)
          call DDI_gsumi(2423,nread,1)
          call DDI_gsumi(2423,monoc1,1)
          call DDI_gsumi(2423,monvr1,1)
          call DDI_gsumi(2423,monoc2,1)
          call DDI_gsumi(2423,monvr2,1)
          call DDI_gsumi(2423,monoc,mxrt)
          call DDI_gsumi(2423,monvr,mxrt)
          call DDI_gsumf(2423,eexcit,mxrt)
          call DDI_gsumf(2423,texcit,3*mxrt)
          if(iexcit(2).eq.2)
     *      call DDI_gsumf(2423,CTDM,nread)
          if(dofret) then
            call DDI_gsumf(2423,excit2,nfg*NSTAT)
            call DDI_gsumf(2423,texcit2,3*nfg*NSTAT)
          end if
          call gddi_scope(ddi_group)
        endif
      endif
      correl=corsav
c
c     Use RHF, not MP2 Mulliken populations and charges.
c
c     if(doddcor.and..not.doscfprp) icurpop=3-icurpop
      if(doddcor.and..not.doscfprp.or.iand(modlmo,8192).ne.0.or.
     *   iand(modlmo,16384).ne.0.)
     *   icurpop=3-icurpop
c
c     if(dopleda) icurpop=1
      if(ilay.gt.1.and.nopden.gt.0) icurpop=icurpops
c     Use layer 1 charges for dimers
      idoprop=1
      if(mdoutmin) call timit(1)
c
      return
 9105 format(//1x,78(1H-),/1x,'FMO iter',I3,'.',I1,',',I7,
     *       ' fragment(s) converged, maxD',F12.9,' maxE',
     *       F12.9,/1x,78(1H-))
 9106 format(1x,'FMO iter',I3,'.',I1,',',I7,
     *       ' fragment(s) converged, maxD',F12.9,' maxE',
     *       F12.9)
 9120 format(/1x,'Warning: ESPs for all fragments are scaled by the ',
     *           'factor',F9.6)
 9200 format(/1x,A8,' monomer',I7,' corr= ',A11,', L1=',I6,', L0=',I6,
     *              ' ID=',I7/)
 9203 format(1x,'Using tighter ICUT=',I2)
 9205 format(/1x,'Resetting LABSIZ=',2I2,/)
 9207 format(1x,'Int dimensions: LABSIZ=',I1,', NINTIC=',I9,
     *          ' ININTIC=',I9)
 9210 format(/1x,'Iter=',I3,' iFrag=',I7,' EFMO=',F16.9,
     *       ', DD=',F12.9,', DE=',F12.9/)
 9215 format(/1x,'Iter=',I3,' iFrag=',I7,' EFMOu=',F16.9)
 9217 format(/1x,'Iter=',I3,' iFrag=',I7,' EFMOc=',F16.9,' EFMOu=',
     *           F16.9)
 9220 format(/1x,12(1H-),'Monomer SCF for layer',I2,' converged in',I3,
     *       ' iterations!',12(1H-))
 9230 format(/1x,9(1H-),'Monomer SCF for layer',I2,' did not converge',
     *                   ' in',I3,' iterations!',9(1H-))
 9240 format(/1x,9(1H-),'No monomers in this layer! ',
     *                   'Is this what you intended?',9(1H-))
 9250 format(/1x,'-Monomer SCF converging: one extra iteration ',
     *                   'to do correlation or properties.-')
 9300 format(/1x,'Trying desperately the alternative SCF converger.')
 9310 format(/1x,'Despite trying desperately, SCF did not converge.')
 9320 format(/1x,'Desperately converged',I7,', diverged',I7,' monomers.'
     *          ,/)
 9400 format(/1x,'Gradient requires converged SCF.',/)
 9500 format(/1x,'Running out of time...',/)
 9510 format(/1x,'Two many iterations: monomer SCF is not converged.')
 9520 format(/1x,I4,' AFO iteration(s) took',F8.1,' s.')
 9600 format(/1x,A8,' SCF synchronisation on iteration',I4,'.',I1,
     *              ' took',F8.1,' s.')
      END
C*MODULE fmo     *DECK edimer
C>
C>    @brief FMO dimers
C>
C>    @details Perform FMO dimer calculations.
C>
C>    @author Dmitri Fedorov
C>
C>    @date 10/5/12 - SRP
C>     - Added dispersion, charge transfer, repulsion and charge
C>       penetration energy to total FMO energy.
C>
C>    @date May, 2014 - Colleen Bertoni
C>     - Modified so that EFMO runs store EFP interaction energy
C>       for each separated dimer in the edim array
C>    @date January, 2017 - C.Bertoni
C>     - Changes for EFMO gradient
C>
      subroutine edimer(ilay,nder,runtyp,loadhf,jobgrp,loadm,loadd,
     *                 mulfg,layfrg,numfrg,cfrg,iodfmo,maxl30,indat,fmoc
     *                 ,iaglob,idmrec0,haver,da,db,wrk,wrk1,dij,zsave,
     *                  fmoespa,fmoespb,emon,edim,fmode,fmopg,enucfmo,
     *                  e1efmo,ekinfmo,atmulq,nfmoelm,fmoelmd,fmoelmt,
     *                  nddfrg,ndtfrg,iabdfg,jabdfg,locfmo,molfrg,scffrg
     *                 ,mapi,mapj,mcnvfmo,mconvex,mconfg,ijvec,correl,
     *                  scftypi,mplevli,CITYPi,CCTYPi,tddfti,nfg2d,nfg2,
     *                  nen,nactfmo,ncasfmo,primul,orbxch,enexch,ntimout
     *                 ,nscf,nemc,docas,nedimes,nedimex,job2grp,needdm,
     *                  ngrfmo,mannod,mastid,nprfrg,isdrec,nfthes,
     *                  ngrdsiz,nelmsiz,nesdsiz,fmoelm,ndar30,NDAR30f,
     *                  savgrd,modmol,exclmol,totdens,totfock,totd,
     *                  iaoglob,densgrid,nxyzg,dgrid,loadgr,nstjob,l1dir
     *                 ,grdpad,vdwrad,spargrid,noffg,indgrd,extracc,
     *                  nextracc,irec0,irec0cor,doddcor,esolv,dovpcm,
     *                  etotdft,nedft,XYZCTS,PEL,VNUC,QSE,ISPHE,qtmp,
     *                  imect,ctdim,popmat,ialoc,indbd,ext2lay,fmoq,
     *                  IDAcFMO,iodcfmo,dopleda,dolat,nunint,nunptc,
     *                  natfmob,untxyz,untrot,esp1i,esp1j,czi,czj,nsymeq
     *                 ,maxl2,n2fmo,klms,esplat,addesp,addesp0,stonep,
     *                  iexcit,eexcit,texcit,monoc,monvr,nstmono,
     *                  isumd,eexfg,nocctdm,nvirtdm,nocctdb,nvirtdb,ctdm
     *               ,exfid,dopdc,modcha,iwhere,gcorrel,skipesd,dodistr,
     *                  fmoddm,FMOFCM,FCMWRK,ABFLDT,DINDF2,DINDDF2,
     *                  ZVLAG,IPTLG,NQMTFG,ZVWRK,hopgrd,dodc,
     *                  dodimden,iddpnt,nevsav,potat,fmohard,efmodimg,
     *                  iactfg,emon1,outpune,enucfg,clm,flm,f_mm,g_mm,
     *                  crfrg,ylmfrg,ylmfrgq,ylmfrgq2,frgnam,iefmoiglob,
     *                  VIPOT,outesd,fullmfmo3,edimlow,ALCNT2F,YALAG,
     *                  IPTYA,YAWRK,NC1,dodcesd,nsetgrid,Xlfmobuf1, 
     *                  dopbcmd,fmozan,needr0,rwrk,mfg2,units,indxiu,
     *                  rrij,ESDIMTMP,reducee,mdout,mdoutmin,griddistr,
     *                  urospn,pmulspin,spinden,lfmasc,needasc,needmul,
     *                  mappcm,savemem2,savememr,edimsum,nrij,icanuse1,
     *                  irmdfmo,qmcout,nftqmc,dofret,some)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(MXATM=2000,MXSH=5000,MXGTOT=20000,MXRT=100,MXGRID=10,
     *         maxpst=10,MaxNp=45,zero=0.0D+00,one=1.0D+00,half=0.5D+00)
      logical myjob,isgddi,parout,INITGDDI,GOPARR,DSKWRK,MASWRK,DIRSCF,
     *        FDIFF,AIMPAC,RPAC,PLTORB,MOLPLT,DGRIDPROG,
     *        orbxch,enexch,esd,primul,
     *        iodexch,jodexch,fmodscf,fmodtrf,prerhf,lie,correl,haver,
     *        usedij,sepdim,needdm,desperate,despread,doddcor,doddcori,
     *        docas,lbmcscf,savgrd,copycore,totdens,totfock,
     *        densgrid,clrcow,forcedir,fordir,spargrid,tightint,skipc,
     *        exclmol,flipsd,dovpcm,ext2lay,fmoq,dopleda,dolat,addesp,
     *        addesp0,addespij,lcflag,lcsav,gopsav,dopdc,urohfi,
     *        urohfj,some,SG1,gcorrel,skipesd,dodistr,hopgrd,DOEFPIEA,
     *        dodc,dodimden,mixdim,outpune,QOPS,QFMM,CAMFLAG,CAMsav,
     *        outesd,wasgddi,fullmfmo3,lowdimer,excstat,uhfcal,mlgddi,
     *        efmosepcalc,dodcesd,dopbcmd,reducee,mdout,mdoutmin,
     *        griddistr,urospn,spinden,savemem2,savememr,icanuse1,qmcout
     *       ,dofret
CFTNC Removed LRINT
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB,ESDFL,ESDREP
      character*11 wfnstri
      character*8 dimdek,end
      character*1 flipch
      integer ddi_world,ddi_group
      Parameter(ddi_world=0,ddi_group=1)
      dimension jobgrp(*),loadm(*),loadd(*),mulfg(*),layfrg(*),numfrg(*)
     *         ,cfrg(3,*),iodfmo(*),maxl30(*),indat(*),fmoc(3,*),
     *          iaglob(*),idmrec0(*),da(*),db(*),wrk(*),wrk1(*),dij(*),
     *          zsave(*),fmoespa(*),fmoespb(*),emon(nfg,2),edim(nfg2d,*)
     *         ,fmode(3,natfmo,*),fmopg(3,*),atmulq(*),fmoelmd(nfmoelm),
     *          fmoelmt(nfmoelm,2),nddfrg(*),ndtfrg(nfg2,2),iabdfg(*),
     *          jabdfg(*),locfmo(*),molfrg(*),scffrg(*),mapi(*),mapj(*),
     *       mcnvfmo(*),mconfg(*),ijvec(5,*),job2grp(*),ngrfmo(maxpst,*)
     *         ,mannod(*),mastid(*),nprfrg(*),isdrec(*),fmoelm(*),
     *          totd(*),iaoglob(*),dgrid(nxyzg,*),vdwrad(*),noffg(*),
     *          indgrd(6,*),extracc(nextracc,*),esolv(*),etotdft(*),
     *          XYZCTS(mxts,3),PEL(*),VNUC(*),QSE(*),ISPHE(*),qtmp(*),
     *          ctdim(*),popmat(maxnat,nfg,2),ialoc(*),indbd(maxabd,*),
     *          iodcfmo(*),untxyz(3,natfmob,0:nunptc+1),
     *          untrot(3,3,0:nunptc),esp1i(*),esp1j(*),czi(*),czj(*),
     *          nsymeq(*),klms(4,*),esplat(n2fmo,*),stonep(*),iexcit(5),
     *          eexcit(mxrt,2),texcit(3,mxrt,2),monoc(mxrt),monvr(mxrt),
     *          icst(mxrt),isumd(mxrt+1),eexfg(2,nfg,mxrt),ctdm(*),
     *          fmoddm(*),FMOFCM(*),FCMWRK(*),ABFLDT(*),DINDF2(*),
     *          DINDDF2(*),ZVLAG(*),IPTLG(*),NQMTFG(*),ZVWRK(*),
     *          iddpnt(*),potat(*),fmohard(natfmo,*),iactfg(*),
     *          emon1(nfg,2),enucfg(*),crfrg(4,ncentm,nfg),grdpad(3),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),frgnam(*),
     *          F_mm((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G_mm((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          VIPOT(MAXNAT,NFG,*),iefmoiglob(*),edimlow(nfg2,3),
     *          chij(MXATM),ALCNT2F(*),YALAG(*),IPTYA(*),YAWRK(*),
     *          Xlfmobuf1(*),FMOZAN(*),RWRK(*),INDXIU(*),rrij(*),
     *          ESDIMTMP(*),pmulspin(*),mappcm(*),edimsum(16),nrij(*)
      COMMON /DFTCAM/ ALPHAC,BETAC,CAMMU,CAMVWN,CAMLYP,CAMFLAG
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,jans
      COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
     *                                                    NAUXSHL
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP,iefmo_agrad
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),edisp
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /GRDPAR/ ORIGIN(3),XVEC(3),YVEC(3),ZVEC(3),UX(3),UY(3),
     *                UZ(3),GRDSIZ,NGRID,IGUNIT,NXG,NYG,NZG,modgrid
      COMMON /IEACAL/ REMPOL,IEACAL,NFGIEA,NFRGIEA,NFRGI1,NFRGI2,IEADA,
     *                MXEFPT,MAXPOL,NPRIEA,NATFIEA,IEABDY,ITRLVL,
     *                LIEACNT,ieaold,DOEFPIEA
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INFOEX/ TDM(3,mxrt),MOCC(mxrt),MVIR(mxrt),MONOC1,MONVR1,
     *                IFMODIM,MONOC2,MONVR2
      common /INT2IC/ NINTIC,iNINTIC,nxxic,lbufpic,lixic,labsix,nintix
      COMMON /INTRFC/ FRIEND,AIMPAC,RPAC,PLTORB,MOLPLT,DGRIDPROG
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NORB,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /NLRC  / LCFLAG,EMU,EMU2,LRFILE
CFTNC COMMON /NLRCF / LRINT
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),ch(mxgtot),ci(mxgtot),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
      COMMON /PCMCHG/ PB,PX,PC,UNZ,QNUC,FN,FE,UNZOR,PORT
      COMMON /PCMDIM/ mxsp,mxts,mempcm1,mempcm2,NTS
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEFPCM,IP_F,nfmopcm,IHET
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /PSILVL/ IPSI,ISKPRP
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RUNOPT/ pUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,npreo(4)
      COMMON /SCFWFN/ AROHF(3),BROHF(3),PACAVO(6),IACAVO,IUHFNO,ICUHF,
     *                MVOQ
      COMMON /STNBUF/ STNPNT(4,2*MXATM),BIGEXP,NPTSTN,NBUFFM
      COMMON /TIMING/ CPU,WALL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      common /fmopmd/ fmobox(3),mdwpbc,nimgcell,imglvl,
     *                ltrvec,lfmogctr,lfmoctmp,lindatmd,lwrkdsav,lindxiu
     *               ,IPBCFST
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /MLTFMO/ Q_MUL,IMLTFMO,ISWPFD,ISWNEW1
      complex*16 Ylmfrg(((NP+1)*(NP+2))/2,ncentm,nfg),
     *           Ylmfrgq(((NP+1)*(NP+2))/2,nfg),
     *           Ylmfrgq2(((NP+1)*(NP+2))/2,nfg)
      data dimdek/' $FMOEND'/,end/' $END'/,RMC/8HMCSCF   /,
     *     rhf/8HRHF     /,energy/8HENERGY  /,rnone/8HNONE    /,
     *     rohf/8HROHF    /,uhf/8HUHF     /
c
c     write(6,*) 'Lagrangian frg2 in edimer',ZVLAG(41),ZVLAG(42)
      IF (DFTBFL) THEN
CDFTB   CALL SYSTEM_CLOCK(ICLOCK_COUNTS_1,CLCK_RATE)
CDFTB   CALL CPU_TIME(T1)
        ESDFL = .FALSE.
        NESDIM3 = 0
        NDIMSCF = 0
        ESDREP = .FALSE.
        IF (IAND(MODESD,6).NE.0) THEN
          ESDFL = .TRUE.
          CALL VCLR(ESDIMTMP,1,NATFMO+NBDFG)
        end if
        IF (IAND(MODESD,1).NE.0) ESDREP = .TRUE.
      END IF
c     MDOUT1=mdout.and.iand(nprfmo,3).ne.3
c     parstat: GlobalFull
c     ifmostp is set really only for makmol in order to read MP2 data.
      ifmostp=3
      if(dolat) iskipesp=1
      ntimout=0
      prerhf=mod(nguess/16,2).ne.0
      copycore=iand(nguess,32).ne.0
c     projact=iand(nguess,64).ne.0
      sepdim=mod(modpar,2).ne.0.and.ngrfmo(5,ilay).ne.0.and.resdim.ne.0
     *      .and.isgddi
      flipsd=iand(modpar,128).ne.0.and.resdim.ne.0
      lbmcscf=docas.and.mod(modpar,2).ne.0.and.ngrfmo(7,ilay).ne.0.and.
     *        nemc.ne.0.and.isgddi
      if(outpune) write(ip,9200) dimdek
      rij=zero
c     haver=rESDIM.ne.zero
      usedij=iand(IXESP,2).eq.0
      desperate=mod(nguess/256,2).ne.0
      despread=desperate.and.iand(nguess,2048).eq.0
      esd=nder.gt.0.and.(resdim.ne.0.and.iand(ixesp,32).eq.0 .or.
     *    modfd.ne.0)
      ndesper=0
      nodesper=0
      dftsav=DFTYPE
      ndftsav=NDFTFG
      lcsav=LCFLAG
      camsav=camFLAG
      cisav=cityp
      mp2sav=mplevl
      hfssav=DFTTYP(3)
      tdsav=tddftyp
c     always assume separated dimers for EFMO
C      IEFMODIMER = 1
      uhfcal=.false.
      do i=1,nfg
        if(scffrg(i).eq.uhf)  uhfcal=.true.
      end do
      if(nfg.eq.0)  write(iw,*) uhfcal
c     if(needdm) call viclr(job2grp,1,nfg2)
c     WRITE(IW,9086)
c     CALL EGOUT(fmode(1,1,2),natfmo)
c9086 FORMAT(/10X,36(1H-)/10X,'2-body gradient after VDER',
c    *       /10X,36(1H-))
c
      if(isgddi) call GDDICOUNT(-1,lgroup,myjob)
c     doddcor=MPLEVLi.gt.0.and.(MPPROP.ne.0.or.nder.gt.0).or.
c    *        citypi.ne.rnone
      if(doddcor) ixesp=ixesp+1024
c     raising 1024th bit signals ESPs to always use RHF densities.
      memon=1
      if(gcorrel.or.dodc) memon=2
      if(dopleda) memon=memon+2
      irec1=idmrec0(1)
cpbc
c     save fmoc
c---  if(dopbcmd) call genfrgmic(0,-1)
      if(dopbcmd) call genimagefg(0,0)
c     if(nfmopcm.gt.0) call vclr(x(lesolv+nfg),1,nfg)
cnb   more thought is needed for pcm[3] and multilayer cases.
c     esfact=one
c     if(ISWNEW1.EQ.1) esfact=2.0D+00
C
c     allways use uncorrelated monomer energies for separated dimers.
      lijfg=0
      iter0=0
      jbsav=jbtyp
      ngrsav=ngroups
      clrcow=.false.
      edeld=zero
c     nc1=natfmo*3
      neh = nc1 * nc1
CDFTB CALL SYSTEM_CLOCK(ICLOCK_COUNTS_2,CLCK_RATE)
CDFTB CALL CPU_TIME(T2)
      do iifg=1,nfg
cpbc
c       generate fragments around the fragment ifg accoording to
c       the minimum image convention. fmoc, cfrg, and untxyz are
c       destroyed (fmoc is stored in fmoctmp), and so they must
c       be restored later using fmoctmp.
c---    if(dopbcmd) call genfrgmic(iifg,0)
        iifg0=iifg
        if(dopbcmd) call genimagefg(2,iifg0)
        if(dopbcmd) then
        call makeindexiu(ilay,loadhf,loadm,indat,fmozan,
     *                   fmoc,iabdfg,jabdfg,scffrg,
     *                   needr0,rrij,rwrk,mfg2,vdwrad,
     *                   nprfrg,.false.,nunptc,natfmob,untxyz,
     *                   units,indxiu,.false.)
        endif
c
        njfg=iifg-1
        iusu=0
        do 500 iu=0,nunint
        if(iu.gt.0) then
          if(IPBCFST.eq.1) goto 500
c         skip symmetry equivalent groups.
          if(nsymeq(iu).le.0) goto 500
          iusu=iusu+1
          call CLOSDA('DELETE')
          CALL OPENDA(0)
          iiifg=iifg
          call makemol(iiifg,0,0,ilay,0,0,0,0,0,0,0,.true.)
          call monbsr(nat,ich,mul,num,nqmt,ne,na,nb,nshell,ngau,enucr,
     *                nat0,ich0,mul0,num0,nqmt0,ne0,na0,nb0,
     *                nsh0,ngau0,enucr0)
          ne0c=ne0+ich0
          if(.not.dopbcmd) then
            call dcopy(nat,zan,1,czi,1)
            call dcopy(nat*3,c,1,czi(nat+1),1)
          endif
        endif
        do 450 jjfg=1,njfg
          lijfg=lijfg+1
          if(loadhf.eq.1.and..not.dopbcmd) then
            if(savememr) then
              if(lijfg.le.nscf) then
                ijfg=loadd(lijfg)
                call tribrk(ijfg,-1,ifg,jfg)
              else
                call loaddes(nrij,rrij,lijfg-nscf,ifg,jfg,ijfg)
              endif
            else
              ijfg=loadd(lijfg)
              call tribrk(ijfg,-1,ifg,jfg)
c             ifg=ifg+1
            endif
          else
            ijfg=lijfg
            ifg=iifg
            jfg=jjfg
          endif
c         if(dolat.and.iu.gt.0) then
c           This is potentially problematic.
c           The following arrays are affected:
c           ndtfrg,nddfrg,esolv,job2grp
c           ijfg=ijfg+nfg2+(iusu-1)*nfg*nfg
c         endif
c         Switch groups for separated dimers and/or after MCSCF dimers
          if(sepdim.and.lijfg.eq.nscf+1.or.
     *      lbmcscf.and.lijfg.eq.nemc+1) then
c           write(6,*) 'The 5/7th groupie'
            CALL TSECND(TIMe0)
            wall0=wall
            call GDDICOUNT( 1,lgroup,myjob)
            igrfmo=5
            if(lbmcscf.and.lijfg.eq.nemc+1) igrfmo=7
            call fmopre(ilay,igrfmo,ngrfmo,mannod,mastid,irmdfmo)
            call GDDICOUNT(-1,lgroup,myjob)
            CALL TSECND(TIMe1)
            if(maswrk) then
              if(igrfmo.eq.5) write(iw,9600) ' ESD ',ilay,wall-wall0
              if(igrfmo.eq.7) write(iw,9600) 'dimMCSCF',ilay,wall-wall0
            endif
          endif
c
          NDFTFG=ndftsav
          dftype=dftsav
          DFTTYP(3)=hfssav
          LCFLAG=lcsav
          camFLAG=camsav
          mplevl=mp2sav
          cityp=cisav
          tddftyp=tdsav
c
          lie=.false.
c         mixdim=modfd.ne.0.and.iactfg(ifg)+iactfg(jfg).eq.1
          mixdim=modfd.ne.0.and.layfrg(ifg)+layfrg(jfg).eq.3
c
          lowdimer=.false.
          if(modfd.eq.0) then
c         skip dimers from higher layers
            if(.not.((layfrg(ifg).eq.ilay.or.layfrg(jfg).eq.ilay).and.
     *        layfrg(ifg).ge.ilay.and.layfrg(jfg).ge.ilay)) then
                 if(fullmfmo3) then
                   if(ilay.ne.1) goto 450
                   lowdimer=.true.
c                  if(maswrk) write(iw,*) 'This is a low dimer.'
                 else
                   goto 450
                 endif
            endif
          else
            if(ilay.ne.2) call abrt
            if(iand(modfd,2).ne.0) then
              if(iactfg(ifg).eq.0.and.iactfg(jfg).eq.0) goto 450
c             fast
            else
              if(layfrg(ifg).lt.ilay.and.layfrg(jfg).lt.ilay .or.
     *           mixdim.and.iactfg(ifg)+iactfg(jfg).ne.1) goto 450
c             slow
            endif
          endif
          if(scffrg(ifg).eq.rnone.or.scffrg(jfg).eq.rnone) goto 450
c         skip dimers that have been done (restart jobs, no BSSE).
          if(.not.savemem2) then
          if(irststp.ge.4.and.irststp.ne.5.and.edim(ijfg,1).ne.zero)
     *       goto 445
c         skip dimers that have been done (restart jobs, BSSE).
c         if(irststp.eq.5.and.edim(ijfg,1).ne.zero.and.edim(ijfg,5)
c    *       .ne.zero) goto 445
          if(nbsse.ne.0) then
            if(irststp.eq.5.and.edim(ijfg,1).ne.zero.and.
     *         edim(ijfg,5).ne.zero) goto 445
          endif
          endif
          if(iand(modmol,1).ne.0) then
c           check if MOLFRG option tells to ignore dimers except those with
c           one from the chosen group.
            ires=molfrg(ifg)+molfrg(jfg)
            if(exclmol) then
              if(ires.ge.0.and.ires.ne.2) goto 450
            else
              if(ires.eq.0.or.ires.eq.2) goto 450
            endif
          endif
          if((cityp.ne.rnone.or.tddftyp.ne.rnone).and.iexcit(3).eq.0)
     *    then
            if(iexcit(1).ne.ifg.and.iexcit(1).ne.jfg) goto 450
          endif
c
          if(ext2lay.and.ilay.eq.2) then
            call vclr(edim(ijfg,1),nfg2,nen)
          endif
c
          CALL TSECND(TYME)
          IF(TYME.GT.TIMLIM) THEN
            IF(MASWRK) WRITE(IW,9500)
            ntimout=1
            goto 590
          ENDIF
c
          if(nstjob.ne.0.and.lijfg.le.nstjob) then
            if(mygroup.lt.loadgr) then
              jbtyp=0
              ngroups=loadgr
              clrcow=.true.
c             temporarily switch to static load balancing and use the reduced
c             number of groups in GDDICOUNT too.
            else
c             otherwise skip the static jobs
              goto 450
            endif
          endif
c
c         reset the inner counter before switching to dynamic load balancing.
c         do not reset the global counter itself.
          if(isgddi.and.clrcow.and.jbtyp.gt.0) then
c           write(6,*) 'wwwClearing the counter'
            call GDDICOUNT(-1,lgroup,myjob)
            clrcow=.false.
          endif
c
          if(isgddi) then
            call GDDICOUNT(0,lgroup,myjob)
            ngroups=ngrsav
            jbtyp=jbsav
            if(.not.myjob) goto 450
          endif
c         if(haver) rij=fmodist(ifg,0,0,jfg)
          if(haver) then
            icurunts=icurunt
            icurunt=iu
            rij=fmodist(ifg,0,0,jfg)
c           write(6,*) 'krb rij = ', rij
            icurunt=icurunts
          end if
          if(modfd.ne.0) then
            enuc0ij=enucfg(ifg)+enucfg(jfg)
          else
            enuc0ij=0
          endif
          if(.not.savemem2) then
          edim1sav=edim(ijfg,1)
          edim2sav=edim(ijfg,2)
          if(nen.gt.2) edim3sav=edim(ijfg,3)
          endif
          if(rij.gt.resdim.and.resdim.ne.zero.and.skipesd) then
            if(savemem2) call abrt
c           call makemol just to get ENUCR!
            call makemol(ifg,jfg,0,ilay,0,0,0,0,0,0,0,.false.)
            if(maswrk) then
              enucfmo=enucfmo+enucr-enuc0ij
c             edim(ijfg,1)=emon(ifg,memon)+emon(jfg,memon)
c             if(gcorrel.or.dodc) edim(ijfg,3)=edim(ijfg,1)
            endif
            goto 450
          endif
          l1i=iand(numfrg(ifg),65535)
          l1j=iand(numfrg(jfg),65535)
          l0i=iand(nqmtfg(ifg),65535)
          l0j=iand(nqmtfg(jfg),65535)
          nai=ishft(numfrg(ifg),-16)
          naj=ishft(numfrg(jfg),-16)
          nbi=nai-mulfg(ifg)+1
          nbj=naj-mulfg(jfg)+1
          SCFi=scffrg(ifg)
          SCFj=scffrg(jfg)
          iodexch=scfi.eq.rmc
          jodexch=scfj.eq.rmc
          urohfi=scfi.eq.uhf.or.scfi.eq.rohf
          urohfj=scfj.eq.uhf.or.scfj.eq.rohf
          l2i=(l1i*l1i+l1i)/2
          l2j=(l1j*l1j+l1j)/2
c         LL1 printed below is an overestimate of the true L1,
c         used only for print-out.
          ll1=l1i+l1j
          if(dolat) then
c           Assume equal size fragments!
            ig=1
            jg=klms(4,iu)
            indi=(ifg-1)*maxl2+1
            indj=(jfg-1)*maxl2+1
            call dcopy(l2i,esplat(indi,ig),1,esp1i,1)
            call dcopy(l2j,esplat(indj,jg),1,esp1j,1)
          endif
          addespij=addesp.and.(rij.gt.zero.or.addesp0).and.
     *            (rij.le.resdim.or.resdim.eq.zero)
          if(addesp) then
            iskipesp=0
            if(addespij) iskipesp=1
          endif
          if(addespij) then
c           ADDESP option supports size-based load balancing (LOADHF),
c           and IFG can come in "random" order.
            call CLOSDA('DELETE')
            CALL OPENDA(0)
            call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0,.true.)
            nat0=nat
            call dcopy(nat,zan,1,czi,1)
            call dcopy(nat*3,c,1,czi(nat+1),1)
            irecv=(irec0-1)/2+nfg*4+1
            CALL rareads(IDAFMO,iodfmo,esp1i,l2i,irecv+ifg,0)
            CALL rareads(IDAFMO,iodfmo,esp1j,l2j,irecv+jfg,0)
            write(6,*) 'VI',irecv+ifg
            call prtril(esp1i,l1i)
            write(6,*) 'VJ',irecv+jfg
            call prtril(esp1i,l1j)
          endif
          if(dolat.or.addespij) then
            call pairvij(ilay,ifg,jfg,iu,nat0,natfmob,nunptc,untxyz,
     *                   cfrg,fmoespa,esp1i,esp1j,czi,czj,dolat)
          endif
c         if(ipieda.ne.0.and.nfmopcm.gt.0) then
          if(nfmopcm.gt.0.and.iand(modprp,64).eq.0) then
            call epcmscr(da,db,ilay,ifg,jfg,l1i,l1j,orbxch,iodexch,
     *                   jodexch,iodfmo,irec0,indat,
     *                   XYZCTS,QSE,ISPHE,qtmp,esolvi,esolvj,eijes2,
     *                   scffrg)
            if(maswrk) then
              esolv(nfg+ifg)=esolv(nfg+ifg)+esolvi
              esolv(nfg+jfg)=esolv(nfg+jfg)+esolvj
              esolv(nfg*2+nfg2+ijfg)=eijes2
            endif
          endif
c         ijskip=0
c
          EDISNRG = ZERO
          EREPNRG = ZERO
          ECHTNRG = ZERO
          EPENNRG = ZERO
C         DO EFMO CALCULATION TO SET UP VARIABLES AND GRADIENT CONTRIBUTIONS
          IF(IEFMORUN.GT.0.AND.IEFMORT.EQ.3) THEN
            efmosepcalc = rij.gt.resdim.and.resdim.ne.zero.or.mixdim
            ECHNRG = ZERO
            EPOLNRG = ZERO
            CALL EFMOFRGS(IFG,JFG,RIJ,ECHNRG,EPOLNRG,EDISNRG,
     *                    EREPNRG,ECHTNRG,EPENNRG,FRGNAM,efmosepcalc)
c           store the dimer negative dimer polarization term
c           as it will be added later
            if(maswrk) edim(ijfg,2) = -EPOLNRG
            if(rij.le.resdim.and..not.maswrk) then
              EDISNRG = ZERO
              EREPNRG = ZERO
              ECHTNRG = ZERO
              EPENNRG = ZERO
            ENDIF
c           storing the EFP interaction energy for EFMO dimers.
c           indexing in edim changes if some dimers use MP2
            if(maswrk) then
               icorr_add = 0
               if(gcorrel) icorr_add = 2
               edim(ijfg,3+icorr_add) = echnrg+epennrg
               edim(ijfg,4+icorr_add) = erepnrg
               edim(ijfg,5+icorr_add) = echtnrg
               edim(ijfg,6+icorr_add) = edisnrg
            else
               icorr_add = 0
               if(gcorrel) icorr_add = 2
               edim(ijfg,3+icorr_add) = zero
               edim(ijfg,4+icorr_add) = zero
               edim(ijfg,5+icorr_add) = zero
               edim(ijfg,6+icorr_add) = zero
            end if
          ENDIF
c
          esd2mp=emon(ifg,memon)+emon(jfg,memon)
          esd2m1=emon(ifg,1)+emon(jfg,1)
          esd2m2=emon(ifg,2)+emon(jfg,2)
          if(nbody.eq.2) then
            esd2m=0
          else
            esd2m=esd2mp
            esd2mp=0
c           FMO3 cannot use this way for now.
c           FDD below does not work with FMO3, so it is fine for now.
          endif
c         esd2mp is used mainly for printing dimer energies
c         esd2ms is used for PIEDA/PCM (it does refer to esd2mp) 
          iilay=ilay
          jjlay=ilay
          irec0i=irec0
          irec0j=irec0
          if(mixdim.and.iactfg(ifg).eq.0) then
            esd2mp=emon1(ifg,memon)+emon(jfg,memon)
            iilay=1
            irec0i=irec1
          endif
          if(mixdim.and.iactfg(jfg).eq.0) then
            esd2mp=emon(ifg,memon)+emon1(jfg,memon)
            jjlay=1
            irec0j=irec1
          endif
c         esd2ms=esd2m
          esd2ms=esd2mp
          if(nfmopcm.ne.0) esd2ms=esd2ms+esolv(ifg)+esolv(jfg)
c         EX in PIEDA/PCM has a doubled PCM-EX coupling for PCM<1>
c         compared to PCM[1], because EX is defined with the PCM potential.
c         This difference is subtracted from CT+mix, so that EX+CT_mix
c         is the same in PCM[1] and PCM<1>.
c         write(6,*) 'wwwwesd2ms',esolv(ifg)+esolv(jfg)
          if(rij.gt.resdim.and.resdim.ne.zero .or. ipieda.ne.0 .or.
     *       mixdim.or.dofret) then
            call stopwa(15,0)
            if(rij.eq.0.and.nder.gt.0) then
              write(iw,*) 'Active domain is not separated from frozen.'
              call abrt
            endif
c           ijskip=1
c           compute energies of separated dimers.
c           note that no BSSE check is done which means for separated dimers
c           we ignore BSSE corrections (be it good or bad).
c           jfg and ifg are interchanged to have ifg<jfg order
c
c
c           esdim is called with DB because FMOESP overwrites DA
c
            if(modfd.ne.0.and.flipsd) call abrt
c           change iilay, irec too
            esd2=esd2m
            if(flipsd.and.l1i.lt.l1j) then
              ifrg=jfg
              jfrg=ifg
              flipch='D'
            else
              ifrg=ifg
              jfrg=jfg
              flipch='d'
            endif
            IF(IEFMORUN.GT.0.AND.IEFMORT.EQ.3) GOTO 420
            edisp=zero
            if(nder.eq.2) then
              neh = nc1 * nc1
c             call gddi_scope(ddi_group)
              if (.not.dftbfl) call vclr(FCMWRK,1,neh)
            end if
            IF (DFTBFL) THEN
              ENUCR = ZERO
              IF (IAND(MODESD,6).NE.0) GO TO 600
              NESDIM3 = NESDIM3 + 1
CD            EPOT = DFTB_ESDIM(nder,ifg,jfg,LAYFRG,IAGLOB,POPMAT)
              IF (MASWRK) THEN
                EPOT = DFTB_ESDIM(nder,ifg,jfg,POPMAT,ilay,ESDREP,WRK1,
     *                            WRK1(MAXNAT*2+1),WRK)
                esd2 = esd2 + epot
                IF (DODC) CALL DFTB_ESDIM_DC_HELP(IFG,JFG,NDER,WRK)
C               edisnrg = edisp
              END IF
              IF(NDER.EQ.2) THEN
                IEEH = 1
                IF (NBODY.GT.2) IEEH = IEEH - NDTFRG(IJFG,1)
                CALL DFTB_ESDHSS(da,wrk1,IFG,JFG,YALAG,IPTYA,FCMWRK,
     *          idmrec0,numfrg,NC1,WRK,DODC,IEEH)
              END IF
              mmdim=0
            ELSE
            call esdim(nder,jfrg,ifrg,esd2,rij,jjlay,iilay,irec0j,irec0i
     *                ,idmrec0,layfrg,iodfmo,maxl30,scffrg,wrk,fmoespa,
     *                 db,dij,isdrec,orbxch,dodistr,clm,flm,f_mm,g_mm,
     *                crfrg,ylmfrg,mmdim,nfg2,ndtfrg,dodcesd,wrk1,iaglob
     *                ,fmode(1,1,2),fmopg,FCMWRK,NQMTFG,YALAG,IPTYA,
     *                 numfrg,Xlfmobuf1,NC1,dopbcmd,untxyz,cfrg,natfmob,
     *                 nunptc,iu,dofret,iexcit)
            END IF
c           write(6,*) "Fret vcouple =",esd2
c           Subtract monomer dispersion energies for DODCESD.
            if(dodcesd) then
c             possible if using emon1.
              if(mixdim) call abrt
c             esd2m1 is SCF+D, esd2m2 is SCF, need to get D. 
              edisp=edisp-(esd2m1-esd2m2)
            endif
            if(nder.eq.2.and..not.dftbfl) then
c             call gddi_scope(ddi_group)
              IF(GOPARR) CALL DDI_GSUMF(2418,FCMWRK,neh)
c             IGOTFCM=0
              IDAD = 1
              IEEH = IDAD
              IF (NBODY.GT.2) THEN
                ida  =-ndtfrg(ijfg,1)
                IEEH = IDAD + IDA
              ENDIF
              CALL FMODEH(IEEH,FCMWRK,fmoddm,FMOFCM,FMOPG,IAGLOB,
     *                    nc1,indat,layfrg,wrk1,1)
            end if 
            if(totfock.and.iand(mofock,16).eq.0) then
              call CLOSDA('DELETE')
              CALL OPENDA(0)
              ifmostps=ifmostp
              ifmostp=6
              call makemol(ifg,jfg,0,ilay,0,0,0,0,0,0,0,.true.)
              ifmostp=ifmostps
              iskipesps=iskipesp
              iskipesp=1
              call oneei
              iskipesp=iskipesps
              icurfg=ifg
              jcurfg=jfg
              kcurfg=0
            call dumpfock(totfock,wrk,num,(num*num+num)/2,0,wrk,wrk,wrk)
c             There is no contribution to e1efmo and ekinfmo
            endif
  420       CONTINUE
C            IEFMODIMER = 1
            if(maswrk) then
              IF( IEFMORUN.GT.0 .AND. IEFMORT.EQ.3 ) THEN
C               SEPARATED EFMO ENERGY AND GRADIENT CONTRIBUTION
c               call makemol(ifg,jfg,0,ilay,0,0,0,0,0,0,0,.false.)
                esd2 = esd2 + echnrg
              ENDIF
              eedimij=esd2+edisp+edisnrg+erepnrg+echtnrg+epennrg
              if(savemem2) then
c               mmdim=0
c               if(iand(modfmm,2).ne.0) 
c    *            call mmdist(ifg,0,0,jfg,t,radius,ty2z,ratio,mmdim)
                if(mmdim.eq.0) edimsum(1)=edimsum(1)+eedimij
c               Do not add this dimer if doing MM with lump ES dimers.
              else
                edim(ijfg,1)=edim(ijfg,1)+eedimij
              endif
c             if(nfmopcm.ne.0) esolv(nfg*2+ijfg)=esolv(ifg)+esolv(jfg)
              if((modfmm.eq.0.or.mmdim.eq.0.or.iand(modfmm,2).eq.0)
     *           .and.outesd) then
                if(.not.dopbcmd) then
                  write(iw,9020) flipch,ifg,jfg,ll1,eedimij+esd2mp
                else
                  write(iw,9021) flipch,ifg,jfg,iu,ll1,eedimij+esd2mp
                end if
                if(iand(nprfmo,3).lt.2) call timit(1)
              endif
              if(savemem2) then
                if(gcorrel.or.dodc) 
     *            edimsum(3)=edimsum(3)+eedimij-edisnrg-edisp
                if(ipieda.ne.0) call abrt 
              else
                if((gcorrel.or.dodc) .and.  .not.reducee)
     *            edim(ijfg,3)=edim(ijfg,1)-edisnrg-edisp
                if(ipieda.ne.0) then
                  edim(ijfg,nedimes)=esd2-esd2m
                  edim(ijfg,nedimex)=zero
                endif
              endif
            endif
c
c           For separated dimers we only get ENUC contribution to properties
c
            call stopwa(15,1)
           if(rij.gt.resdim.and.resdim.ne.zero.or.mixdim.or.dofret) then
              if(maswrk.and..not.lowdimer) enucfmo=enucfmo+enucr-enuc0ij
              lie=.true.
              goto 440
            endif
c           Else repeat the dimer with SCF
          endif
C
C         Calculate redundant terms in Variational FMO
C
          IF (IAND(MODESP,512).NE.0.AND.RESPPC(1).NE.ZERO) THEN
            RIJ555=FMODIST(IFG,0,0,JFG)
            IF (RIJ555.GT.RESPPC(1)) THEN
              CALL SUBTRCTESP(2,IFG,JFG,0,ILAY,IREC0,
     *                        IODFMO,SCFFRG,DA,FMOC,VIPOT,ORBXCH)
C             CALL compvipot(IFG,JFG,0,indat,fmoc,VIPOT(1,1,icurpop))
            END IF
          END IF
c         NEVALS=0
          icurfg=0
          SCFTYP0=SCFTYPi
c         if(iodexch.or.jodexch) SCFTYP0=rmc
c         Reset to RHF if both fragments are RHF (assuming for now SCFi=SCFj)
          if(.not.iodexch.and..not.jodexch) SCFTYP0=SCFi
          if(urohfi) SCFTYP0=SCFi
          if(urohfj) SCFTYP0=SCFj
c         if(scftypi.ne.rmc.and.SCFTYP0.eq.rmc) SCFTYP0=scftypi
c         same as in monoscf, SCFTYP0 may be altered only after odexch is set.
          SCFTYP=SCFTYP0
          if(gcorrel.and.correl) then
c           check if MOLFRG option further restricts the correlation
            ires=molfrg(ifg)+molfrg(jfg)
            if(exclmol) then
              skipc=ires.ge.0.and.ires.ne.2
            else
              skipc=ires.eq.0.or.ires.eq.2
            endif
            if(tddfti.ne.rnone.or.citypi.ne.rnone) then
             if(iexcit(1).ne.ifg.and.iexcit(1).ne.jfg.or.
     *          iexcit(2).lt.2) skipc=.true.
            endif
            if((rij.gt.rcorsd.and.rcorsd.ne.0).or.skipc) then
              mplevl=0
              cctyp=rnone
              cityp=rnone
              tddftyp=rnone
              if(skipc.and.maswrk) write(iw,9050) ifg,jfg
            else
              mplevl=mplevli
              cctyp=cctypi
              cityp=citypi
              tddftyp=tddfti
c             DAF records
c              16 contains MP2 density (1st order)
c             308 contains SCF density (0th order)
            endif
          endif
          doddcori=MPLEVL.gt.0.and.(MPPROP.ne.0.or.nder.gt.0).or.
     *             cityp.ne.rnone.or.(tddftyp.ne.rnone.and.nder.gt.0)
          irecd=16
          if(doddcori) irecd=308
          if(maswrk.and.mdout) then
            call wfnstr(wfnstri)
            if(dolat.or.dopbcmd) then
              write(iw,9002) scftyp0,ifg,jfg,iu,wfnstri,ll1,lijfg
            else
              write(iw,9000) scftyp0,ifg,jfg,wfnstri,ll1,lijfg
            endif
          endif
          call CLOSDA('DELETE')
          CALL OPENDA(0)
          nprsav=nprint
          excstat=cityp.ne.rnone.or.tddftyp.ne.rnone
          if(excstat.or.iand(nprfmo,32).ne.0) nprint=7
          if(iu.eq.0) then
            call makemol(ifg,jfg,0,ilay,0,0,0,0,0,0,0,.true.)
          else
c           for PBC runs with propagated cells one has to add JFG using
c           new propagated coordinates, so that makmol has to be split
c           (IFG - original cell, JFG - propagated).
            call makemol(jfg,0,0,ilay,0,nat0,nsh0,ngau0,ne0c,ich0,
     *                   mul0,.true.)
          endif
c
          if(moncor.ge.0) moncor=0
c         fmonad sets norb.
          if(iodexch) then
            if(moncor.ge.0) moncor=naj
            call fmonad(idum1,idum2)
            nai=nactfmo
          endif
          if(jodexch) then
            if(moncor.ge.0) moncor=nai
            call fmonad(idum1,idum2)
            naj=nactfmo
          endif
c         nai and naj for RHF are NA (the number of alpha electrons)
c         for MCSCF they become the number of occupied orbitals
c
          l1=num
          l2=(l1*l1+l1)/2
          l3=l1*l1
          if(maswrk.and..not.lowdimer) enucfmo=enucfmo+enucr-enuc0ij
          if(maswrk) then
            if(labsiz.ne.labsix.and.iand(nprfmo,3).eq.0) 
     *        write(iw,9005) labsiz,labsix
            if(NINTIC.ne.0.and.iand(nprfmo,3).lt.2) 
     *        write(iw,9007) LABSIZ,NINTIC,ININTIC
            dum=0
            if(idoprop.ne.0.and.qmcout)
     *        call qmcfout(nftqmc,ifg,jfg,0,dum)
          endif
c
c       Compute dimer initial density
c
          if(dftbfl) then
            NDIMSCF = NDIMSCF + 1
            call diminic(ifg,jfg,0,wrk1,popmat,indat,iaglob,ialoc,
     *                   indbd)
            !! maybe needed to calculate esp gradient
C           if (nder.gt.0 .or. mod(mconv,16).ge.8) then
C          call diminid(0,jfg,ifg,l1j,l1i,l0j,l0i,naj,nai,nbj,nbi,l1,da,
C    *              db,wrk,wrk1,iodfmo,irec0,iabdfg,jabdfg,indat,iaglob,
C    *                 locfmo,mapj,mapi,orbxch,enexch,jodexch,iodexch,
C    *                 iu,untrot(1,1,iu),0,scffrg(jfg).eq.uhf,
C    *                 scffrg(ifg).eq.uhf,mulfg,some)
c            call dawrit(IDAF,IODA,da,L2,16,0)
C           end if
          end if
          if (.not.dftbfl.or.(nder.gt.0.or.mod(mconv,16).ge.8))
     *    call diminid(0,jfg,ifg,l1j,l1i,l0j,l0i,naj,nai,nbj,nbi,l1,da,
     *              db,wrk,wrk1,iodfmo,irec0,iabdfg,jabdfg,indat,iaglob,
     *                 locfmo,mapj,mapi,orbxch,enexch,jodexch,iodexch,
     *                 iu,untrot(1,1,iu),0,scffrg(jfg).eq.uhf,
     *                 scffrg(ifg).eq.uhf,mulfg,some)
          if(dodimden.and.nevsav.gt.0)
     *      call getdd(ifg,jfg,orbxch,wrk,l1,iddpnt,iresdd)
          if(dolat.or.addespij) then
            call addv2(l1,l2,mapi,mapj,esp1i,esp1j,fmoespa)
c           write(6,*) 'VIJ'
c           call prtril(fmoespa,l1)
          endif
c         do lfg=1,nfg
c           if(lfg.ne.ifg.and.lfg.ne.jfg) then
c             write(6,*) 'Distance map for dimer',ifg,jfg,lfg
c             call mapdist(wrk,indat,indatg,iaglob,ifg,jfg,0,lfg)
c           endif
c         enddo
          if(.not.dftbfl) call dcopy(l2,da,1,dij,1)
c         write(6,*) 'wwwinidens'
c         call prtril(da,l1)
          igot=0
          if(orbxch) call fmorvec(ifg,jfg,0,ilay,ijvec,l1,da(1+l2),igot)
          if(mod(nguess/2,2).eq.0.and.igot.eq.0) then
            write(6,*) 'running Huckel guess for dimer'
            ifmostp=3
            icurfg=0
            jcurfg=0
            kcurfg=0
            CALL ONEEI
            NEVALS=0
            call vclr(wrk,1,l1)
            CALL dawrit(IDAF,IODA,wrk,l1,17,0)
            CALL GUESMO(GUESS)
          endif
          ifmostp=4
          icurfg=ifg
          jcurfg=jfg
          kcurfg=0
c           MCONV=mcnvfmo(ifmostp)
c         if(SCFTYP.eq.rmc) call readcas
          fordir=forcedir(l1dir,l1,maswrk)
          if(nintic.ne.0.and.scftyp.eq.rmc.and.goparr) fordir=.true.
          iconvij=-1
          call fmocvij(ifg,jfg,0,mconvex,mconfg(nfg+1),iconvij)
          call fmoconv(mcnvfmo(ifmostp),iconvij,l1,wrk,enexch,orbxch,
     *                 irststp.le.3.or.iter0.eq.0,.false.,fordir)
          iter0=1
c         It may be a good idea to call MCIN to be sure
          if(.not.savemem2) then
            if(irststp.gt.ifmostp.and.edim(ijfg,1).ne.zero) goto 430
c           skip dimer energy for restart jobs ifmostp=5.
          endif
c
          NEVALS=NEVALS+1
          irestsav=irest
c
          tightint=(iand(nprfrg(ifg),32).ne.0.or.iand(nprfrg(jfg),32)
     *              .ne.0).and.DIRSCF.and.FDIFF
          icutsav=icut
          if(tightint) then
            icut=icut+1
            if(maswrk) write(iw,9203) icut
          endif
c
c         Compute PCM correction to the dimer energies. Note that
c         nuclear potential is also computed but at present extravagantly.
c
          if(nfmopcm.ne.0) then
c           ida=1
c           if(nfmopcm.gt.2) ida=ida-ndtfrg(ijfg,1)
c           if(nfmopcm.lt.2) ida=0
            ida=0
            call pcmnup(ida,vnuc)
          endif
c
c         Run RHF before DFT or MCSCF
c
          if(SCFTYP0.eq.rmc.and.prerhf) then
            CALL daread(IDAF,IODA,wrk,L3,15,0)
c           write(6,*) 'www1: Initial orbitals'
c           call prsq(wrk,l1,l1,l1)
            SCFTYP=RHF
            mvoqsav=MVOQ
            MVOQ=6
            call fmosdir(0,fmodscf,fmodtrf)
            CALL BRNCHX(energy)
c           This code is not quite ready for non-singlets
            call fmosdir(1,fmodscf,fmodtrf)
            MVOQ=mvoqsav
            if(iand(nguess,16384).ne.0) then
c             old style matching: match blindly
              call fmodor(enexch,wrk,da(1+l2),da,da(1+l2+l3),wrk(l3+1),
     *                    wrk(l3+l1+1),wrk1,nai+naj,l1,l2,l3)
            else
c             new style: match CAS orbitals and then fill in the core as left.
              call matchcas(enexch,wrk,da(1+l2),da,da(1+l2+l3),wrk(l3+1)
     *                     ,wrk(l3+l1+1),wrk1,nai+naj,ncasfmo,l1,l2,l3)
            endif
c           write(6,*) 'www1.5: RHF orbitals'
c           call prsq(da(1+l2),l1,l1,l1)
            if(copycore) then
c
c             Use RHF core for MCSCF core, but restore MCSCF active orbitals
c             (that is, use monomer MCSCF orbitals).
c             wrk holds initial orbitals (most likely, obtained by
c             adding two monomer sets), da will store converged RHF set.
c
c             Possibly rid of fractioned bond projections (projact).
c             Project initial MCSCF orbitals.
c
c           if(projact) call projgues(l1,l2,wrk,db(1+l2+l3),db)
c           projact has been disabled in favour of its replacement,
c           which is applied to all orbitals, and for all wave functions.
c           write(6,*) 'www2: Projected orbitals',l1
c           call prsq(wrk,l1,l1,l1)
              ncoremc=nai+naj-ncasfmo
              nshift=1+ncoremc*l1
c             copy LCAO coeffiecints for the MCSCF monomer into dimer MOs
c             while keeping RHF dimer LCAO coeffiecints for other AOs.
              call nzcopy(l1*ncasfmo,wrk(nshift),1,da(nshift+l2),1)
c           write(6,*) 'www3: Final orbitals',ncoremc,ncasfmo
c           call prsq(da(1+l2),l1,l1,l1)
              CALL dawrit(IDAF,IODA,da(1+l2),L3,15,0)
            endif
            irest=2
c           since we run CAS again
          endif
c
          if(dftype.ne.rnone.and.prerhf) then
            DFTYPE=rnone
            NDFTFG=0
            DFTTYP(3)=1.0D+00
            LCFLAG=.false.
            camFLAG=.false.
            CALL BRNCHX(energy)
            NDFTFG=ndftsav
            dftype=dftsav
            DFTTYP(3)=hfssav
            LCFLAG=lcsav
            camFLAG=camsav
            irest=2
          endif
          SCFTYP=SCFTYP0
          IRSTLsav=IRSTLAY
          IRSTLAY=moncor+nactfmo
          if(moncor.lt.0) IRSTLAY=nai+naj
c         write(6,*) 'wwwIRSTLAY',nai,naj,IRSTLAY
          call fmosdir(0,fmodscf,fmodtrf)
c
c     -- FOR FMO-TDDFT
          if(TDDFTYP.ne.rnone.and.(rij.le.rcorsd.or.rcorsd.eq.0).and.
     *       .not.skipc) then
c
c        SAVE Monomer MO for TDDFT/HF calculations-1
            uhfcal=scffrg(ifg).eq.uhf.or.scffrg(jfg).eq.uhf
c
            if (iexcit(4).gt.0) then
              if (ifg.eq.iexcit(1)) then
                call monovec(wrk,fmoespb,mapi,L1i,L1,ifg,irec0,iodfmo,
     *          orbxch,enexch,iodexch,uhfcal)
              else
                call monovec(wrk,fmoespb,mapj,L1j,L1,jfg,irec0,iodfmo,
     *          orbxch,enexch,iodexch,uhfcal)
              endif
              if(uhfcal) lnum=l1*l1*2
              if(.not.uhfcal) lnum=l1*l1
              CALL dawrit(IDAF,IODA,wrk,lnum,478,0)
              IFMODIM=2
            endif
          endif
c
          CALL BRNCHX(RUNTYP)
c         Try converging once again with an alternative converger
          if(etot.eq.0.and.desperate) then
            if(maswrk) write(iw,9300)
c           Increase accuracy of DIRSCF/FDIFF.
            if(DIRSCF.and.FDIFF) icut=icut+1
c           to reuse integrals
            irest=2
            if(despread) then
c             do not use density from the previous run that failed, use the
c             pristine one (otherwise continue converging).
              CALL dawrit(IDAF,IODA,dij,L2,16,0)
              if(orbxch) then
                write(iw,*) 'Not ready yet'
                call abrt
              endif
            endif
            call fmoconv(mcnvfmo(ifmostp),iconvij,l1,wrk,enexch,orbxch,
     *                   irststp.le.3.or.iter0.eq.0,.true.,fordir)
            CALL BRNCHX(RUNTYP)
c           for desperate runs abort if not converged.
            if(etot.eq.0) then
              if(maswrk) write(iw,9310)
c             call abrt
              if(maswrk) nodesper=nodesper+1
            else
              if(maswrk) ndesper=ndesper+1
            endif
          endif
          call fmosdir(1,fmodscf,fmodtrf)
C
C     SRP: FOR RMD DYNAMICS, WE JUST DROP ANY STATE THAT DOES
C          NOT CONVERGE A DIMER SCF
C
            if(irmdfmo.gt.0.and.etot.eq.0) then
               ierr=2
               if(maswrk) write(iw,9299)        
               irmdfmo = irmdfmo+ierr
c              modeff=modsav
               return
            endif
c
          IRSTLAY=IRSTLsav
          irest=irestsav
          icut=icutsav
          nprint=nprsav
          if(RUNTYP.ne.energy.and.etot.eq.0) then
c           if(maswrk) write(iw,9400)
            write(iw,9400)
c           write(iw,*) 'zero energy?',meglob,RUNTYP,etot
            call abrt
          endif
c
          if((TDDFTYP.ne.rnone.or.cityp.ne.rnone).and.
     *       (rij.le.rcorsd.or.rcorsd.eq.0).and..not.skipc) then
c
c        Monomer MO for TDDFT/HF calculations
c
            if (iexcit(4).gt.0) then
              if (ifg.eq.iexcit(1)) then
                call monovec(wrk,fmoespb,mapi,L1i,L1,ifg,irec0,iodfmo,
     *          orbxch,enexch,iodexch,uhfcal)
              else
                call monovec(wrk,fmoespb,mapj,L1j,L1,jfg,irec0,iodfmo,
     *          orbxch,enexch,iodexch,uhfcal)
              endif
            endif
            idfg=ifg
            if(ifg.eq.iexcit(1)) idfg=jfg
c        -- Excitation type check
            if(maswrk) then
            gopsav=goparr
            goparr=.false.
            call excheck(wrk,fmoespb,db,wrk1,nqmt,L1,NSTMONO,MONOC,MONVR
     *                  ,ICST,iexcit,idfg,eexfg,nocctdm,nvirtdm,na,
     *                   nqmt-na,exfid,ctdm,uhfcal,nocctdb,nvirtdb,
     *                   nb,nqmt-nb)
c        -- Summing energy and transition dipole moment
            call tdesum(iexcit,eexcit,texcit,NSTMONO,ICST,ISUMD,
     *                  ifg,jfg,idfg,rij,eexfg,uhfcal)
            goparr=gopsav
            endif
c
          endif
c
          if(dodimden)
     *      call putdd(ifg,jfg,irecd,orbxch,wrk,l1,iddpnt,iresdd)
c
c         write(iw,*) 'Final 2e ESP is'
c         call prtril(wrk,l1)
c         CALL daread(IDAF,IODA,da,l2,irecd,0)
c         call vsub(dij,1,da,1,db,1,l2)
c         call prtril(db,l1)
c         db holds DIJ-DI-DJ
c         dijc=TRACEP(db,wrk,l1)
c         write(6,*) 'wwwcorr',ifg,jfg,' Ec=',dijc
c
c         properties must be computed with the highest correlated density
          if(primul.and.iand(modcha,3).ne.1) then
            if(NPTSTN.ne.0) then
              if(nprint.eq.-5.or.ISKPRP.ne.0) call stone(ip,rnone,0)
              call dcopy(nat,stonep,1,wrk1,1)
            else if(dopdc) then
              if(nprint.eq.-5.or.ISKPRP.ne.0) CALL ELEPOTC(iwhere)
              call dcopy(nat,stonep,1,wrk1,1)
c             write(6,*) 'wwwZ',(wrk1(i),i=1,nat)
            else
              call DENDD1(DA,da(1+l2),L2)
c             CALL daread(IDAF,IODA,da,l2,16,0)
              CALL daread(IDAF,IODA,db,l2,12,0)
              call vclr(wrk,1,l1)
              call mulpop(l1,da,db,wrk)
              call mulpopa(wrk,wrk1)
            endif
          if(maswrk) ctdim(ijfg)=ctpair(ifg,jfg,wrk1,popmat(1,1,icurpop)
     *                                 ,indat,iaglob,ialoc,indbd,imect)
          endif
          call ctpaira(ifg,jfg,wrk1,popmat(1,1,icurpop),indat,iaglob,
     *                 ialoc,indbd,chij)
c         3-body properties with correlation are not finished. One would have
c         to put a loop from 1 to 2 here, similar to monoscf. The only
c         finished 3-body properties are those in extracc for FMO-CC
c         (and the 3-body correlation energy). BUT NOT dipole moments nor
c         gradients.
          if(nbody.gt.2) then
            ida=-ndtfrg(ijfg,1)
            ida2=-ndtfrg(ijfg,2)
c           For trimers Dij contribution is needed per se, saved in
c           fmoelmt(1,2) and then explicitly added to the dimer sum
c           (that contains not only Dij but Di and Dj).
            if(nfmoelm.ne.0) call vclr(fmoelmt(1,2),1,nfmoelm)
            call addprop(2,primul,primul,1,ida,1,iaglob,wrk1,nfmoelm,
     *                   fmoelmt(1,2),fmoelmt,fmoelmt,atmulq,
     *                   atmulq(natfmo+1),atmulq)
            if(nfmoelm.ne.0) 
     *        call daxpy(nfmoelm,one,fmoelmt(1,2),1,fmoelmd,1)
          else
            ida=0
            ida2=0
            call addprop(2,primul,primul,1,ida,1,iaglob,wrk1,nfmoelm,
     *                   fmoelmd,fmoelmt,fmoelmt,atmulq,atmulq,atmulq)
          endif
c         if(primul.and.maswrk) ctdim(ijfg)=ctpair(ifg,jfg,wrk1,
c    *               popmat(1,1,icurpop),indat,iaglob,ialoc,indbd,imect)
          if(iahard.gt.0) then
            call DENDD1(DA,da(1+l2),L2)
            CALL EPCALC(fmoc,potat,da,natfmo,L2)
c           write(6,*) ifg,jfg,'wwwV',(potat(i),i=1,natfmo)
            if(maswrk) then
              call daxpy(natfmo,one,potat,1,fmohard(1,2),1)
              if(1+ida.ne.0.and.nbody.ge.3)
     *          call daxpy(natfmo,one+ida,potat,1,fmohard(1,3),1)
c             There are two minuses for each term.
            endif
          endif
          if(cctyp.ne.rnone.and.maswrk)
     *      call addecc(2,0,1,ida2,extracc,nextracc)
          if(mplevl.ne.0.and.maswrk)
     *      call addemp(2,0,1,ida2,extracc,nextracc)
          if(irecd.eq.16) then
            call DENDD1(DA,da(1+l2),L2)
          else if((scffrg(ifg).eq.uhf.or.scffrg(jfg).eq.uhf)
     *            .and.irecd.ne.16) then
C         DA and DB are 418 and 428 for UHF
            call daread(IDAF,IODA,da,l2,418,0)
            call daread(IDAF,IODA,wrk,l2,428,0)
            call daxpy(l2,one,wrk,1,da,1)
          else
            CALL daread(IDAF,IODA,da,l2,irecd,0)
c           Else, where is the beta ROHF density?! Now we read total RHF one?
c           call prtril(da,l1)
          endif
c
          if(totdens) call fmototd(1+ida,l2,da,totd,iaoglob)
          call dumpfock(totfock,wrk,l1,l2,1+ida,da,e1efmo,ekinfmo)
          if(densgrid) then
            call grdbox(ixmin,ixmax,iymin,iymax,izmin,izmax,vdwrad,
     *                  grdpad(2))
            if(spinden) then
              if(urohfi.or.urohfj) then
C               Alpha - Beta 
                call daread(IDAF,IODA,wrk,l3,15,0)
                call DMTX2(da,wrk,na,l1,l1,0)
                call daread(IDAF,IODA,wrk,l3,19,0)
                call DMTX2(db,wrk,nb,l1,l1,0)
                call daxpy(l2,-one,db,1,da,1)
                kdum=-2
                ldum=-2
                call fmoprc(1+ida,1,l2,da,dgrid,1,NXG,1,NYG,1,NZG,
     *                  ixmin,ixmax,iymin,iymax,izmin,izmax,0,0,0,0,0,0,
     *                  ORIGIN,UX,UY,UZ,nsetgrid,griddistr,0,kdum,ldum)
C               Restore Density 
                call daread(IDAF,IODA,wrk,l3,15,0)
                call DMTX2(da,wrk,na,l1,l1,0)
                call daread(IDAF,IODA,wrk,l3,19,0)
                call DMTX2(db,wrk,nb,l1,l1,0)
                call daxpy(l2,one,db,1,da,1)
                call dcopy(l2,da,1,db,1)
             end if
            else
              kdum=-2
              ldum=-2
              call fmoprc(1+ida,1,l2,da,dgrid,1,NXG,1,NYG,1,NZG,
     *                  ixmin,ixmax,iymin,iymax,izmin,izmax,0,0,0,0,0,0,
     *                  ORIGIN,UX,UY,UZ,nsetgrid,griddistr,0,kdum,ldum)
            endif
          endif
          if(spargrid) then
c           Compute the total density on a sparse grid
c           First compute on the grid for fragment J (J<I).
            joff=noffg(jfg)
            kdum=-2
            ldum=-2
            call fmoprc(1+ida,1,l2,da,dgrid(joff,2),indgrd(1,jfg),
     *                  indgrd(2,jfg),indgrd(3,jfg),indgrd(4,jfg),
     *                  indgrd(5,jfg),indgrd(6,jfg),indgrd(1,jfg),
     *                  indgrd(2,jfg),indgrd(3,jfg),indgrd(4,jfg),
     *                  indgrd(5,jfg),indgrd(6,jfg), 0,0,0,0,0,0,
     *                  ORIGIN,UX,UY,UZ,nsetgrid,griddistr,0,kdum,ldum)
c           Now compute on the grid for fragment I excluding J's grid.
            ioff=noffg(ifg)
            kdum=-2
            ldum=-2
            call fmoprc(1+ida,2,l2,da,dgrid(ioff,2),indgrd(1,ifg),
     *                  indgrd(2,ifg),indgrd(3,ifg),indgrd(4,ifg),
     *                  indgrd(5,ifg),indgrd(6,ifg),indgrd(1,ifg),
     *                  indgrd(2,ifg),indgrd(3,ifg),indgrd(4,ifg),
     *                  indgrd(5,ifg),indgrd(6,ifg),indgrd(1,jfg),
     *                  indgrd(2,jfg),indgrd(3,jfg),indgrd(4,jfg),
     *                  indgrd(5,jfg),indgrd(6,jfg),ORIGIN,UX,UY,UZ,
     *                  nsetgrid,griddistr,0,kdum,ldum)
          endif
c
c         the second fmoelmt is dummy
c         if(ijskip.ne.0) goto 315
c
c         call DENDD1(DA,DB,L2)
c         if(scffrg(ifg).eq.uhf.or.scffrg(jfg).eq.uhf) then
c          if(irecd.eq.16) then
c           call daread(IDAF,IODA,wrk,l2,16,0)
c           call daread(IDAF,IODA,da,l2,20,0)
c           call daxpy(l2,one,wrk,1,da,1)
c          else
c           call daread(IDAF,IODA,da,l2,418,0)
c           call daread(IDAF,IODA,wrk,l2,428,0)
c           call daxpy(l2,one,wrk,1,da,1)
c          end if
c         end if
          dele=zero
          if (.not.dftbfl) dele=TRACEP(da,fmoespa,l1)
          if(dftbfl.and.scc) dele=edft(1)
          if(nfmopcm.ne.0) then
            if(maswrk) esolv(nfg*2+ijfg)=(PC-PX)*half
c           IF (ISWNEW1.EQ.1) THEN
c             if(maswrk) esolv(nfg*2+ijfg)= PC-PX
c           ELSE
c             if(maswrk) esolv(nfg*2+ijfg)=(PC-PX)*half
c           END IF
c           efmo gets one many-body solvation energy
c           from the efp total polarization. clear here
            if(iefmorun.gt.0) esolv(nfg*2+ijfg)=0
            if(etot.ne.0) then
              etot=etot-esolv(nfg*2+ijfg)
              if(gcorrel.or.dodc) escf=escf-esolv(nfg*2+ijfg)
            endif
          endif
          eunc=zero
          ecor=zero
          edeld=zero
          if(maswrk.and..not.dftbfl) then
            if(savemem2) then
              if(etot.ne.0) then
                edimsum(1)=edimsum(1)+etot-dele-esd2m1
                ecor=etot-dele
                if(gcorrel) then
                  eunc=escf-dele
                  edimsum(3)=edimsum(3)+eunc-esd2m2
                else if(dodc) then
                  eunc=escf-dele-edisp
                  edimsum(3)=edimsum(3)+eunc-esd2m2
                else
                  eunc=ecor
                endif
                if(ipieda.ne.0) call abrt 
              endif
            else
              edim(ijfg,1)=etot-dele
c         ESCF may not be available. It is safer to use the value from previous
c         iteration (if available). delE is the same for correlated/
c         uncorrelated cases as the density is the same (e.g., MP2 and RHF).
              if(gcorrel) edim(ijfg,3)=escf-dele
              if(dodc) edim(ijfg,3)=escf-dele-edisp
              if(etot.eq.zero) edim(ijfg,1)=zero
              if(ipieda.ne.0) edim(ijfg,nedimex)=
     *                        e0scf(1)-esd2ms-edim(ijfg,nedimes)
c             write(6,*) 'wwwaha',ijfg,e0scf(1),esd2ms,edim(ijfg,nedimes),
c    *                         edim(ijfg,nedimex)
c
            endif
          endif
c
c         if(nbsse.eq.3) CALL dawrit(IDAF,IODA,da,L2,16,0)
c             CALL dawrit(IDAF,IODA,fmoespb,L2,16,0)
c         if(nbsse.eq.0.or.nbsse.eq.3) then
          if(dftbfl) then
            if(maswrk) then
              if (.not.scc) then
                edft(2) = zero
                dele = zero
              end if
              if(maswrk.and..not.lowdimer) enucfmo=enucfmo+enucr-enuc0ij
              ecor=etot-dele
              if(savemem2) then
                edimsum(1)=edimsum(1)+ecor-esd2m1
              else
                edim(ijfg,1)=ecor
              endif
              eunc=ecor
c             edim(ijfg,2)=dele-edij(ifg,jfg)-edij(jfg,ifg)
c             NB: NCC-DFTB will not work with D?
C             if(scc) then
                if(savemem2) then 
                  edeld=edft(2)
                  edimsum(2)=edimsum(2)+edeld
                  if(dodc) then
                     eunc=escf-dele-edisp
                     edimsum(3)=edimsum(3)+eunc-esd2m2
                  endif
                else
                  if(reducee) then
                    edim(ijfg,1)=edim(ijfg,1)+edft(2)
                    edeld=edft(2)
                    if(dodc) eunc=escf-dele-edisp
                  else
                    edim(ijfg,2)=edft(2)
                    if(dodc) edim(ijfg,3)=escf-dele-edisp
                  endif
                endif
C             endif
              if(etot.eq.zero.and..not.savemem2) edim(ijfg,1)=zero
            endif
          else
          if(usedij) then
c           dij holds DI+DJ, subtract from DIJ
c           call daxpy(l2,-one,dij,1,da,1)
            call vsub(dij,1,da,1,db,1,l2)
c           db holds DIJ-DI-DJ
c           dont do this for efmo, it is handled elsewhere
            if(maswrk.and.iefmorun.eq.0) then
              edeld=TRACEP(db,fmoespa,l1) 
              if(savemem2) then
                edimsum(2)=edimsum(2)+edeld
              else
                edim(ijfg,2)=edeld
              endif
c             e1efmo=e1efmo+(1+ida)*edim(ijfg,2)
            endif
c           if(needdm) then
c             call GDDI_PUT(iddm,ijfg,l2,db)
c             if(maswrk) job2grp(ijfg)=meglob+nprocg
c           endif
            if(fmoq.or.needdm) then
              l2all=l2
c             l2all should be max(L){l2(L)}, the max value over layers:
c             now MFMOQ FMO3/ESapp must have the same basis set.
              CALL rawrites(IDAcFMO,iodcfmo,db,l2all,l2,ijfg,0)
              if(maswrk) job2grp(ijfg)=l1*npglob+mygroup
c             write(6,*) 'wwwdens',ijfg
c             call prtril(db,l1)
            endif
c           write(6,*) 'wwwdens',ijfg
c           call prtril(db,l1)
c
            if(doddcori) then
c             one has to toil constructing DI+DJ again, this time correlated.
c             We do not want any orbitals or energies so set the options to .f.
c             call DENDD1(dij,dij(1+l2),L2)
              CALL daread(IDAF,IODA,dij,l2,16,0)
c             write(6,*) 'read dimer density from ',16
c             call prtril(dij,l1)
c             delec=TRACEP(dij,fmoespa,l1)
c             It is probably a bug to set orbxch to .false. below.
              call diminid(0,jfg,ifg,l1j,l1i,l0j,l0i,naj,nai,nbj,nbi,l1,
     *                     da,db,wrk,wrk1,iodfmo,irec0cor,iabdfg,jabdfg,
     *                     indat,iaglob,locfmo,mapj,mapi,.false.,.false.
     *                    ,.false.,.false.,iu,untrot(1,1,iu),0,
     *                     scffrg(jfg).eq.uhf,scffrg(ifg).eq.uhf,
     *                     mulfg,some)
c             da holds correlated DI+DJ, dij holds correlated DIJ.
c             put DIJ-DI-DJ into db.
              call vsub(da,1,dij,1,db,1,l2)
C
C             FIX MP2 DENSITY DESTROYED IN DIMINID
C
              CALL DAWRIT(IDAF,IODA,DIJ,L2,16,0)
C
c             write(6,*) 'den'
c             call prtril(dij,l1)
c             write(6,*) 'V'
c             call prtril(fmoespa,l1)
              if(maswrk) then
                edeldc=TRACEP(db,fmoespa,l1) 
                if(savemem2) then
                  edimsum(4)=edimsum(4)+edeldc
                else 
                  edim(ijfg,4)=edeldc
                endif 
              endif 
              if(nbsse.ne.0) CALL daread(IDAF,IODA,da,l2,irecd,0)
c             the BSSE code although not really ready for doddcor is expecting
c             to find the dimer density in DA.
c             correct E'(MP2) for dimers:
c             it is up to now: EMP2-Tr(D(RHF)V)
c             it should be:    EMP2-Tr(D(MP2)V)
c             dele contains Tr(D(RHF)V), delec contains Tr(D(MP2)V)
c
c             This is the latest fix to replace the delta-D (MP2) by RHF.
c             To put back, uncomment the edim(ijfg,1) assignment below.
c
c             if(maswrk) edim(ijfg,1)=edim(ijfg,1)+dele-delec
            endif
            if(dopleda) then
c             construct (DIJ-DI-DJ) for PL0 densities and compute its trace
c             with VIJ. Store this in edim(*,4), overwriting those values
c             which are set if doddcor. Note that edim(*,4) in doddcor
c             although computed, is not used for anything.
              if(maswrk) edim(ijfg,4)=TRACEP(da,fmoespa,l1)
              call diminid(0,jfg,ifg,l1j,l1i,l0j,l0i,naj,nai,nbj,nbi,l1,
     *                     da,db,wrk,wrk1,iodfmo,irec0cor,iabdfg,jabdfg,
     *                     indat,iaglob,locfmo,mapj,mapi,orbxch,.false.,
     *                     .false.,.false.,iu,untrot(1,1,iu),0,
     *                     scffrg(jfg).eq.uhf,scffrg(ifg).eq.uhf,
     *                     mulfg,some)
              if(maswrk) edim(ijfg,4)=edim(ijfg,4)-TRACEP(da,fmoespa,l1)
c             write(6,*) 'wwwhi',edim(ijfg,4)
            endif
          endif
          end if
          if(maswrk.and.mdoutmin) then
            if(savemem2) then
              if(correl.or.dodc) write(iw,9110) ifg,jfg,ecor
              write(iw,9100) ifg,jfg,eunc,edelD
            else
            if(correl.or.dodc) then
              write(iw,9110) ifg,jfg,edim(ijfg,1)
              if (reducee) then
                write(iw,9100) ifg,jfg,eunc,edelD
              else
                write(iw,9100) ifg,jfg,edim(ijfg,3),edim(ijfg,2)
              end if
            else
              if(reducee) then
                write(iw,9100) ifg,jfg,edim(ijfg,1),edelD
              else
                write(iw,9100) ifg,jfg,edim(ijfg,1),edim(ijfg,2)
              endif
            endif
            endif
          endif
  430     continue
c
c       Compute BSSE corrections
c
          if(nbsse.ne.0) then
            ifmostp=5
c           MCONV=mcnvfmo(ifmostp)
c           -1 should be replaced by mconfg for that fragment.
            call fmoconv(mcnvfmo(ifmostp),-1,l1,wrk,enexch,orbxch,
     *                   .false.,.false.,fordir)
c           if doing vaccuum BSSE rerun dimer in vaccuum
c           if(nbsse.eq.3) then
c             if(maswrk) write(iw,9005) ifg,jfg
c             CALL BRNCHX(RUNTYP)
c             edim(3,ijfg)=etot
            if(nbsse.ne.3) then
              call dcopy(l2,da,1,dij,1)
              if(maswrk) edim(ijfg,5)=edim(ijfg,1)
            else
              if(maswrk) edim(ijfg,5)=zero
            endif
c           the following is used below: ifg >= jfg
c           this is why jfg must be run first (ij.eq.1)
            do ij=1,2
              if(maswrk.and.ij.eq.1) write(iw,9010) scftyp,jfg,ifg
              if(maswrk.and.ij.eq.2) write(iw,9010) scftyp,ifg,jfg
              if(ij.eq.1) then
                icurfg=jfg
                jcurfg=ifg
                scftyp=scfi
              else
                icurfg=ifg
                jcurfg=jfg
                scftyp=scfj
              endif
              kcurfg=0
              call makesbs(ij,icurfg,zsave,nesav,indat,iaglob)
c
c             Initial guess density
c
              call diminid(ij,jfg,ifg,l1j,l1i,l0j,l0i,naj,nai,nbj,nbi,
     *                     l1,da,db,wrk,wrk1,iodfmo,irec0,iabdfg,jabdfg,
     *                     indat,iaglob,locfmo,mapj,mapi,orbxch,enexch,
     *                     jodexch,iodexch,iu,untrot(1,1,iu),0,
     *                     scffrg(jfg).eq.uhf,scffrg(ifg).eq.uhf,
     *                     mulfg,some)
c
              call fmosdir(0,fmodscf,fmodtrf)
c             CALL BRNCHX(RUNTYP)
c             it is possible to compute BSSE gradient. But for now only energy
c             (that is, gradient is computed without BSSE).
              CALL BRNCHX(energy)
              call fmosdir(1,fmodscf,fmodtrf)
c
              if(nbsse.ne.3) then
                call DENDD1(DA,DB,L2)
                if(maswrk)
     *            edim(ijfg,5)=edim(ijfg,5)-(etot-TRACEP(da,fmoespa,l1))
c               dij holds DIJ, substract DI and DJ
                call daxpy(l2,-one,da,1,dij,1)
              else
c               edim(5) contains the sum of I and J energies in the I+J basis
                if(maswrk) edim(ijfg,5)=edim(ijfg,5)+etot
              endif
            enddo
c           dij holds DIJ-DI-DJ
            if(nbsse.ne.3.and.usedij.and.maswrk)
     *        edim(ijfg,6)=TRACEP(dij,fmoespa,l1)
          endif
c 315     continue
          if(nfmopcm.ne.0) then
            call stopwa(7,0)
            if(nfmopcm.gt.1.and.dovpcm) then
              ida=1
              if(nfmopcm.gt.2) ida=ida-ndtfrg(ijfg,1)
              fda=-ida
              call EPOTEN(fda,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),PEL,
     *                    da,NTS,L2)
            endif
            call stopwa(7,1)
          endif
          if(ndftfg.eq.1.and.maswrk) then
            fda=1+ida
            call daxpy(nedft,fda,edft,1,etotdft,1)
          endif
c
          IF( IEFMORUN.GT.0.AND.IEFMORT.EQ.3.AND.MASWRK ) THEN
C            IEFMODIMER = -1
          ENDIF
c
c         accumulate gradient
c
c         if(nbody.eq.2) ida=0
c         ida=ida+1
          idad=1
          if(ilay.eq.1.and.ext2lay) idad=idad+nddfrg(ijfg)
C
C         HOP CONTRIBUTION TO GRADIENT
C
          if(hopgrd) then
c           call daread(IDAF,IODA,da,L2,16,0)
c           if((ifg.eq.iexcit(1).or.jfg.eq.iexcit(1)).and.(rij.le.rcorsd
c    *         .or.rcorsd.eq.0).and..not.skipc) then
c            call daread(IDAF,IODA,da,L2,308,0)
c            CALL dawrit(IDAF,IODA,da,L2,16,0)
c           endif
            CALL HOPDER(0,0,idad,idad+ida,L1,L2,DA,
     *                  DA(L2+1),DB(L2+1),FMOFCM)
          END IF
c
          if(nder.gt.0.and.runtyp.ne.energy.and.maswrk) then
c     adding 2 body QM grad
            if(idad.ne.0) call fmodeg(idad,fmode(1,1,2),fmopg,iaglob)
            if(nbody.gt.2.and.idad+ida.ne.0)
     *        call fmodeg(idad+ida,fmode(1,1,3),fmopg,iaglob)
            if(nbody.eq.2.and.ext2lay)
     *        call fmodeg(1,fmode(1,1,3),fmopg,iaglob)
c             effectively, this is always ilay=2 (since nbody(1)=3,2)
            IF (IEFPFMO.NE.0) THEN
              CALL EFPDEG(1,2)
              if(nbody.gt.2.and.1+ida.ne.0) CALL EFPDEG(1+ida,3)
            ENDIF

          endif
C
C           POLARIZATION OF SOLUTE DUE TO DENSITY CHANGE
C
          IF (IEFPFMO.EQ.2) THEN
c           avoid destroying NO 16
            CALL daread(IDAF,IODA,DIJ,l2,16,0)
            call diminid(0,jfg,ifg,l1j,l1i,l0j,l0i,naj,nai,nbj,nbi,l1,
     *                   DA,db,wrk,wrk1,iodfmo,irec0,iabdfg,jabdfg,indat
     *                  ,iaglob,locfmo,mapj,mapi,orbxch,enexch,jodexch,
     *                   iodexch,iu,untrot(1,1,iu),0,
     *                   scffrg(jfg).eq.uhf,scffrg(ifg).eq.uhf,
     *                   mulfg,some)
            CALL dawrit(IDAF,IODA,DIJ,l2,16,0)
            call daxpy(l2,-one,da,1,dij,1)
c           always uses the RHF density
            CALL DAREAD(IDAF,IODA,DA,l2,IRECD,0)

            CALL DAREAD(IDAF,IODA,FMOESPA(L2+1),L2,89,0)
            TMP2FOCK=TRACEP(DIJ,FMOESPA(L2+1),L1)
            EADA = IDAD
            IF (IEABDY.GT.2) EADA = IDAD + IDA
            IF (MASWRK) THEN
              EADA = EADA * 0.5D+00
              ALCNT2F(IFG) = ALCNT2F(IFG) + TMP2FOCK*EADA
              ALCNT2F(JFG) = ALCNT2F(JFG) + TMP2FOCK*EADA
            END IF
          END IF
C
          IF (IEACAL.EQ.1) THEN
c           CALL daread(IDAF,IODA,DIJ,l2,irecd,0)
c           avoid destroying NO 16
            CALL daread(IDAF,IODA,DIJ,l2,16,0)
            call diminid(0,jfg,ifg,l1j,l1i,l0j,l0i,naj,nai,nbj,nbi,l1,
     *                   DA,db,wrk,wrk1,iodfmo,irec0,iabdfg,jabdfg,indat
     *                  ,iaglob,locfmo,mapj,mapi,orbxch,enexch,jodexch,
     *                   iodexch,iu,untrot(1,1,iu),0,
     *                   scffrg(jfg).eq.uhf,scffrg(ifg).eq.uhf,
     *                   mulfg,some)
            CALL dawrit(IDAF,IODA,DIJ,l2,16,0)
            call daxpy(l2,-one,da,1,dij,1)
c           CALL daread(IDAF,IODA,DA,l2,16,0)
c           always uses the RHF density
            CALL DAREAD(IDAF,IODA,DA,l2,IRECD,0)
            IF (IEABDY.EQ.2) IEADA2 = IDAD
            IF (IEABDY.GT.2) IEADA2 = IDAD + IDA
            IEADA = 1
            CALL CALCIEA(L1,L2,DA,DIJ,2,IEADA2)
          END IF
C
C         new FMO/EFP
C
          IF (IEFPFMO.EQ.2) THEN
            IDAEFP = IDAD
            IF (NBODY.GT.2) IDAEFP = IDAD + IDA - 1
            CALL GETABFLDT(0,1,IDAEFP,L1,L2,ABFLDT,DINDF2,DINDDF2,DA,DB,
     *                     NDER.GT.0.AND.RUNTYP.NE.ENERGY)
            IF (MPLEVL.EQ.2) THEN
              IF (NBODY.GT.2) IDAEFP = IDAEFP + 1
              CALL GETABFLDT(1,0,IDAEFP,L1,L2,ABFLDT,DINDF2,DINDDF2,
     *                       DA,DB,NDER.GT.0.AND.RUNTYP.NE.ENERGY)
            END IF
          END IF
C
C         For FMO/PCM<1> grad
C
          IF (NDER.GT.0.AND.RUNTYP.NE.ENERGY.AND.ISWNEW1.EQ.1) THEN
            IDAPCM1 = IDAD
c           IF (NBODY.GT.2) IDAPCM1 = IDAD+IDA-1
            IF (NBODY.GT.2) IDAPCM1 = IDAD+IDA
            FDA = -IDAPCM1
            IF (IDAPCM1.NE.0)
     *      CALL WRAPEPOT(0,FDA,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),
     *                    DA,DB,NTS,L2,mappcm)
            IF (MPLEVL.EQ.2) THEN
              IF (NBODY.GT.2) IDAPCM1 = IDAPCM1 + 1
              FDA  = -IDAPCM1
              IF (IDAPCM1.NE.0)
     *        CALL WRAPEPOT(1,FDA,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),
     *                      DA,DB,NTS,L2,mappcm)
            END IF
          END IF
C
          if((urohfi.or.urohfj).and.urospn) then
c           write(6,*) "wwwcheck=",scal,ijfg
c           for dimer ifg,jfg compute spin transfer from ifg to jfg.
            call fmocalspinchg(ifg,da,db,pmulspin,l1,iaglob,indat,
     *           1.0D+00,2,ctspin,imect)
            pmulspin(ijfg+natfmo*2)=ctspin
          end if
C
C
          IF (NDER.GT.0.AND.RUNTYP.NE.ENERGY.AND.
     *       IAND(MODGRD,2).NE.0)                THEN
            if(.not.dopbcmd .or. iu.eq.0) then
c             if((ifg.eq.iexcit(1).or.jfg.eq.iexcit(1)).and.(rij.le.rcorsd
c    *           .or.rcorsd.eq.0).and..not.skipc) then
c              call daread(IDAF,IODA,da,L2,308,0)
c              CALL dawrit(IDAF,IODA,da,L2,16,0)
c             endif
              IESD3B = 0
              IF (NBODY.GT.2) IESD3B = IDAD+IDA
              IF(nder.ne.2)
     *        CALL FMOESDER(l1,l2,da,layfrg,scffrg,idmrec0,da,wrk1,
     *                      mapi,mapj,mapi,1,irec0, IDAD,IESD3B,
     *                      orbxch,enexch,.false.,jodexch,iodexch,
     *                      ZVLAG,IPTLG,NQMTFG,loadhf,clm,flm,f_mm,g_mm,
     *                      crfrg,Ylmfrgq,Ylmfrgq2)
            endif
          ENDIF
C
          if(nder.eq.2.and..not.dftbfl) call vclr(FCMWRK,1,neh)
          if(nder.eq.2.AND.IAND(MODGRD,2).NE.0) then
c           if(isgddi) call gddi_scope(ddi_group)
            !IEEH is only for FMO-DFTB
            IEEH = IDAD
            IF (NBODY.GT.2) IEEH = IDAD + IDA
            CALL FMOESHSS(l1,l2,da,scffrg,idmrec0,da,wrk1,
     *           mapi,mapj,mapi,1,irec0, orbxch,enexch,.false.,
     *           jodexch,iodexch,NQMTFG,YALAG,IPTYA,YAWRK,FCMWRK,
     *           numfrg,modfd,FCMWRK(NC1*NC1+1),NC1,IEEH)
            IF(GOPARR.AND..NOT.DFTBFL) CALL DDI_GSUMF(2418,FCMWRK,neh)
          end if
C         Hessian contribution
C
          IF (NDER.EQ.2.AND.RUNTYP.NE.ENERGY) THEN
            IEEH = IDAD
            IF (NBODY.GT.2) IEEH = IDAD + IDA
            nc2 = max(nc1,nat*3)
            IF (DFTBFL) THEN
              CALL FMODEH(IEEH,FCMWRK(NC2*NC2+1+NAT),
     *                    fmoddm,FMOFCM,FMOPG,IAGLOB,nc1,indat,layfrg,
     *                    FCMWRK(NC2*NC2+1),-1)
            ELSE
              CALL FMODEH(IEEH,FCMWRK,fmoddm,FMOFCM,FMOPG,IAGLOB,
     *                    nc1,indat,layfrg,FCMWRK(NC2*NC2+1),0)
            END IF
          END IF
C
          IF (IEFPFMO.NE.0.AND.NDER.GT.0) CALL DEFPCLR
c
          if(npunch.ne.0.and.PLTORB) CALL PLTMEM
c
c         save data for restarts
c         synchronise the format with edin
c
  440     continue
c
c         finish up efmo gradient
          IF( IEFMORUN.GT.0 .AND. MASWRK .AND. IEFMORT.EQ.3.AND.
     *        NDER.GT.0) THEN
c$$$ this adds or subtracts to the gradient, depending on idimtyp
c$$$ if it's a long-range dimer (using EFP terms) it's added, and
c$$$ idimtyp is 1. if it's a short range term, then only polarization
c$$$ is calculated, and it's subtracted (idimtyp=-1)
            CALL EFMODEG(IDIMTYP,FMODE(1,1,2),IEFMOIGLOB,EFMODIMG)
C            CALL EFMODEG(IEFMODIMER,FMODE(1,1,2),IEFMOIGLOB,EFMODIMG)
          ENDIF
          if(savgrd) call grdrst(1,nfthes,ngrdsiz,fmode,nelmsiz,fmoelm,
     *         nesdsiz,isdrec,lie,IDAFMO,ndar30,NDAR30f,iodfmo,icanuse1)
  445     continue
          if(outpune) then
            write(ip,9210) ifg,jfg,ilay,(edim(ijfg,ien),ien=1,nen)
          endif
c         if(lowdimer) then
          if(fullmfmo3.and.ilay.eq.1.and.maswrk) then
            edimlow(ijfg,1)=edim(ijfg,1)
            edimlow(ijfg,2)=edim(ijfg,2)
            if(correl.or.dodc) edimlow(ijfg,3)=edim(ijfg,3)
            if(lowdimer) then
              edim(ijfg,1)=edim1sav
              edim(ijfg,2)=edim2sav
              if(nen.gt.2) edim(ijfg,3)=edim3sav
c             Only element 1 should be restored to avoid double counting.
c             Elements 2 and 3 need not be, but are done "just in case".
            endif
          endif
c
  450   continue
        if(dolat.or.dopbcmd) then
          call dcopy(3*natfmob,untxyz,1,cfrg,1)
          call monbsr(nat0,ich0,mul0,num0,nqmt0,ne0,na0,nb0,nsh0,ngau0
     *          ,enucr0,nat,ich,mul,num,nqmt,ne,na,nb,nshell,ngau,enucr)
        endif
        njfg=nfg
  500 continue
      enddo
  590 continue
c
  600 continue
      if(mdoutmin) call timit(1)
      call stopwa(16,0)
      CALL TSECND(TIMe0)
      wall0=wall
      if(isgddi) call GDDICOUNT( 1,lgroup,myjob)
      CALL TSECND(TIMe1)
      call stopwa(16,1)
      if(maswrk.and.mdoutmin) write(iw,9600) 'Dimer',ilay,wall-wall0
      if(outpune) write(ip,9200) END
cpbc
c     restore the original atomic coordinates
c---  if(dopbcmd) call genfrgmic(0,1)
      if(dopbcmd) call genimagefg(1,0)
c     if(dopbcmd) then
c       call makeindexiu(ilay,loadhf,loadm,indat,fmozan,
c    *                   fmoc,iabdfg,jabdfg,scffrg,
c    *                   needr0,rrij,rwrk,mfg2,vdwrad,
c    *                   nprfrg,isgddi,nunptc,natfmob,untxyz,
c    *                   units,indxiu,.false.)
c     endif
c
      if(iand(ixesp,1024).ne.0) ixesp=ixesp-1024
c
      IF (DFTBFL.AND.ESDFL) call lumpesd(nder,loadhf,nfg2,nes,nscf,
     *  ndimscf,nesdim3,nfg2d,iifg,edisnrg,gcorrel,dodc,reducee,
     *  ESDIMTMP,edim,loadd,savemem2,savememr,edimsum,rrij,nrij,
     *  wrk,wrk1,mdoutmin)
      IF (DFTBFL.AND.NDER.EQ.2) THEN
        IF (MASWRK) THEN
          CALL SYMTRZE(FMOFCM,NC1,NC1)
        ELSE
          CALL VCLR(FMOFCM,1,NC1*NC1)
        END IF
      END IF
c
c     finish up separated dimer gradients.
c
c     idmrec0 is not flipped: FMO/FD will not handle MP2 in L1
c     write(6,*) 'Lagrangian frg2 before esdgrd',ZVLAG(41),ZVLAG(42)
      if(esd.and.iefmorun.eq.0.and.nder.ne.2.and..not.dftbfl) then
        if(mdoutmin) call timit(1)
        call esdgrd(ilay,loadhf,jobgrp,loadm,layfrg,numfrg,iodfmo,
     *                    maxl30,iaglob,scffrg,ngrfmo,mannod,mastid,da,
     *                    fmoespa,fmoespb,wrk,fmode,fmopg,isdrec,
     *                    orbxch,irec0,irec1,dodistr,NQMTFG,IPTLG,ZVLAG,
     *                    ZVWRK,dopbcmd,irmdfmo)
      endif
C
      IF (NDER.GT.0.AND.DFTBFL.and.scc.AND.NBODY.EQ.2) THEN
        CALL DFTB_FMOGRAD(LAYFRG,FMODE,IDMREC0,NUMFRG,IODFMO,ORBXCH,
     *                    FMOFCM,MODGRD,mdoutmin)
      END IF
      if(iand(modfmm,8).ne.0) then
        if(isgddi) call gddi_scope(ddi_world)
        call DDI_gsumf(2423,ylmfrgq2,(NP+1)*(NP+2)*nfg)
        if(isgddi) call gddi_scope(ddi_group)
        call esp1gmm(ilay,ncentm,clm,flm,f_mm,g_mm,crfrg,popmat,ylmfrgq2
     *              ,FMODE(1,1,2),fmopg,iaglob,layfrg,loadhf,loadm)
      endif
C
      IF (NDER.GT.0.AND.NBODY.EQ.2.) THEN
        if(doddcor.and.iand(ixesp,1024).eq.0) ixesp=ixesp+1024
C
C       REMAINING TERMS IN FMO/EFP AND FMO/PCM<1>
C
         DUM = ZERO
        IDUM = 0
        IF (IEFPFMO.EQ.2.AND..NOT.DFTBFL) THEN
          CALL DNEWIND2(0,ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,IDUM,DUM,
     *                  FMODE(1,1,2),ORBXCH,NUMFRG,IODFMO,
     *                  LAYFRG,SCFFRG,ISGDDI,IREC0,NGRFMO,MANNOD,MASTID,
     *                  NQMTFG,DUM,DUM,DUM,DUM)
        END IF
        IF (ISWNEW1.EQ.1) THEN
          CALL FMOPCMREMD(0,NTS,ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,
     *                    IDUM,DUM,FMODE(1,1,2),ORBXCH,NUMFRG,
     *                    IODFMO,LAYFRG,SCFFRG,IREC0,
     *                    NGRFMO,MANNOD,MASTID,NQMTFG,mulfg,
     *                    lfmasc,needasc,needmul,mappcm)
        END IF
C
C       FMO CPHF CALCULATION: SELF-CONSISTENT Z-VECTOR METHOD
C
        ifmostps = ifmostp
        ifmostp  = 4
          IF( IEFMORUN.GT.0 .AND.
     *        iefmo_agrad .gt. 0) THEN

c$$$ does dipole derivative contributions and polarizability contributions
           if(maswrk) write(*,*) "about to call efmo_dipder_grad"
              if( (iand(imodefer,1) .ne. 0)
     *            .or. (iand(imodefd,1) .ne. 0)
     *            .or. (.not.(iand(imodefp,1) .ne. 0)) ) then
              call efmo_dipder_grad( IPTLG,ZVLAG,
     *            FMODE(1,1,2),IEFMOIGLOB,EFMODIMG, isgddi, ilay,
     *                NGRFMO,MANNOD,MASTID, irec0, loadhf, loadm,
     *                iodfmo,irmdfmo)
           endif
           if(maswrk) write(*,*) "about to call efmo_sec_order_ti"
c$$$ does second order time-independent cphf contrib. need efmo_scphf to be full
              if( .not.(iand(imodefp,1) .ne. 0) ) then
           CALL efmo_sec_order_ti_resp_wrap(ILAY,LOADHF,LOADM,DA,
     *                FMODE(1,1,2),
     *                  NUMFRG,IODFMO,LAYFRG,SCFFRG,ISGDDI,
     *                  IREC0,NGRFMO,MANNOD,MASTID,NQMTFG,IPTLG,mulfg,
     *                 irmdfmo)
           endif
           if(maswrk) write(*,*) "about to call secord_disp"
c$$$ let's try second order cptdhf for dispersion. need efmo_scptdhf to be full
          if( iand(imodefd,1) .ne. 0 ) then
             call efmo_secord_disp(ILAY,LOADHF,LOADM,FMODE(1,1,2),
     *            NUMFRG,IODFMO,LAYFRG,SCFFRG,ISGDDI,
     *            IREC0,NGRFMO,MANNOD,MASTID,NQMTFG,IPTLG,irmdfmo)
          endif

c$$$ does cpl solving and fock derivative solving (all occ_occ_resp 
c$$$ should be before this, and all contributions to cpl_contrib)
              if( (iand(imodefer,1) .ne. 0)
     *            .or. (iand(imodefd,1) .ne. 0)
     *            .or. (.not.(iand(imodefp,1) .ne. 0)) ) then
           CALL efmo_cpl_and_fock(ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,
     *                  FMODE(1,1,2),NUMFRG,
     *                  IODFMO,SCFFRG,ISGDDI,IREC0,
     *                  NGRFMO,MANNOD,MASTID,NQMTFG,irmdfmo)
         endif

      endif
 
        if (iand(modgrd,8).ne.0.and.resppc(1).ne.zero
     *      .and..not.dftbfl) then
          CALL ESPPCDER(0,ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,
     *                  DUM,FMODE(1,1,2),ORBXCH,NUMFRG,
     *                  IODFMO,LAYFRG,SCFFRG,ISGDDI,IREC0,
     *                  NGRFMO,MANNOD,MASTID,NQMTFG,mulfg,irmdfmo)
        end if
        IF (IAND(MODGRD,32).NE.0) THEN
c$$$ does first order z-vector response

          CALL ESDCPHFX(ILAY,LOADHF,LOADM,DA,WRK,DB,ZVLAG,FMODE(1,1,2),
     *                  NUMFRG,IODFMO,IDMREC0,LAYFRG,SCFFRG,
     *                  IREC0,NGRFMO,MANNOD,MASTID,NQMTFG,IPTLG,hopgrd,
     *                  nevsav,XYZCTS,mulfg,dopbcmd,PEL,lfmasc,needasc,
     *                  needmul,mappcm,irmdfmo,mdoutmin)
        END IF
        ifmostp  = ifmostps
        if(iand(ixesp,1024).ne.0) ixesp=ixesp-1024
      END IF
C
c
c     exchange dimer job indices.
c
c     if(needdm.and.isgddi) then
c       call gddi_scope(ddi_world)
c       call ddi_gsumi(2418,job2grp,nfg2)
c       call gddi_scope(ddi_group)
c       write(6,*) 'job2grp',(job2grp(i),i=1,nfg2)
c     endif
      if(needdm.and.isgddi)
     *  call ddexch(ilay,nfg2,job2grp,layfrg,IDAcFMO,iodcfmo,mastid,da)
      if(desperate) then
        if(isgddi) then
          call gddi_scope(ddi_world)
          idum=0
          call DDI_nsumi(2423,ndesper,nodesper,idum,idum,2)
          call gddi_scope(ddi_group)
        endif
        if(maswrk) write(iw,9320) ndesper,nodesper
c       if(nodesper.ne.0) call abrt
      endif
      ifmodim=1
      if(mdoutmin) call timit(1)
      return
 9000 format(/1x,A8,' dimer',2I7,' corr= ',A11,', LL1=',I6,' ID=',I14)
 9002 format(/1x,A8,' dimer',2I6,'(',I6,')',' corr= ',A11,' LL1=',I6,
     *              ' ID=',I12)
 9005 format(/1x,'Resetting LABSIZ=',2I2,/)
 9007 format(1x,'Int dimensions: LABSIZ=',I1,', NINTIC=',I9,
     *          ' ININTIC=',I9)
c9005 format(/1x,'Running energy for dimer ',2I4,' in vaccuum',/)
 9010 format(/1x,'Running ',A8,' energy for monomer',I5,
     *           ' including the basis set for fragment',I5/)
 9020 format(/1x,'energy of the separated ',a1,'imer',2I5,', L1=',I5,
     *           ' is',F20.9/)
 9021 format(/1x,'energy of the separated ',a1,'imer',2I5,', IU=',I5,
     *           ' L1=',I5,' is',F20.9/)
 9050 format(/1x,'No electron correlation for the dimer',2I5/)
 9100 format(/1x,' iFrag=',I7,' jFrag=',I7,' EFMOu=',F16.9,' Tr=',F12.9)
 9110 format(/1x,' iFrag=',I7,' jFrag=',I7,' EFMOc=',F16.9)
 9200 format(a8)
 9203 format(1x,'Using tighter ICUT=',I2)
 9210 format(1x,2I5,I3,3F22.10,2(/14x,3F22.10))
c9215 format(1x,2I5,I3,3F22.10,/14x,3F22.10)
 9299 format(//1x,'Dropping state from RMD, printing coordinates ',
     *             'and fragmentation scheme.'/)
 9300 format(/1x,'Trying desperately the alternative SCF converger.')
 9310 format(/1x,'Despite trying desperately, SCF did not converge.')
 9320 format(/1x,'Desperately converged',I5,', diverged',I5,' dimers.',
     *           /)
 9400 format(/1x,'Gradient requires converged SCF.',/)
 9500 format(/1x,'Running out of time...',/)
 9600 format(/1x,A5,' synchronisation for layer',I2,' took',F8.1,' s.')
      END
C*MODULE fmo     *DECK esdim
C
C     @brief ES dimer energy
C
C     @details Calculate ES dimer energy.
C
C     @author Dmitri Fedorov
C
      subroutine esdim(nder,iifg,jjfg,edimij,rij,iilay,jjlay,irec0i,
     *                 irec0j,idmrec,layfrg,iodfmo,maxl30,scffrg,da,fa,
     *                 db,fb,isdrec,orbxch,dodistr,clm,flm,f_mm,g_mm,
     *                 crfrg,ylmfrg,mmdim,nfg2,ndtfrg,dodcesd,wrk1,
     *                 iaglob,fmode,fmopg,FCMWRK,NQMTFG,YALAG,IPTYA,
     *                 numfrg,Xlfmobuf1,NC1,dopbcmd,untxyz,cfrg,
     *                 natfmob,nunptc,iunit,dofret,iexcit)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Parameter(MXRT=100,MXATM=2000,zero=0.0D+00,one=1.0D+00,MaxNp=45)
      LOGICAL dosap,dospc,orbxch,odexch,full2e,esdder,dodistr,GOPARR,
     *        DSKWRK,MASWRK,QOPS,QFMM,dodcesd,dopbcmd,dofret
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /FMCOM / X(1)
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /QMFM  / SIZE,EPS,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo,ifmobas,itmfmo(2)
      complex*16 Ylmfrg(((NP+1)*(NP+2))/2,ncentm,nfg)
      dimension idmrec(*),layfrg(*),iodfmo(*),maxl30(*),scffrg(*),da(*),
     *          fa(*),db(*),fb(*),isdrec(*),crfrg(4,ncentm,nfg),t(3),
     *          CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),ndtfrg(nfg2,2),
     *          F_mm((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G_mm((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          wrk1(*),iaglob(*),fmode(3,*),fmopg(3,*),FCMWRK(*),
     *          NQMTFG(*),YALAG(*),IPTYA(*),numfrg(*),Xlfmobuf1(*),
     *          untxyz(3,natfmob,0:nunptc+1),cfrg(3,*),iexcit(5)
      DATA rmc/8HMCSCF     /,uhf/8HUHF     /
c
c     compute energies of the separated dimer iifg,jjfg
c     Most work is done with monomer basis sets/coordinates.
c     parstat: GroupFull
c     For gradients runs Schwarz screening is less dense (more integrals are
c     computed compared to energy runs) due to simultaneously contracting two
c     densities (for each monomer in the dimer), thus very minor differences
c     in energies (with and without gradients) may be observed.
c
      IF(dofret) THEN
        edimij=Zero
        irec0=irec0i
c       if(MASWRK) write(6,'("Enter fret")')
        CALL EXC_FRET(scffrg,irec0,numfrg,NQMTFG,X(LZVLAG),X(LIPTLG),
     *       iifg,db,jjfg,Xlfmobuf1,edimij,edipint,iexcit)
c       if(MASWRK) write(6,'("running fret ",2F12.7)') edimij,edipint
        return
      END IF
c
      ifmostp=6
c
c     Before calling FMM, set the maximum error.
c
c     EPS=1.0D-10
      mmdim=0
      if(modfmm.ne.0) then
c
c       Ylm are defined elsewhere (as Ylmfrg) with NP used to compute its
c       leading dimension.
c       Therefore, the same NP from QMFM should be used to define Ylm,
c       although one can use a different one for calculations (NPs).
c
c       if too short: calculate exactly elsewhere
c
        call mmdist(iifg,0,0,jjfg,t,radius,ty2z,ratio,mmdim)
c
        if(mmdim.eq.1) then
c
C         We should also implement the following very fast idea but for the
c          moment let just nps=np.
c
C         USE VERY FAST MULTIPOLE IDEA
c
          nps=int(log10(EPS*abs(ty2z-radius))/log10(ratio)-1.0d+00)
          if (nps.gt.np) then
             IF (MASWRK) WRITE(IW,9000) np,nps
             call abrt
          endif
c
          if (ncentm.gt.1) then
          call esdimfmm_m(iifg,jjfg,iilay,
     *                  crfrg(1,1,iifg),crfrg(1,1,jjfg),clm,flm,f_mm,
     *                 g_mm,nps,t,ty2z,ylmfrg(1,1,iifg),ylmfrg(1,1,jjfg)
     *                 ,dedimij)
          else
          call esdimfmm(iifg,jjfg,iilay,
     *                  clm,flm,f_mm,g_mm,nps,
     *                 t,ty2z,ylmfrg(1,1,iifg),ylmfrg(1,1,jjfg),dedimij)
          endif
          edimij=edimij+dedimij
c         if(maswrk) write(6,*) jjfg,iifg,'FMM dEij=',dedimij
          return
        endif
      endif
c
c     Note on DB: ONEEI  puts 1e ESP into DB by using pointers.
c     Note on FA: FMOESP puts 2e ESP into FA by using pointers (and adds DB).
c
      dosap=respap(2).ne.zero
      dospc=resppc(2).ne.zero
      esdder=nder.gt.0.and.iand(ixesp,32).eq.0.and.resdim.ne.0
c
c     2nd bit of modpar needs to be reset to enforce ESP shell parallelisation
c     because here we have only one fragment and fragment par. is no good!
c
      modpars=modpar
      if(iand(modpar,2).ne.0) modpar=modpar-2
c
      full2e=(rij.le.respap(2).or..not.dosap).and.
     *       (rij.le.resppc(2).or..not.dospc)
c     There are two symmetric contribution (I-J and J-I) to dimer energies.
c     It is not important now that for ij=1 ifg<jfg.
      modedisp=nder+1
      enucrij=zero
      nprints=nprint
c     l1i=0
      l2i=0
      if(dodcesd.and.nder.gt.0) call vclr(wrk1,1,maxnat*2*3)
      do ij=1,2
        if(ij.eq.1) then
          ifg=iifg
          jfg=jjfg
          irec0=irec0i
          ilay=iilay
        else
          ifg=jjfg
          jfg=iifg
          irec0=irec0j
          ilay=jjlay
        endif
        if(dopbcmd) then
c         in -edimer, iifg and jjfg are defined as the monomer (jfg,iu)
c         and (ifg,iu=0), respectively.
          if(iunit.gt.0.and.ij.eq.1) then
            call dcopy(3*natfmob,untxyz(1,1,iunit),1,cfrg,1)
          endif
          ncursh=-iunit-ishft(ij,16)
        endif
c
        icurfg=0
c       if(maswrk) CLOSE(UNIT=IDAF,STATUS='DELETE')
        call CLOSDA('DELETE')
        CALL OPENDA(0)
        call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0,.false.)
        l1=num
        l2=(l1*l1+l1)/2
        enucrij=enucrij+enucr
        if(dopbcmd.and.iunit.gt.0.and.ij.eq.1)
     *    call dcopy(3*natfmob,untxyz,1,cfrg,1)
c
c       In the current version of ES dispersion, all
c       dimers contribute, so that we must subtract
c       the gradient of monomer dispersion here (i.e., EIJ-EI-EJ).
c
        if(dodcesd.and.nder.gt.0.and.nder.ne.2) then
          call vclr(de,1,nat*3)
          nprint=-123
          CALL DFTD3(modedisp,EDISP,de)
          nprint=nprints
          call fmodeg(-1,fmode,fmopg,iaglob)
c         Gradients of the dispersion -EI-EJ.
c         write(6,*) 'Executing the new dispersion code',edisp
        endif
c
c       add Tr(DI*uJ) and, possibly, Tr(DI*vJ), if the latter is
c       done with point charges.
c       secret arguments to fmoesp
        icurfg=ifg
        jcurfg=jfg
        kcurfg=0
c       3rd argument is dummy (Hamiltonian)
        nat1es=nat1e
        nat1e=1
        if(full2e) nat1e=2
c       if doing full I-J ESP, do only lower triangle (symmetric).
c       if(full2e.and.jfg.gt.ifg) nat1e=0
        if(full2e.and.ij.eq.1) nat1e=0
        odexch=scffrg(ifg).eq.rmc
        call readmond(da,orbxch.and..not.odexch,.false.,na,nb,l1,
     *                iodfmo,ifg+irec0,scffrg(ifg).eq.uhf)
        call fmoesp(l1,l2,x,layfrg,scffrg,idmrec)
        nat1e=nat1es
c       add Tr(DI*uJ)+Tr(DI*vJ)+EN
c       enucr (EN) is set in fmoesp as epot.
        edimij=edimij+TRACEP(da,fa,l1)
c
c       if(.false.) then
        if(ij.eq.2.and.esdder) then
          dac=one
          if(nbody.gt.2) then
            iiifg=max(ifg,jfg)
            jjjfg=min(ifg,jfg)
            ijfg=(iiifg*iiifg-3*iiifg)/2+jjjfg+1
            dac=dac-ndtfrg(ijfg,1)
c           write(6,*) 'wwwwlag',iiifg,jjjfg,dac,1-dac
          endif
c         Here we write to the 3rd block reserved for beta densities.
c         This should be changed when FMO-ROHF is implemented.
          nreci=1+iifg+nfg
          nrecj=1+jjfg+nfg
          if(isdrec(nreci).eq.0.or.dodistr) then
            call vclr(db,1,l2i)
          else
            CALL rareads(IDAFMO,iodfmo,db,l2i,nreci,0)
          endif
          call daxpy(l2i,dac,fb,1,db,1)
          imxl30=maxl30(iifg)
          if(.not.dodistr.or.maswrk) then
            CALL rawrites(IDAFMO,iodfmo,db,imxl30,l2i,nreci,0)
            isdrec(nreci)=1
          endif
c         write(6,*) 'Saved Vm',l1i,l2i,nreci
c         call prtril(db,l1i)
          if(isdrec(nrecj).eq.0.or.dodistr) then
            call vclr(db,1,l2)
          else
            CALL rareads(IDAFMO,iodfmo,db,l2,nrecj,0)
          endif
          call daxpy(l2,dac,fa,1,db,1)
          imxl30=maxl30(jjfg)
          if(.not.dodistr.or.maswrk) then
            CALL rawrites(IDAFMO,iodfmo,db,imxl30,l2,nrecj,0)
            isdrec(nrecj)=1
          endif
c         write(6,*) 'Saving Vm',l1,l2,nrecj
c         call prtril(db,l1)
        endif
c       l1i=l1
        l2i=l2
c
c       Memo on array usage for separated dimer gradients
c       ij=1: lmoespa (aka fa) contains FI
c       ij=1: lwrkesp (aka fb) contains FI
c       ij=2: lmoespa (aka fa) contains FJ+GJ
c       ij=2: lwrkesp (aka fb) contains FI+GI
c       where F and G stand for one and two-electron contributions to ESPs
c       (subscript I means that matrix elements are for AOs in I).
c       fb is not used if only energy is computed.
c
      enddo
c
      IF(NDER.eq.2) THEN
        CALL ESDHSS(NDER,FCMWRK,scffrg,irec0,YALAG,IPTYA,numfrg,NQMTFG,
     *       ifg,db,jfg,Xlfmobuf1,layfrg,FCMWRK(NC1*NC1+1),NC1)
      END IF
c     Possibly, do the dispersion.
c
      if(dodcesd.and.nder.ne.2) then
        call makemol(jjfg,iifg,0,iilay,0,0,0,0,0,0,0,.false.)
        if(nder.gt.0) call vclr(de,1,nat*3)
        nprint=-123
        CALL DFTD3(modedisp,EDISP,DE)
        nprint=nprints
        if(nder.gt.0) call fmodeg(1,fmode,fmopg,iaglob)
c       Gradients of the dispersion EIJ.
c       write(6,*) 'Executing the new dispersion code',edisp
      endif
c     epot is set in FMOESP for ifg>jfg
      edimij=edimij+epot
c     edimij=edimij+emoni+emonj+epot
      enucr=enucrij+epot
C
c     enucrij is enuc(i)+enuc(j)
c     epot is deltaEnuc(ij) (cross term).
      modpar=modpars
      ifmostp=3
c     write(6,*) 'Exit esdim'
      return
 9000 FORMAT(/1X,'Increase NP or decrease IEPS in $FMM: NP,NPS=',2I8)
      end
C*MODULE fmo     *DECK etrimer
C
C     @brief trimer energy
C
C     @details Calculate trimer energy.
C
C     @author Dmitri Fedorov
C
      subroutine etrimer(ilay,nder,runtyp,loadhf,loadt,mulfg,layfrg,
     *                   numfrg,iodfmo,indat,fmoc,iaglob,da,db,dc,wrk,
     *                   wrk1,dij,fmoespa,etrim,fmode,fmopg,atmulq,
     *                   nfmoelm,fmoelm,iabdfg,jabdfg,locfmo,molfrg,
     *                   scffrg,mapi,mapj,map3,mcnvfmo,mconvex,mconfg,
     *                   ijvec,correl,scftypi,mplevli,CITYPi,CCTYPi,
     *                   tddfti,nfg3,nent,nactfmo,maxl1d,primul,orbxch,
     *                   enexch,ntimout,job2grp,needdm,nprfrg,totdens,
     *                   totfock,totd,iaoglob,modmol,exclmol,densgrid,
     *                  dgrid,l1dir,grdpad,vdwrad,extracc,nextracc,irec0
     *                  ,doddcor,esolv,dovpcm,etotdft,nedft,XYZCTS,PEL,
     *                   VNUC,IDAcFMO,iodcfmo,untrot,stonep,dopdc,modcha
     *                  ,iwhere,gcorrel,e1efmo,ekinfmo,fmoddm,FMOFCM,
     *                   FCMWRK,ABFLDT,DINDF2,DINDDF2,ZVLAG,IPTLG,hopgrd
     *                  ,potat,fmohard,IDMREC0,NQMTFG,LOADM,NGRFMO,
     *                   MANNOD,MASTID,NEVSAV,outpune,clm,flm,f_mm,g_mm,
     *                   crfrg,Ylmfrgq,Ylmfrgq2,dodc,nsetgrid,YALAG,
     *                   IPTYA,YAWRK,dopbcmd,savemem,etrimsum,mdout,
     *                   mdoutmin,griddistr,irmdfmo,popmat,ialoc,indbd,
     *                   qmcout,nftqmc,some)
c
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      integer ddi_world,ddi_group
      parameter (MXATM=2000,MXRT=100,MXGRID=10,zero=0.0D+00,one=1.0D+00,
     *           half=0.5D+00,MaxNp=45)
      Parameter(ddi_world=0,ddi_group=1)
      logical myjob,isgddi,parout,INITGDDI,GOPARR,DSKWRK,MASWRK,DIRSCF,
     *        FDIFF,AIMPAC,RPAC,PLTORB,MOLPLT,DGRIDPROG,
     *        orbxch,primul,enexch,
     *        iodexch,jodexch,kodexch,fmodscf,fmodtrf,prerhf,correl,
     *       needdm,totdens,totfock,densgrid,desperate,despread,forcedir
     *       ,fordir,tightint,exclmol,skipc,doddcor,dovpcm,dopdc,
     *        urohfi,urohfj,urohfk,SG1,gcorrel,hopgrd,outpune,some,
     *        doddcori,QOPS,QFMM,wasgddi,excstat,dodc,dopbcmd,savemem,
     *        mdout,mdoutmin,griddistr,mlgddi,qmcout
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      character*11 wfnstri
      character*8 tridek,end
      complex*16 Ylmfrgq(((NP+1)*(NP+2))/2,nfg)
      complex*16 Ylmfrgq2(((NP+1)*(NP+2))/2,nfg)
      dimension mulfg(*),layfrg(*),numfrg(*),iodfmo(*),indat(*),
     *          fmoc(3,*),iaglob(*),da(*),db(*),dc(*),wrk(*),wrk1(*),
     *          dij(*),fmoespa(*),etrim(nfg3,*),fmode(3,natfmo,*),
     *          fmopg(3,*),atmulq(*),fmoelm(nfmoelm),iabdfg(*),jabdfg(*)
     *         ,locfmo(*),molfrg(*),scffrg(*),mapi(*),mapj(*),
     *          map3(maxl1d,3),loadt(*),mcnvfmo(*),mconfg(*),ijvec(5,*),
     *          job2grp(*),nprfrg(*),totd(*),iaoglob(*),dgrid(*),
     *          vdwrad(*),extracc(nextracc,*),esolv(*),etotdft(*),
     *          XYZCTS(mxts,3),PEL(*),VNUC(*),iodcfmo(*),untrot(3,3,*),
     *          stonep(*),fmoddm(*),FMOFCM(*),FCMWRK(*),ABFLDT(*),
     *          DINDF2(*),DINDDF2(*),ZVLAG(*),IPTLG(*),potat(*),
     *         fmohard(natfmo,*),IDMREC0(*),NQMTFG(*),LOADM(*),NGRFMO(*)
     *         ,MANNOD(*),MASTID(*),CLM(-maxNP:maxNP),FLM(-maxNP:maxNP),
     *          F_mm((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          G_mm((maxNP*(maxNP+1)*(maxNP+2)*4)/3+(maxNP+1),8),
     *          crfrg(4,ncentm,nfg),YALAG(*),IPTYA(*),YAWRK(*),
     *          etrimsum(6),grdpad(3),popmat(maxnat,nfg,2),ialoc(*),
     *          indbd(maxabd,*)
c
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,jans
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
     *                                                    NAUXSHL
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /GRDPAR/ ORIGIN(3),XVEC(3),YVEC(3),ZVEC(3),UX(3),UY(3),
     *                UZ(3),GRDSIZ,NGRID,IGUNIT,NXG,NYG,NZG,modgrid
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      common /INT2IC/ NINTIC,iNINTIC,nxxic,lbufpic,lixic,labsix,nintix
      COMMON /INTRFC/ FRIEND,AIMPAC,RPAC,PLTORB,MOLPLT,DGRIDPROG
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NORB,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCKLAB/ LABSIZ
      COMMON /PCMCHG/ PB,PX,PC,UNZ,QNUC,FN,FE,UNZOR,PORT
      COMMON /PCMDIM/ mxsp,mxts,mempcm1,mempcm2,NTS
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEFPCM,IP_F,nfmopcm,IHET
      COMMON /PRPOPT/ ETOLLZ,ILOCAL,IAHARD
      COMMON /PSILVL/ IPSI,ISKPRP
      COMMON /QMFM  / SIZE,EPS1,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
     *                ITERMS,QOPS,ISCUT
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RUNOPT/ pUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,npreo(4)
      COMMON /STNBUF/ STNPNT(4,2*MXATM),BIGEXP,NPTSTN,NBUFFM
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /MLTFMO/ Q_MUL,IMLTFMO,ISWPFD,ISWNEW1
      data tridek/' $FMOENT'/,end/' $END'/,RMC/8HMCSCF   /,
     *     rhf/8HRHF     /,energy/8HENERGY  /,rnone/8HNONE    /,
     *     rohf/8HROHF    /,uhf/8HUHF     /
c
c     parstat: GlobalFull
c     ifmostp is set really only for makmol in order to read MP2 data.
      ifmostp=8
      if(nunesp.gt.0) iskipesp=1
      ntimout=0
      prerhf=mod(nguess/16,2).ne.0
      desperate=mod(nguess/256,2).ne.0
      despread=desperate.and.iand(nguess,2048).eq.0
      ndesper=0
      nodesper=0
      if(outpune) write(ip,9200) tridek
      dftsav=DFTYPE
      ndftsav=NDFTFG
      hfssav=DFTTYP(3)
      if(doddcor) ixesp=ixesp+1024
      doddcori=MPLEVL.gt.0.and.(MPPROP.ne.0.or.nder.gt.0).or.
     *         cityp.ne.rnone.or.(tddftyp.ne.rnone.and.nder.gt.0)
      irecd=16
      if(doddcori) irecd=308
      neh = natfmo*natfmo*9
      nc1 = natfmo*3
C
c     raising 1024th bit signals ESPs to always use RHF densities.
c
c     NB: For FMO-ROHF reroutined to MCSCF the active space read in inidfmo
c     corresponds to closed shell singlet no matter what multiplicity.
c     This is not a problem since real multiplicity will be used where needed.
c
      if(isgddi) call GDDICOUNT(-1,lgroup,myjob)
      lijkfg=0
      iter0=0
      rmin=0
      rmax=0
      eijk1=0
      eijk2=0
      eijk3=0
      do 450 iifg=1,nfg
        do 450 jjfg=1,iifg-1
          do 450 kkfg=1,jjfg-1
          lijkfg=lijkfg+1
          if(loadhf.eq.1.and.nfg3.ne.0) then
             ijkfg=loadt(lijkfg)
c            write(6,*) 'breaking',ijkfg,lijkfg
             call cubbrk(ijkfg,-1,ifg,jfg,kfg)
c            write(6,*) 'broke',ifg,jfg,kfg
          else
             ijkfg=lijkfg
             ifg=iifg
             jfg=jjfg
             kfg=kkfg
          endif
          ifglay=layfrg(ifg)
          jfglay=layfrg(jfg)
          kfglay=layfrg(kfg)
c
c         skip trimers from higher layers
          if(.not.((ifglay.eq.ilay.or.jfglay.eq.ilay.or.kfglay.eq.ilay)
     *       .and.ifglay.ge.ilay.and.jfglay.ge.ilay.and.kfglay.ge.ilay))
     *       goto 450
          if(nfg3.ne.0.and..not.savemem) then
c           skip trimers that have been done for restart jobs
            if(irststp.ge.9.and.etrim(ijkfg,1).ne.zero) goto 440
          endif
          if(iand(modmol,1).ne.0) then
c           check if MOLFRG option tells to ignore dimers except those with
c           one from the chosen group.
            ires=molfrg(ifg)+molfrg(jfg)+molfrg(kfg)
            if(exclmol) then
              if(ires.ge.0.and.ires.ne.3) goto 450
            else
              if(ires.ge.0.and.ires.ne.1) goto 450
            endif
          endif
          if(needr.ne.0.and.restri(1).ne.0) then
            call fmodist3(ifg,jfg,kfg,rmin,rmax)
            if(rmin.gt.restri(1).and.rmax.gt.restri(2).or.
     *         rmax.gt.restri(3).and.restri(3).ne.0) then
c             SCF dimer + separate monomer: no contribution
c             Now, there is no need to zero out: already done.
c             if(maswrk) write(iw,9110) ifg,jfg,kfg
              goto 440
            endif
c           else: do SCF below.
          endif
          CALL TSECND(TYME)
          IF(TYME.GT.TIMLIM) THEN
            IF(MASWRK) WRITE(IW,9500)
            ntimout=1
            goto 590
          ENDIF
c
          if(isgddi) then
            call GDDICOUNT(0,lgroup,myjob)
            if(.not.myjob) goto 450
          endif
          l1i=iand(numfrg(ifg),65535)
          l1j=iand(numfrg(jfg),65535)
          l1k=iand(numfrg(kfg),65535)
          l0i=iand(nqmtfg(ifg),65535)
          l0j=iand(nqmtfg(jfg),65535)
          l0k=iand(nqmtfg(kfg),65535)
c         LL1 printed below is an overestimate of the true L1,
c         used only for print-out.
          ll1=l1i+l1j+l1k
          icurfg=0
          nai=ishft(numfrg(ifg),-16)
          naj=ishft(numfrg(jfg),-16)
          nak=ishft(numfrg(kfg),-16)
          nbi=nai-mulfg(ifg)+1
          nbj=naj-mulfg(jfg)+1
          nbk=nak-mulfg(kfg)+1
          iodexch=scffrg(ifg).eq.rmc
          jodexch=scffrg(jfg).eq.rmc
          kodexch=scffrg(kfg).eq.rmc
          SCFi=scffrg(ifg)
          SCFj=scffrg(jfg)
          SCFk=scffrg(kfg)
          urohfi=scfi.eq.uhf.or.scfi.eq.rohf
          urohfj=scfj.eq.uhf.or.scfj.eq.rohf
          urohfk=scfk.eq.uhf.or.scfk.eq.rohf
          SCFTYP0=SCFTYPi
          if(iodexch.or.jodexch.or.kodexch) SCFTYP0=rmc
         if(.not.iodexch.and..not.jodexch.and..not.kodexch) SCFTYP0=SCFi
          if(urohfi) SCFTYP0=SCFi
          if(urohfj) SCFTYP0=SCFj
          if(urohfk) SCFTYP0=SCFk
          SCFTYP=SCFTYP0
          if(gcorrel.and.correl) then
c           check if MOLFRG option further restricts the correlation
            ires=molfrg(ifg)+molfrg(jfg)+molfrg(kfg)
            if(exclmol) then
              skipc=ires.ge.0.and.ires.ne.3
            else
              skipc=ires.ge.0.and.ires.ne.1
            endif
            if(rmax.gt.restri(4).and.restri(4).ne.0 .or. skipc) then
              mplevl=0
              cctyp=rnone
              cityp=rnone
              TDDFTYP=rnone
            else
              mplevl=mplevli
              cctyp=cctypi
              cityp=citypi
              TDDFTYP=tddfti
            endif
          endif
          if(maswrk.and.mdout) then 
            call wfnstr(wfnstri)
            write(iw,9000) scftyp0,ifg,jfg,kfg,wfnstri,ll1,lijkfg
          endif
c         if(maswrk) CLOSE(UNIT=IDAF,STATUS='DELETE')
          call CLOSDA('DELETE')
          CALL OPENDA(0)
          nprsav=nprint
          excstat=cityp.ne.rnone.or.tddftyp.ne.rnone
          if(excstat.or.iand(nprfmo,32).ne.0) nprint=7
          call makemol(ifg,jfg,kfg,ilay,0,0,0,0,0,0,0,.true.)
c
          if(moncor.ge.0) moncor=0
c         fmonad sets norb.
          if(iodexch) then
            if(moncor.ge.0) moncor=naj+nak
            call fmonad(idum1,idum2)
            nai=nactfmo
          endif
          if(jodexch) then
            if(moncor.ge.0) moncor=nai+nak
            call fmonad(idum1,idum2)
            naj=nactfmo
          endif
          if(kodexch) then
            if(moncor.ge.0) moncor=nai+naj
            call fmonad(idum1,idum2)
            nak=nactfmo
          endif
c
          l1=num
          l2=(l1*l1+l1)/2
          l3=l1*l1
c         nai and naj for RHF are NA (the number of alpha electrons)
c         for MCSCF they become the number of occupied orbitals
         if(maswrk) then
            if(iand(nprfmo,3).eq.0.and.labsiz.ne.labsix)
     *        write(iw,9005) labsiz,labsix
            dum=0
            if(idoprop.ne.0.and.qmcout)
     *        call qmcfout(nftqmc,ifg,jfg,kfg,dum)
          endif
c
c       Compute trimer initial density
c
          if (dftbfl) then
            call diminic(ifg,jfg,kfg,wrk1,popmat,indat,iaglob,ialoc,
     *                   indbd)
          end if
          if (.not.dftbfl.or.(nder.gt.0.or.mod(mconv,16).ge.8))
     *    call triminid(kfg,jfg,ifg,l1k,l1j,l1i,l0k,l0j,l0i,nak,naj,nai,
     *                  nbk,nbj,nbi,l1,da,db,dc,wrk,wrk1,iodfmo,irec0,
     *                  iabdfg,jabdfg,indat,iaglob,locfmo,map3(1,3),
     *                  map3(1,2),map3(1,1),orbxch,enexch,kodexch,
     *                  jodexch,iodexch,0,urohfk,urohfj,urohfi,some)
          if (.not.dftbfl) call dcopy(l2,da,1,dij,1)
c         do lfg=1,nfg
c           if(lfg.ne.ifg.and.lfg.ne.jfg.and.lfg.ne.kfg) then
c             write(6,*) 'Distance map for trimer',ifg,jfg,kfg,lfg
c             call mapdist(wrk,indat,indatg,iaglob,ifg,jfg,kfg,lfg)
c           endif
c         enddo
          igot=0
          if(orbxch)
     *      call fmorvec(ifg,jfg,kfg,ilay,ijvec,l1,da(1+l2),igot)
          if(mod(nguess/2,2).eq.0.and.igot.eq.0) then
            ifmostp=8
            icurfg=0
            jcurfg=0
            kcurfg=0
            CALL ONEEI
            NEVALS=0
            CALL GUESMO(GUESS)
          endif
          ifmostp=9
          icurfg=ifg
          jcurfg=jfg
          kcurfg=kfg
c           MCONV=mcnvfmo(ifmostp)
c         if(SCFTYP.eq.rmc) call readcas
          fordir=forcedir(l1dir,l1,maswrk)
          if(nintic.ne.0.and.scftyp.eq.rmc.and.goparr) fordir=.true.
          iconvijk=-1
          call fmocvij(ifg,jfg,kfg,mconvex,mconfg(nfg+1),iconvijk)
          call fmoconv(mcnvfmo(ifmostp),iconvijk,l1,wrk,enexch,orbxch,
     *                 irststp.le.3.or.iter0.eq.0,.false.,fordir)
          iter0=1
          if(nfg3.ne.0.and..not.savemem) then
c           It may be a good idea to call MCIN to be sure
            if(irststp.gt.ifmostp.and.etrim(ijkfg,1).ne.zero) goto 450
c           skip trimers energy for restart jobs ifmostp=: not finished yet.
          endif
c
          NEVALS=NEVALS+1
c
          irestsav=irest
          tightint=(iand(nprfrg(ifg),32).ne.0.or.iand(nprfrg(jfg),32)
     *              .ne.0.or.iand(nprfrg(kfg),32).ne.0).and.
     *             DIRSCF.and.FDIFF
          icutsav=icut
          if(tightint) then
            icut=icut+1
            if(maswrk) write(iw,9203) icut
          endif
c
c         Compute PCM ASC-nuclei correction to the trimer energies.
c
          if(nfmopcm.gt.0) then
c           ida=1
c           if(nfmopcm.lt.3) ida=0
            ida=0
            call pcmnup(ida,vnuc)
          endif
c
          if(nbdfg.ne.0.and.SCFTYP0.eq.rmc.and.prerhf) then
            CALL daread(IDAF,IODA,wrk,L3,15,0)
            SCFTYP=RHF
            call fmosdir(0,fmodscf,fmodtrf)
            CALL BRNCHX(energy)
cnb         fmodor is not really ready for trimers!
c           call abrt
            call fmodor(enexch,wrk,da(1+l2),da,da(1+l2+l3),wrk(l3+1),
     *                  wrk(l3+l1+1),wrk1,nai+naj+nak,l1,l2,l3)
            call fmosdir(1,fmodscf,fmodtrf)
            irest=2
c           since we run CAS again
          endif
          if(dftype.ne.rnone.and.prerhf) then
            DFTYPE=rnone
            NDFTFG=0
            DFTTYP(3)=1.0D+00
            CALL BRNCHX(energy)
            NDFTFG=ndftsav
            dftype=dftsav
            DFTTYP(3)=hfssav
            irest=2
c           since we run SCF again
c         else
c           if(coroff.ne.0.and.swoff.eq.0) swoff=coroff
          endif
          SCFTYP=SCFTYP0
          IRSTLsav=IRSTLAY
          IRSTLAY=moncor+nactfmo
          if(moncor.lt.0) IRSTLAY=nai+naj+nak
          call fmosdir(0,fmodscf,fmodtrf)
          CALL BRNCHX(RUNTYP)
c         Try converging once again with an alternative converger
          if(etot.eq.0.and.desperate) then
            if(maswrk) write(iw,9300)
c           Increase accuracy of DIRSCF/FDIFF.
            if(DIRSCF.and.FDIFF) icut=icut+1
c           to reuse integrals
            irest=2
            if(despread) then
c             do not use density from the previous run that failed, use the
c             pristine one (otherwise continue converging).
              CALL dawrit(IDAF,IODA,dij,L2,16,0)
              if(orbxch) then
                write(iw,*) 'Not ready yet'
                call abrt
              endif
            endif
            call fmoconv(mcnvfmo(ifmostp),iconvijk,l1,wrk,enexch,orbxch,
     *                   irststp.le.3.or.iter0.eq.0,.true.,fordir)
            CALL BRNCHX(RUNTYP)
c           for desperate runs abort if not converged.
            if(etot.eq.0) then
              if(maswrk) write(iw,9310)
c             call abrt
              if(maswrk) nodesper=nodesper+1
            else
              if(maswrk) ndesper=ndesper+1
            endif
          endif
          call fmosdir(1,fmodscf,fmodtrf)
          IRSTLAY=IRSTLsav
          irest=irestsav
          icut=icutsav
          nprint=nprsav
c
c         RHF density for deltaDIJK
          if(irecd.eq.16) then
            call DENDD1(DA,da(1+l2),L2)
          else
            CALL daread(IDAF,IODA,da,l2,irecd,0)
          endif
          if (dftbfl) then
            if (scc) then
              selfv = edft(1)
              dele = edft(2)
            else
              selfv = zero
              dele = zero
            end if
          else
            selfv=TRACEP(da,fmoespa,l1)
          end if
c         MP2 density for properties
          if(irecd.ne.16) call DENDD1(DA,DB,L2)
          if(urohfi.or.urohfj.or.urohfk) then
            call daread(IDAF,IODA,da(l2+1),l3,15,0)
            call DMTX2(da,da(l2+1),na,l1,l1,0)
            if(SCFTYP.eq.uhf)  call daread(IDAF,IODA,db(l2+1),l3,19,0)
            if(SCFTYP.eq.rohf) call daread(IDAF,IODA,db(l2+1),l3,15,0)
            call DMTX2(db,db(l2+1),nb,l1,l1,0)
            call daxpy(l2,one,db,1,da,1)
            selfv=TRACEP(da,fmoespa,l1)
          end if
c
          if(nfmopcm.ne.0) then
            if(maswrk) esolv(ijkfg)=(PC-PX)*half
c           IF (ISWNEW1.EQ.1) THEN
c             if(maswrk) esolv(ijkfg)= PC-PX
c           ELSE
c             if(maswrk) esolv(ijkfg)=(PC-PX)*half
c           END IF
c           esfact=one
c           if(ISWNEW1.EQ.1) esfact=2.0D+00
            if(etot.ne.0) then
              etot=etot-esolv(ijkfg)
              if(gcorrel) escf=escf-esolv(ijkfg)
            endif
          endif
          if(maswrk.and.nfg3.ne.0) then
            if(savemem) then
              eijk1=etot-selfv
              if(dodc) eijk1=eijk1-edisp
              etrimsum(1)=etrimsum(1)+eijk1
              if(gcorrel) then
                 eijk3=escf-selfv
                 etrimsum(3)=etrimsum(3)+eijk3
              endif
              if(etot.eq.zero) call abrt
c             For now abort.
            else
              etrim(ijkfg,1)=etot-selfv
              if(dodc) etrim(ijkfg,1)=etrim(ijkfg,1)-edisp
              if(gcorrel) etrim(ijkfg,nent)=escf-selfv
              if(etot.eq.zero) etrim(ijkfg,1)=one
c             Assign +1 to signal to the properties that this trimer diverged.
            endif
          endif
c
          delv=zero
c         the energy corrections below destroy shells, atomic coordinates etc
c         (by making dimer corrdinates instead of trimer).
c         Therefore, all properties should be computed before these corrections.
        if(primul.and.(iand(modcha,3).eq.0.or.iand(modcha,3).ge.3)) then
            if(NPTSTN.ne.0) then
              if(nprint.eq.-5.or.ISKPRP.ne.0) call stone(ip,rnone,0)
              call dcopy(nat,stonep,1,wrk1,1)
            else if(dopdc) then
              if(nprint.eq.-5.or.ISKPRP.ne.0) CALL ELEPOTC(iwhere)
              call dcopy(nat,stonep,1,wrk1,1)
c             write(6,*) 'wwwZ',(wrk1(i),i=1,nat)
           else
              call DENDD1(DA,da(1+l2),L2)
c             CALL daread(IDAF,IODA,da,l2,16,0)
              CALL daread(IDAF,IODA,db,l2,12,0)
              call mulpop(l1,da,db,wrk)
              call mulpopa(wrk,wrk1)
            endif
          endif
c
          if(cctyp.ne.rnone.and.maswrk)
     *      call addecc(3,0,0,1,extracc,nextracc)
          if(mplevl.ne.0.and.maswrk)
     *      call addemp(3,0,0,1,extracc,nextracc)
          call addprop(3,primul,primul,1,1,1,iaglob,wrk1,nfmoelm,fmoelm,
     *                 fmoelm,fmoelm,atmulq,atmulq,atmulq)
c         the second and the third fmoelm are dummy
c
          if(iahard.gt.0) then
            CALL EPCALC(fmoc,potat,da,natfmo,L2)
c           write(6,*) ifg,jfg,kfg,'wwwV',(potat(i),i=1,natfmo)
            if(maswrk) call daxpy(natfmo,one,potat,1,fmohard(1,3),1)
c           There are two minuses for each term.
          endif
c         Correlated density is used (may be wrong, see edimer)
          if(totdens) call fmototd(1,l2,da,totd,iaoglob)
          call dumpfock(totfock,wrk,l1,l2,1,da,e1efmo,ekinfmo)
c
          if(densgrid) then
            call grdbox(ixmin,ixmax,iymin,iymax,izmin,izmax,vdwrad,
     *                  grdpad(2))
            kdum=-2
            ldum=-2
            call fmoprc(1,1,l2,da,dgrid,1,NXG,1,NYG,1,NZG,ixmin,ixmax,
     *                  iymin,iymax,izmin,izmax, 0,0,0,0,0,0,
     *                  ORIGIN,UX,UY,UZ,nsetgrid,griddistr,0,kdum,ldum)
          endif
c
          if(nfmopcm.ne.0) then
            call stopwa(7,0)
            if(nfmopcm.gt.2.and.dovpcm)
     *        call EPOTEN(-one,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),PEL,
     *                    da,NTS,L2)
            call stopwa(7,1)
          endif
          if(ndftfg.eq.1.and.maswrk) then
            call daxpy(nedft,one,edft,1,etotdft,1)
          endif
C
C         HOP CONTRIBUTION TO GRADIENT
C
          if(hopgrd) then
            CALL HOPDER(0,0,0,1,L1,L2,DA,DA(L2+1),DB(L2+1),FMOFCM)
          end if
C
C
c
c         accumulate gradient
c
          if(nder.gt.0.and.runtyp.ne.energy.and.maswrk) then
            call fmodeg(1,fmode(1,1,3),fmopg,iaglob)
            IF (IEFPFMO.NE.0) call EFPDEG(1,3)
          ENDIF
C
          if(npunch.ne.0.and.PLTORB) CALL PLTMEM
c
c         idijk=-1
cnba+     this needs to be fixed. Slaves should participate.
          if(needdm.and.maswrk) then
c           DI+DJ+DK comes with a plus if approximations are used
c           (entirely equivalent formulation)
c
c           first get dimer density contractions
c
c           idijk=0
c           idijk counts how many times we add DI+DJ+DK.
c           in case of approximations this term appears for each separated dimer
c           for no approximations the formula in use is different and there is
c           one such term always.
c
            call vclr(wrk,1,l2)
c
            ijfg=(ifg*ifg-3*ifg)/2+jfg+1
            igotij=job2grp(ijfg)
            if(igotij.ne.0) then
c             this will not work with broken bonds!
              call makemol(ifg,jfg,0,ilay,1,0,0,0,0,0,0,.false.)
              l1ij=num
              l2ij=(l1ij*l1ij+l1ij)/2
c             call GDDI_GET(iddm,igotij,ijfg,l2ij,db)
              CALL rareads(IDAcFMO,iodcfmo,db,l2ij,ijfg,0)
              call diminid(-1,ifg,jfg,l1i,l1j,l0i,l0j,nai,naj,nbi,nbj,
     *                    l1ij,da,db,wrk,wrk1,iodfmo,irec0,iabdfg,jabdfg
     *                    ,indat,iaglob,locfmo,mapi,mapj,orbxch,enexch,
     *                    iodexch,jodexch,0,untrot,0,urohfi,urohfj,
     *                    mulfg,some)
c             write(6,*) 'www den ij',ijfg
c             call prtril(db,l1ij)
c             call readmond(dc,orbxch,kodexch,nak,l1k,iodfmo,irec0+kfg)
              call stuff123(l1ij,l1,maxl1d,mapi,mapj,map3(1,1),map3(1,2)
     *                     ,wrk1,db,wrk)
            endif
            ikfg=(ifg*ifg-3*ifg)/2+kfg+1
            igotik=job2grp(ikfg)
c           note that mapi and mapj arrays are also used to store mapk.
c           the order of mapi and mapj should be the same in diminid and
c           stuff123.
            if(igotik.ne.0) then
              call makemol(ifg,kfg,0,ilay,1,0,0,0,0,0,0,.false.)
              l1ik=num
              l2ik=(l1ik*l1ik+l1ik)/2
c             call GDDI_GET(iddm,igotik,ikfg,l2ik,db)
              CALL rareads(IDAcFMO,iodcfmo,db,l2ik,ikfg,0)
              call diminid(-1,ifg,kfg,l1i,l1k,l0i,l0k,nai,nak,nbi,nbk,
     *                    l1ik,da,db,wrk,wrk1,iodfmo,irec0,iabdfg,jabdfg
     *                    ,indat,iaglob,locfmo,mapi,mapj,orbxch,enexch,
     *                    iodexch,kodexch,0,untrot,0,urohfi,urohfk,
     *                     mulfg,some)
c             write(6,*) 'www den ik',ikfg
c             call prtril(db,l1ik)
c             call readmond(dc,orbxch,jodexch,naj,l1j,iodfmo,irec0+jfg)
              call stuff123(l1ik,l1,maxl1d,mapi,mapj,map3(1,1),map3(1,3)
     *                     ,wrk1,db,wrk)
            endif
            jkfg=(jfg*jfg-3*jfg)/2+kfg+1
            igotjk=job2grp(jkfg)
            if(igotjk.ne.0) then
              call makemol(jfg,kfg,0,ilay,1,0,0,0,0,0,0,.false.)
              l1jk=num
              l2jk=(l1jk*l1jk+l1jk)/2
c             call GDDI_GET(iddm,igotjk,jkfg,l2jk,db)
              CALL rareads(IDAcFMO,iodcfmo,db,l2jk,jkfg,0)
              call diminid(-1,jfg,kfg,l1j,l1k,l0j,l0k,naj,nak,nbj,nbk,
     *                    l1jk,da,db,wrk,wrk1,iodfmo,irec0,iabdfg,jabdfg
     *                     ,indat,iaglob,locfmo,mapj,mapi,orbxch,enexch,
     *                    jodexch,kodexch,0,untrot,0,urohfj,urohfk,
     *                     mulfg,some)
c             write(6,*) 'www den ik',jkfg
c             call prtril(db,l1jk)
c             call readmond(dc,orbxch,iodexch,nai,l1i,iodfmo,irec0+ifg)
              call stuff123(l1jk,l1,maxl1d,mapj,mapi,map3(1,2),map3(1,3)
     *                     ,wrk1,db,wrk)
c             write(6,*) 'www den jk',jkfg
c             call prtri(db,14)
            endif
            if(igotij+igotik+igotjk.ne.0) delv=TRACEP(wrk,fmoespa,l1)
c           It is possible to replace this TRACEP by daxpy.
          endif
          if(nfg3.ne.0) then
c           if((needdm.or.needr2.eq.0).and.maswrk) then
            if(maswrk) then
              if (.not.dftbfl) dele=selfv-delv-TRACEP(dij,fmoespa,l1)
              if(savemem) then
                etrimsum(2)=etrimsum(2)+dele
                eijk2=dele
              else
                if(needdm) then
                  etrim(ijkfg,2)=dele+delv
                  etrim(ijkfg,3)=dele
                else
                  etrim(ijkfg,2)=dele
                endif
              endif
c             write(6,*) 'www3',dele,selfv,delv,TRACEP(dij,fmoespa,l1)
            endif
c           That is, do not include dV terms into it.  -> change to include.
c 300       continue
c
            if(.not.savemem) then
              eijk1=etrim(ijkfg,1)
              eijk2=etrim(ijkfg,2)
              eijk3=etrim(ijkfg,nent)
            endif
            if(maswrk.and.mdoutmin) then
              if(correl) then
                write(iw,9110) ifg,jfg,kfg,eijk1
                write(iw,9100) ifg,jfg,kfg,eijk3,eijk2
              else
                write(iw,9100) ifg,jfg,kfg,eijk1,eijk2
              endif
              if(outpune.and..not.savemem) write(ip,9210) ifg,jfg,kfg,
     *                               ilay,(etrim(ijkfg,ien),ien=1,nent)
            endif
          endif
C
          IF (IEFPFMO.EQ.2) THEN
            CALL GETABFLDT(0,1,1,L1,L2,ABFLDT,DINDF2,DINDDF2,DA,DB,
     *                     NDER.GT.0.AND.RUNTYP.NE.ENERGY)
            IF (MPLEVL.EQ.2) THEN
              CALL GETABFLDT(1,0,1,L1,L2,ABFLDT,DINDF2,DINDDF2,DA,DB,
     *                       NDER.GT.0.AND.RUNTYP.NE.ENERGY)
            END IF
          END IF
C
          IF (NDER.GT.0.AND.RUNTYP.NE.ENERGY.AND.ISWNEW1.EQ.1) THEN
            CALL WRAPEPOT(0,-ONE,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),
     *                    DA,DB,NTS,L2,idum)
            IF (MPLEVL.EQ.2) THEN
              CALL WRAPEPOT(1,-ONE,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),
     *                      DA,DB,NTS,L2,idum)
            END IF
          END IF
C
          IF (NDER.GT.0.AND.RUNTYP.NE.ENERGY.AND.
     *      IAND(MODGRD,2).NE.0.AND.NDER.NE.2)         THEN
            CALL FMOESDER(l1,l2,da,layfrg,scffrg,idmrec0,dc,wrk1,
     *                    mapi,mapj,map3,maxl1d,irec0, 1,0,
     *                    orbxch,enexch,kodexch,jodexch,iodexch,
     *                    ZVLAG,IPTLG,NQMTFG,loadhf,clm,flm,f_mm,g_mm,
     *                    crfrg,Ylmfrgq,Ylmfrgq2)
          ENDIF
C
C         Hessian contribution
C
          if(nder.eq.2.and..not.dftbfl) call vclr(FCMWRK,1,neh) 
          if(nder.eq.2.AND.IAND(MODGRD,2).NE.0) then
            CALL FMOESHSS(l1,l2,da,scffrg,idmrec0,dc,wrk1,
     *           mapi,mapj,map3,maxl1d,irec0, orbxch,enexch,kodexch,
     *           jodexch,iodexch,NQMTFG,YALAG,IPTYA,YAWRK,FCMWRK,
     *           numfrg,0,FCMWRK(NC1*NC1+1),NC1,1)
            IF(GOPARR.AND..NOT.DFTBFL) CALL DDI_GSUMF(2418,FCMWRK,neh)
          end if
C
          IF (NDER.EQ.2.AND.RUNTYP.NE.ENERGY) then
c           nc1=natfmo*3
            IF (DFTBFL) THEN
              CALL FMODEH(1,FCMWRK(NC1*NC1+1+NAT),fmoddm,FMOFCM,FMOPG,
     *                    IAGLOB,nc1,indat,layfrg,FCMWRK(nc1*nc1+1),-1)
            ELSE
              CALL FMODEH(1,FCMWRK,fmoddm,FMOFCM,FMOPG,IAGLOB,
     *                    nc1,indat,layfrg,FCMWRK(nc1*nc1+1),0)
            END IF
          END IF
C
          IF (IEFPFMO.NE.0.AND.NDER.GT.0) CALL DEFPCLR
C
C
  440     continue
c
  450 continue
  590 continue
      call stopwa(18,0)
      if(isgddi) call GDDICOUNT( 1,lgroup,myjob)
      call stopwa(18,1)
      if(outpune) write(ip,9200) END
      NDFTFG=ndftsav
      dftype=dftsav
      DFTTYP(3)=hfssav
      if(doddcor) ixesp=ixesp-1024
C
      IF (NDER.GT.0.AND.DFTBFL.and.scc) THEN
        CALL DFTB_FMOGRAD(LAYFRG,FMODE,IDMREC0,NUMFRG,IODFMO,
     *                    ORBXCH,FMOFCM,MODGRD,MDOUT)
      END IF
      IF (DFTBFL.AND.NDER.EQ.2) THEN
        IF (MASWRK) THEN
          CALL SYMTRZE(FMOFCM,NC1,NC1)
        ELSE
          CALL VCLR(FMOFCM,1,NC1*NC1)
        END IF
      END IF
C
C     FMO CPHF CALCULATION: SELF-CONSISTENT Z-VECTOR METHOD
C
      IF (NDER.GT.0.AND.NBODY.EQ.3.and.nder.ne.2) THEN
        if(doddcor.and.iand(ixesp,1024).eq.0) ixesp=ixesp+1024
         DUM = ZERO
        IDUM = 0
        IF (IEFPFMO.EQ.2.AND..NOT.DFTBFL) THEN
          CALL DNEWIND2(0,ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,IDUM,DUM,
     *                  FMODE(1,1,3),ORBXCH,NUMFRG,IODFMO,
     *                  LAYFRG,SCFFRG,ISGDDI,IREC0,NGRFMO,MANNOD,
     *                  MASTID,NQMTFG,DUM,DUM,DUM,DUM)
        END IF
        IF (ISWNEW1.EQ.1) THEN
          CALL FMOPCMREMD(0,NTS,ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,
     *                    IDUM,DUM,FMODE(1,1,3),ORBXCH,NUMFRG,
     *                    IODFMO,LAYFRG,SCFFRG,IREC0,
     *                    NGRFMO,MANNOD,MASTID,NQMTFG,mulfg,
     *                    idum,idum,idum,idum)
        END IF
        ifmostps = ifmostp
        ifmostp  = 9
czcz    The call to ESPPCDER was added by Takeshi on 22 apr 2012.
        if (iand(modgrd,8).ne.0.and.resppc(1).ne.zero
     *      .and..not.dftbfl) then
          CALL ESPPCDER(0,ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,
     *                  DUM,FMODE(1,1,3),ORBXCH,NUMFRG,
     *                  IODFMO,LAYFRG,SCFFRG,ISGDDI,IREC0,
     *                  NGRFMO,MANNOD,MASTID,NQMTFG,mulfg,irmdfmo)
        end if
        IF (IAND(MODGRD,32).NE.0) THEN
          CALL ESDCPHFX(ILAY,LOADHF,LOADM,DA,WRK,DB,ZVLAG,FMODE(1,1,3),
     *                  NUMFRG,IODFMO,IDMREC0,LAYFRG,SCFFRG,
     *                  IREC0,NGRFMO,MANNOD,MASTID,NQMTFG,IPTLG,hopgrd,
     *                  nevsav,XYZCTS,mulfg,dopbcmd,dum,idum,idum,
     *                  idum,idum,irmdfmo,mdoutmin)
        END IF
        ifmostp  = ifmostps
        if(iand(ixesp,1024).ne.0) ixesp=ixesp-1024
      END IF
C
      if(desperate) then
        if(isgddi) then
          call gddi_scope(ddi_world)
          idum=0
          call DDI_nsumi(2423,ndesper,nodesper,idum,idum,2)
          call gddi_scope(ddi_group)
        endif
        if(maswrk) write(iw,9320) ndesper,nodesper
c       if(nodesper.ne.0) call abrt
      endif
      if(iand(nprfmo,3).lt.2) call timit(1)
      return
 9000 format(/1x,A8,' trimer',3I6,' corr= ',A11,', LL1=',I6,' ID=',I12)
 9005 format(/1x,'Resetting LABSIZ=',2I2,/)
c9005 format(/1x,'Running energy for trimer ',3I4,' in vaccuum',/)
c9010 format(/1x,'Running ',A8,' energy for monomer ',I3,
c    *           ' including the basis set for fragment',I3/)
c9020 format(/1x,'energy of the separated trimer ',2I4,', L1=',I5,
c    *           ' is',F20.9/)
 9200 format(a8)
 9203 format(1x,'Using tighter ICUT=',I2)
 9210 format(1x,3I5,I3,2F22.10,2F16.10)
 9100 format(/1x,' iFrag=',I5,' jFrag=',I5,' kFrag=',I5,' EFMOu=',F16.9,
     *           ' Tr=',F12.9)
 9110 format(/1x,' iFrag=',I5,' jFrag=',I5,' kFrag=',I5,' EFMOc=',F16.9)
c9110 format(/1x,'Skipping iFrag=',I5,' jFrag=',I5,' kFrag=',I5,/)
 9300 format(/1x,'Trying desperately the alternative SCF converger.')
 9310 format(/1x,'Despite trying desperately, SCF did not converge.')
 9320 format(/1x,'Desperately converged',I5,', diverged',I5,' trimers.'
     *          ,/)
 9500 format(/1x,'Running out of time...',/)
      END
C*MODULE fmo     *DECK efmoq
      subroutine efmoq(ilay,loadhf,loadd,layfrg,molfrg,IDAcFMO,
     *                 iodcfmo,modmol,exclmol,edimq)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      logical GOPARR,DSKWRK,MASWRK,ISGDDI,PAROUT,INITGDDI,myjob,exclmol,
     *        wasgddi,mlgddi
      Parameter(MXATM=2000)
      dimension loadd(*),layfrg(*),iodcfmo(*),edimq(*),molfrg(*)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
c
c     The main FMOQ correction driver.
c
      if(isgddi) call GDDICOUNT(-1,lgroup,myjob)
      lijfg=0
      do 450 iifg=1,nfg
        do 450 jjfg=1,iifg-1
          lijfg=lijfg+1
          if(loadhf.eq.1) then
            ijfg=loadd(lijfg)
            call tribrk(ijfg,-1,ifg,jfg)
c           ifg=ifg+1
          else
            ijfg=lijfg
            ifg=iifg
            jfg=jjfg
          endif
          if(resdim.ne.0) then
            rij=fmodist(ifg,0,0,jfg)
            if(rij.gt.resdim) goto 450
          endif
c         skip dimers from higher layers
          if(.not.((layfrg(ifg).eq.ilay.or.layfrg(jfg).eq.ilay).and.
     *       layfrg(ifg).ge.ilay.and.layfrg(jfg).ge.ilay)) goto 450
          if(iand(modmol,1).ne.0) then
c           check if MOLFRG option tells to ignore dimers except those with
c           one from the chosen group.
            ires=molfrg(ifg)+molfrg(jfg)
            if(exclmol) then
              if(ires.ge.0.and.ires.ne.2) goto 450
            else
              if(ires.eq.0.or.ires.eq.2) goto 450
            endif
          endif
          if(isgddi) then
            call GDDICOUNT(0,lgroup,myjob)
            if(.not.myjob) goto 450
          endif
          call makemol(ifg,jfg,0,ilay,0,0,0,0,0,0,0,.true.)
c         l0=nqmt
          l1=num
          l2=(l1*l1+l1)/2
c         l3=l1*l1
          if(maswrk) write(iw,9000) ifg,jfg,l1
          call fmoqesp(ilay,ijfg,ifg,jfg,l1,l2,loadd,IDAcFMO,iodcfmo,
     *                 edimq)
c
  450 continue
      if(isgddi) call GDDICOUNT(1,lgroup,myjob)
      return
 9000 format(/1x,'Running dimer',2I5,', LL1=',I4)
      END
