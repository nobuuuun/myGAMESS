C  1 Apr 16 - TN,HN,DGF - changes for FMO 5.2
C 22 Oct 14 - HN - changes for FMO 5.1
C 21 May 13 - DGF,HN,TN - changes for FMO 5.0
C 19 Oct 12 - MWS - synchronize FRGINF common
C  2 Sep 12 - MWS - synchronize MCINP
C 21 JUN 12 - DGF - changes for FMO 4.3
C 23 MAR 12 - DGF - pad common blocks
C 28 DEC 11 - DGF - pad commons for FMO 4.2
C 15 Apr 11 - MWS - synch FMOPNT common
C 11 Aug 10 - TN  - new module for Hessians in FMO
c
C*MODULE FMOHSS  *DECK FMODEH
C>
C>     @brief Hessian contributions
C>
C>     @details Accumulates Hessian contributions.
C>
C>     @author Takeshi Nagata
C>
      SUBROUTINE FMODEH(ida,FCM,fmoddm,FMOFCM,fmopg,iaglob,nc0,
     *           indat,layfrg,iwrk,job)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      Parameter (MXATM=2000)
CZCZ  common /GRAD  / DE(3,MXATM)
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
CZCZ  COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,nfmopcm,IHET
c     Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
cz    common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
cz   *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
cz   *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
cz   *                IESDPPC,idoprop,mp2run
      dimension fmopg(3,*),iaglob(*)
      DIMENSION fmoddm(3,3,*),FMOFCM(nc0,*),FCM(3*nat,*),
     *          indat(*),layfrg(*),iwrk(*)
c
c     gather FMO HESSIAN contributions coming from the analytic gradient of a
c     monomer/dimer.
c
c     Add the contribution from electrostatic potential
      if(ida.eq.0) return
      da  = ida
      neh = nc0 * nc0
      if(maswrk.and.job.ne.-1) call daxpy(neh,da,FCM,1,FMOFCM,1)
C
      if(nat.lt.0) write(iw,*) fmopg(1,1)
      if(job.eq.1) return
C
      call mapfmohess(nat,iaglob,indat,layfrg,iwrk,ntmp,0)
C
c     write(6,'(5I3)') (iwrk(iii),iii=1,nat)
C
      NC1 = 3*NAT
c
c     Accumulate the dipole derivatives.
c
      CALL DAREAD(IDAF,IODA,FCM,3*NC1,34,0)

      if(maswrk) then
      da = ida
      do i = 1, nat
        ih  = iwrk(i)
        if(ih.ne.0) then
         do k = 1,3
          ii  = 9*(i-1)+(k-1)*3
          do l = 1,3
            fmoddm(l,k,ih) = fmoddm(l,k,ih)+da*fcm(ii+l,1)
c           Here we treat fcm as a linear array of size 3*3*nat.
          end do
         end do
        endif
      end do
      endif
c
c     Accumulate the Hessian
c
C
      CALL DAREAD(IDAF,IODA,FCM,NC1*NC1,4,0)
C
c     CALL FCMOUT(FCM,nc1)
C
      IF(DFTBFL) THEN
        DO IXYZ=1,NAT*3
         DO JXYZ=1,IXYZ
          DUM = (FCM(IXYZ,JXYZ) + FCM(JXYZ,IXYZ))/2.0D+00
          FCM(IXYZ,JXYZ) = DUM
          FCM(JXYZ,IXYZ) = DUM
         END DO
        END DO
      END IF

C
      if(maswrk) then
      da = ida
      do i = 1, nat
        ih  = iwrk(i)
        ii  = 3*(i-1)
        ims = 3*(ih-1)
        do j = 1, nat
          jh  = iwrk(j)
          jj  = 3*(j-1)
          jms = 3*(jh-1)
          if(ih.ne.0.and.jh.ne.0) then
           do k = 1,3
            do l = 1,3
              fmofcm(ims+k,jms+l)=fmofcm(ims+k,jms+l)+da*fcm(ii+k,jj+l)
            end do
           end do
          end if
        end do
      end do
      endif
c
      CALL VCLR(FCM,1,NC1*NC1)
      CALL DAWRIT(IDAF,IODA,FCM,NC1*NC1,4,0)
c
c     No FMO/PCM contribution for separated dimers.
CZCZ  if(nfmopcm.gt.0.and.ifmostp.ne.6.and.ifmostp.ne.7
CZCZ *   .and.IESDPPC.eq.0) call daxpy(natfmo*3,da,fmopg,1,fmode,1)
      return
      end
C*MODULE FMOHSS  *DECK FMOHESSX
C>
C>     @brief FMO Hessian driver
C>
C>     @details Perform FMO Hessian calculations.
C>
C>     @author Takeshi Nagata
C>
      SUBROUTINE FMOHESSX(VIBOVR,GOTWFN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION METHOD,METHNR
C
      LOGICAL PRTIFC,PURIFY,PROJCT,VIBANL,RDHESS,DECOMP,LINEAR,
     *        GOTEG,GOTEH,GOTDDM,GOTADM,STATPT,SOME,PRTSCN,GOTFRQ,
     *        VIBOVR,GOTWFN,GOPARR,DSKWRK,MASWRK,TEST,
     *        PULCOR,EFLDL,POLAR,HSSEND,SCFOK,REDOVB,OK,FGONLY,
     *        QMMM,MMONLY,CARTSN,CANONC,FCORE,FORS,EKT,LINSER,
     *        MPGRD,CIGRD,DIISON,OUT,STPT,PROJCT2,PROJCSAV,tst,
     *        prtout,prtpun
C
      PARAMETER (MXATM=2000, MXAO=8192, MXPT=2000, MXFRG=1050,
     *           MXFGPT=12000, MXNORO=250, MAXNFRAGS=10,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12, MXIRR=14)
      PARAMETER (NNAM=20)
C
      DIMENSION QNAM(NNAM), KQNAM(NNAM), APOL(6), RAMALF(6)
C
      COMMON /CHFINF/ CHFSLV,CPTYPE,NWDCHF,POLAR,NSPLIT
      COMMON /EFLDC / EVEC(3),EFLDL
      COMMON /FMCOM / X(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /FROZNC/ IFREEZ(3*MXATM),NFRZ
      COMMON /FUNCT / E,EG(3,MXATM)
      COMMON /GVBWFN/ CICOEF(2,12),F(25),ALPHA(325),BETA(325),NO(10),
     *                NCO,NSETO,NOPEN,NPAIR,NORB,NCONF(MXAO),NHAM
      COMMON /HSSCTL/ IHESSM,IHREP,HSSEND,IGOTH
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /MCINP / METHNR,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /MIOPT / DTOL,CNVLOC,DIISTL,ALPHAX,
     *                NF(MAXNFRAGS),MF(MAXNFRAGS),NFRAGS,MSHIFT,ITERMI,
     *                ITLOC,IGUESS,MXDIIS,
     *                IOPT,MIFLAG,DIISON
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOLMP,METHMP,NWDMP2,MEMPRI,
     *                MPPROP,NACORMP,NBCORMP,NOAMP,NOBMP,NORBMP,NBFMP,
     *                NOMITMP,MPCPHF,MAXITCMP
      COMMON /NEOJOB/ NEORUN,NELERM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,NFMOPCM,IHET
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,TAU,
     *                IQRORD,MODQR,NESOC,NRATOM,
     *                NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SVPOPT/ ISVP,NSVP,MTHSVP,NCAV,NVLPL,IQP
      COMMON /SYMBLK/ NIRRED,NSALC,NSALC2,NSALC3,NSAFMO
      COMMON /SYMREP/ IRPNAM(MXIRR),IPA(MXIRR),LAMBDA(MXIRR),
     *                LAMBD0(MXIRR),IADDR1(MXIRR),IADDR2(MXIRR),
     *                IADDR3(MXIRR)
      COMMON /THERMD/ FREQ(3*MXATM),TEMP(10),SCLFAC,NTEMP,PRTSCN,GOTFRQ
      COMMON /TINOPT/ mparti,MMONLY,QMMM
      COMMON /VBDCMP/ DECOMP,NROW,NDEG
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /ZMAT  / NZMAT,NZVAR,NVAR,NSYMC,LINEAR
      COMMON /ZRFPAR/ GZRF,FIND(3),GNUCF,EBORN,DIELEC,IZRF,ICALC
c
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
C
C     COSMO information
C
      LOGICAL ISEPS,USEPS
      COMMON /ISEPS / ISEPS, USEPS
      LOGICAL COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
      COMMON /COSDAT/ SE2,SECORR,QVCOSMO,ELAST,EMP2COS,EMP2LAST,
     *                COSVOL,COSSAR,EDIEL,EOC1,DEOC_RS,SUMQSC,
     *                SUMQSCOLD,ZSUM,ZSUM2,ZSUM3,FEPSI,RDS,DISEX2,
     *                EPSI,COSRAD,DISEX,OUTCHG,EDIEL_SAVE,
     *                MAXNPS,ICORR,ITRIP,NQS,MP2TRIP,MP2ITER,
     *                ICFREQ,NSPA,NSPH,NPSD,NPS,NPS2,NDEN,NPSPHER,
     *                COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
C    for fmomm hessian
      logical imomm,simomm,CHGEMB
      common /QMMM1/ IMOMM,SIMOMM,NPAIRMM,NSEQ,CHGEMB
C
      PARAMETER (TOLG=0.0005D+00, ZERO=0.0D+00)
C
C     ----- SET UP NAMELIST SIMULATION -----
C
      DATA FORCE/8HFORCE   /
      DATA QNAM/8HNVIB    ,8HVIBSIZ  ,8HPRTIFC  ,8HPURIFY  ,8HPROJCT  ,
     *          8HMETHOD  ,8HVIBANL  ,8HRDHESS  ,8HDECOMP  ,8HSCLFAC  ,
     *          8HTEMP    ,8HFREQ    ,8HPRTSCN  ,8HNPRT    ,8HNPUN    ,
     *          8HPULCOR  ,8HTEST    ,8HREDOVB  ,8HHSSTYP  ,8HNPRHSS  /
      DATA KQNAM/1,3,0,0,0,5,0,0,0,3,103,-3,0,1,1,0,0,0,5,1/
C
      DATA HSSIAN/8HHESSIAN /
      DATA GAMMA/8HGAMMA    /
      DATA ANAL,SNUM,FNUM,RNUM
     *      /8HANALYTIC,8HSEMINUM ,8HFULLNUM ,8HNUMERIC /
      DATA RHF,ROHF,UHF/8HRHF     ,8HROHF    ,8HUHF     /
      DATA      GVB,RMC/8HGVB     ,8HMCSCF   /
      DATA GENCI,GUGA,CIS/8HGENCI   ,8HGUGA    ,8HCIS     /
      DATA ZAPT/8HZAPT    /
      DATA NONE,RNONE/4HNONE,8HNONE    /
      DATA CHECK/8HCHECK   /
      DATA FMOHESS/8HFMOHESS /
      DATA IRRA/4HA   /
      DATA GENERAL/8HGENERAL /,CHECKME/8HCHKFMOHS/
      dimension dum3(3)
C
C     ----- MAIN DRIVER TO OBTAIN HESSIAN MATRIX -----
C
C     THE ENERGY, GRADIENT, HESSIAN, AND DIPOLE DERIVATIVE TENSOR
C     ARE OBTAINED BY READING THEM FROM CARDS, OR COMPUTING THEM.
C     THE ALPHA POLARIZABILITY DERIVATIVE TENSOR IS OBTAINED ONLY
C     BY READING IT FROM CARDS.  IT IS COMPUTED ONLY BY RUNTYP=RAMAN.
C
C     THE CALLING ARGUMENTS PERMIT YOU TO OVERRIDE THE VALUE OF
C     VIBANL GIVEN IN $FORCE BELOW, AND INDICATE THE SUCCESFUL
C     CONCLUSION OF A GEOMETRY SEARCH, USEFUL FOR $STATPT 'HSSEND'
C
      tst=exetyp.eq.checkme
CZCZ
CZ    Scan $FMOXYZ to find natfmo.
      qmmm   =.false.
      mmonly =.false.
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $TINKEY',JEOF1)
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $LINK  ',JEOF2)
      if(JEOF1.eq.0 .and. JEOF2.eq.0) qmmm=.true.
      if(JEOF1.eq.0 .and. JEOF2.ne.0) mmonly=.true.
      if(mmonly) call abrt
CZ
      if(qmmm. or. mmonly) then
        CALL TINKIN(IR,IW)
c       force tinker coordinates to pass to LINKIN
c       if(qmmm) ICOORD=5
        if(qmmm) CALL LINKIN(1)
        CALL TOPTIN
        if(qmmm)   natfmo=nseq+npairmm
c       write(6,*) "wwwqmmm =",natfmo,npair,NPAIRMM
      else
c       write(6,*) "wwwfmoxyz0"
        call fmoxyz(' $FMOXYZ',1,natfmo,dum,dum3,idum)
      endif
CZ
      CALL VALFM(LOADFM)
      LFMOC   = LOADFM  + 1
      LFMOZAN = LFMOC   + 3*(NATFMO+1)
      LFMOMAS = LFMOZAN + NATFMO
      LIZBAS  = LFMOMAS + NATFMO
      LFREQ   = LIZBAS  + (NATFMO-1)/NWDVAR+1
      LAST    = LFREQ   + 3*natfmo
      NEEDFMO = LAST - LOADFM - 1
      CALL GETFM(NEEDFMO)
CZCZ
      if(qmmm .or. mmonly) then
         call tin2fmo(natfmo,x(lfmozan),x(lfmoc),x(lizbas))
      endif
C

      SOME = NPRINT.NE.-5 .AND. MASWRK
CZCZ  NCOORD = 3*NAT
      NCOORD = 3*natfmo
c     NCOORD0 = 3*min(natfmo,mxatm)
      NCF    = 6*NFRG
      GOTEG  = .FALSE.
      GOTEH  = .FALSE.
      GOTDDM = .FALSE.
      GOTADM = .FALSE.
C
C     ----- READ $FORCE INPUT GROUP -----
C
C        THE STRATEGY FOR DETERMINING THE DEFAULT DIFFERENTIATION
C        IS TO PERFORM AN ANALYTIC CALCULATION IF POSSIBLE, OR TO
C        CHOOSE SEMI-NUMERICAL DIFFERENTIATION OF ANALYTIC GRADIENTS.
C        IF THE ANALYTIC GRADIENT IS NOT CODED, THE USER IS PERMITTED
C        TO REQUEST FULLY NUMERIC DIFFERENTIATION, BUT BECAUSE THIS
C        IS REASONABLE ONLY FOR SMALL MOLECULES, WE NEVER PICK THAT
C        AS A DEFAULT (THEY MUST TYPE IT).
C
      METHOD=ANAL
C
C     ---- THE FOLLOWING METHODS ONLY ALLOW SEMI-NUMERIC HESSIANS ----
C        BASIS SETS WITH F OR G FUNCTIONS
C        UHF, OR GVB WITH MORE THAN ONE PERFECT PAIR
C        MCSCF IF IT DOES NOT USE FULL ACTIVE SPACE DETERMINANT CODE
C        CI, MP2 (RHF OR UHF), DFT
C        MOPAC WAVEFUNCTIONS
C        SIMOMM MODEL
C        SOLVENT MODELS: EFP, ONSAGER, PCM, OR COSMO
C        SCALAR RELATIVISTIC CORRECTIONS
C        APPLIED EXTERNAL ELECTRIC FIELD
C        SCF-MI
C     ALL OF WHICH HAVE ANALYTIC GRADIENTS PROGRAMMED.
C     IN ADDITION, THE PARTIAL HESSIAN ANALYSIS IS SEMI-NUMERIC
C
      CALL BASCHK(LMAX)
      IF(LMAX.GT.2)                             METHOD=SNUM
      IF(SCFTYP.EQ.UHF)                         METHOD=SNUM
      IF(SCFTYP.EQ.GVB  .AND.  NPAIR.GT.1)      METHOD=SNUM
      IF(SCFTYP.EQ.RMC  .AND.  CISTEP.EQ.GUGA)  METHOD=SNUM
      IF(SCFTYP.EQ.RMC  .AND.  CISTEP.EQ.GENCI) METHOD=SNUM
      IF(MPLEVL.GT.0)                           METHOD=SNUM
      IF(CITYP.NE.RNONE)                        METHOD=SNUM
      IF(DFTYPE.NE.RNONE)                       METHOD=SNUM
      IF(SCFTYP.EQ.RHF  .AND. TDDFTYP.NE.RNONE) METHOD=SNUM
      IF(MPCTYP.NE.NONE)                        METHOD=SNUM
      IF(IECP.EQ.5)                             METHOD=SNUM
c     IF(QMMM)                                  METHOD=SNUM
      ISOLV = NFRG + IZRF + IPCM
      IF(ISOLV.GE.1  .OR.  ISEPS)               METHOD=SNUM
      IF(RMETHOD.NE.RNONE)                      METHOD=SNUM
      IF(EFLDL)                                 METHOD=SNUM
      IF(MIFLAG.EQ.1)                           METHOD=SNUM
      IF(RUNTYP.EQ.HSSIAN.AND.IFREEZ(1).NE.0)   METHOD=SNUM
      IF(NEORUN.EQ.1)                           METHOD=SNUM
C
C         IF WE HAVE THE ENERGY, BUT NOT THE ANALYTIC GRADIENTS...
C
      MPGRD = SCFTYP.EQ.RHF  .OR.  SCFTYP.EQ.UHF
     *                       .OR. (SCFTYP.EQ.ROHF  .AND.  OSPT.EQ.ZAPT)
      CIGRD = SCFTYP.EQ.RHF .AND. (CITYP.EQ.GUGA  .OR.  CITYP.EQ.CIS)
      IF(MPLEVL.GT.0  .AND.  .NOT.MPGRD)           METHOD=RNONE
      IF(CITYP.NE.RNONE  .AND.  .NOT.CIGRD)        METHOD=RNONE
      IF(CCTYP.NE.RNONE)                           METHOD=RNONE
      IF(VBTYP.NE.RNONE)                           METHOD=RNONE
      IF(SCFTYP.NE.RHF  .AND. TDDFTYP.NE.RNONE)    METHOD=RNONE
      IF(ISVP.EQ.1)                                METHOD=RNONE
C        NOTE THAT WE ARE LETTING EFP SLIDE HERE,
C        FOR TRADITIONAL REASONS,
C        BUT WE DON'T HAVE MP2/CI+EFP GRADIENTS CORRECTLY CODED.
      IF(MPLEVL.GT.0  .OR.  CITYP.NE.RNONE) THEN
         IF(IZRF.GE.1 .OR.  IPCM.EQ.1  .OR. ISEPS) METHOD=RNONE
      END IF
C
C         REMEMBER THIS DEFAULT FOR ERROR CHECKING LATER
C
      IANAL=0
      ISNUM=0
      IFNUM=0
      IF(METHOD.EQ.ANAL)  IANAL=1
      IF(METHOD.EQ.SNUM)  ISNUM=1
      IF(METHOD.EQ.RNONE) IFNUM=1
C
      FGONLY = NUM.EQ.0  .AND.  NFRG.GT.0
      IF(ISEPS) ICFREQ=1
      RDHESS=.FALSE.
      NVIB = 1
      MPRINT=NPRINT
      VIBSIZ=0.01D+00
      PURIFY=.FALSE.
      PRTIFC=.FALSE.
      VIBANL=.FALSE.
czcz  IF(RUNTYP.EQ.HSSIAN) VIBANL=.TRUE.
      IF(RUNTYP.EQ.FMOHESS) VIBANL=.TRUE.
      DECOMP=.FALSE.
      PROJCT=.FALSE.
      IF(IFREEZ(1).NE.0) PROJCT=.TRUE.
      SCLFAC = 1.0D+00
      DO 100 I=1,10
         TEMP(I) = ZERO
  100 CONTINUE
      TEMP(1) = 298.15D+00
      KQNAM(12) = NCOORD*10+3
      call vclr(x(lfreq),1,NCOORD)
      PRTSCN = .FALSE.
      NPRT = 0
      NPUN = 0
      PULCOR=.FALSE.
      REDOVB=.TRUE.
C
C     "TEST" IS AN UNDOCUMENTED WAY TO AVOID THE CHECK MADE
C     BELOW AS TO WHEN ANALYTIC HESSIANS CAN BE REQUESTED.
C
      PROJCSAV=PROJCT
C
      TEST=.FALSE.
C
      HSSTYP=GENERAL
c
      NPRHSS=0
c     1 - stop printing the Hessian, dipole etc
c     2 - stop punching the Hessian, dipole etc
c     4 - stop printing/punching normal modes
C
      JRET=0
      CALL NAMEIO(IR,JRET,FORCE,NNAM,QNAM,KQNAM,
     *            NVIB,VIBSIZ,PRTIFC,PURIFY,PROJCT,METHOD,VIBANL,
     *            RDHESS,DECOMP,SCLFAC,TEMP,x(lFREQ),PRTSCN,NPRT,NPUN,
     *            PULCOR,TEST,REDOVB,HSSTYP,NPRHSS,
     *                0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
      NERR=0
      IF(JRET.EQ.2) NERR=NERR+1
C
C       'NUMERIC ' IS TO BE CONSIDERED AN ACCEPTABLE TYPO FOR 'SEMINUM '
      IF(METHOD.EQ.RNUM) METHOD=SNUM
C
      IF(NPRT.LT.0) NPRT=0
      IF(NPRT.GT.1) NPRT=1
      IF(NPUN.LT.0) NPUN=0
      IF(NPUN.GT.2) NPUN=2
      prtout=iand(nprhss,1).eq.0
      prtpun=iand(nprhss,2).eq.0
C
      IF(SOME) WRITE(IW,9010) METHOD,NVIB,VIBSIZ,
     *                        RDHESS,PURIFY,PRTIFC,
     *                        VIBANL,DECOMP,PROJCT,
     *                        SCLFAC,PRTSCN,NPRT,
     *                        PULCOR,NPUN,REDOVB
C
      NTEMP=0
      DO 200 I=1,10
         IF(TEMP(I).NE.ZERO) NTEMP=NTEMP+1
  200 CONTINUE
      IF(SOME  .AND.  VIBANL) WRITE(IW,9012) NTEMP,(TEMP(I),I=1,NTEMP)
C
      NFREQ=0
      DO 210 I=1,NCOORD
         IF(x(lFREQ+I-1).NE.ZERO) NFREQ=NFREQ+1
  210 CONTINUE
      IF(NFREQ.GT.0) THEN
         IF (SOME) WRITE(IW,9014) NFREQ,(x(lFREQ+I-1),I=1,NFREQ)
         GOTFRQ=.TRUE.
      END IF
C
      IF(NVIB.LE.0  .OR.  NVIB.GT.2) NERR=NERR+1
      IF(ABS(VIBSIZ).GT.0.25D+00) NERR=NERR+1
C
      OK=.FALSE.
      IF(METHOD.EQ.ANAL) OK=.TRUE.
      IF(METHOD.EQ.SNUM) OK=.TRUE.
      IF(METHOD.EQ.FNUM) OK=.TRUE.
      IF(.NOT.OK) THEN
         IF(MASWRK) WRITE(IW,*)
     *       '*** ERROR: METHOD = ANALYTIC, SEMINUM, OR FULLNUM ONLY'
         NERR=NERR+1
      END IF
      IF(METHOD.EQ.ANAL) NHLEVL=0
      IF(METHOD.EQ.SNUM) NHLEVL=1
      IF(METHOD.EQ.FNUM) NHLEVL=2
C
      IF(NGLEVL.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9090)
         NERR=NERR+1
      END IF
C
C        CHECK TO SEE IF DIFFERENTIATION METHOD IS REASONABLE
C     THE UNDOCUMENTED KEYWORD -TEST- ALLOWS SKIPPING THESE CHECKS.
C     OF COURSE, -TEST- SHOULD BE CHOSEN ONLY BY SOMEONE WHO IS
C     TRYING TO PROGRAM A MISSING METHOD.
C
      IF(.NOT.TEST) THEN
         IF(METHOD.EQ.ANAL  .AND.  (ISNUM+IFNUM).GT.0) THEN
            IF(MASWRK) WRITE(IW,9100)
            IF(MASWRK) WRITE(IW,9105) METHOD
            NERR=NERR+1
         END IF
         IF(METHOD.EQ.SNUM  .AND.  IFNUM.GT.0) THEN
            IF(MASWRK) WRITE(IW,9100)
            IF(MASWRK) WRITE(IW,9105) METHOD
            NERR=NERR+1
         END IF
      END IF
C
C        PRINT SOME FRIENDLY ADVISE IF A HIGHER METHOD IS FEASIBLE
C
      IF(MASWRK) THEN
         IF(METHOD.EQ.SNUM  .AND.  IANAL.EQ.1) WRITE(IW,9106) ANAL,SNUM
         IF(METHOD.EQ.FNUM  .AND.  IANAL.EQ.1) WRITE(IW,9106) ANAL,FNUM
         IF(METHOD.EQ.FNUM  .AND.  ISNUM.EQ.1) WRITE(IW,9106) SNUM,FNUM
      END IF
C
      IF(NERR.GT.0) THEN
         IF(MASWRK) WRITE(IW,*)
     *      'ERROR IN $FORCE INPUT, PLEASE FIX AND TRY AGAIN.'
         CALL ABRT
      END IF
C
      IF(GOTFRQ) GO TO 800
C
C     ----- READ INTERNALS, GENERATE B MATRIX -----
C     THIS MUST BE DONE AFTER -DECOMP- IS KNOWN, AS THE DECOMPOSITION
C     SOMETIMES USES MORE THAN 3N-6 COORDINATES.  THE Z-MATRIX
C     CODE PERMITS MORE THAN 3N-6 COORDINATES ONLY IF DECOMP=.T.
C
      CARTSN = NZVAR.EQ.0
      IF(NZVAR.GT.0 .AND. RUNTYP.EQ.HSSIAN) THEN
         CALL ZMATIN(CARTSN)
         CALL BANDBI
         CALL PZANDG(F,0)
      END IF
C
C     ----- OBTAIN THE INFORMATION FROM CARD INPUT -----
C
      IF(RDHESS) THEN
         CALL VALFM(LOADFM)
         LFCM   = LOADFM+1
         LDDM   = LFCM   + (NCOORD+NCF)*(NCOORD+NCF)
         LADM   = LDDM   + 3*(NCOORD+NCF)
C
C            NOTE THAT $ALPDR IS NOT SET UP TO WORK WITH ANY
C        --- SOLVATION MODELS, SO ONLY 6*NCOORDS WORDS ARE
C            NEEDED INSTEAD OF 6*(NCOORD+NCF)
C
         LEG    = LADM   + 6*NCOORD
         LAST   = LEG    + NCOORD
         NEED = LAST-LOADFM
         CALL GETFM(NEED)
C
C           LOOK FOR OPTIONAL GRADIENT VECTOR
C           LOOK FOR HESSIAN MATRIX
C           LOOK FOR OPTIONAL DIPOLE DERIVATIVE TENSOR
C           LOOK FOR OPTIONAL ALPHA POLARIZABILITY DERIVATIVE TENSOR
C
         CALL EGIN(X(LEG),NCOORD,GOTEG,' $GRAD  ')
         CALL FCMIN(X(LFCM),NCOORD+NCF,GOTEH)
         CALL DDMIN(X(LDDM),NCOORD+NCF,GOTDDM)
         CALL ADMIN(RAMALF,X(LADM),NCOORD,GOTADM)
         CALL RETFM(NEED)
         IF(GOTEH) THEN
            SCFOK=.TRUE.
            GO TO 700
         ELSE
            IF (MASWRK) WRITE(IW,9030)
            CALL ABRT
         END IF
      END IF
C
C     ----- OTHERWISE, THEY MUST BE COMPUTED -----
C
CZ
CZ    FMO HESSIAN CALCULATION
CZ
c     if (.not.rdhess) then
      GOTDDM=.TRUE.
      if (maswrk) write(6,*) 'HESS CALC IN FMOHESS DRIVER STARTS'
      if(.not.tst) CALL FMOX(0)
      igoth=0
      IF(modfd.ne.0) then
        if(rdhess) then
          if(maswrk) write(iw,9005)
          call abrt
        endif
        CALL VALFM(LOADFM)
C
        MODE    = -25
        NCVAL   = NAT*3
        NCOORD  = NAT*3
        OUT     = .false.
        MAX2    = NZVAR
        LNZVAR  = LOADFM + 1
        LOZVAR  = LNZVAR + MAX2
        LDDM    = LOZVAR + MAX2
        LAST    = LDDM   + 3*(NCOORD+NCF)
        NEED    = LAST   - LOADFM - 1
        CALL GETFM(NEED)
C       READ FROZEN COORDINATE LIST
        CALL SIGINI(MODE,RUNTYP,NCVAL,NCOORD,METHOD2,OUT,
     *               GOTEG,NPRT2,NPUN2,ITBMAT,STPT,STSTEP,
     *               PROJCT2,X(LNZVAR),X(LOZVAR),MAX2,NPRTHS)
C
        CALL PRATM(IW,2)
C       Calculate/Read Hessian
        if(igoth.eq.0) then
          CALL FMOX(1)
        else
c         Replace data for values in B.
          call dcopy(nat,zmass,1,x(lfmomas),1)
          call dcopy(nat,  zan,1,x(lfmozan),1)
          call dcopy(nat*3,  c,1,x(lfmoc),1)
          if(nirred.le.1) then
c            Brute force C1: these arrays are not set as no QM was run!
             nirred=1
             irpnam(1)=irra
          endif
c
          CALL DDMIN(X(LDDM),NCOORD+NCF,GOTDDM)
c         DO I=1,NAT
c           write(6,6666) 'wwwzz',i,zmass(i),zan(i),C(1,i),C(2,i),C(3,i)
c6666       format(A5,I3,5F12.6)
c         enddo
        endif
        CALL RETFM(NEED)
C
      END IF
      if (maswrk) write(6,*) 'HESS CALC IN FMOHESS DRIVER ENDS'
      SCFOK = .TRUE.
c     end if
cz
cz    Tricky part: this is just for the vibrational analysis
cz
      IF(modfd.eq.0) nat = natfmo
      ncoord = nat*3
czcz

cz    IF(METHOD.EQ.ANAL) THEN
cz       IHESSM=2
cz       GOTDDM=.TRUE.
cz       GOTEG =.TRUE.
cz       CALL VALFM(LOADFM)
cz       LDDM = LOADFM+1
cz       LAST = LDDM  + 3*NCOORD
cz       NEED = LAST-LOADFM
cz       CALL GETFM(NEED)
cz       CALL VCLR(X(LDDM),1,3*NCOORD)
cz       CALL DAWRIT(IDAF,IODA,X(LDDM),3*NCOORD,34,0)
cz       CALL RETFM(NEED)
cz       CALL HSSANA(GOTWFN)
cz       SCFOK=.TRUE.
cz    END IF
C
cz    IF(METHOD.EQ.SNUM) THEN
cz       IHESSM=1
cz       GOTDDM=.TRUE.
cz       GOTEG =.TRUE.
cz       CALL VALFM(LOADFM)
cz       LFCM   = LOADFM + 1
cz       LDDM   = LFCM   +   (NCOORD+6*NFRG)**2
cz       LIST   = LDDM   + 3*(NCOORD+6*NFRG)
cz       LSKIP  = LIST   + 6*NFRG*NVIB
cz       LSKIP2 = LSKIP  + NAT+2*NFRG
cz       LWRK   = LSKIP2 + NAT*NAT
cz       LAST   = LWRK   + NUM*NUM
cz       NEED = LAST-LOADFM
cz       CALL GETFM(NEED)
cz       NATM = NAT
cz       CALL HSSNUM(X(LFCM),X(LDDM),X(LSKIP),X(LSKIP2),X(LWRK),
cz   *               X(LIST),NCOORD+6*NFRG,NAT+2*NFRG,NATM,
cz   *               NVIB,VIBSIZ,NPRT,NPUN,SCFOK,GOTWFN,REDOVB)
cz       CALL RETFM(NEED)
cz    END IF
c
cz    IF(METHOD.EQ.FNUM) THEN
cz       IHESSM=0
cz       IF(NFRG.GT.0) THEN
cz          IF(MASWRK) WRITE(IW,*)
cz   *          'FULLY NUMERIC HESSIAN NOT AVAILABLE WITH EFP'
cz          CALL ABRT
cz       END IF
cz       GOTDDM = .FALSE.
cz       GOTEG  = .FALSE.
cz       MYNC1  = 3*NAT
C           THE ACTUAL NUMBER OF POINTS DONE CANNOT EXCEED MXSP
cz       MXSP   = 1 + 24*NAT + 18*NAT*NAT
cz       CALL VALFM(LOADFM)
cz       LFCM   = LOADFM + 1         ! START OF FCM
cz       LDDM   = LFCM   + MYNC1**2  ! START OF DDM
cz       LSKIP  = LDDM   + 3*MYNC1   ! START OF SKIP ARRAY
cz       LATMP  = LSKIP  + NAT       ! START OF ATOM PAIR ARRAY
cz       LWRK   = LATMP  + NAT*NAT   ! STORT OF VIB0 ORBITALS
cz       LESP   = LWRK   + NUM*NUM   ! START OF SINGLE POINT ENERGIES
cz       LEG    = LESP   + MXSP      ! START OF GRADIENT
cz       LAST   = LEG    + NCOORD    ! LAST ADDRESS ON STACK
cz       NEED   = LAST - LOADFM
cz       CALL GETFM(NEED)
cz       CALL HSSFUL(X(LESP),X(LFCM),X(LSKIP),X(LATMP),X(LWRK),
cz   *               NAT,MYNC1,MXSP,VIBSIZ,GOTEG,SCFOK)
cz       CALL RETFM(NEED)
cz    END IF
C
C         THE HESSIAN COMPUTATION IS NOW FINISHED
C
  700 CONTINUE
C
C         HESSIAN MAY BE COMPUTED AS PART OF A GEOMETRY OPTIMIZATION,
C         ETC., AND THOSE RUNS MAY NOW TEST -IHESSM- TO KNOW THEY ARE
C         NO LONGER IN A HESSIAN CALCULATION PHASE...
C
      IHESSM=0
C
C     --- PURIFY THE HESSIAN,DIPOLE DERIVATIVES,ALPHA POLARIZABILITY ---
C
      NPRINT=MPRINT
      IF(NZVAR.GT.0 .AND. (PURIFY.OR.PRTIFC.OR.DECOMP.OR.PULCOR)) THEN
         CALL VALFM(LOADFM)
         LFCM   = LOADFM + 1
         LFCMI  = LFCM  + NCOORD*NCOORD
         LEG    = LFCMI + NROW*NROW
         LDDM   = LEG   + MAX(NCOORD,NROW)
         LDDN   = LDDM  + 3*NCOORD
         LADM   = LDDN  + 3*NVAR
         LADMI  = LADM  + 6*NCOORD
         LBMAT  = LADMI + 6*NVAR
         LBINV  = LBMAT + NVAR*NCOORD
         LWRK   = LBINV + NCOORD*NVAR
         LZMAT  = LWRK  + MAX(NCOORD,NROW)
         LIZMAT = LZMAT + NVAR
         LIWRK  = LIZMAT+ NZMAT
         LAST   = LIWRK + NVAR
         NEED = LAST - LOADFM - 1
         CALL GETFM(NEED)
C
C    PURIFY GRADIENT AND/OR PRINT INTERNAL GRADIENT
C
         IF(PRTIFC.OR.PURIFY) THEN
            CALL DAREAD(IDAF,IODA,X(LEG),NCOORD,3,0)
            CALL TRANG(X(LEG),NVAR,NCOORD)
            IF (PRTIFC) THEN
               CALL PZANDG(X(LEG),1)
               IF (NSYMC .EQ. 0)
     *            CALL PUZMAT(X(LZMAT),X(LIZMAT),X(LIWRK),NVAR,NZMAT)
            END IF
            IF (PURIFY) CALL TRANGB(X(LEG),NVAR,NCOORD)
         END IF
C
         CALL PURFCM(X(LFCM),X(LFCMI),X(LIZMAT),NCOORD,NROW,NVAR,
     *               NZMAT,PURIFY,PRTIFC,DECOMP)
C
         IF (PULCOR) THEN
C---         CALL HSSCOR(X(LFCM),X(LFCMI),X(LBINV),X(LEG),NCOORD,NVAR)
             IF(MASWRK) WRITE(IW,*) 'OPTION -PULCOR- IS INACTIVE'
         END IF
C
         IF(GOTDDM  .AND.  PURIFY)
     *      CALL PURDDM(X(LDDM),X(LDDN),X(LBMAT),X(LBINV),X(LWRK),
     *                  NCOORD,NVAR)
         IF(GOTADM .AND. PURIFY)
     *      CALL PURADM(X(LADM),X(LADMI),X(LBMAT),X(LBINV),X(LWRK),
     *                  NCOORD,NVAR)
         CALL RETFM(NEED)
      END IF
C
C     ----- PRINT/PUNCH GRADIENT, HESSIAN, DIPOLE DERIVATIVES,
C     ----- ALPHA POLARIZABILITY DERIVATIVES.
C
      CALL VALFM(LOADFM)
      LFCM = LOADFM + 1
      LEG  = LFCM   + (NCOORD+6*NFRG)*(NCOORD+6*NFRG)
      LDDM = LEG    + NCOORD
      LADM = LDDM   + 3*(NCOORD+6*NFRG)
      LAST = LADM   + 6*NCOORD
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      if(tst) then
         call vclr(X(LEG),1,NCOORD)
         call vclr(X(LFCM),1,(NCOORD+6*NFRG)**2)
         CALL VCLR(X(LDDM),1,3*(NCOORD+6*NFRG))
         CALL DAWRIT(IDAF,IODA,X(LEG),NCOORD,3,0)
         CALL DAWRIT(IDAF,IODA,X(LFCM),(NCOORD+6*NFRG)**2,4,0)
         CALL DAWRIT(IDAF,IODA,X(LDDM),3*(NCOORD+6*NFRG),34,0)
c        create a fake close packed linear chain of H atoms.
         do i=1,natfmo
           di=i
           x(lfmoc+(i-1)*3)=di/1000
           x(lfmoc+(i-1)*3+1)=0
           x(lfmoc+(i-1)*3+2)=0
           x(lfmozan+i-1)=1
           x(lfmomas+i-1)=1
         enddo
         CALL SPDTR
         CALL SYMORB
      else
      IF(NAT.GT.0) CALL DAREAD(IDAF,IODA,X(LEG) ,NCOORD,3,0)
      CALL DAREAD(IDAF,IODA,X(LFCM),(NCOORD+6*NFRG)**2, 4,0)
      IF(GOTDDM) THEN
         CALL DAREAD(IDAF,IODA,X(LDDM),3*(NCOORD+6*NFRG) ,34,0)
      ELSE
         CALL VCLR(X(LDDM),1,3*(NCOORD+6*NFRG))
      END IF
      endif
C
      IF(RUNTYP.EQ.GAMMA) CALL FCMSAV(X(LFCM),NCOORD)
C
      IF(GOTEG .AND. .NOT. FGONLY) THEN
         GRMS = DDOT(NCOORD,X(LEG),1,X(LEG),1)
         GRMS = SQRT(GRMS/NCOORD)
         LOCMX = IDAMAX(NCOORD,X(LEG),1)
         GMAX = X(LEG-1+LOCMX)
         STATPT = GMAX.LT.TOLG  .AND.  GRMS.LT.(TOLG/3.0D+00)
      ELSE
         STATPT = .TRUE.
      END IF
C
czcz  IF(RUNTYP.EQ.HSSIAN  .OR.  GOTWFN) THEN
      IF((RUNTYP.EQ.FMOHESS  .OR.  GOTWFN).and.prtout) THEN
         IF(GOTEG.AND.MASWRK) WRITE(IW,9040)
         IF(GOTEG)  CALL  EGOUT(X(LEG) ,NAT)
CZCZ                CALL FCMOUT(X(LFCM),NCOORD+6*NFRG)
         if(igoth.eq.0) CALL FMOFCMOUT(X(LFCM),NCOORD+6*NFRG)
         IF(POLAR  .AND.  EXETYP.NE.CHECK) THEN
            IF(IFREEZ(1).EQ.0) THEN
               CALL DAREAD(IDAF,IODA,APOL,6,251,0)
               CALL POLOUT(APOL)
            END IF
         END IF
         IF(GOTDDM .AND. .NOT.FGONLY) THEN
c           IF(IFREEZ(1).EQ.0) THEN
            CALL DDMOUT(X(LDDM),NCOORD+6*NFRG)
c           END IF
         END IF
         IF(GOTADM .AND. .NOT.FGONLY) THEN
            CALL POLOUT(RAMALF)
            CALL ADMOUT(X(LADM),NCOORD)
         END IF
      END IF
C
      if(prtpun) then
      IF(GOTEG)  CALL  EGPUN(X(LEG) ,NAT,' $GRAD  ')
                 CALL FCMPUN(X(LFCM),NCOORD+6*NFRG)
      IF(GOTDDM) CALL DDMPUN(X(LDDM),NCOORD+6*NFRG)
      IF(GOTADM) CALL ADMPUN(E,RAMALF,X(LADM),NCOORD)
      endif
      CALL RETFM(NEED)
C
C     ----- NORMAL COORDINATE VIBRATIONAL ANALYSIS -----
C
  800 CONTINUE
      IF(.NOT.VIBANL  .AND.  .NOT.VIBOVR) RETURN
      NC1 = NCOORD+6*NFRG
      NC2 = (NC1**2+NC1)/2
      NC3 = NC1**2
C
      NPART = NAT
      KMASS=0
      DO 820 IFRG=1,NFRG
         DO 810 III=1,NMPTS(IFRG)
            IF(FMASS(III+KMASS).GT.ZERO) NPART=NPART+1
  810    CONTINUE
         KMASS=KMASS+NMPTS(IFRG)
  820 CONTINUE
C
c     IF(IFREEZ(1).NE.0) PROJCT=.TRUE.
      PROJCT = PROJCSAV
C
      CALL VALFM(LOADFM)
      LVEC   = LOADFM + 1
      LFCM   = LVEC   + NC3
      LE     = LFCM   + NC2
      LSCR   = LE     + NC1
      LIA    = LSCR   + NC1*8
      LRM    = LIA    + NC1
      LSVT   = LRM    + (NCOORD+21*NFRG)
      LSVR   = LSVT   + NC1*3
      LSVTT  = LSVR   + NC1*3
      LSVRT  = LSVTT  + NC1
      LCC    = LSVRT  + NC1
      LCOM   = LCC    + 3*NPART
      LZMS   = LCOM   + 3*NPART
      LBUF1  = LZMS   +   NPART
      LBUF2  = LBUF1
      IF (PROJCT.OR.NFRG.NE.0) LBUF2  = LBUF1  + NC3
      LDDM   = LBUF2
      IF (PROJCT) LDDM   = LBUF2  + NC3
      LADM   = LDDM   + NC1*3
      LAST   = LADM   + NC1*6
      NEED = LAST-LOADFM
      CALL GETFM(NEED)
CZ    NATM = NAT+2*NFRG
      IF(NEORUN.EQ.0) THEN
         CALL FGMTRX(X(LVEC),X(LFCM),X(LE),X(LSCR),X(LIA),X(LRM),
     *               X(LSVT),X(LSVR),X(LSVTT),X(LSVRT),x(lfreq),
     *               X(Lfmoc),X(LCOM),X(Lfmomas),X(LBUF1),X(LBUF2),
     *               NC1,NC2,NPART,X(LDDM),GOTDDM,X(LADM),GOTADM,
     *               PROJCT,STATPT,SCFOK,1,NPRHSS)
      ELSE
         CALL FGMTRX_NEO(X(LVEC),X(LFCM),X(LE),X(LSCR),X(LIA),X(LRM),
     *               X(LSVT),X(LSVR),X(LSVTT),X(LSVRT),
     *               X(Lfmoc),X(LCOM),X(Lfmomas),X(LBUF1),X(LBUF2),
     *               NC1,NC2,NPART,X(LDDM),GOTDDM,X(LADM),GOTADM,
     *               PROJCT,STATPT,SCFOK)
      END IF
C
C        SAVE HARMONIC FREQUENCIES AND NORMAL MODES FOR EXTENDED TDHF
C
      IF(IGETOLI(1).NE.0) THEN
        CALL SVGFNM(x(lFREQ),X(LVEC),NC1,LINEAR)
      END IF
C
      CALL RETFM(NEED)
czcz
      call retfm(needfmo)
czcz
      IF (MASWRK) WRITE(IW,9020)
      CALL TIMIT(1)
      RETURN
C
 9005 FORMAT(/1X,'To read Hessian for FDD, use HESS=READ in $STATPT.')
 9010 FORMAT(/5X,33(1H-)/
     *        5X,'HESSIAN MATRIX CONTROL PARAMETERS'/5X,33(1H-)/
     *        5X,'METHOD=',A8,3X,'NVIB  =',I8,3X,'VIBSIZ=',F8.5/
     *        5X,'RDHESS=',L8,3X,'PURIFY=',L8,3X,'PRTIFC=',L8/
     *        5X,'VIBANL=',L8,3X,'DECOMP=',L8,3X,'PROJCT=',L8/
     *        5X,'SCLFAC=',F8.5,3X,'PRTSCN=',L8,3X,'NPRT  =',I8/
     *        5X,'PULCOR=',L8,3X,'NPUN  =',I8,3X,'REDOVB=',L8)
 9012 FORMAT(5X,'THERMOCHEMISTRY WILL BE PRINTED FOR',I5,
     *          ' TEMPERATURES:'/(3X,5F12.5/))
 9014 FORMAT(5X,'HESSIAN COMPUTATION WILL BE SKIPPED AS'/
     *       5X,'A TOTAL OF',I5,' FREQUENCIES WERE INPUT:'/
     *      (5X,5F12.5/))
 9020 FORMAT(1X,'......END OF NORMAL COORDINATE ANALYSIS......')
 9030 FORMAT(1X,'RDHESS IS TRUE, BUT NO HESSIAN MATRIX WAS FOUND IN',
     *          ' YOUR INPUT FILE.')
 9040 FORMAT(/10X,15(1H-)/10X,'ENERGY GRADIENT'/10X,15(1H-))
 9090 FORMAT(/1X,'PLEASE DO NOT USE NUMGRD=.TRUE. DURING HESSIAN JOBS,'/
     *   1X,'INSTEAD USE METHOD=ANALYTIC, SEMINUM, OR FULLNUM ONLY.'/
     *   1X,'(IF NECESSARY, RUN THE HESSIAN IN A SEPARATE JOB THAN'/
     *   1X,'A GEOMETRY SEARCH (I.E. AVOID HESS=CALC OR HSSEND=.TRUE.)')
 9100 FORMAT(/10X,'**** ERROR IN DIFFERENTIATION METHOD ****'//
     *  1X,'ANALYTIC COMPUTATION OF THE HESSIAN IS IMPLEMENTED'/
     *  5X,'FOR S,P,D BASIS SETS (INCLUDING ECP USAGE) FOR AB INITIO',
     *     ' RHF, ROHF,'/
     *  5X,'GVB (OPEN SHELL OR TCSCF) AND MCSCF (CISTEP=ALDET)',
     *     ' WAVEFUNCTIONS.'//
     *  1X,'SEMI-NUMERIC HESSIANS CAN BE COMPUTED WHEN ANALYTIC',
     *     ' GRADIENTS ARE AVAILABLE:'/
     *  5X,'IF F,G FUNCTIONS ARE IN THE BASIS SET,'/
     *  5X,'IF USING GRID-BASED OR GRID-FREE DFT,'/
     *  5X,'IF UHF, OR IF GVB WITH MORE THAN ONE PERFECT PAIR,'/
     *  5X,'IF MCSCF USES SOME CISTEP OTHER THAN ALDET,'/
     *  5X,'IF MPLEVL=2 FOR RHF OR UHF WAVEFUNCTIONS,'/
     *  5X,'IF EXCITED STATE CIS FOR RHF WAVEFUNCTIONS,'/
     *  5X,'IF GROUND OR EXCITED STATE GUGA CI FOR RHF WAVEFUNCTIONS,'/
     *  5X,'IF SEMI-EMPIRICAL MODELS AM1, PM3, OR MNDO ARE USED,'/
     *  5X,'IF EFP, PCM, ONSAGER, OR COSMO SOLVENT MODELS ARE USED,'/
     *  5X,'IF THERE IS AN APPLIED EXTERNAL ELECTRIC FIELD,'/
     *  5X,'IF SCALAR RELATIVISTIC TRANSFORMATIONS ARE IN USE, OR'/
     *  5X,'IF RUNNING SCF-MI COMPUTATIONS.'//
     *  1X,'FULLY NUMERIC HESSIANS CAN BE COMPUTED WHEN ONLY THE',
     *     ' ENERGY IS AVAILABLE:'/
     *  5X,'WHEN MODEL CORE POTENTIAL INTEGRALS ARE USED,'/
     *  5X,'WHEN MPLEVL=2 FOR SCFTYP=ROHF/OSPT=RMP OR SCFTYP=MCSCF,'/
     *  5X,'WHEN CITYP IS SELECTED AND THE SCFTYP IS NOT RHF,'/
     *  5X,'WHEN THE CITYP SELECTED IS NOT CIS OR GUGA, OR'/
     *  5X,'WHEN ANY CCTYP IS SELECTED'/)
 9105 FORMAT(1X,'YOUR INPUT MISTAKENLY REQUESTED METHOD=',A8)
 9106 FORMAT(/15X,'* * * EFFICIENCY NOTE * * *'/
     *        1X,'THIS CALCULATION CAN BE RUN WITH DIFFERENTIATION',
     *           ' METHOD=',A8/
     *        1X,'THIS MIGHT BE MORE ACCURATE AND/OR FASTER THAN',
     *           ' YOUR CHOICE,'/
     *        1X,'BUT THE REQUESTED CALCULATION METHOD=',A8,
     *           ' IS PROCEEDING.'/)
      END
C*MODULE FMOHSS  *DECK FMOFCMOUT
      SUBROUTINE FMOFCMOUT(FCM,NCOORD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION FCM(NCOORD,NCOORD)
      DIMENSION CLAB(3)
czcz
      character*4 cdum4(4)
      character*8 cdum8
czcz
C
      PARAMETER (MXATM=2000, MXFRG=1050,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FROZNC/ IFREEZ(3*MXATM),NFRZ
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
Cz    COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
CZ
      COMMON /FMCOM / X(1)
c     common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
czcz
C
      DATA CLAB /4H   X,4H   Y,4H   Z/
      DATA HSSIAN/8HHESSIAN /
C
c     IF(iand(nprfmo,3).ne.0.or..NOT.MASWRK) RETURN
      IF(.NOT.MASWRK) RETURN
C
      WRITE(IW,9000)
C
      IF(IFREEZ(1).NE.0.AND.RUNTYP.EQ.HSSIAN.AND.MASWRK)
     *  WRITE (IW, 9005)
C
      cdum8 = '        '
      INCR= 2
      IF(NPRINT.EQ.6) INCR=4
      DO 140 MINCOL=1,NAT,INCR
         MAXCOL = MINCOL+INCR-1
         IF (MAXCOL .GT. NAT) MAXCOL = NAT
         ico = 0
         do ii = mincol, maxcol
           ico = ico + 1
CZ         ztmp = x(lfmomas+ii-1)
           iantmp = int(x(lfmozan+ii-1)+0.1D+00)
           call zsymnum(cdum8,cdum4(ico),iantmp)
         end do
         WRITE(IW,9010) (N,N = MINCOL,MAXCOL)
CZ       WRITE(IW,9020) (ANAM(N),BNAM(N),N = MINCOL,MAXCOL)
         WRITE(IW,9020) (cdum4(N),cdum8,N = 1,ico)
         WRITE(IW,9030) ((CLAB(M),M = 1,3),N = MINCOL,MAXCOL)
         J0 = 3*(MINCOL-1)+1
         J1 = 3*MAXCOL
         IFC=1
         DO 120 IAT = MINCOL,NAT+2*NFRG
            I0 = 3*(IAT-1)
            IF(IAT.LE.NAT) THEN
CZ             ztmp = x(lfmomas+iat-1)
               iantmp = int(x(lfmozan+iat-1)+0.1D+00)
               call zsymnum(cdum8,cdum4(1),iantmp)
               WRITE(IW,9040) IAT,cdum4(1),cdum8,CLAB(1),
     *                         (FCM(I0+1,J),J = J0,J1)
            ELSE
               IFCT=MOD(IAT-NAT,2)
               IF(IFCT.EQ.1) THEN
                 WRITE(IW,9050) IFC,CLAB(1),
     *                         (FCM(I0+1,J),J = J0,J1)
               ELSE IF(IFCT.EQ.0) THEN
                 WRITE(IW,9060) IFC,CLAB(1),
     *                         (FCM(I0+1,J),J = J0,J1)
               IFC=IFC+1
               END IF
            END IF
            WRITE(IW,9070) CLAB(2),(FCM(I0+2,J),J = J0,J1)
            WRITE(IW,9070) CLAB(3),(FCM(I0+3,J),J = J0,J1)
  120    CONTINUE
  140 CONTINUE
C                    TWO SETS OF COLUMNS (TRANSLATION AND ROTATION)
C                    FOR PRINTING THE FRAGMENT/FRAGMENT BLOCK
      DO 150 IFRG=1,NFRG
         WRITE(IW,9080) IFRG
         WRITE(IW,9030) ((CLAB(M),M = 1,3),N = 1,2)
         J0 = 3*NAT + 6*(IFRG-1) + 1
         J1 = J0 + 5
         DO 130 JFRG = IFRG,NFRG
            I0 = 3*NAT + 6*(JFRG-1)
            WRITE(IW,9050) JFRG,CLAB(1),(FCM(I0+1,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(2),(FCM(I0+2,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(3),(FCM(I0+3,J),J = J0,J1)
            WRITE(IW,9060) JFRG,CLAB(1),(FCM(I0+4,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(2),(FCM(I0+5,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(3),(FCM(I0+6,J),J = J0,J1)
  130    CONTINUE
  150 CONTINUE
      RETURN
C
 9000 FORMAT(/10X,31(1H-)/10X,'CARTESIAN FORCE CONSTANT MATRIX'/
     *        10X,31(1H-))
 9005 FORMAT(//1X,'THERE ARE FROZEN COORDINATES, ',
     *'PARTIAL HESSIAN ANALYSIS WILL BE DONE.'//1X,
     *'FOR THE FROZEN ATOMS AND FRAGMENTS, ',
     *'DIAGONAL MATRIX ELEMENTS ARE '/1X,'SET TO BE 1.0D-08,',
     *' ALL THE OTHER MATRIX ELEMENTS RELATED TO FROZEN '/1X,
     *'ATOMS AND FRAGMENTS ARE SET TO BE ZERO.'//)
 9010 FORMAT(/20X,4(12X,I4,11X))
 9020 FORMAT( 20X,4(11X,A8,A2,6X))
 9030 FORMAT( 20X,4(3X,A4,5X,A4,5X,A4,2X))
 9040 FORMAT(I3,3X,A8,A2,A4,12F9.6)
 9050 FORMAT(1X,'FRAG.',I3,1X,'TRANS.',A4,12F9.6)
 9060 FORMAT(1X,'FRAG.',I3,1X,'ROT.  ',A4,12F9.6)
 9070 FORMAT(16X,A4,12F9.6)
 9080 FORMAT(/20X,'FRAGMENT',I3,3X,'TRANSLATION',13X,'ROTATION ')
      END
C
C*MODULE FMOHSS  *DECK FMOESHSS
C>
C>     @brief ESP contributions to FMO Hessian
C>
C>     @details Add ESP contributions to FMO Hessian.
C>
C>     @author Hiroya Nakata
C>
      SUBROUTINE FMOESHSS(L1,L2,DA,SCFFRG,IDMREC0,DC,WRK1,
     *                    MAPI,MAPJ,MAP3,MAXL1D,IREC00,
     *                    ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,
     *                    NQMTFG,
     *                    YALAG,IPTYA,YAWRK,FCM,
     *                    numfrg,modfd,iwrk,NC1,IEEH)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000,MXSH=5000,MXGTOT=20000, MXRT=100 )
c     LOGICAL DIRSCF,FDIFF,PACK2E,GOPARR,DSKWRK,MASWRK,QFMM,QOPS
      LOGICAL ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH
      LOGICAL LCFLAG,LRINT,CAMFLAG,LCFLAGS,LRINTS,CAMFLAS
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION DA(*),SCFFRG(*),IDMREC0(*)
      DIMENSION DC(*),WRK1(*),MAPI(*),MAPJ(*),MAP3(MAXL1D,3)
      DIMENSION NQMTFG(*), numfrg(1),iwrk(*)
C    FMO dftb hessian
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /DFTCAM/ ALPHAC,BETAC,CAMMU,CAMVWN,CAMLYP,CAMFLAG
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
c     COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
C     COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NLRC  / LCFLAG,EMU,EMU2,LRFILE
      COMMON /NLRCF / LRINT
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
c     COMMON /OPTSCF/ DIRSCF,FDIFF
c     COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c     COMMON /QMFM  / SIZE,EPS1,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
c    *                ITERMS,QOPS,ISCUT
c     COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
c     COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
c     COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,NANGM,NGTH(4)
c     COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
c    *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2,maxrij
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
c     COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
c    *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
c    *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
c    *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
c    *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
c    *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
c     common /ppcpnt/ lddijpot,lzppcpot,lvipot,lgrdtest
c     COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
c     COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
c    *                MPLEVL,MPCTYP
C
c     COMMON /GRAD  / DE(3,MXATM)
C
C     For FMO second derivatives,
C     1. This subroutine calculate the contribution
C     which come from the Electrostatic Potential
C     For the detail mathmatical equation:
C         J. Chem. Phys.    138, 164103 (2013) : RHF, and
C         Chem. Phys. Lett. 603 (2014) 67-74.  : UHF or ROHF
C         J. Chem. Phys. 142, 124101 (2015)    : 3-body(here) or DFT(hss2a)
C         (http://dx.doi.org/10.1063/1.4915068)
C
C     2. ES-DIM approzimation is based on this subroutine:
C     (also see detail for Chem. Phys. Lett. 603 (2014) 67-74. )
C
C     3. Trancations are added for FMO Frozen Domain Hessian
C        1. Trancation of Second order derivative of ESP (here)
C        2. Trancation of CPHF (cphf.src, Closed shell only)
C     (See detail for J. Chem. Theory Comput., 2015, 11 (7), pp 3053â€“3064)
C                     Doi: 10.1021/acs.jctc.5b00277
C
C     4. FMO-DFTB second order derivatives,
C        Both DFTB2 and DFTB3 are possible with ES-DIM approximation.
C        (See detail XXX  )
C
      DIMENSION YALAG(*),IPTYA(*),YAWRK(*),FCM(*)
C
      CALL TIMIT(1)
      IF(MASWRK) WRITE(IW,*) 'BEGIN FMOESHSS'
C
      LWRKDEN =LFMOBUF(1) ! MAXL1D+MAXL2D+MAXL3D
      LWRKESP =LFMOBUF(2) ! MAXL2D
      IFG=ICURFG
      JFG=JCURFG
      KFG=KCURFG
      L1IJ=L1
      L2IJ=L2
      L3IJ=L1 * L1
      L1K = 1
      L2K = 1
      IF(IFG.EQ.0) RETURN
      L1I  = IAND(NUMFRG(IFG),65535)
      IF (JFG.NE.0) THEN
        L1J  = IAND(NUMFRG(JFG),65535)
      END IF
      IF (KFG.NE.0) THEN
        L1K  = IAND(NUMFRG(KFG),65535)
        L2K   = (L1K*L1K + L1K)/2
      END IF
      L2I   = (L1I*L1I + L1I)/2
      L2J   = (L1J*L1J + L1J)/2
      NDSIJ = L2  * NAT  * 3
C
      IF(DFTBFL) THEN
        NOCC = NA
        NVIR = L1IJ - NA
        LPNT = NOCC * NVIR * 3 * NAT + 1
        NATIJ= NAT
        IF (IEEH.EQ.0) RETURN
        CALL esp2der_dftb(IFG,JFG,KFG,DA,L1IJ,L1I,L1J,L1K,X(LNUMFRG),
     *       X(LNATFRG),YALAG,IPTYA,YAWRK,YAWRK(LPNT),NOCC,NVIR,NATIJ,
     *       MAPI,MAPJ,MAP3,IDMREC0,X(LINDFRG),X(LWRKESP),X(LFMODB),
     *       DC,X(LWRKDEN),WRK1,IREC00,ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,
     *       IODEXCH,FCM,MAXL1D,IEEH)
        IF(MASWRK) WRITE(IW,*) 'DONE FMOESHSS'
        CALL TIMIT(1)
        RETURN
      END IF
C
      LCFLAGS = LCFLAG
      LRINTS  = LRINT
      CAMFLAS = camFLAG
      LCFLAG  = .FALSE.
      camFLAG = .FALSE.
      LRINT   = .FALSE.
C
      CALL DERCHK(NDER)
      if(nder.ne.2) then
        write(iw,*) 'FMOESHSS: nder=',nder
        call abrt
      endif
C
      CALL MONBSR(NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR,
     *            NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,
     *            NCURSH,NGAU0,ENUCR0)
C
      IESDPPC = 1
C     For FDD Hessian: change mapping
      idum=0
      job=2
      if(modfd.ne.0) job=1
      call mapfmohess(natfmo,idum,x(lindat),X(liactfg),iwrk,nactatm,job)
C
C    allocate memory
      CALL VALFM(LOADFM)
      LEG  = LOADFM + 1
      LEH  = LEG    + 3 *  nactatm
      LFD  = LEH    + 9 * (nactatm*nactatm+nactatm)/2
      if(modfd.ne.0)  LFD  = LEH    + 9*nactatm*nactatm
      LAST = LFD    + MAX(3 *  nactatm* L2,L3IJ*2)
      NEED = LAST-LOADFM-1
      CALL GETFM(NEED)
CZ
      NFD  = 3*nactatm*L2
      NEGH = 3*nactatm+9*(nactatm*(nactatm+1))/2
c
c     if(maswrk) write(6,*) "Construct ini den"
C     Get Density ||  S^{a,I} || S^{a,J}
CZ    DA is  Delta DIJ - DI - DJ
      call ESDDVDD(l1,l2,DA,X(LFMODB),DC,X(LWRKDEN),WRK1,
     *     X(LFMOESPA),X(LWRKESP),X(LNUMFRG),MAPI,MAPJ,MAP3,
     *     MAXL1D,IREC00,ORBXCH1,ENEXCH1,
     *     KODEXCH,JODEXCH,IODEXCH,NQMTFG, scffrg,0,
     *     l1i,l1j,X(LFD))
c     CALL TIMIT(1)
C
      call vclr(x(leg),1,NEGH)
      call vclr(x(lfd),1,NFD)
c     Second derivative for one-electron terms
c     write(6,*) "begin first derivative"
      call esddv1d(DA,LEG,LEH,LFD,X(LIAGLOB),IWRK,nactatm)
c     write(6,*) "begin second derivative"
c     Second derivative for two-electron terms
c     kfg = 0
      call esddv2d(IFG,JFG,KFG,L1IJ,L1I,L1J,l1k,nak,nbk,natk,
     *     X(LFMOESPA),X(LIAGLOB),X(LEG), X(LEH),l2ij,NQMTFG,
     *     X(LFMODB),X(LWRKDEN),x(LLAYFRG),IDMREC0,DA,x(LFD),FCM,
     *     scffrg,IWRK,nactatm)
C     summing up contribution (\Delta D * V^ab)
      call addhss(nactatm,nactatm,x(LEH),FCM,0,iwrk)
C
      CALL MONBSR(NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,NCURSH,NGAU0,
     *           ENUCR0,NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR)
C
      NCURSH = 0
C
      CALL VALFM(LOADFM)
      LDSIJ  = LOADFM + 1
      LAST   = LDSIJ  + NDSIJ
      if(modfd.ne.0) LAST   = LDSIJ  + max(NDSIJ,natfmo+nactatm)
      NEEDIJ = LAST-LOADFM-1
      CALL GETFM(NEEDIJ)
C
c     write(6,*) "begin ESP",KFG
c     calcualting S^a * V^b terms in ( fmohss1a.src )
      IF (KFG.EQ.0) THEN
       call ESPSDXVD(l1,l2,X(LFMODB),X(LWRKDEN),WRK1,
     *      X(LNUMFRG),MAPI,MAPJ,MAP3, x(liaglob), MAXL1D,IREC00,
     *      ORBXCH1, KODEXCH,JODEXCH,IODEXCH,NQMTFG, scffrg,0,
     *      x(LDSIJ),l1i,l2i,x(LDSIJ),l1j,l2j,x(LDSIJ),l2ij,x(LFD),
     *      NQMT0,FCM,YALAG,IPTYA,YAWRK,NA0,NB0,
     *      l1k,l2k,x(LDSIJ),X(liactfg),IWRK,nactatm,modfd)
      ELSE IF(KFG.NE.0) THEN
       call ESPSDXVD(l1,l2,X(LFMODB),X(LWRKDEN),WRK1,
     *      X(LNUMFRG),MAP3(1,1),MAP3(1,2),MAP3(1,3), x(liaglob),
     *      MAXL1D,IREC00,
     *      ORBXCH1, KODEXCH,JODEXCH,IODEXCH,NQMTFG, scffrg,0,
     *      x(LDSIJ),l1i,l2i,x(LDSIJ),l1j,l2j,x(LDSIJ),l2ij,x(LFD),
     *      NQMT0,FCM,YALAG,IPTYA,YAWRK,NA0,NB0,
     *      l1k,l2k,x(LDSIJ),X(liactfg),IWRK,nactatm,modfd)
      END IF
c
      IF(modfd.ne.0) then
       CALL DCOPY(9*nactatm*nactatm,FCM,1,X(LEH),1)
       call vclr(FCM,1,nc1*nc1)
       call mapfmohess(natfmo,idum,x(lindat),X(liactfg),iwrk,nactatm,1)
       call mapfmohess(natfmo,idum,x(lindat),X(LLAYFRG),X(LDSIJ),nc0,4)
c      write(6,*) "nc0=",nc0,nactatm
       call packfmohess(nactatm,iwrk,X(LEH),nc0,X(LDSIJ),FCM,
     *      X(LDSIJ+natfmo))
      end if
C
      NQMT = NQMT0
C
      LCFLAG  = LCFLAGS
      LRINT   = LRINTS
      camFLAG = CAMFLAS
C
      CALL RETFM(NEEDIJ)
      CALL RETFM(NEED)

      IF(MASWRK) WRITE(IW,*) 'DONE FMOESHSS'
      CALL TIMIT(1)
      return
      end

C*MODULE FMOHSS  *DECK ESDDVDD
C>
C>     @brief Density contributions from ESP for FMO Hessian
C>
C>     @details Add density contributions from ESP for FMO Hessian.
C>
C>     @author Hiroya Nakata
C>
      subroutine ESDDVDD(l1,l2,DA,DB,DC,WRK,WRK1,
     *     ESPA,WRKESP,NUMFRG,MAPI,MAPJ,MAP3,
     *     MAXL1D,IREC0,ORBXCH1,ENEXCH1,
     *     KODEXCH,JODEXCH,IODEXCH,NQMTFG,
     *     scffrg,IMODE,l1i,l1j,FD)

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000,ONE=1.0D+00)
C
c     LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL SOME1,ORBXCH1,ENEXCH1
      LOGICAL KODEXCH,JODEXCH,IODEXCH
C
C
      DIMENSION DA(1),DB(1),DC(1),FD(*)
      DIMENSION ESPA(1),WRK(1),WRK1(1),WRKESP(1)
      DIMENSION NUMFRG(1),NQMTFG(*)
      DIMENSION MAPI(1),MAPJ(1),MAP3(MAXL1D,3)
      DIMENSION scffrg(*)
c     DIMENSION DSI(l2i,*),DSJ(l2j,*),DSIJ(l2ij,*)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c     COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
c     COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
c    *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
c    *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
c    *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
c    *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
c    *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
CZ    COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
c     COMMON /GRAD  / DE(3,MXATM)
      DATA   UHF/8HUHF     /
      DATA  ROHF/8HROHF    /
CZ
CZ    DENSITY DERIVATIVES OF EXTERNAL ELECTROSTATIC POTENTIALS
CZ
C     dummy argument it is used later implementation
c     DC(1)=0.0D+00
      DUM  = ESPA(1)
      if(imode.ne.0) write(iw,*) "imode =",
     * imode
C
      IFG=ICURFG
      JFG=JCURFG
      KFG=KCURFG
      l3 =l1 * l1

C     Notice record number 16 is written by diminid  subroutine
      IF(scftyp.eq.uhf.or.scftyp.eq.rohf) then
          CALL DAREAD(IDAF,IODA,FD      ,L3,15,0)
          CALL DAREAD(IDAF,IODA,FD(L3+1),L3,19,0)
          call dmtx2(wrkesp,FD,na,l1,l1,0)
          call dmtx2(da(l2+1),FD(l3+1),nb,l1,l1,0)
          call daxpy(L2,one,da(l2+1),1,wrkesp,1)
          iomit = 0
      ELSE
          CALL DAREAD(IDAF,IODA,da(l2+1),L3,15,0)
          call dmtx2(wrkesp,da(l2+1),na,l1,l1,na)
          iomit = 1
      END IF

      L1I  = IAND(NUMFRG(IFG),65535)
      NAI  = ISHFT(NUMFRG(IFG),-16)
c     NATI = IXFTCH(X(LNATFRG),IFG)
      MULI = IXFTCH(X(LMULFG),IFG)
      NBI  = NAI-MULI+1
      NQI  = IAND(NQMTFG(IFG),65535)
      IF (JFG.NE.0) THEN
        L1J  = IAND(NUMFRG(JFG),65535)
        NAJ  = ISHFT(NUMFRG(JFG),-16)
c       NATJ = IXFTCH(X(LNATFRG),JFG)
        MULJ = IXFTCH(X(LMULFG),JFG)
        NBJ  = NAJ-MULJ+1
        NQJ  = IAND(NQMTFG(JFG),65535)
      END IF
      IF (KFG.NE.0) THEN
        L1K  = IAND(NUMFRG(KFG),65535)
        NAK  = ISHFT(NUMFRG(KFG),-16)
        MULK = IXFTCH(X(LMULFG),KFG)
        NBK  = NAK-MULK+1
        NQK  = IAND(NQMTFG(KFG),65535)
      END IF
c
      some1=.False.
      if(ifmostp.eq.4) then
        CALL DIMINID(0,JFG,IFG,L1J,L1I,NQJ,NQI,NAJ,NAI,NBJ,NBI,L1,DA,DB,
     *               WRK,WRK1,X(LIODFMO),IREC0,X(LIABDFG),X(LJABDFG),
     *               X(LINDAT),X(LIAGLOB),X(LLOCFMO),MAPJ,MAPI,
     *               ORBXCH1,ENEXCH1,JODEXCH,IODEXCH,0,DUM,iomit,
     *               scffrg(jfg).eq.uhf,scffrg(ifg).eq.uhf,
     *               X(LMULFG),some1)
      END IF
      if(ifmostp.eq.9) then
c       write(6,*) "FMO trimer initial Density",l1,MAXL1D
        CALL TRIMINID(KFG,JFG,IFG,L1K,L1J,L1I,NQK,NQJ,NQI,NAK,NAJ,NAI,
     *               NBK,NBJ,NBI,L1,DA,DB,DC,WRK,WRK1,X(LIODFMO),IREC0,
     *               X(LIABDFG),X(LJABDFG),X(LINDAT),X(LIAGLOB),
     *               X(LLOCFMO),MAP3(1,3),MAP3(1,2),MAP3(1,1),
     *               ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,iomit,
     *               scffrg(kfg).eq.uhf,scffrg(jfg).eq.uhf,
     *               scffrg(ifg).eq.uhf,SOME1)
      END IF

      CALL DAXPY(L2,-ONE,WRKESP,1,DA,1)
      CALL DSCAL(L2,-ONE,DA,1)
c     NCURS  = NCURSH
c     NCURSH = 0
c     write(*,*) "check density"
c     call prtril(DA,L1)
C
      IF(scftyp.eq.uhf.or.scftyp.eq.rohf) then
        CALL dawrit(IDAF,IODA,FD,L3,15,0)
        CALL dawrit(IDAF,IODA,FD(L3+1),L3,19,0)
      END IF
C
c     CALL MAKEMOL(IFG,0,0,ILAY,0,0,0,0,0,0,0,.FALSE.)
c     CALL EXTSDER(WRK,DSI,L1I,L2I,.TRUE.,.TRUE.,0)
c     IF(GOPARR) CALL DDI_GSUMF(1501,DSI,L2I*3*NATI)
C
c     CALL MAKEMOL(JFG,0,0,ILAY,0,0,0,0,0,0,0,.FALSE.)
c     CALL EXTSDER(WRK,DSJ,L1J,L2J,.TRUE.,.TRUE.,0)
c     IF(GOPARR) CALL DDI_GSUMF(1501,DSJ,L2J*3*NATJ)
C
c     CALL MAKEMOL(IFG,JFG,0,ILAY,0,0,0,0,0,0,0,.true.)
c     CALL EXTSDER(WRK,DSIJ,L1,L2IJ,.TRUE.,.TRUE.,0)
c     IF(GOPARR) CALL DDI_GSUMF(1501,DSIJ,L2IJ*3*NAT)

c     NCURSH = NCURS
      return
      end
C
C*MODULE FMOHSS  *DECK YALGMEM1
C>
C>     @brief Measure size of Ya
C>
C>     @details Get total dimension of  U^{a} and max dimension of U^{a,X}.
C>
C>     @author Hiroya Nakata
C>
      SUBROUTINE YALGMEM1(NYA,MXYAWK,NQMTFG,scffrg,mulfg,natfrg,layfrg)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION NQMTFG(*),natfrg(*)
C     FOR UHF
      DIMENSION mulfg(nfg),scffrg(nfg),layfrg(*)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      DATA  UHF/8HUHF     /
      DATA ROHF/8HROHF    /
c
C     dummy arguments
c     if(scffrg(1).eq.uhf) write(*,*) "mulfg=",mulfg(1)
c
      NYA = 0
      MXYAWK = 0
      DO I = 1, NFG
        IF(layfrg(I).EQ.nlayer) THEN
          NQMT = IAND(NQMTFG(I),65535)
          NAI  = ISHFT(NQMTFG(I),-16)
          NOCV = NAI * (NQMT - NAI)
          NXYZI= natfrg(i) * 3
          IF(scffrg(I).eq.UHF.or.scffrg(I).eq.rohf) THEN
            NBI = NAI  - mulfg(I) + 1
            NOCV= NOCV + NBI * (NQMT - NBI)
          END IF
c         write(*,*) "NXYZI NOCV = ",NXYZI,NOCV
          NYA  = NYA + NOCV * NXYZI
          DO j=1,I-1
             NXYZJ = natfrg(j) * 3
             NATOMT= NXYZI + NXYZJ
             MXYAWK= max(MXYAWK,NATOMT)
c            write(*,*) " NATOMT = " , NATOMT
             IF(NBODY.EQ.3) THEN
               DO K=1,J-1
                 NXYZK = natfrg(k) * 3
                 NATOMT= NXYZI + NXYZJ + NXYZK
                 MXYAWK= max(MXYAWK,NATOMT)
               END DO
             END IF
          END DO
        END IF
      END DO
C
      RETURN
      END
c
C*MODULE FMOHSS* DECK YALGMEM2
C>
C>     @brief Mapping for U^a
C>
C>     @details Get point for respective U^{a,X}.
C>
C>     @author Hiroya Nakata
C>
      SUBROUTINE YALGMEM2(IPTLG,NQMTFG,scffrg,mulfg,natfrg,layfrg)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
C
      DIMENSION IPTLG(1),NQMTFG(1),natfrg(1)
c     For UHF fragment
      DIMENSION mulfg(nfg),scffrg(nfg),layfrg(*)
      DATA  UHF/8HUHF     /
      DATA ROHF/8HROHF    /
c
C     dummy arguments
c     if(scffrg(1).eq.uhf) write(*,*) "mulfg=",mulfg(1)
C
      IPT = 1
      DO I = 1, NFG
        IPTLG(I) = IPT
        IF(layfrg(I).EQ.nlayer) THEN
          NQMT =  IAND(NQMTFG(I),65535)
          NAI  = ISHFT(NQMTFG(I),-16)
          NOCV = NAI * (NQMT - NAI)
          IF(SCFFRG(I).EQ.UHF.or.SCFFRG(I).EQ.rohf) THEN
            NBI  = NAI  - mulfg(I)+1
            NOCVB= NBI  * (NQMT - NBI)
            NOCV = NOCV + NOCVB
          END IF
          NXYZI= natfrg(i) * 3
c         write(*,*) "NXYZI NOCV = ",NXYZI,NOCV
          IPT = IPT + NOCV * NXYZI
        END IF
      END DO
      IPTLG(NFG+1) = IPT - 1
C
      RETURN
      END
C
C*MODULE FMOHSS  *DECK addhss
C>
C>     @brief   Add V^{ab} contributions to FMO Hessian
C>
C>     @details Add FCMWRK to FCM.
C>
C>     @author Hiroya Nakata
C>
      subroutine addhss(nat,natfmo,FCMWRK,FCM,imode,iaglob)
      implicit double precision(A-H,O-Z)
c
      DIMENSION FCMWRK(9,(nat*nat+nat)/2)
      DIMENSION FCM(natfmo*3,natfmo*3),iaglob(*)
c
      do iatom = 1,nat
         do jatom = 1,iatom
            if(imode.eq.0) then
              ij = (iatom * iatom - iatom)/ 2 + jatom
              ix = (iatom-1) * 3 + 1
              iy = (iatom-1) * 3 + 2
              iz = (iatom-1) * 3 + 3
              jx = (jatom-1) * 3 + 1
              jy = (jatom-1) * 3 + 2
              jz = (jatom-1) * 3 + 3
            else if(imode.eq.1) then
              ij = (iatom * iatom - iatom)/ 2 + jatom
              ix = (iaglob(iatom)-1) * 3 + 1
              iy = (iaglob(iatom)-1) * 3 + 2
              iz = (iaglob(iatom)-1) * 3 + 3
              jx = (iaglob(jatom)-1) * 3 + 1
              jy = (iaglob(jatom)-1) * 3 + 2
              jz = (iaglob(jatom)-1) * 3 + 3
            end if
            if(iatom.ne.jatom) then
               FCM(ix,jx) = FCM(ix,jx) + FCMWRK(1,ij)
               FCM(ix,jy) = FCM(ix,jy) + FCMWRK(2,ij)
               FCM(ix,jz) = FCM(ix,jz) + FCMWRK(3,ij)
               FCM(iy,jx) = FCM(iy,jx) + FCMWRK(4,ij)
               FCM(iy,jy) = FCM(iy,jy) + FCMWRK(5,ij)
               FCM(iy,jz) = FCM(iy,jz) + FCMWRK(6,ij)
               FCM(iz,jx) = FCM(iz,jx) + FCMWRK(7,ij)
               FCM(iz,jy) = FCM(iz,jy) + FCMWRK(8,ij)
               FCM(iz,jz) = FCM(iz,jz) + FCMWRK(9,ij)
C
               FCM(jx,ix) = FCM(jx,ix) + FCMWRK(1,ij)
               FCM(jy,ix) = FCM(jy,ix) + FCMWRK(2,ij)
               FCM(jz,ix) = FCM(jz,ix) + FCMWRK(3,ij)
               FCM(jx,iy) = FCM(jx,iy) + FCMWRK(4,ij)
               FCM(jy,iy) = FCM(jy,iy) + FCMWRK(5,ij)
               FCM(jz,iy) = FCM(jz,iy) + FCMWRK(6,ij)
               FCM(jx,iz) = FCM(jx,iz) + FCMWRK(7,ij)
               FCM(jy,iz) = FCM(jy,iz) + FCMWRK(8,ij)
               FCM(jz,iz) = FCM(jz,iz) + FCMWRK(9,ij)
            else
               FCM(ix,jx) = FCM(ix,jx) + FCMWRK(1,ij)
               FCM(ix,jy) = FCM(ix,jy) + FCMWRK(2,ij)
               FCM(ix,jz) = FCM(ix,jz) + FCMWRK(3,ij)
               FCM(iy,jx) = FCM(iy,jx) + FCMWRK(4,ij)
               FCM(iy,jy) = FCM(iy,jy) + FCMWRK(5,ij)
               FCM(iy,jz) = FCM(iy,jz) + FCMWRK(6,ij)
               FCM(iz,jx) = FCM(iz,jx) + FCMWRK(7,ij)
               FCM(iz,jy) = FCM(iz,jy) + FCMWRK(8,ij)
               FCM(iz,jz) = FCM(iz,jz) + FCMWRK(9,ij)
C
            end if
         end do
      end do
      return
      end
c
C*MODULE FMOHSS  *DECK FMOCPHOP
C>
C>     @brief Add P^a contributions to CPHF equation
C>
C>     @details Add (S DD S^a) contributions to FMO Hessian.
C>
C>     @author Hiroya Nakata
C>
      SUBROUTINE FMOCPHOP(nocc,nvir,l1,l2,nxyz,WAX,nrot,AA,nocc2,
     *            SS,  SDER,DD,NAO,NMO,ILOC,PARRGO,WRK3,nomit,
     *           NOCCB,NOCC2B,NVIRB,AB,WAXB,CPHF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c     LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL PARRGO
      DIMENSION SDER(L2,3,*), DD(1),  SS(L1,*)
      DIMENSION WAX(nocc,nvir,*), AA(nocc2,*),WRK3(*)
      DIMENSION AB(nocc2b,*),WAXB(noccb,nvirb,*)
C
      PARAMETER (ONE=1.0D+00,TWO=2.0D+00,MXATM=2000,MXAO=8192)
      PARAMETER (ZERO=0.0D+00)
c
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      data UHF/8HUHF     /
c
      l3 = l1 * l1
      LC = L3 *  3 + 1
      if(nrot.eq.0) write(6,*) "dumm =",NMO,parrgo,NXYZ,lcrfrg
c     MAXIC = NATFMO
c     call setatz(1,MAXIC,fastvesp,lfvesp,needfv)
c
      do 30 iatom = 1,nat
c       IAZ=IXFTCH(X(LIAGLOB),iatom)
c       icind=lfvesp+(IAZ-1)*6
c       FRACESPI=x(icind+1)
c       write(*,*) "fracespi =",fracespi,IAZ
        SCAL = TWO * TWO
c       if(fracespi.ge.0.5D+00.and.fracespi.ne.zero) go to 30
c       if(fracespi.ne.zero) go to 30
        do 40 ixyz = 1,3
          izxyz = (iatom - 1) * 3 + ixyz
          CALL CPYTSQ(SDER(1,ixyz,iatom),WRK3,l1,1)
          CALL CPYTSQ(DD,WRK3(l3+1),NAO,1)
C         S^a(l1,nao) * DD(NAO,NAO) *  S(l1,nao)^T
          CALL DGEMM('N','N',l1,NAO,NAO,ONE,WRK3(iloc*l1-l1+1),L1,
     *                wrk3(l3+1),NAO,ZERO, WRK3(L3*2+1),L1)
          CALL DGEMM('N','T',l1, l1,NAO,ONE,WRK3(l3*2+1),L1,
     *                SS(1,iloc),l1,ZERO, WRK3,L1)
          CALL SQ2TRI(L1,L1,WRK3,WRK3(l3+1),one)
C         C^T *  P * C   ( AO --> MO)
          CALL TFTRI(WRK3,wrk3(l3+1),wrk3(LC),WRK3(2*l3+1),NQMT,l1,l1)
          if(DFTBFL) then
            l1tmp = nocc+nvir
            l2tmp = (l1tmp+l1tmp*l1tmp)/2
c           write(6,*) "l1tmp=",l1,l1tmp,NQMT
c           CALL PRTRI(wrk3,L1tmp)
            call daxpy(l2tmp,one,wrk3,1,sder(1,ixyz,nat+iatom),1)
            go to 40
          end if
C         summing up contributions
          do 10 iocc = 1,nocc
            do 20 jocc = 1,iocc
              IJ = IA(IOCC) + JOCC
              AA(ij,izxyz) = AA(ij,izxyz) + WRK3(IJ) * SCAL
c             if(iatom.eq.3.and.ixyz.eq.3) write(*,*) WRK3(IJ),IJ
 20         continue
 10       continue
c         do 15 ivir = 1,nvir
          do 15 ivir = 1,nvir-nomit
            do 25 iocc = 1,nocc
              ij = IA(nocc+ivir) + iocc
              WAX(iocc,ivir,izxyz)=WAX(iocc,ivir,izxyz)+WRK3(IJ)*SCAL
c             if(iatom.eq.3.and.ixyz.eq.3) write(*,*) "val=",WRK3(IJ),IJ
 25         continue
 15       continue
          if(cphf.eq.uhf) then
           LCB = L3 * 4 + 1
           CALL TFTRI(WRK3,wrk3(l3+1),wrk3(LCB),WRK3(2*l3+1),NQMT,l1,l1)
C          summing up contributions
           do iocc = 1,noccb
             do jocc = 1,iocc
               IJ = IA(IOCC) + JOCC
               AB(ij,izxyz) = AB(ij,izxyz) + WRK3(IJ) * SCAL
c              if(iatom.eq.3.and.ixyz.eq.3) write(*,*) WRK3(IJ),IJ
             end do
           end do
c          do 15 ivir = 1,nvir
           do ivir = 1,nvirb
             do iocc = 1,noccb
               ij = IA(noccb+ivir) + iocc
               WAXB(iocc,ivir,izxyz)=WAXB(iocc,ivir,izxyz)+WRK3(IJ)*SCAL
c              if(iatom.eq.3.and.ixyz.eq.3) write(*,*) "val=",WRK3(IJ),IJ
             end do
           end do
c          write(*,*) "added contributions to WAXB",
c    *                IJ,WAXB(noccb,nvirb,izxyz)
c          write(*,*) "U-a P^b terms",WRK3(IJ),noccb,nvirb
          end if
 40     continue
 30   continue
c
c     if(fastvesp) call retfm(needfv)
c
      return
      END
C
C*MODULE FMOHSS  *DECK FMOCPHOP2
C>
C>     @brief Add P^a contribution to CPHF equation
C>
C>     @details Add (S DD^a S) contribution to CPHF equation.
C>
C>     @author Hiroya Nakata
C>
      SUBROUTINE FMOCPHOP2(L1,IRGHT,LEFT,ILOC,PARRGO,JJ,JAT,
     *                    NAO,NMO,CLCAO,LDC,ROTLCAO,LDR,NSHELL,
     *                    KATOM,KTYPE,KLOC,KMIN,SHIFTB,IBDTYP,
     *                    IAPRJO,JAPRJO,ISIDE, SS,ZAXIS,BOND,
     *                    WAX,AA,WRK3,nomit,nocc,nvir,nocc2,
     *                    NOCCB,nocc2B,NVIRB,AB,WAXB,CPHF,
     *                    HDER,L2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXATM=2000,MXAO=8192)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
C
c     LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL PARRGO
      DIMENSION CLCAO(LDC,NMO),ROTLCAO(LDR,NMO),
     *          KATOM(*),KTYPE(*),KLOC(*),KMIN(*)
      DIMENSION SHIFTB(MAXCAO,*),IAPRJO(MAXCAO,*),JAPRJO(MAXCAO,*)
      DIMENSION SS(L1,*),ZAXIS(3),BOND(3)
      DIMENSION WAX(nocc,nvir,*), AA(nocc2,*),WRK3(*)
      DIMENSION AB(nocc2b,*),WAXB(noccb,nvirb,*)
      DIMENSION HDER(L2,3,*)
C
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /FMCOM / X(1)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TT(432),INVT(48),NT
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      data UHF/8HUHF     /
C
C     COMPUTE DERIVATIVES OF HOP COEFFICIENTS
      if(l1.eq.0) write(6,*) "PARRGO =",PARRGO
C
      CALL VALFM(LOADFM)
      LPTRD  = LOADFM + 1
      LDTRD  = LPTRD  + 3*3
      LFTRD  = LDTRD  + 6*6
      LGTRD  = LFTRD  + 10*10
      LDROT  = LGTRD  + 15*15
      LAST   = LDROT  + LDR*NAO

      NEED  = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
C     wrk1 : LWAX
C     wrk2 : LAA
C     wrk3 : l3 * 4 free space
      l3   = l1 * l1
      lc   = l3 *  3 + 1
      ilin = 0
      irin = 0
      DO iatom = 1, nat
        IAZ=IXFTCH(X(LIAGLOB),iatom)
        if(iaz.eq.LEFT ) ilin = iatom
        if(iaz.eq.IRGHT) irin = iatom
      END DO
c     write(*,*) "in fmohop =",nomit
      DO 40 IC = 1, 3
        CALL VECROTDER(ISKIP,IC,ZAXIS,BOND,TT)
        IF (ISKIP.EQ.0) THEN
          CALL TRMATDER(X(LPTRD),X(LDTRD),X(LFTRD),X(LGTRD))
          CALL VCLR(X(LDROT),1,LDR*NAO)
          ! note that nao is reset here
          CALL ROTCAO(JJ,JAT,X(LPTRD),X(LDTRD),X(LFTRD),X(LGTRD),NAO,
     *                NMO,CLCAO,LDC,X(LDROT),LDR,NSHELL,KATOM,KTYPE,
     *                KLOC,KMIN,.TRUE.)
c
          CALL VCLR(WRK3,1,NAO*NAO+l3)
          DO IMO = 1, NMO
            if(iside.eq.0.and.iaprjo(imo,ibdtyp).ne.0.or.
     *         iside.ne.0.and.japrjo(imo,ibdtyp).ne.0) then

             BSHIFT = SHIFTB(imo,ibdtyp)
             CALL DGEMM('N','T',NAO,NAO,1,BSHIFT,X(LDROT+LDR*(IMO-1)),
     *                   LDR,ROTLCAO(1,IMO),LDR,ZERO,WRK3,NAO)
             CALL DAXPY(NAO*NAO,ONE,WRK3,1,WRK3(l3+1),1)
            end if
          END DO
          CALL SQ2TRI(NAO,NAO,WRK3(l3+1),WRK3(l3*2+1),one)
          CALL TFTRI0(WRK3(l3+1),WRK3(L3*2+1),SS(ILOC,1),WRK3,
     *                L1,NAO,L1)
c       C^T *  P * C   ( AO --> MO)
          CALL TFTRI(WRK3,wrk3(l3+1),wrk3(LC),WRK3(2*l3+1),NQMT,l1,l1)
          if(DFTBFL) then
           l1tmp = nocc+nvir
           l2tmp = (l1tmp+l1tmp*l1tmp)/2
           if(ilin.ne.0) call daxpy(l2tmp,-one,wrk3,1,hder(1,ic,ilin),1)
           if(irin.ne.0) call daxpy(l2tmp, one,wrk3,1,hder(1,ic,irin),1)
           go to 40
          end if
          do 10 iocc = 1,nocc
            do 20 jocc = 1,iocc
             IJ = IA(IOCC) + JOCC
             ll = (ilin - 1) * 3 + IC
             kk = (irin - 1) * 3 + IC
c            write(*,*) "IJ =",IJ,nocc2,WRK3(IJ)
             if(ilin.ne.0) AA(IJ,ll) = AA(IJ,ll) - WRK3(IJ) *two*two
             if(irin.ne.0) AA(IJ,kk) = AA(IJ,kk) + WRK3(IJ) *two*two
 20         continue
 10       continue
c         write(*,*) "U-a P^b terms"
c         do 15 mm = 1,nvir
          do 15 mm = 1,nvir - nomit
            do 25 ii = 1,nocc
              ij = IA(nocc+mm) + ii
              ll = (ilin - 1) * 3 + IC
              kk = (irin - 1) * 3 + IC
c             write(*,*) "IJ =",IJ,WRK3(IJ)
             if(ilin.ne.0)
     *          wax(ii,mm,ll) = wax(ii,mm,ll) - WRK3(IJ) * two * two
             if(irin.ne.0)
     *          wax(ii,mm,kk) = wax(ii,mm,kk) + WRK3(IJ) * two * two
 25         continue
 15       continue
          IF(CPHF.EQ.UHF) THEN
           LCB  = l3 *  4 + 1
           CALL TFTRI(WRK3,wrk3(l3+1),wrk3(LCB),WRK3(2*l3+1),NQMT,l1,l1)
           do    iocc = 1,noccb
             do    jocc = 1,iocc
              IJ = IA(IOCC) + JOCC
              ll = (ilin - 1) * 3 + IC
              kk = (irin - 1) * 3 + IC
c             write(*,*) "IJ =",IJ,nocc2,WRK3(IJ)
              if(ilin.ne.0) AB(IJ,ll) = AB(IJ,ll) - WRK3(IJ) *two*two
              if(irin.ne.0) AB(IJ,kk) = AB(IJ,kk) + WRK3(IJ) *two*two
             end do
           end do
c          do 15 mm = 1,nvir
           do    mm = 1,nvirb
             do    ii = 1,noccb
               ij = IA(noccb+mm) + ii
               ll = (ilin   - 1) * 3 + IC
               kk = (irin   - 1) * 3 + IC
c              write(*,*) "IJ =",IJ,WRK3(IJ)
              if(ilin.ne.0)
     *          waxb(ii,mm,ll) = waxb(ii,mm,ll) - WRK3(IJ) *two*two
              if(irin.ne.0)
     *          waxb(ii,mm,kk) = waxb(ii,mm,kk) + WRK3(IJ) *two*two
             end do
           end do
          END IF
        END IF
 40   CONTINUE
c
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE FMOHSS  *DECK HOPSHSS
C>
C>     @brief Add P^ab contribution to FMO Hessian
C>
C>     @details Add P^ab contribution to FMO Hessian.
C>
C>     @author Hiroya Nakata
C>
      SUBROUTINE HOPSHSS(L1,L2,ILOC,NAO,PARRGO,SDER,DD,DENS,SS,
     *                   WRK1,WRK2,WRK3,FCM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (MXATM=2000)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,two=2.0D+00)

      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL PARRGO
      DIMENSION SDER(L2,*), DD(1), DENS(1), SS(L1,*)
      DIMENSION WRK1(L1,*), WRK2(L1,*),WRK3(*)
      DIMENSION FCM(natfmo*3,*)

      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
c     COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
C
C     SDER is Overlap derivative, DD is projection matrix
C     DENS is Density matrix (density or symmetrized ZVEC)
C     SS   is Overlap matrix in the square form
      if(l1.eq.0) write(6,*) "jjjjj =",PARRGO
      L3   = l1   * l1
      LC   = l3   * 3   + 1
c     NLOC = ILOC + NAO - 1
c     call vclr(FCM,1,negh)
c     write(*,*) "check01 =",NAO,ILOC
      CALL TFTRI0(WRK1,DD,SS(ILOC,1),WRK3,L1,NAO,L1)
      CALL TFTRI(WRK3(l3+1),wrk1,wrk3(LC),WRK3,NQMT,l1,l1)
      IJ = 0
      DO 130 I = 1,L1
         DO 120 J = 1,I
            IJ = IJ+1
            DUM = ZERO
            DO 110 K = 1,NA
               II  = LC + l1 * (K - 1)  + I - 1
               JJ  = LC + l1 * (K - 1)  + J - 1
               KK  = (K * K  - K)/2 + 1 + L3
               DUM = DUM+WRK3(KK)*WRK3(II)*WRK3(JJ)
  110       CONTINUE
c           WRK3(IJ) = DUM + DUM
            WRK3(IJ) = DUM
  120    CONTINUE
  130 CONTINUE
C-
      do 200 iat =  1,nat
        IAZ=IXFTCH(X(LIAGLOB),IAT)
        do ixyz = 1,3
          izxyz = (iaz - 1) * 3 + ixyz
          ii    = (iat - 1) * 3 + ixyz
c         CALL CPYTSQ(DENS,WRK3,L1,1)
          CALL CPYTSQ(SDER(1,ii),WRK2,L1,1)
          CALL CPYTSQ(WRK3,WRK3(L3+1),L1,1)
          CALL DGEMM('N','N',L1,L1,L1,ONE,WRK2,L1,wrk3(l3+1),L1,ZERO,
     *               WRK1,L1)
          do 100 jat = 1,nat
            JAZ=IXFTCH(X(LIAGLOB),JAT)
            do jxyz = 1,3
              jzxyz = (jaz - 1) * 3 + jxyz
              jj    = (jat - 1) * 3 + jxyz
              CALL CPYTSQ(SDER(1,jj),WRK2,L1,1)
              CALL DGEMM('N','N',L1,L1,L1,ONE,WRK1,L1,wrk2,L1,ZERO,
     *               WRK3(l3+1),L1)
              CALL CPYTSQ(DENS,WRK2,L1,1)
              val = ddot(l1*l1,WRK3(L3+1),1,WRK2,1)
C
              FCM(izxyz,jzxyz) =  FCM(izxyz,jzxyz) - val
              FCM(jzxyz,izxyz) =  FCM(jzxyz,izxyz) - val
c             write(*,*) "val01  =",val,izxyz,jzxyz
            end do
 100      continue
        end do
 200  continue
C
C
      CALL VALFM(LOADFM)
      NGOTMX=LIMFM-LOADFM
c
      LSX    = 1     + LOADFM
      LSY    = LSX   + L2
      LSZ    = LSY   + L2
      LDSDX  = LSZ   + L2
      LDSDY  = LDSDX + L3
      LDSDZ  = LDSDY + L3
      LDE    = LDSDZ + L3
      LDH    = LDE   + NAT * 3
      LAST   = LDH   + (NAT+NAT*NAT)*9/2
      NEED   = LAST  - LSX
      IF(NEED.GT.NGOTMX) THEN
         IF (MASWRK) WRITE(6,*) 'IN SD, NEED,NGOT=',NEED,NGOTMX
         CALL ABRT
      END IF
      CALL GETFM(NEED)
c
      NEGH = 3*NAT+9*(NAT*(NAT+1))/2
      CALL VCLR(X(LDE),1,NEGH)
      CALL VCLR(X(LDSDX),1,L3)
      CALL VCLR(X(LDSDY),1,L3)
      CALL VCLR(X(LDSDZ),1,L3)
C
      CALL DSCAL(L2,two,wrk3,1)
C
      CALL SDSPD(X(LDE),x(LDH),WRK3,X(LSX),X(LSY),X(LSZ),
     *           X(LDSDX),X(LDSDY),X(LDSDZ),.false.,WRK1,.false.)
      IF(GOPARR) CALL DDI_GSUMF(1625,x(LDE),NEGH)
      call addhss(nat,natfmo,x(LDH),FCM,1,x(liaglob))
C
C-
C
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE FMOHSS  *DECK FMOESP_CPFCK
C>    @brief Calculate derivative of ESP terms
C>
C>    @details Calculate the electrostatic potential derivative
C>    for B^a matrix to solve CPHF
C>
C>    @author Hiroya Nakata
C>    - APR, 2013- Subroutine written
C>
C>           --- INPUT ---
C>    @param   L1      Number of atomic orbital
C>    @param   L2      Number of elements in triangular matrix of AO
C>    @param   IFG     Fragment indice in current for monomer
C>    @param   JFG     Fragment indice in current for dimer
C>    @param   LFG     Fragment indice in current for trimer
C>    @param IDMREC0   Record number to read orbital
C>    @param SCFFRG    SCFTYP for fragment (for UHF or ROHF)
C>           --- OUTPUT ---
C>    @param DV        Derivative of ESP with respect to cartesian coordinate in FMO
      SUBROUTINE FMOESP_CPFCK(DV,L1,L2,IFG,JFG,LFG,IDMREC0,SCFFRG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000,MXSH=5000,MXGTOT=20000,MXRT=100)
      PARAMETER (MXGSH=30,MXG2=MXGSH*MXGSH,MAXL=5)
      PARAMETER (TWO=2.0D+00,HALF=0.5D+00,ONE=1.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK,SAVGOP,NXT
      LOGICAL ESPPAR,LARGEPRI,DODDCOR,BSSEDIM,PACK2E
      DIMENSION DV(L2,*),IDMREC0(*),SCFFRG(*)
      DIMENSION KARTEN(0:MAXL-1)
C
      COMMON /FMCOM / X(1)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,NZMTFMO,ifmobas,itmfmo(2)
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      DATA KARTEN/1,4,6,10,15/
      DATA  UHF/8HUHF     /
      DATA ROHF/8HROHF    /
C
      newhss=1
C
c     irec0=ixftch(x(lidmrec),ICURLAY)
C
C     write(*,*) "NQMT =",NQMT
C
      call TVD_CPHF(DV)
C
      CALL DSCAL(L2*NAT*3,TWO,DV,1)
      do I = 1,NAT*3
         II=0
         DO JJ=1,L1
           II = II+JJ
           DV(II,I) = DV(II,I) * HALF
         ENDDO
      end do
C
C
      ILAY    = ICURLAY
      KFG0    = 1
      KFG1    = NFG
c     NATA    = NAT
c     IZ      = 1
      ESPPAR=MOD(MODPAR/2,2).NE.0.AND.GOPARR
c     RESPAPI =RESPAP(IZ)
c     RESPPCI =RESPPC(IZ)
C
C
      CALL MONBSR(NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR,
     *            NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,
     *            NCURSH,NGAU0,ENUCR0)
C
      NE0C=NE0+ICH0
      LOADHF=MOD(MODPAR,2)
      LARGEPRI=LOADHF.EQ.1.AND.ESPPAR
      DODDCOR=IAND(IXESP,1024).NE.0
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C
      NXT = IBTYP.EQ.1
      NEXT  = -1
      KOUNT = -1
C     ESP WILL BE COMPUTED IN THE DIRECT FASHION
C
      DO 100 KKFG=KFG0,KFG1
C
        IF(LARGEPRI) THEN
          KFG=IXFTCH(X(LLOADM),KKFG)
        ELSE
          KFG=KKFG
        ENDIF
C
        IF(IFG.EQ.KFG.OR.JFG.EQ.KFG.OR.LFG.EQ.KFG) GOTO 100
C
        IF(ESPPAR) THEN
          KOUNT=KOUNT+1
          IF(GOPARR) THEN
            IF(NXT) THEN
              IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.KOUNT) GOTO 100
            ELSE
              IF(MOD(KOUNT,NPROC).NE.ME) GOTO 100
            ENDIF
          ENDIF
          SAVGOP=GOPARR
          GOPARR=.FALSE.
c         GOPARR IS SET TO .FALSE. TO PREVENT SHELL-BASED WORK DIVISION
C         INSIDE OF EXCHNG AND FMOESP.
C         NOTE THAT SHELL-BASED WORK DIVISION IS USED FOR ESPPAR=.FALSE.
        ENDIF
        KLAY=MIN(ILAY,ixftch(x(llayfrg),KFG))
        BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5
        KFGX = KFG
C
C
        CALL MAKEMOL(KFGX,0,0,KLAY,0,NAT0,NCURSH,NGAU0,NE0C,ICH0,MUL0,
     *               .FALSE.)
C
        L1K=NUM-NUM0
        L2K=(L1K*L1K+L1K)/2
        L3K=L1K*L1K
c       natk = nat - nat0
C
        IREC0=IDMREC0(KLAY)
        IF(DODDCOR) THEN
          IREC0RHF=1
          IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
          IREC0=IREC0RHF
        ENDIF
C
CC
        IDMREC0K=KFG+IREC0
        NAK  = ISHFT(IXFTCH(X(LNUMFRG),KFG),-16)
        NBK  = NAK
C       FOR UHF
        IF(SCFFRG(KFG).EQ.UHF.OR.SCFFRG(KFG).EQ.ROHF) THEN
          MULK = IXFTCH(X(LMULFG),KFG)
          NBK  = NAK - MULK + 1
        END IF
C
C
C
        CALL BASCHK(LMAX)
        IF(LMAX.GE.5) THEN
           IF(MASWRK) WRITE(6,*) 'FMO HAS NOT BEEN REVIEWED FOR H,I'
           CALL ABRT
        END IF
        NANGM= KARTEN(MAX(LMAX,1))
        MAXG = NANGM**4
C
        lenrec = L3K + L1K
        if(scffrg(kfg).eq.uhf) lenrec= L3K+L1K+L3K+L1K
C
        CALL VALFM(LOADFM)
        CALL GOTFM(NGOTMX)
C
        NSH2    = (NSHELL + NSHELL * NSHELL)/ 2
        LXCHNG  = LOADFM  + 1
        LGHOND  = LXCHNG  + NSH2
        LDDIJ   = LGHOND  + MAXG
        LWRK    = LDDIJ   +  49 * MXG2
        LAST    = LWRK    + L2K + lenrec
C
        NEEDK   =  LAST   - LOADFM -1
        if(NEEDK.gt.NGOTMX) then
            write(6,*) "Can not allocate  memory in fmohss"
            write(6,*) "NEED = ",NEEDK,"MAX =",NGOTMX
            call abrt
        end if
C
        CALL GETFM(NEEDK)
C
CC
        CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRK+L2K),lenrec,
     *               IDMREC0K,0)
CC     Outside Density K
        if(scffrg(kfg).eq.uhf) then
          CALL DMTX2(X(LWRK),X(LWRK+L2K),NAK,L1K,L1K,0)
          CALL DMTX2(X(LWRK+L2K),X(LWRK+L2K+L3K),NBK,L1K,L1K,0)
          CALL DAXPY(L2K,ONE,X(LWRK+L2K),1,X(LWRK),1)
        else
          CALL DMTX2(X(LWRK),X(LWRK+L2K),NAK,L1K,L1K,NBK)
        end if
C
        IST=1
        JST=1
        KST=1
        LST=1
        CALL JANDK
        CALL EXCHNG(X(LXCHNG),X(LGHOND),X(LDDIJ), NSH2,MAXG,INTTYP)
C
        IF(newhss.eq.0) then
         call FMO2_CPHF(IFG,JFG,KFG,L1,L1K,
     *     X(LWRK),L2K,DV,L2,nat0,BSSEDIM,X(LXCHNG))
        else
         call FMO2_CPHF2(L1,L1K,X(LWRK),DV,L2,nat0,X(LXCHNG))
        end if
C
        IF(ESPPAR) GOPARR=SAVGOP
        CALL RETFM(NEEDK)
 100  CONTINUE
C
      IF (GOPARR) THEN
          CALL DDI_GSUMF(1605,DV,3*NAT0*L2)
      END IF
C
      CALL DSCAL(3*NAT0*L2,HALF,DV,1)
      do i = 1, NAT0 * 3
         II=0
         DO JJ=1,L1
           II = II+JJ
           DV(II,i) = DV(II,i) + DV(II,i)
         ENDDO
      end do
C
      CALL MAKEMOL(IFG,JFG,LFG,ILAY,0,0,0,0,0,0,0,.TRUE.)
C
      CALL MONBSR(NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,NCURSH,NGAU0,
     *           ENUCR0,NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR)
C
      NCURSH = 0
C
C     write(*,*) "NQMT =",NQMT
C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK ADD_ESPDER
C>    @brief Adder ESP derivative term to WAX
C>
C>    @details Added ESP terms to second order derivative of energy
C>    with respect to the orbital and coordinate
C>
C>    @author Hiroya Nakata
C>    - APR, 2013- Subroutine written
C>
C>           --- INPUT ---
C>    @param   L1      Number of atomic orbital
C>    @param NNXYZ     Number of unique cartesian coodinate elements
C>    @param NOCC      Number of occupied molecular orbital
C>    @param NVIR      Number of virtual  molecular orbital
C>    @param DV        Derivative of ESP with respect to cartesian coordinate in FMO
C>    @param   L2      Number of elements in triangular matrix of AO
C>    @param WRK3      Temporary work for ESP derivative
C>    @param  SCAL     Scal factor to control closed or open shell orbital
C>    @param  VEC      molecular orbital coefficient
C>           --- OUTPUT ---
C>    @param WAX       Derivative of energy with respect to MO and coordiante
      SUBROUTINE ADD_ESPDER(L1,NNXYZ,WAX,NOCC,NVIR,DV,L2,WRK3,SCAL,VEC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION WAX(NOCC,NVIR,NNXYZ),DV(L2,NNXYZ),WRK3(*)
      DIMENSION VEC(*)
      PARAMETER (MXATM=2000)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C

      L3 = L1 * L1
C
      DO ixyz = 1,NNXYZ
C
        CALL TFTRI(WRK3(L3+1),DV(1,ixyz),VEC,WRK3,NQMT,l1,l1)
        CALL CPYTSQ(WRK3(l3+1),WRK3,NQMT,1)
C
        DO IVIR= 1,NVIR
          DO IOCC = 1,NOCC
            III = IOCC + (IVIR + NOCC - 1) * NQMT
            WAX(IOCC,IVIR,ixyz)=WAX(IOCC,IVIR,ixyz) + WRK3(III) * SCAL
          END DO
        END DO
C
      END DO
C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK PRJFMOHSS
C>    @brief   Project out frozen element
C>
C>    @details Project Hessian contributions out with FMO/FDD
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param FCMWRK    Working array
C>    @param DDMWRK    Working array
C>    @param NC2       3*NAT
C>    @param NATFMO    Total number of atoms in the systems
C>    @param LAYFRG    Layer information for respective fragments
C>    @param INDAT     Converts global atomic location to fragment index
C>    @param MODE      Controls the job
C>           --- OUTPUT ---
C>    @param FCM       Hessian matrix
C>    @param DDM       Dipole derivatives
      SUBROUTINE PRJFMOHSS(FCM,FCMWRK,DDM,DDMWRK,
     *           NC2,natfmo,layfrg,indat,mode)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,SMALL=1.0D-08)
C
      LOGICAL  FOUND
      COMMON /FROZNC/ IFREEZ(3*MXATM),NFRZ
      DIMENSION FCM(NC2,*)
      DIMENSION FCMWRK(nc2,*),DDMWRK(3,*)
      DIMENSION DDM(3,*)
      DIMENSION IACTIATM(MXATM)
      DIMENSION layfrg(*),indat(*)
C
      NC1=natfmo*3
C
      IF(mode.eq.3) THEN
C       write(6,*) "Expand HESS matrix"
        nati=0
        ilay=0
        CALL VCLR(FCM,1,NC1*NC1)
        do iat=1,natfmo
          if(layfrg(indat(iat)).gt.ilay) then
            nati=nati+1
            natj=0
            do jat=1,natfmo
              if(layfrg(indat(jat)).gt.ilay) then
c             if(mode.eq.0.and.layfrg(indat(jat)).gt.1 .or.
c    *           mode.eq.1.and.iactfg(indat(jat)).gt.0) then
                 natj=natj+1
                 do ixyz=1,3
                    ilxyz = (nati-1) * 3 + ixyz
                    igxyz = ( iat-1) * 3 + ixyz
                    do jxyz=1,3
                      jlxyz = (natj-1) * 3 + jxyz
                      jgxyz = ( jat-1) * 3 + jxyz
c                     write(6,*) "check =",FCMWRK(ilxyz,jlxyz)
                      FCM(igxyz,jgxyz)=FCMWRK(ilxyz,jlxyz)
                    end do
                 end do
              endif
            end do
          endif
        enddo
        CALL DCOPY(NC1*NC1,FCM,1,FCMWRK,1)
C       write(6,*) "Done Expand HESS matrix"
        return
      END IF
C
C
c     nati=0
c     if(mode.eq.0)              ilay=1
c     if(mode.eq.1.or.mode.eq.2) ilay=0
c     do iat=1,natfmo
c       if(layfrg(indat(iat)).gt.ilay) then
c         nati=nati+1
c         if(mode.eq.0) then
c           DO ixyz=1,3
c             ilxyz = (nati-1) * 3 + ixyz
c             igxyz = ( iat-1) * 3 + ixyz
c             DDMWRK(1,ilxyz)=DDM(1,igxyz)
c             DDMWRK(2,ilxyz)=DDM(2,igxyz)
c             DDMWRK(3,ilxyz)=DDM(3,igxyz)
c           END DO
c         end if
c         natj=0
c         if(mode.eq.0.or.mode.eq.2) then
c           do jat=1,natfmo
c             if(layfrg(indat(jat)).gt.ilay) then
c             if(mode.eq.0.and.layfrg(indat(jat)).gt.1 .or.
c    *           mode.eq.1.and.iactfg(indat(jat)).gt.0) then
c                natj=natj+1
c                do ixyz=1,3
c                   ilxyz = (nati-1) * 3 + ixyz
c                   igxyz = ( iat-1) * 3 + ixyz
c                   do jxyz=1,3
c                     jlxyz = (natj-1) * 3 + jxyz
c                     jgxyz = ( jat-1) * 3 + jxyz
c                     FCMWRK(ilxyz,jlxyz)=FCM(igxyz,jgxyz)
c                   end do
c                end do
c             endif
c           end do
c         endif
c       endif
c     enddo
C
C
      IF(mode.eq.0) then
        CALL DCOPY(NC2*NC2,FCM,1,FCMWRK,1)
        CALL DCOPY(NC2*3  ,DDM,1,DDMWRK,1)
        N=0
        DO I = 1,NC2
          II=IFREEZ(I)
          IF(II.NE.0) THEN
            DDMWRK(1,II)=0.0D+00
            DDMWRK(2,II)=0.0D+00
            DDMWRK(3,II)=0.0D+00
          END IF
          DO J =1,NC2
            JJ=IFREEZ(J)
            IF(II.NE.0.AND.JJ.NE.0) THEN
              FCMWRK(II,JJ) = 0.0D+00
            END IF
          END DO
          IF(II.NE.0) THEN
            FCMWRK(II,II) = SMALL
            N = N + 1
          END IF
        END DO
C
C       IF(NFRZ.NE.N) write(6,*) "DIMENSION ERROR in PRJFMO?"
C       IF(NFRZ.NE.N) CALL ABRT
C
        NACT=0
        DO I=1,NC2
          FOUND=.False.
          DO J=1,N
            IF(IFREEZ(J).EQ.I) FOUND=.TRUE.
          END DO
          IF(.not.FOUND) NACT = NACT + 1
          IF(.not.FOUND) IACTIATM(NACT)=I
        END DO
        DO I=1,NACT
          II = IACTIATM(I)
          DO J=1,N
            JJ = IFREEZ(J)
            FCMWRK(II,JJ) = 0.0D+00
            FCMWRK(JJ,II) = 0.0D+00
          END DO
        END DO
      END IF
C
C          Hiroya explains this is development code, not in use in 8/2016.
C          NATI is not initialized at this point...
C--   if(mode.eq.1) THEN
C--     NC2=nati*3
C--     return
C--   end if
C
c     IF(nati*3.ne.NC2) then
c       write(6,*) "Dimension did not much between layers",nati
c       call abrt
c     end if
C
C     write(6,*) "NFRZ =",NFRZ,mode
C

      CALL DCOPY(NC2*NC2,FCMWRK,1,FCM,1)
      CALL DCOPY(NC2*3  ,DDMWRK,1,DDM,1)
C
C
C
      RETURN
      END
C
C*MODULE FMOHSS  *DECK FMODDMNUC
C>    @brief Nuclear atom contribution to Derivative of dipolemoment
C>
C>    @details Calculate dipole mooment derivative terms
C>     of nuclear coordinate and charge if necessary
C>
C>    @author Hiroya Nakata
C>    - APR, 2013- Subroutine writte
C>
C>           --- INPUT ---
C>    @param  NFG      number of fragment
C>    @param  ZAN      atomic nuclear charge
C>    @param ZMASS     nuclear mass
C>    @param  NAT      number of atom in fragments
C>    @param ichfg     number of charge in fragments
C>           --- OUTPUT---
C>    @param  ddm      dipole derivative moments
      SUBROUTINE FMODDMNUC(NFG,ZAN,ZMASS,NAT,ichfg,ddm)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXIRR=14)
C
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /SYMBLK/ NIRRED,NSALC,NSALC2,NSALC3,NSAFMO
      COMMON /SYMREP/ IRPNAM(MXIRR),IPA(MXIRR),LAMBDA(MXIRR),
     *                LAMBD0(MXIRR),IADDR1(MXIRR),IADDR2(MXIRR),
     *                IADDR3(MXIRR)
      INTEGER A
      DATA A /4HA   /
C
C
      DIMENSION ZAN(*)
      DIMENSION ZMASS(*)
      DIMENSION DDM(9,*)
      DIMENSION ichfg(*)
C
      IF(dftbfl) then
       NIRRED=1
       IRPNAM(1)= A
      end if
C
      ICH=0
      DO IFG=1,NFG
       ICH=ICH+ichfg(ifg)
      END DO
C
c     write(6,*) "ICH=",ICH,NAT
C
      total_mass = 0.0D+00
      DO  I=1,NAT
         total_mass = total_mass + ZMASS(I)
      enddo
C
      DO 4 L=1,9,4
         DO 5 N=1,NAT
            IF(.NOT.DFTBFL) DDM(L,N)=DDM(L,N) + ZAN(N) *4.803242D+00
C     This is the contribution to charged molecules that results
C     from using the center of mass as the origin.
            DDM(L,N)=DDM(L,N) -
     &           4.803242D+00 * ICH * zmass(N) / total_mass
c         write(6,'("MASS =",I3,2F10.7)') N,zmass(N),ZAN(N)
    5    CONTINUE
    4 CONTINUE
C
      RETURN
      END
c
C*MODULE FMOHSS  *DECK ESDHSS
C>    @brief Second order derivatiev of energy separated dimers
C>
C>    @details  Main driver to allocate memory, and calculate
C>      for all the contribution of separated dimers to Hessian
C>
C>    @author Hiroya Nakata
C>    - APR, 2013- Subroutine writte
C>           --- INPUT ---
C>    @param NDER      Energy derivative order
C>    @param SCFFRG    SCFTYP for fragment (for UHF or ROHF)
C>    @param IREC0     Record number to read orbital in the fragments
C>    @param YALAG     The solution of alpha orbital relaxation term for entire systems
C>    @param IPTYA     The pointer  for YALAG
C>    @param numfrg    number of AO basis in the respective fragments
C>    @param NQMTFG    number of MO basis in the respectvie fragments
C>    @param   IFG     Fragment indice in current for monomer
C>    @param   DI      Density for IFG
C>    @param   JFG     Fragment indice in current for dimer
C>    @param   DJ      Density for JFG
C>    @param LAYFRG    Layer information for respective fragments
C>           --- OUTPUT ---
C>    @param    FCM    Foce constant matrix
      SUBROUTINE ESDHSS(NDER,FCM,scffrg,irec0,YALAG,IPTYA,numfrg,
     *           NQMTFG,IFG,DI,JFG,DJ,LAYFRG,IWRK,NC1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXSH=5000,MXGTOT=20000, MXRT=100 )
      PARAMETER (ONE=1.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL FIRST,SECND,CPHF,BOTH,MFIRST,MSECND,MCPHF
c     Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /HSSPAR/ FIRST,SECND,CPHF,BOTH,MFIRST,MSECND,MCPHF
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,NZMTFMO,ifmobas,itmfmo(2)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
C
      DIMENSION FCM(NC1,*),SCFFRG(*)
      DIMENSION numfrg(*),NQMTFG(*)
      DIMENSION YALAG(*),IPTYA(*),DI(*),DJ(*)
      DIMENSION LAYFRG(*),IWRK(*)
C
      DATA UHF/8HUHF     /
C
      FIRST=.TRUE.
      SECND=.TRUE.
      CPHF=.TRUE.
      BOTH=.TRUE.
      MFIRST=.TRUE.
      MSECND=.TRUE.
      MCPHF=.TRUE.
C
      ilay=layfrg(ifg)
      jlay=layfrg(jfg)
      IF(NDER.ne.2) write(6,*) IPTYA(1),NUMFRG(1),YALAG(1)
C
      call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0, .false.)
C
      call monbsr(nat,ich,mul,num,nqmt,ne,na,nb,nshell,ngau,enucr,
     *            nat0,ich0,mul0,num0,nqmt0,ne0,na0,nb0,
     *            ncursh,ngau0,enucr0)
      NE0C=NE0+ICH0
C
C     IF(MASWRK) write(*,*) "Second order derivative for ES-DIM terms"
C
      NATI = NAT
      l1I  = num
      L2I  = (L1I*L1I+L1I)/2
      L3I  = L1I*L1I
C
      MULI = IXFTCH(X(LMULFG),IFG)
      NAI  = NA
      NBI  = NA - MULI + 1
C
c     write(*,*) "INFO IFG=",IFG,NATI,l1I,NAI,NBI,NQI,ncursh
C
      call makemol(jfg,0,0,jlay,0,nat0,ncursh,ngau0,ne0c,ich0,mul0,
     *               .false.)
C
      NATJ = NAT-NATI
      l1J  = num - l1I
      L2J  = (L1J*L1J+L1J)/2
      L3J  = L1J*L1J
c     NQJ  = IAND(NQMTFG(JFG),65535)
      MULJ = IXFTCH(X(LMULFG),JFG)
      NAJ  = NA - NAI
      NBJ  = NAJ-MULJ+1
C
      call mapfmohess(nat,X(liaglob),X(lindat),layfrg,iwrk,ntmp,0)
C
C
      lenrecj= L3J + L1J
      lenreci= L3I + L1I
      if(scffrg(jfg).eq.uhf)  lenrecj = L3J * 2 + L1J * 2
      if(scffrg(ifg).eq.uhf)  lenreci = L3I * 2 + L1I * 2

C
      CALL rareads(IDAFMO,x(liodfmo),DJ(l2j+1),lenrecj,jfg+irec0,0)
      if(scffrg(jfg).eq.uhf) then
        call DMTX2(DJ,DJ(l2j+1),naj,l1j,l1j,0)
        call DMTX2(DJ(l2j+1),DJ(l2j+1+l3j),nbj,l1j,l1j,0)
        CALL DAXPY(L2J,ONE,DJ(L2J+1),1,DJ,1)
        CALL rareads(IDAFMO,x(liodfmo),DJ(l2j+1),lenrecj,jfg+irec0,0)
      else
        call DMTX2(DJ,DJ(l2j+1),naj,l1j,l1j,nbj)
      end if
C
      CALL rareads(IDAFMO,x(liodfmo),DI(l2i+1),lenreci,ifg+irec0,0)
      if(scffrg(ifg).eq.uhf) then
        call DMTX2(DI,DI(L2I+1),NAI,L1I,L1I,0)
        call DMTX2(DI(l2I+1),DI(L2I+1+L3I),NBI,L1I,L1I,0)
        CALL DAXPY(L2I,ONE,DI(L2I+1),1,DI,1)
        CALL rareads(IDAFMO,x(liodfmo),DI(l2i+1),lenreci,ifg+irec0,0)
      else
        call DMTX2(DI,DI(L2I+1),NAI,L1I,L1I,NBI)
      end if
C
      CALL ESDNHSS(NATI,FCM,IWRK,nc1)
C
c     IF(MASWRK) write(*,*) "testtesttest00",IFG,L1I,NAI
c     IF(MASWRK) write(*,'(5f12.8)') (DI(iii+L2I),iii=1,l3i)
c     IF(MASWRK) write(*,*) "testtesttest10",JFG,L1J,NAJ
c     IF(MASWRK) write(*,'(5f12.8)') (DJ(iii+L2J),iii=1,l3j)
c     write(*,*) "INFO IFG NAT=",NAT
C
      NC0=int(NC1/3)
C    allocate memory
      CALL VALFM(LOADFM)
      LEG  = LOADFM + 1
      LEH  = LEG    + NC1
      LFDI = LEH    + 9 * (NC0*NC0+NC0)/2
      LFDJ = LFDI   + 3 *  NAT * L2I
      LAST = LFDJ   + max(3 *  NAT * L2J, 6 * L2I * NATJ)
      NEED = LAST-LOADFM-1
      CALL GETFM(NEED)
C
      NFD  = 3 * NAT    * (L2I + L2J)
      NEGH = 3 * NC0    + 9 * (NC0 * (NC0+1))/2
C
      call vclr(x(leg),1,NEGH)
      call vclr(x(lfdi),1,NFD)
C
C     Second order derivative for 1e integral
      CALL ESDIMhss1a(IFG,l1I,DI,LFDI,NATI,
     *                JFG,l1J,DJ,LFDJ,NATJ,
     *                LEG,LEH,IWRK,NC1)
c
C
c     Second derivative for two-electron terms
      call ESDIMhss2a(IFG,L1I,nai,nbi,nati,DI,LFDI,ILAY,
     *                JFG,L1J,naj,nbj,natj,DJ,LFDJ,JLAY,
     *                X(LEG), X(LEH),NQMTFG,
     *                x(LLAYFRG),FCM,SCFFRG,IWRK,NC1)
c
C
c
      IF(GOPARR) CALL DSCAL(NC1*NC1,1.0D+00/NPROC,FCM,1)
C
      call addhss(nc0,nc0,X(LEH),FCM,0,iwrk)
C
      CALL RETFM(NEED)
C
      call monbsr(nat0,ich0,mul0,num0,nqmt0,ne0,na0,nb0,ncursh,ngau0,
     *           enucr0,nat,ich,mul,num,nqmt,ne,na,nb,nshell,ngau,enucr)
C


      RETURN
      END
c
C*MODULE FMOHSS  *DECK ESDNHSS
C>    @brief Second order derivatiev of ES-DIM for nuclear coordinate
C>
C>    @details  Contribution of nuclear coordinate for ES-DIM
C>
C>    @author Hiroya Nakata
C>    - APR, 2013- Subroutine writte
C>           --- INPUT ---
C>    @param  NATI     number of atom
C>    @param    iaglob global label for atom
C>    @param    natfmo total number of atoms in the system
C>           --- OUTPUT ---
C>    @param    FCMWRK Foce constant matrix
      SUBROUTINE ESDNHSS(nati,FCMWRK,iaglob,NC1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      PARAMETER (TWO=2.0D+00,THREE=3.0D+00)
c     logical GOPARR,DSKWRK,MASWRK
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION FCMWRK(NC1,*),iaglob(*)
      DIMENSION SDR(9)

C
      DO 40 IAT = NATI+1,NAT
        ZAI = ZAN(IAT)
      DO 40 JAT = 1,NATI
        IF(IAT.eq.JAT) GO TO 40
        ZAJ = ZAN(JAT)
C
        RX = C(1,IAT) - C(1,JAT)
        RY = C(2,IAT) - C(2,JAT)
        RZ = C(3,IAT) - C(3,JAT)
        RIJ= SQRT(RX*RX+RY*RY+RZ*RZ)
        RD = (RIJ**5)
        RXX = RX * RX
        RYY = RY * RY
        RZZ = RZ * RZ
C
C
        SDR(1) = ( TWO * RXX - RYY - RZZ )/RD
        SDR(5) = ( TWO * RYY - RZZ - RXX )/RD
        SDR(9) = ( TWO * RZZ - RXX - RYY )/RD
        SDR(2) = ( THREE * RX * RY )/RD
        SDR(4) = SDR(2)
        SDR(3) = ( THREE * RZ * RX )/RD
        SDR(7) = SDR(3)
        SDR(6) = ( THREE * RY * RZ )/RD
        SDR(8) = SDR(6)
C
        ZAIJ = ZAI * ZAJ
C
C
        DO 42 I = 1,9
   42     SDR(I) = ZAIJ * SDR(I)
C
C       write(*,*) "RD00 =",SDR(1),SDR(5),SDR(9)
C
        IZAT   = iaglob(IAT)
        JZAT   = iaglob(JAT)
        IX     = IZAT * 3 - 2
        IY     = IZAT * 3 - 1
        IZ     = IZAT * 3
        JX     = JZAT * 3 - 2
        JY     = JZAT * 3 - 1
        JZ     = JZAT * 3
C
        IF(IZAT.NE.0) THEN
          FCMWRK(IX,IX) = FCMWRK(IX,IX) + SDR(1)
          FCMWRK(IY,IX) = FCMWRK(IY,IX) + SDR(2)
          FCMWRK(IZ,IX) = FCMWRK(IZ,IX) + SDR(3)
          FCMWRK(IX,IY) = FCMWRK(IX,IY) + SDR(4)
          FCMWRK(IY,IY) = FCMWRK(IY,IY) + SDR(5)
          FCMWRK(IZ,IY) = FCMWRK(IZ,IY) + SDR(6)
          FCMWRK(IX,IZ) = FCMWRK(IX,IZ) + SDR(7)
          FCMWRK(IY,IZ) = FCMWRK(IY,IZ) + SDR(8)
          FCMWRK(IZ,IZ) = FCMWRK(IZ,IZ) + SDR(9)
        END IF
C
C
        IF(IZAT.NE.0.AND.JZAT.NE.0) THEN
          FCMWRK(IX,JX) = FCMWRK(IX,JX) - SDR(1)
          FCMWRK(IY,JX) = FCMWRK(IY,JX) - SDR(2)
          FCMWRK(IZ,JX) = FCMWRK(IZ,JX) - SDR(3)
          FCMWRK(IX,JY) = FCMWRK(IX,JY) - SDR(4)
          FCMWRK(IY,JY) = FCMWRK(IY,JY) - SDR(5)
          FCMWRK(IZ,JY) = FCMWRK(IZ,JY) - SDR(6)
          FCMWRK(IX,JZ) = FCMWRK(IX,JZ) - SDR(7)
          FCMWRK(IY,JZ) = FCMWRK(IY,JZ) - SDR(8)
          FCMWRK(IZ,JZ) = FCMWRK(IZ,JZ) - SDR(9)
C
C
          FCMWRK(JX,IX) = FCMWRK(JX,IX) - SDR(1)
          FCMWRK(JY,IX) = FCMWRK(JY,IX) - SDR(2)
          FCMWRK(JZ,IX) = FCMWRK(JZ,IX) - SDR(3)
          FCMWRK(JX,IY) = FCMWRK(JX,IY) - SDR(4)
          FCMWRK(JY,IY) = FCMWRK(JY,IY) - SDR(5)
          FCMWRK(JZ,IY) = FCMWRK(JZ,IY) - SDR(6)
          FCMWRK(JX,IZ) = FCMWRK(JX,IZ) - SDR(7)
          FCMWRK(JY,IZ) = FCMWRK(JY,IZ) - SDR(8)
          FCMWRK(JZ,IZ) = FCMWRK(JZ,IZ) - SDR(9)
        END IF
C
C
C
        IF(JZAT.NE.0) THEN
          FCMWRK(JX,JX) = FCMWRK(JX,JX) + SDR(1)
          FCMWRK(JY,JX) = FCMWRK(JY,JX) + SDR(2)
          FCMWRK(JZ,JX) = FCMWRK(JZ,JX) + SDR(3)
          FCMWRK(JX,JY) = FCMWRK(JX,JY) + SDR(4)
          FCMWRK(JY,JY) = FCMWRK(JY,JY) + SDR(5)
          FCMWRK(JZ,JY) = FCMWRK(JZ,JY) + SDR(6)
          FCMWRK(JX,JZ) = FCMWRK(JX,JZ) + SDR(7)
          FCMWRK(JY,JZ) = FCMWRK(JY,JZ) + SDR(8)
          FCMWRK(JZ,JZ) = FCMWRK(JZ,JZ) + SDR(9)
        END IF
C


   40 CONTINUE
C

      RETURN
      END
C
C*MODULE FMOHSS  *DECK ESDIMhss1a
C>    @brief Second order derivatiev of ES-DIM for one electron integral
C>
C>    @details  Contribution of one electron integral for ES-DIM
C>
C>    @author Hiroya Nakata
C>    - Apr, 2013- Subroutine writte
C>           --- INPUT ---
C>    @param   IFG     Fragment indice in current for monomer
C>    @param   L1I     Number of atomic orbital in IFG
C>    @param   DI      Density for IFG
C>    @param   LFDI    Derivative of Fock matrix elements in IFG
C>    @param  NATI     number of atom in IFG
C>    @param   JFG     Fragment indice in current for dimer
C>    @param   L1J     Number of atomic orbital in JFG
C>    @param   DJ      Density for JFG
C>    @param   LFDJ    Derivative of Fock matrix elements in JFG
C>    @param  NATJ     number of atom in JFG
C>    --- OUTPUT ---
C>    @param   LEG     Derivative of energy
C>    @param   LEH     Second Derivative of energy
      SUBROUTINE ESDIMhss1a(IFG,l1I,DI,LFDI,NATI,
     *                      JFG,l1J,DJ,LFDJ,NATJ,
     *                      LEG,LEH,IWRK,NC1)

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C
      PARAMETER (MXATM=2000,TWO=2.0D+00,HALF=0.5D+00)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)

      COMMON /FMCOM / X(1)

      DIMENSION DI(*),DJ(*),IWRK(*)
C
      if(IFG.eq.0) write(6,*) "JFG=",JFG,NATJ
C
      L2I = (L1I + L1I * L1I) / 2
      L2J = (L1J + L1J * L1J) / 2
c     L2  =  L2I + L2J
      NFD = (L2I + L2J) * NAT * 3
C
C     HELMANN-FEYNMAN TERMS
      call ESDIM_HLF(x(LEG),x(LEH),
     *               DI,l1I,l2I,x(LFDI),NATI,
     *               DJ,l2J,x(LFDJ),IWRK)
c
C
C
C     Coupling terms
      call ESDIM_HFD(x(LEH),DI,l1I,NATI,DJ,IWRK)
C
C     Nuclear atraction
      call ESDIM_TVD(X(LEG),X(LEH),
     *               DI,l1I,l2I,x(LFDI),NATI,
     *               DJ,l2J,x(LFDJ),IWRK,NC1)
c
C
C
      CALL DSCAL(NFD,two,x(LFDI),1)
      do i = 1,nat*3
         II=0
         DO JJ=1,L1I
           II = II+JJ
           x(LFDI+II-1+l2i*(i-1)) = x(LFDI+II-1+l2i*(i-1)) * half
         ENDDO
         II=0
         DO JJ=1,L1J
           II = II+JJ
           x(LFDJ+II-1+l2j*(i-1)) = x(LFDJ+II-1+l2j*(i-1)) * half
         ENDDO
      end do
C
C
      RETURN
      END
C
C*MODULE FMOHSS  *DECK ESDIMhss2a
C>    @brief Second order derivatiev of ES-DIM for two electron integral
C>
C>    @details  Contribution of two-electron integral for ES-DIM
C>
C>    @author Hiroya Nakata
C>    - Apr, 2013- Subroutine writte
C>           --- INPUT ---
C>    @param   IFG     Fragment indice in current for monomer
C>    @param   L1I     Number of atomic orbital in IFG
C>    @param   nai     number of alpha electron for ifg
C>    @param   nbi     number of beta  electron for ifg
C>    @param  NATI     number of atom in IFG
C>    @param   DI      Density for IFG
C>    @param   LFDI    Derivative of Fock matrix elements in IFG
C>    @param   ILAY    layer for ifg
C>    @param   JFG     Fragment indice in current for dimer
C>    @param   L1J     Number of atomic orbital in JFG
C>    @param   naj     number of alpha electron in jfg
C>    @param   nbj     number of beta  electron in jfg
C>    @param  NATJ     number of atom in JFG
C>    @param   DJ      Density for JFG
C>    @param   LFDJ    Derivative of Fock matrix elements in JFG
C>    @param   JLAY    layer for ifg
C>    @param    iaglob global label for atom
C>    @param   NQMTFG  number of orbital for fragments
C>    @param LAYFRG    Layer information for respective fragments
C>    @param SCFFRG    SCFTYP for fragment (for UHF or ROHF)
C>    --- OUTPUT ---
C>    @param    EG     Derivative of energy
C>    @param    EH     Second Derivative of energy
C>    @param   FCM     Foce constant matrix
      subroutine ESDIMhss2a(IFG,L1I,nai,nbi,nati,DI,LFDI,ILAY,
     *                      JFG,L1J,naj,nbj,natj,DJ,LFDJ,JLAY,
     *                      EG, EH, NQMTFG,
     *                LAYFRG,FCM,SCFFRG,IWRK,NC1)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (HALF=0.5D+00,thrush=1.0D+04)
      PARAMETER (MXGSH=30,MXG2=MXGSH*MXGSH,MAXL=5)
      PARAMETER (MXGTOT=20000, MXSH=5000, MXATM=2000)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,UROHF
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c     COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
c     COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
c    *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
c    *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
c    *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
c    *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
c    *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
C
      COMMON /SCYVEC/ IDFYVEC,LIPTYVEC,LIPTYA
      COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
      DIMENSION KARTEN(0:MAXL-1)
      DATA KARTEN/1,4,6,10,15/
      DATA  UHF/8HUHF     /
      DATA ROHF/8HROHF    /
C
      DIMENSION DI(*),DJ(*),FCM(NC1,*),IWRK(*)
      DIMENSION EG(*),EH(*),NQMTFG(*)
      DIMENSION LAYFRG(*),SCFFRG(*)
C
      IF(NBI.eq.0) write(iw,*) "LAYFRG=",LAYFRG(1),NBI,NBJ,thrush,
     *             ILAY,JLAY
c     IF(MASWRK) write(*,*) "Entering 2 electron integrals in ES-DIM"
C   For I fragment
      L2I   = (L1I + L1I * L1I) / 2
      L3I   =  L1I * L1I
      NQI   = IAND(NQMTFG(IFG),65535)
      IF(NQI.EQ.0) NQI=L1I
      NOCCI = NAI
      NOCCIB= NBI
C
C   HOP treatment
      leneig  = L2I + L3I
      if(scffrg(ifg).eq.uhf) leneig = L2I + L3I * 2
      ICOUNT  = 0
      DO IORB = 1,NQI
        IF(DI(leneig+IORB) .gt. thrush) ICOUNT = ICOUNT + 1
      END DO
      NVIRI = NQI - NOCCI  - ICOUNT
      NVIRIB= NQI - NOCCIB - ICOUNT
C
c     write(6,'("L1I =",4I4)') IFG,L1I,NQI,NVIRI
C   For J fragment
      L2J   = (L1J + L1J * L1J) / 2
      L3J   =  L1J * L1J
      NQJ   = IAND(NQMTFG(JFG),65535)
      IF(NQJ.EQ.0) NQJ=L1J
      NOCCJ = NAJ
      NOCCJB= NBJ
C
C   HOP treatment
      leneig  = L2J + L3J
      if(scffrg(jfg).eq.uhf) leneig = L2J + L3J * 2
      ICOUNT  = 0
      DO IORB = 1,NQJ
        IF(DJ(leneig+IORB) .gt. thrush) ICOUNT = ICOUNT + 1
      END DO
      NVIRJ = NQJ - NOCCJ - ICOUNT
      NVIRJB= NQJ - NOCCJB- ICOUNT
C
c     write(6,'("L1J =",4I4)') JFG,L1J,NQJ,NVIRJ
C
      CALL BASCHK(LMAX)
      IF(LMAX.GE.5) THEN
         IF(MASWRK) WRITE(IW,*) 'FMO HAS NOT BEEN REVIEWED FOR H,I'
         CALL ABRT
      END IF
      NANGM= KARTEN(MAX(LMAX,1))
      MAXG = NANGM**4
C
c     write(*,*) "TESTTEST =",NOCCI,NVIRI,NOCCJ,NVIRJ
      CALL VALFM(LOADFM)
      CALL GOTFM(NGOTMX)
C
      NSH2    = (NSHELL + NSHELL * NSHELL)/ 2
      LDSI    = LOADFM  + 1
      LDSJ    = LDSI    + l2I * nati  * 3
      LWRK2   = LDSJ    + l2J * natj  * 3 * 2   ! for pure 2-electron terms
      LXCHNG  = LWRK2   + max(L3I,L3J) * 4 + max(l2I,l2J)*2  + num*8
      LGHOND  = LXCHNG  + NSH2
      LDDIJ   = LGHOND  + MAXG
      LAST    = LDDIJ   + 49 * MXG2
      LWRK3   = LAST
      UROHF   =          SCFFRG(IFG).EQ.UHF .OR.SCFFRG(JFG).EQ.UHF
      UROHF   = UROHF.OR.SCFFRG(IFG).EQ.ROHF.OR.SCFFRG(JFG).EQ.ROHF
      IF(UROHF) THEN
        LAST  = LWRK3   + max(L3I,L3J) * 2
      END IF
C
      NEEDK   =  LAST   - LOADFM -1
      if(NEEDK.gt.NGOTMX) then
          write(iw,*) "Can not allocate  memory in fmohss"
          write(iw,*) "NEED = ",NEEDK,"MAX =",NGOTMX
          call abrt
          if(lfmobuf(3).ne.0) call abrt
      end if
      CALL GETFM(NEEDK)
C
      IST=1
      JST=1
      KST=1
      LST=1
      CALL JANDK
C
      CALL DAREAD(IDAF,IODA,X(LXCHNG),NSH2,54,0)
C
c     write(6,*) "ESD 2eHSS"
C
      call ESD_2eHSS(IFG,L1I,L2I,DI,X(LFDI),
     *               JFG,L1J,L2J,DJ,X(LFDJ),
     *               EG, EH,X(LWRK2),X(LXCHNG),IWRK)
C
C
c     write(6,*) "ESD 2eHSS END?"
C   DBG
c     NEGH = 3*NATFMO+9*(NATFMO*(NATFMO+1))/2
c     IF(GOPARR) CALL DDI_GSUMF(1625,EG,NEGH)
c     IF(MASWRK) THEN
c        WRITE(*,*) "checkcheckcheck01"
c        CALL HSSPRT(NATFMO,EG,EH)
c     END IF
c     IF(GOPARR) CALL DSCAL(negh,1.0D+00/NPROC,EG,1)
c     RESTORE THE PRISTINE MONOMER(DIMER) CONFIGURATION
      IF (GOPARR) THEN
          CALL DDI_GSUMF(1605,X(LFDI),3*NAT*(L2I+L2J))
      END IF
C
      CALL DSCAL(3*NAT*L2I,half,X(LFDI),1)
      CALL DSCAL(3*NAT*L2J,half,X(LFDJ),1)
      do i = 1,nat*3
         II=0
         DO JJ=1,L1I
           II = II+JJ
           X(LFDI+II-1+l2I*(i-1))
     *   = X(LFDI+II-1+l2I*(i-1)) + X(LFDI+II-1+l2I*(i-1))
         ENDDO
         II=0
         DO JJ=1,L1J
           II = II+JJ
           X(LFDJ+II-1+L2J*(i-1))
     *   = X(LFDJ+II-1+L2J*(i-1)) + X(LFDJ+II-1+L2J*(i-1))
         ENDDO
c        val = TRACEP(DI,x(LFDI+l2I*(i-1)),L1I)
c        val = val + TRACEP(DJ,x(LFDJ+l2J*(i-1)),L1J)
c        write(*,*) i,val
      end do
C
C     summing up contribution (\Delta D * S * D * (ii | uv)
      IILAY=IXFTCH(X(liactfg),IFG) + 1
      JJLAY=IXFTCH(X(liactfg),JFG) + 1
c     write(6,*) "ESD 2eHSSR"
C
      CALL ESD_2ehssR(IFG,L1I,NQI,NOCCI,NVIRI,DI,X(LFDI),X(LDSI),nati,
     *                JFG,L1J,NQJ,NOCCJ,NVIRJ,DJ,X(LFDJ),X(LDSJ),natj,
     *                IWRK,FCM,X(LXCHNG),X(LGHOND),X(LWRK2),L2I,L2J,
     *                X(LIPTYA),X(LYALAG),NOCCIB,NVIRIB,NOCCJB,NVIRJB,
     *                X(LSCFFRG),X(LWRK3),IILAY,JJLAY,NC1)
C
CC
      CALL RETFM(NEEDK)
C
      RETURN
      END
C
C*MODULE FMOHSS  *DECK mapfmohess
C>    @brief   Generate mapping for Hessian
C>
C>    @details Generate mapping for FMO Hessian
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT       Number of atoms in the fragment
C>    @param IAGLOB    Global label for atoms
C>    @param INDAT     Converts global atomic location to fragment index
C>    @param LAYFRG    Layer information for respective fragments
C>    @param MODE      Controls the job
C>           --- OUTPUT ---
C>    @param IWRK      Location of Hessian
C>    @param NATI      Number of active atoms
      SUBROUTINE mapfmohess(nat,iaglob,indat,layfrg,iwrk,nati,mode)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody

      DIMENSION iaglob(*),indat(*),layfrg(*),iwrk(*)

C     Mapping for Hessian | output is nati, iwrk
C     mode 0: nat(frg)--> high-layer (B)
C     mode 1: natfmo  --> active     (A)
C     mode 2: natfmo  --> natfmo     (ALL) (dummy subroutine)
C     mode 3: nat(frg)--> active     (A)
C     mode 4: natfmo  --> high-layer (B)

      nati=0
      call viclr(iwrk,1,nat)
C
      if(mode.eq.0.or.mode.eq.4) nact = nlayer
      if(mode.eq.1.or.mode.eq.3) nact = 1
c     write(6,*) "Check =",nat,nati
      do 10 iat=1,natfmo
        if(mode.eq.2) then
          iwrk(iat)=iat
          nati=nati+1
          go to 10
        end if
        if(layfrg(indat(iat)).eq.nact) then
          nati=nati+1
          if(mode.eq.0.or.mode.eq.3) then
            do jat=1,nat
              jzat=iaglob(jat)
              if(jzat.eq.iat) iwrk(jat)=nati
            end do
          end if
          if(mode.eq.1.or.mode.eq.4) iwrk(iat)=nati
        end if
 10   continue

      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK packfmohess
C>    @brief   FMO/FDD Hessian
C>
C>    @details Convert Hessian for active atoms to global Hessian
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NACT      Number of active atoms
C>    @param IACT      List of active atoms
C>    @param FCMA      Hessian of active atoms
C>    @param NBUF      3*NAT
C>    @param IBUF      Location of Hessian
C>    @param IWRK      Working array
C>           --- OUTPUT ---
C>    @param FCMB      Global Hessian matrix
      subroutine  packfmohess(nact,iact,FCMA,nbuf,ibuf,FCMB,iwrk)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
C
      dimension iact(*),ibuf(*),iwrk(*)
      dimension FCMA(nact*3,*),FCMB(nbuf*3,*)


c     write(6,'("iact=",5I3)') (iact(iii),iii=1,natfmo)
c     write(6,'("ibuf=",5I3)') (ibuf(iii),iii=1,natfmo)
      do iatm=1,natfmo
       if(iact(iatm).ne.0) iwrk(iact(iatm))=iatm
      end do
c     write(6,'("iglob=",5I3)') (iwrk(iii),iii=1,nact)
      do iatm=1,nact
         itmp=ibuf(iwrk(iatm))
         do jatm=1,nact
           jtmp=ibuf(iwrk(jatm))
           do ixyz=1,3
             igrbxyz=(itmp-1)*3+ixyz
             ilocxyz=(iatm-1)*3+ixyz
             do jxyz=1,3
               jgrbxyz=(jtmp-1)*3+jxyz
               jlocxyz=(jatm-1)*3+jxyz
               FCMB(igrbxyz,jgrbxyz)=FCMA(ilocxyz,jlocxyz)
             end do
           end do
         end do
      end do
C


      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK GETmapfmohss
C>    @brief   FMO/FDD Hessian
C>
C>    @details Check whether truncation is required or not in CPHF
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT       Number of atoms
C>    @param IAGLOB    Global label for atom
C>    @param INDAT     Converts global atomic location to fragment index
C>    @param IACTFRG   Information of active atoms in FDD
C>    @param MAPFMO    Working array for mapping
C>    @param DOTRUN    Whether truncated or not
C>           --- OUTPUT ---
C>    @param NINI      Index of initial atom
C>    @param NEND      Index of the last atom
      SUBROUTINE  GETmapfmohss(nat,iaglob,indat,iactfg,
     *      mapfmo,dotrun,nini,nend)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION iaglob(*),indat(*),iactfg(*),mapfmo(*)
      LOGICAL  dotrun
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
C
      dotrun=.false.
C
      if(modfd.eq.0) then
        return
      end if
c
      call mapfmohess(nat,iaglob,indat,iactfg,mapfmo,nactatm,3)
c
      ncount = 0
      nparam = 1
      if(NBDFG.ne.0)  nparam = 6
      do iatm=1,nat
        if(mapfmo(iatm).eq.0) ncount=ncount+1
      end do
      if(ncount.ge.nparam) then
        dotrun=.true.
        do iatm=1,nat
         if(mapfmo(iatm).ne.0.and.nini.eq.0) nini=iatm
         if(mapfmo(iatm).ne.0              ) nend=iatm
        end do
      end if
c
C     check subroutine
c     if(maswrk) then
c        write(6,'("CHECK glob=",4I4)')  (iaglob(iii),iii=1,nat)
c        write(6,'("CHECK indat=",4I4)') (indat(iaglob(iii)),iii=1,nat)
c        write(6,'("CHECK mapfmo=",4I4)') (mapfmo(iii),iii=1,nat)
c        write(6,'("CHECK range=",2I4)') nini,nend
c     end if
c
      RETURN
      END
C
C*MODULE FMOHSS  *DECK FMOESP_CP_DFTB
C>    @brief   ESP contributions for FMO-DFTB Hessian in CP-DFTB
C>
C>    @details Add ESP contributions in CP-DFTB iteration for FMO-DFTB
C>             Hessian
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NI        Atom to be differentiated
C>    @param KI        Axis to be differentiated
C>    @param L1        Number of basis functions
C>    @param L2        L1*(L1+1)/2
C>    @param IFG       Fragment indice in current for monomer
C>    @param JFG       Fragment indice in current for dimer
C>    @param KFG       Fragment indice in current for trimer
C>    @param SDER      Overlap derivative in AO basis
C>    @param SAO       Overlap matrix in AO basis
C>    @param EIG       Orbital energy
C>    @param CHAMUL    Mulliken charge
C>    @param SAVGOP    Temporary GOPARR
C>           --- OUTPUT ---
C>    @param UINIT     Non-response U
      SUBROUTINE FMOESP_CP_DFTB(NI,KI,UINIT,L1,L2,IFG,JFG,KFG,
     *           SDER,SAO,VEC,EIG,CHAMUL,SAVGOP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      DIMENSION UINIT(l1,l1,*),SDER(L2),SAO(L2),VEC(*),EIG(*),
     *          CHAMUL(*)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL  SAVGOP
C
      Parameter (MXATM=2000,MXSPE=10)
      Parameter (ONE=1.0D+00)
CZCZ  common /GRAD  / DE(3,MXATM)
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /FMCOM / X(1)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,NZMTFMO,ifmobas,itmfmo(2)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C     FMO V^a contribution to U
c     write(6,'("INA=",3I4)') NA,NAT,MODGAMMA
C
      CALL VALFM(LOADFM)
      LSHIFT  = LOADFM  + 1
      LSHIFT3 = LSHIFT  + NAT
      LWRK1   = LSHIFT3
      if(DFTB3) LWRK1   = LSHIFT3 + NAT * 2
      LWRK2   = LWRK1   + L2
      LWRK3   = LWRK2   + L2
      LAST    = LWRK3   + L1
      NEED    = LAST    - LOADFM - 1
      CALL GETFM(NEED)

      CALL VCLR(X(LSHIFT),1,NAT)
C     GET OMEGA^a (a =  NI,KI)
      lpopmati=lpopmat+(maxnat*nfg)*(icurpop-1)
      CALL FMOESP_CP_DFTBX(NFG,X(LSHIFT),X(lpopmati),
     *     X(LISPE),X(lfmoc),NI,KI,IFG,JFG,KFG,X(lindfrg),X(lnatfrg),
     *     x(liatfrg),x(liaglob),X(LGAMMAD),X(LGAMMA3D),CHAMUL(NI))!
C
      CALL SHIFT_TRIANGLE(NAT,L2,IND,X(LSHIFT),SAO,X(LWRK1))
c     write(6,'("wwwchk1=",F16.8)') (X(LSHIFT+iii-1),iii=1,NAT)
      IF(SAVGOP) GOPARR=SAVGOP
      CALL DAREAD(IDAF,IODA,X(LSHIFT),NAT,566,0)
C
      if(DFTB3) THEN
        CALL DAREAD(IDAF,IODA,X(LSHIFT3),NAT*2,567,0)
        CALL DFTB_3RD_SHIFT_FMO(X(LSHIFT),CHAMUL,X(LSHIFT3),NAT)
      END IF
C
      IF(SAVGOP) GOPARR=.false.
      CALL SHIFT_TRIANGLE(NAT,L2,IND,X(LSHIFT),SDER,X(LWRK2))
c     write(6,'("wwwchk2=",F16.8)') (X(LSHIFT+iii-1),iii=1,NAT)
c     CALL VCLR(X(LWRK2),1,L2)
      CALL DAXPY(L2,ONE,X(LWRK1),1,X(LWRK2),1)
      CALL TFTRI(X(LWRK1),X(LWRK2),vec,x(lwrk3),l1,l1,l1)
C
      DO IVIR=1+NA,L1
        EI = EIG(IVIR)
        IJ = (IVIR*IVIR-IVIR)/2
        DO IOCC=1,NA
          EJ = EIG(IOCC)
          UINIT(IVIR,IOCC,1)=UINIT(IVIR,IOCC,1)+X(LWRK1+IJ)/(EJ-EI)
          IJ = IJ + 1
        END DO
      END DO
C
      CALL RETFM(NEED)

      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK FMOESP_CP_DFTBX
C>    @brief   ESP contributions for FMO-DFTB Hessian in CP-DFTB
C>
C>    @details Actual subroutine that calculates the ESP contribution
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NFG       Number of fragments
C>    @param POPMAT    Mulliken population of each fragment
C>    @param ISPEFMO   ISPE for each atom in the system
C>    @param FMOC      Coordinate for each atom in the system
C>    @param KI        Axis to be differentiated
C>    @param L1        Number of basis functions
C>    @param L2        L1*(L1+1)/2
C>    @param IFG       Fragment indice in current for monomer
C>    @param JFG       Fragment indice in current for dimer
C>    @param KFG       Fragment indice in current for trimer
C>    @param INDFRG    First atom of each fragment in terms of NATFMOB?
C>    @param NATFRG    Number of atoms in fragment
C>    @param IATFRG    Global atom index with NBDFG?
C>    @param IAGLOB    Global index of atom
C>    @param GAMMA1    Some parameters for DFTB2 gamma
C>    @param GAMMA3    Some parameters for DFTB3 gamma
C>    @param CHAMULI   Mulliken charge of atom NI
C>           --- OUTPUT ---
C>    @param SHIFT     Shift contributions
      SUBROUTINE FMOESP_CP_DFTBX(NFG,SHIFT,popmat,ISPEFMO,
     *      FMOC,NI,KI,IFG,JFG,KFG,INDFRG,NATFRG,IATFRG,IAGLOB,GAMMA1,
     *      GAMMA3,CHAMULI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      PARAMETER (MXATM=2000,MXSPE=10)
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
c     COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
c    *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FMCOM / X(1)
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij

      DIMENSION SHIFT(*),popmat(maxnat,*)
      DIMENSION ISPEFMO(*),FMOC(3,*)
      DIMENSION GAMMA1(10,NSPE,NSPE),GAMMA3(11,NSPE,NSPE)
      DIMENSION INDFRG(*),NATFRG(*),IAGLOB(*),IATFRG(*)

      PARAMETER (ZERO=0.0D+00,TWO=2.0D+00,ONE_THIRD=1.0D+00/3.0D+00)

      IAG    = IAGLOB(NI)
      ISP    = ISPEFMO(IAG)
      DO 100 LFG=1,NFG

        IF(LFG.EQ.IFG.OR.LFG.EQ.JFG.OR.LFG.EQ.KFG) GO TO 100

        NATJ = natfrg(lfg)
        INDJ = INDFRG(lfg)
        JJ   = INDJ - 1
        DO 200 J = 1, NATJ !! ENVIRONMENTAL FRAGMENTS
          JJ     = JJ + 1
          CHAMULJ = POPMAT(J,LFG) - X(LZREF+JJ-1)
c         write(6,'("wwwchk=",2I3,F12.8)') LFG,J,CHAMUL
          IF (CHAMULJ.EQ.ZERO) GOTO 200
          JAG = IATFRG(JJ)
          JSP = ISPEFMO(JAG)
c         DO I = 1, NAT !! FRAGMNET TO BE CONSIDERED
C         Only element NI,KI in X
          DIST   = (FMOC(1,IAG)-FMOC(1,JAG))**2
     *           + (FMOC(2,IAG)-FMOC(2,JAG))**2
     *           + (FMOC(3,IAG)-FMOC(3,JAG))**2
          IF (DIST.EQ.ZERO) GOTO 200
          DIST   = SQRT(DIST)
          DISTI  = 1.0D+00/DIST
          GAMMAV = GAMD_FMO2(DIST,DISTI,GAMMA1(1,ISP,JSP),DAMPXH,
     *                       DAMPXHE,SPE(ISP),SPE(JSP))
          VAL    = FMOC(KI,IAG)-FMOC(KI,JAG)
          IF (DFTB3) THEN
            CALL DFTB_GAMD3(DIST,DISTI,GAMI,GAMJ,HUBB(ISP),HUBB(JSP),
     *        HUBDER(ISP),HUBDER(JSP),GAMMA3(1,ISP,JSP),
     *        GAMMA3(1,JSP,ISP),DAMPXH,DAMPXHE,SPE(ISP),SPE(JSP))
            GAMMAV = GAMMAV + ONE_THIRD*(TWO*CHAMULI*GAMI+CHAMULJ*GAMJ)
          END IF
          VAL    = CHAMULJ*GAMMAV*VAL*DISTI !/DIST
          SHIFT(NI) = SHIFT(NI) + VAL
 200    CONTINUE


 100  CONTINUE


      RETURN
      END
C
C*MODULE FMOHSS  *DECK esp2der_dftb
C>    @brief   ESP derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate second-order derivative of ESP contributions
C>             for FMO-DFTB Hessian
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param IFG       Fragment indice in current for monomer
C>    @param JFG       Fragment indice in current for dimer
C>    @param KFG       Fragment indice in current for trimer
C>    @param DA        Density matrix
C>    @param L1IJ      Number of basis functions for IJK
C>    @param L1I       Number of basis functions for I
C>    @param L1J       Number of basis functions for  J
C>    @param L1K       Number of basis functions for   K
C>    @param NUMFRG    Number of AO basis in the respective fragments
C>    @param NATFRG    Number of atoms in fragment
C>    @param YALAG     The solution of alpha orbital relaxation term for entire systems
C>    @param IPTYA     The pointer  for YALAG
C>    @param YAIJ      U_{mi}^a for fragment IJK
C>    @param QD        dQ/da for IJK
C>    @param NOCC      Number of occupied orbitals
C>    @param NVIR      Number of virtual orbitals
C>    @param NATIJ     Number of atoms for fragment IJK
C>    @param MAPI      Mapping information for framgnet I
C>    @param MAPJ      Mapping information for framgnet  J
C>    @param MAP3      Mapping information for framgnet   K
C>    @param IDMREC0   Record number to read density matrix
C>    @param INDFRG    First atom of each fragment in terms of NATFMOB?
C>    @param WRKESP    Working array
C>    @param DB        Working array
C>    @param DC        Working array
C>    @param WRK       Working array
C>    @param WRK1      Working array
C>    @param IREC00    Record number to read orbital in the fragments
C>    @param ORBXCH1   Orbitals have been exchanged or not
C>    @param ENEXCH1   Orbtital energies have been exchanged or not
C>    @param KODEXCH   MCSCF or not for KFG
C>    @param JODEXCH   MCSCF or not for JFG
C>    @param IODEXCH   MCSCF or not for IFG
C>    @param MAXL1D    Maximum basis functions
C>    @param IEEH      Scaling of Hessian contributions
C>           --- OUTPUT ---
C>    @param FCM       Hessian matrix
      SUBROUTINE esp2der_dftb(IFG,JFG,KFG,DA,L1IJ,L1I,L1J,L1K,NUMFRG,
     *       NATFRG,YALAG,IPTYA,YAIJ,QD,NOCC,NVIR,NATIJ,MAPI,MAPJ,MAP3,
     *       IDMREC0,INDFRG,WRKESP,DB,DC,WRK,WRK1,IREC00,
     *       ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,FCM,MAXL1D,IEEH)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION numfrg(*),natfrg(*)
      DIMENSION YALAG(*),YAIJ(NOCC,NVIR,*),IPTYA(*)
      DIMENSION QD(NATIJ,*),DA(*)
      DIMENSION MAPI(*),MAPJ(*),MAP3(MAXL1D,3),IDMREC0(*),INDFRG(*)
      DIMENSION WRKESP(*),DB(*),DC(*),WRK(*),WRK1(*)
      DIMENSION FCM(*)
C
      PARAMETER (ONE=1.0D+00,ZERO=0.0D+00)
      PARAMETER (MXATM=2000,MXSPE=10)
C
      LOGICAL ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,SOME1
      LOGICAL fastvesp
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /FMCOM / X(1)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
c     COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
c    *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
c    *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
c    *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
c    *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
c    *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
C     dimension
C     db    :  L1 + L2 + L3
c     dc    :  L1 + L2 + l3 ( for FMO3 only)
C     wrk   :  L1 + L2*2 + L3*2
C     wrk1  :  l1 + L2   + L3*2
c     wrkesp:  L2IJ
C
      SCAL = IEEH
      NATI = NATFRG(IFG)
      NATJ = NATFRG(JFG)
      NAI  = ISHFT(NUMFRG(IFG),-16)
      NAJ  = ISHFT(NUMFRG(JFG),-16)
      NBI  = NAI
      NBJ  = NAJ
      NVIRI= L1I - NAI
      NVIRJ= L1J - NAJ
      IF (KFG.NE.0) THEN
        NATK = NATFRG(KFG)
        NAK  = ISHFT(NUMFRG(KFG),-16)
        NBK  = NAK
        NVIRK= L1K - NAK
      END IF
C
C
      L2I  = (L1I  + L1I *L1I )/2
      L3I  =  L1I  * L1I
      L2J  = (L1J  + L1J *L1J )/2
      L3J  =  L1J  * L1J
      L2IJ = (L1IJ + L1IJ*L1IJ)/2
      L3IJ =  L1IJ * L1IJ
      IF (KFG.NE.0) THEN
        L2K  = (L1K  + L1K *L1K )/2
        L3K  =  L1K  * L1K
      END IF
C
      IREC0=IDMREC0(1)
C
      CALL DAREAD(IDAF,IODA,da(l2ij+1),l3ij,15,0)
      call dmtx2(wrkesp,da(l2ij+1),NOCC,l1ij,l1ij,NOCC)
c     iomit = 1
      some1 = .False.
      IF (KFG.EQ.0) THEN
      CALL DIMINID(0,JFG,IFG,L1J,L1I,L1J,L1I,NAJ,NAI,NBJ,NBI,L1IJ,DA,DB,
     *             WRK,WRK1,X(LIODFMO),IREC00,X(LIABDFG),X(LJABDFG),
     *             X(LINDAT),X(LIAGLOB),X(LLOCFMO),MAPJ,MAPI,
     *             ORBXCH1,ENEXCH1,JODEXCH,IODEXCH,0,DUM,1,
     *             .false.,.false.,X(LMULFG),some1)
      ELSE
      NQI=L1I
      NQJ=L1J
      NQK=L1K
      CALL TRIMINID(KFG,JFG,IFG,L1K,L1J,L1I,NQK,NQJ,NQI,NAK,NAJ,NAI,
     *             NBK,NBJ,NBI,L1IJ,DA,DB,DC,WRK,WRK1,X(LIODFMO),IREC00,
     *             X(LIABDFG),X(LJABDFG),X(LINDAT),X(LIAGLOB),
     *             X(LLOCFMO),MAP3(1,3),MAP3(1,2),MAP3(1,1),
     *             ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,1,
     *             .false.,.false.,.false.,some1)
C    *             scffrg(kfg).eq.uhf,scffrg(jfg).eq.uhf,
C    *             scffrg(ifg).eq.uhf,SOME1)
      END IF
C
      CALL DAXPY(L2IJ,-ONE,WRKESP,1,DA,1)
      CALL DSCAL(L2IJ,-ONE,DA,1)
c     XXX dose diminid can work with dftb??, jusft for check
c     dele=TRACEP(da,x(lfmoespa),l1ij)
c     write(6,'("wwwchk2=",F12.8)') dele
C
      CALL VALFM(LOADFM)
      LOMGD= LOADFM + 1
      LGAMH= LOMGD  + NATIJ * NATFMO * 3
C     XXX IS SIZE CORRECT for GAMH?
      LDQIJ= LGAMH  + 11*NSPE*NSPE
      LAST = LDQIJ  + NATIJ
      IF (DFTB3) THEN
        LDQIJ2 = LAST
        LMUL1A = LDQIJ2 + NATIJ
        LCTIJ  = LMUL1A + NATIJ
        LAST   = LCTIJ  + NATIJ
C
        LQDDQ  = LAST
        LAST   = LQDDQ  + NATIJ * NATIJ * 3
      END IF
C
      LPS  = LAST
      LSIJ = LPS    + L2IJ*NATIJ * 3
      LQDI = LSIJ   + L2IJ
      LQDJ = LQDI   + NATI*NATI  * 3
      LAST = LQDJ   + NATJ*NATJ  * 3
      IF (KFG.NE.0) THEN
        LQDK=LAST
        LAST=LQDK   + NATK*NATK  * 3
      END IF
      NEED = LAST   - LOADFM     - 1
      CALL GETFM(NEED)
C
      CALL VCLR(X(LOMGD),1,NATIJ * NATFMO * 3)
      lpopmati = lpopmat+(maxnat*nfg)*(icurpop-1)
C     GET QI^a
      IDMREC0K = IFG + IREC0
      CALL RAREADS(IDAFMO,X(LIODFMO),wrk1,L3I,IDMREC0K,0)
      CALL FMO2DER_GETKPOT(0,NATIJ,NATI,wrk1,L1I,X(lpopmati),
     *     YALAG(IPTYA(IFG)),NAI,NVIRI,X(LIATFRG),X(LFMOC),
     *     X(LISPE),DUM,X(LQDI),DUM,wrk,IFG,INDFRG,
     *     X(LIAGLOB),X(LPS),L2I,L3I,DUM,DUM,DUM,DUM,DUM,DUM,DUM,idum)
C     GET QJ^a
      IDMREC0K = JFG + IREC0
      CALL RAREADS(IDAFMO,X(LIODFMO),wrk1,L3J,IDMREC0K,0)
      CALL FMO2DER_GETKPOT(0,NATIJ,NATJ,wrk1,L1J,X(lpopmati),
     *     YALAG(IPTYA(JFG)),NAJ,NVIRJ,X(LIATFRG),X(LFMOC),
     *     X(LISPE),DUM,X(LQDJ),DUM,wrk,JFG,INDFRG,
     *     X(LIAGLOB),X(LPS),L2J,L3J,DUM,DUM,DUM,DUM,DUM,DUM,DUM,idum)
      IF (KFG.NE.0) THEN
C     GET QK^a
      IDMREC0K = KFG + IREC0
      CALL RAREADS(IDAFMO,X(LIODFMO),wrk1,L3K,IDMREC0K,0)
      CALL FMO2DER_GETKPOT(0,NATIJ,NATK,wrk1,L1K,X(lpopmati),
     *     YALAG(IPTYA(KFG)),NAK,NVIRK,X(LIATFRG),X(LFMOC),
     *     X(LISPE),DUM,X(LQDK),DUM,wrk,KFG,INDFRG,
     *     X(LIAGLOB),X(LPS),L2K,L3K,DUM,DUM,DUM,DUM,DUM,DUM,DUM,idum)
      END IF
C     GET QIJ   - QI   - QJ
      CALL DAREAD(IDAF,IODA,X(LSIJ),l2ij,12,0)
      CALL DFTB_MULLIKEN(L1IJ,L2IJ,DA,X(LSIJ),WRK1)
      CALL VCLR(X(LDQIJ),1,NATIJ)
      DO NC = 1, NATIJ
        VAL  = ZERO
        DO L = 1, IND(NC+1) - IND(NC)
          MU  = IND(NC) + L
          VAL = VAL     + WRK1(MU)
        END DO
        X(LDQIJ+NC-1)=X(LDQIJ+NC-1) + VAL
      END DO
C
C     LDQIJ2 = Q(IJ)^2 - Q(I)^2 - Q(J)^2
      IF (DFTB3) THEN
        CALL DAREAD(IDAF,IODA,X(LMUL1A),NATIJ,556,0)
        IF (KFG.EQ.0) THEN
          DO I = 1, NATIJ
            X(LMUL1A+I-1) = X(LMUL1A+I-1) - ZREF(I)
          END DO
          call ctpairb(ifg,jfg,X(LMUL1A),X(LPOPMATI),x(lindat),
     *                 x(liaglob),x(lialoc),X(lindbd),X(LDQIJ2),2,
     *                 x(lzref),x(lindfrg))
        ELSE
          call cttrim(ifg,jfg,kfg,X(LMUL1A),ZREF,X(LPOPMATI),
     *                x(lindat),x(liaglob),x(lialoc),X(lindbd),X(LCTIJ),
     *                X(LDQIJ2),x(lzref),x(lindfrg),dftb3)
          DO I = 1, NATIJ
            X(LMUL1A+I-1) = X(LMUL1A+I-1) - ZREF(I)
          END DO
        END IF
C
C       QDDQ = (delta QIJ)*QIJ^a - (delta QI)*QI^a - (delta QJ)*QJ^a
        CALL DFTB_CALC_QDDQ(IFG,JFG,KFG,QD,X(LQDDQ),X(LQDI),X(LQDJ),
     *       X(LQDK),X(LMUL1A),NATIJ,NATI,NATJ,NATK,X(LINDAT),
     *       X(LIAGLOB),X(LIALOC),X(LINDBD),X(LINDFRG),X(LZREF),
     *       X(LPOPMATI))
      END IF
c     write(6,'("wwwchk=",F12.8)') (X(LDQIJ+NC-1),NC=1,NATIJ)
C     GET QIJ^a - QI^a - QJ^a   !XXX Check for covalent bond later
      call getdqijpot(IFG,JFG,KFG,QD,NATIJ,X(LQDI),NATI,X(LQDJ),NATJ,
     *      X(LQDK),NATK,x(lindat),x(liaglob),x(lialoc),X(lindbd))
c     write(6,'("www DQIJ^a")')
c     call prsq(qd,natIJ*3,natij,natij)
C     GET GAMH
      CALL FMO2DER_GETGMH(X(LGAMH),NSPE)
C
C     WRITE(6,*) 'WWWLB',LARGEPRI
      MAXIC = NATFMO
      call setatz(1,MAXIC,fastvesp,lfvesp,needfv)
C
      DO 100 LFG=1,NFG

        IF(LFG.EQ.IFG.OR.LFG.EQ.JFG.OR.LFG.EQ.KFG) GO TO 100
C
        NATL = natfrg(lfg)
c       INDL = INDFRG(lfg)
        L1L  = IAND(NUMFRG(LFG),65535)
        L2L  = (L1L*L1L+L1L)/2
        L3L  = L1L*L1L
        NOCCL= ISHFT(NUMFRG(LFG),-16)
        NVIRL= L1L  - NOCCL
c       write(6,'("CHK=",4I4)') L1L,NOCCL,NVIRL,NATL
        CALL VALFM(LOADFM)
        LQL  = LOADFM + 1
        LQDL = LQL    + NATL
        LPSL = LQDL   + NATL  * NATL         * 3
        LAST = LPSL   + L2L   * NATL         * 3
c       LAST = LOMGD  + NATIJ * (NATIJ+NATL) * 3
c
        NEEDK= LAST   - LOADFM    - 1
        CALL GETFM(NEEDK)
C       Rerad orbital
        IDMREC0K = LFG + IREC0
        CALL RAREADS(IDAFMO,X(LIODFMO),wrk1,L1L*L1L,IDMREC0K,0)
C
c       write(6,'("CHECK VEC in DIM",I3)')  LFG
c       call prsq(WRK1,l1l,l1l,l1l)
C       Get DQ^K, Q^K,b, and OMEGA^K,b
        CALL FMO2DER_GETKPOT(1,NATIJ,NATL,wrk1,L1L,X(lpopmati),
     *       YALAG(IPTYA(LFG)),NOCCL,NVIRL,X(LIATFRG),X(LFMOC),
     *       X(LISPE),X(LQL),X(LQDL),X(LOMGD),wrk,LFG,
     *       INDFRG,X(LIAGLOB),X(LPSL),L2L,L3L,X(LDQIJ),X(LDQIJ2),QD,
     *       X(LQDDQ),FCM,X(LGAMH),SCAL,lfvesp)
C
        CALL RETFM(NEEDK)
C
 100  CONTINUE
C
C     IF(GOPARR.AND.NXT) CALL DDI_DLBRESET
C
C     IF(GOPARR) CALL DDI_GSUMF(1503,X(LOMGD),NATIJ*NATFMO*3)
c     S^a
      CALL DFTB_EXTSDER(X(LPS),L2IJ,1,NATIJ)
C
C     Calculate remaining Hess contributions

      IF (KFG.EQ.0) THEN
      CALL FMO2DER_DSCNT(NATIJ,DA,wrk,wrk1,X(LSIJ),X(LPS),L1IJ,
     *       L2IJ,MAPI,MAPJ,MAP3,L1I,L1J,L1K,NATI,NATJ,NATK,X(LIAGLOB),
     *       X(LOMGD),FCM,IREC0,IFG,JFG,KFG,NOCC,NVIR,NAI,NVIRI,NAJ,
     *       NVIRJ,NAK,NVIRK,YAIJ,YALAG(IPTYA(IFG)),YALAG(IPTYA(JFG)),
     *       YALAG(IPTYA(KFG)),SCAL,INDFRG,X(LIATFRG))
      ELSE
      CALL FMO2DER_DSCNT(NATIJ,DA,wrk,wrk1,X(LSIJ),X(LPS),L1IJ,
     *       L2IJ,MAP3(1,1),MAP3(1,2),MAP3(1,3),L1I,L1J,L1K,NATI,NATJ,
     *       NATK,X(LIAGLOB),X(LOMGD),FCM,IREC0,IFG,JFG,KFG,NOCC,NVIR,
     *       NAI,NVIRI,NAJ,NVIRJ,NAK,NVIRK,YAIJ,YALAG(IPTYA(IFG)),
     *       YALAG(IPTYA(JFG)),YALAG(IPTYA(KFG)),SCAL,INDFRG,X(LIATFRG))
      END IF
C
C
      if(fastvesp) call retfm(needfv)
C     For I
c     call dmtx2(x(lwrk2),x(lwrk1),nai,l1i,l1i,nai)
c     write(6,*) "map check"
c     write(6,'(2I4)') (MAPI(IAO),MAPJ(IAO),IAO=1,L1IJ)
c     DO IXYZ= 1, NAT*3
c       WRITE (6,'(I3,F20.10)') (IO,QD(IO,IXYZ),IO=1,NAT)
c     END DO
      CALL RETFM(NEED)
C
c     NC1  = NATFMO * 3
c     IF(GOPARR) CALL DSCAL(NC1*NC1,1.0D+00/NPROC,FCM,1)
C
      RETURN
      END SUBROUTINE
C
C
C*MODULE FMOHSS  *DECK FMO2DER_GETKPOT
C>    @brief   ESP derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate the derivative of potential due to ESP
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param IMODE     Controls the job
C>    @param NATIJ     Number of atoms for IJK
C>    @param NATL      Number of atoms for LFG
C>    @param WRK1      Working array
C>    @param L1L       Number of basis functions for LFG
C>    @param POPMAT    Mulliken population of each fragment
C>    @param YAL       The solution of alpha orbital relaxation term for entire systems
C>    @param NOCCL     Number of occupied orbitals
C>    @param NVIRL     Number of virtual orbitals
C>    @param IATFRG    Global atom index with NBDFG?
C>    @param FMOC      Coordinate for each atom in the system
C>    @param ISPEFMO   ISPE for each atom in the system
C>    @param QL        Mulliken charges
C>    @param QDL       Mulliken charge derivatives
C>    @param OMGD      Derivative of shift contributions
C>    @param WRK       Working array
C>    @param LFG       Fragment indice in current for the external loop
C>    @param INDFRG    First atom of each fragment in terms of NATFMOB?
C>    @param IAGLOB    Global index of atom
C>    @param PSL       Overlap derivative in AO basis
C>    @param L2L       L1L*(L1L+1)/2
C>    @param L3L       L1L*L1L
C>    @param DQIJ      QIJ - QI - QJ
C>    @param DQIJ2     (QIJ)^2 - (QI)^2 - (QJ)^2
C>    @param QDIJ      dQ/da for IJK
C>    @param QDDQ      delta (delta Q)*QIJ^a
C>    @param GAMH      Some parameters for DFTB2/3 gamma second der.
C>    @param SCAL      Scaling of Hessian contributions
C>    @param LFVESP    Pointer of ...
C>           --- OUTPUT ---
C>    @param FCM       Hessian matrix
      SUBROUTINE FMO2DER_GETKPOT(IMODE,NATIJ,NATL,wrk1,L1L,popmat,
     *       YAL,NOCCL,NVIRL,IATFRG,FMOC,ISPEFMO,QL,QDL,OMGD,wrk,
     *       LFG,INDFRG,IAGLOB,PSL,L2L,L3L,DQIJ,DQIJ2,QDIJ,QDDQ,FCM,
     *       GAMH,SCAL,lfvesp)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      Parameter (MXATM=2000,MXSPE=10)
      Parameter (ONE=1.0D+00,ZERO=0.0D+00,HALF=0.5D+00,TWO=2.0D+00)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FMCOM / X(1)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD

      DIMENSION WRK1(*),popmat(maxnat,*)
      DIMENSION YAL(NOCCL,NVIRL,*),IATFRG(*),FMOC(3,*),ISPEFMO(*)
      DIMENSION QL(*),QDL(NATL,*),OMGD(NATIJ,*)
      DIMENSION WRK(*),INDFRG(*),IAGLOB(*),PSL(L2L,*)
      DIMENSION DQIJ(NATIJ),DQIJ2(NATIJ),QDIJ(NATIJ,*),QDDQ(NATIJ,*)
      DIMENSION FCM(*),GAMH(*)
C     WRK1--> VK : L3*2 + L2 + 1
C     wrk   :  L1 + L2*2 + L3*2 : free space
C
c     write(6,'("GET Q,Q^a,OMEG^a in ",I4," FRG")') LFG
C
      INDI   = INDFRG(LFG)
      IND(1) = 0
      NAT    = NATL
      DO I = 1, NAT
        IAG = IATFRG(INDI+I-1)
        CALL DCOPY(3,FMOC(1,IAG),1,C(1,I),1)
        ISPE(I)  = ISPEFMO(IAG)
        IND(I+1) = IND(I) + MAXANG(ISPE(I))**2
      END DO
C
      CALL VCLR(QDL,1,NAT*NAT*3)
C
      LVORB = 1+L1L*noccl
      LDL   = L3L  +1
      LSL   = L3L*2+1
C     V,D,S,S^a for L fragment
      call dmtx2(wrk1(LDL),wrk1,noccl,l1l,l1l,noccl)
      CALL VCLR(WRK1(LSL),1,L2L)
      CALL DFTB_HAM_OVER(1,NAT,WRK1(LSL),WRK1(LSL),.FALSE.,.TRUE.)
      CALL DFTB_EXTSDER(PSL,L2L,1,NAT)
C
      DO IXYZ=1,NAT*3
C      C(l1,occ)*U(occ,vir)*C(l1,vir)^T
       CALL DGEMM('N','N',L1L,NVIRL,NOCCL,ONE,WRK1,L1L,
     *             YAL(1,1,ixyz),noccl,ZERO,WRK,L1L)
       CALL DGEMM('N','T',L1L,L1L,NVIRL,ONE,WRK,L1L,WRK1(LVORB),L1L,
     *             ZERO,WRK(L3L+1),L1L)
       CALL SQ2TRI(L1L,L1L,WRK(L3L+1),WRK,TWO)
C      --- CALCULATE D*S*D LATER
C      CALL CPYTSQ(wrk1(LDL),WRK(l2l*2+1),L1L,1)
C      CALL TFTRI(WRK(L2L+1),PSL(1,IXYZ),WRK(l2L*2+1),WRK(l2L*2+L3L+1),
C    *      l1l,l1l,l1l)
C      call daxpy(L2L,-half,WRK(L2L+1),1,WRK,1)
C      GET Mulliken
       CALL DFTB_MULLIKEN(L1L,L2L,WRK,WRK1(LSL),WRK(L2L+1))
       CALL DFTB_MULLIKEN(L1L,L2L,WRK1(LDL),PSL(1,IXYZ),WRK(L2L+L1L+1))
C      call daxpy(L1L,ONE,WRK(L2L+L1L+1),1,WRK(L2L+1),1)
       CALL VADD(WRK(L2L+L1L+1),1,WRK(L2L+1),1,WRK(L2L+1),1,L1L)
C      from L1 to NATL
       DO NC = 1, NATL
         VAL = ZERO
         DO L = 1, IND(NC+1) - IND(NC)
           MU  = IND(NC)+L
           VAL = VAL + WRK(L2L+MU)
         END DO
         QDL(NC,IXYZ) = QDL(NC,IXYZ) + VAL
       END DO
      END DO
C
      CALL CPYTSQ(WRK1(LSL),WRK(L3L    +1),L1L,1)
      CALL CPYTSQ(WRK1(LDL),WRK(L3L+L3L+1),L1L,1)
      !! SD
      CALL MRARBR(WRK(L3L+1),L1L,L1L,L1L,WRK(L3L+L3L+1),L1L,L1L,
     *            WRK,L1L)
C
      DO NC = 1, NATL
        !! WRK = (DS)
        NNN = IND(NC+1)-IND(NC)
        !! partial D*(SD)
        CALL MRARBR(WRK(L3L+L3L+1+L1L*IND(NC)),L1L,L1L,NNN,
     *              WRK(1+IND(NC)),L1L,L1L,
     *              WRK(L3L+1),L1L)
        CALL SQ2TRI(L1L,L1L,WRK(L3L+1),WRK1,HALF)
        DO IXYZ=1,NAT*3
          QDL(NC,IXYZ) = QDL(NC,IXYZ)
     *      - DDOT(L2L,PSL(1,IXYZ),1,WRK1,1)
        END DO
      END DO
C     Check
c     write(6,'("www Q^a",I4)') LFG
c     call prsq(qdl,nat*3,nat,nat)
C     Recover IJ info
      NAT = NATIJ
      DO I = 1, NAT
        IAG = IAGLOB(I)
        CALL DCOPY(3,FMOC(1,IAG),1,C(1,I),1)
        ISPE(I)  = ISPEFMO(IAG)
        IND(I+1) = IND(I) + MAXANG(ISPE(I))**2
      END DO
C
      IF(IMODE.EQ.0) RETURN
C     GET KFRG info and QL
      JJ   = INDI
      DO I = 1, NATL
        IAG = IATFRG(INDI+I-1)
        CALL DCOPY(3,FMOC(1,IAG),1,C(1,I+NAT),1)
        ISPE(I+NAT)   = ISPEFMO(IAG)
        IND(NAT+I+1)  = IND(NAT+I) + MAXANG(ISPE(I+NAT))**2
        IAGLOB(NAT+I) = IAG
C       Charge
        QL(I) = POPMAT(I,LFG) - X(LZREF+JJ-1)
        JJ    = JJ + 1
      END DO
      NAT     = NAT + NATL
C     Check
c     write(6,'("www Q")')
c     call prsq(QL,natl,1,1)
C     GET OMGD
      CALL FMO2DER_DOMEGK(OMGD,NATIJ,NATL,qdl,ql,X(LGAMMA),
     *                    DQIJ,DQIJ2,QDIJ,QDDQ,FCM,GAMH,IAGLOB,lfvesp,
     *                    X(LGAMMA3),SCAL)

      NAT     = NATIJ

      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK FMO2DER_DOMEGK
C>    @brief   ESP derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate Hessian contributions due to ESP
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param OMGD      Derivative of Coulomb interaction
C>    @param NATIJ     Number of atoms for IJK
C>    @param NATL      Number of atoms for LFG
C>    @param QDL       Mulliken charge derivative of LFG
C>    @param QL        Mulliken charge of LFG
C>    @param GAMMA     Some parameters for DFTB2 gamma
C>    @param DQIJ      QIJ - QI - QJ
C>    @param DQIJ2     (QIJ)^2 - (QI)^2 - (QJ)^2
C>    @param QDIJ      dQ/da for IJK
C>    @param QDDQ      delta (delta Q)*QIJ^a
C>    @param GAMH      Some parameters for DFTB2/3 gamma second der.
C>    @param IAGLOB    Global index of atom
C>    @param LFVESP    Pointer of ...
C>    @param GAMMA3    Some parameters for DFTB3 gamma
C>    @param SCAL      Scaling of Hessian contributions
C>           --- OUTPUT ---
C>    @param FCM       Hessian matrix
      SUBROUTINE FMO2DER_DOMEGK(OMGD,NATIJ,NATL,qdl,ql,GAMMA,
     *           DQIJ,DQIJ2,QDIJ,QDDQ,FCM,GAMH,IAGLOB,lfvesp,GAMMA3,
     *           SCAL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

C
      PARAMETER (MXATM=2000,MXSPE=10)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
      Parameter (ONETHIRD=1.0D+00/3.0D+00)
C
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      LOGICAL SKPLAT,SKPIAT
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FMCOM / X(1)

C
      DIMENSION OMGD(NATIJ,*), QDL(NATL,*),QL(NATL)
      DIMENSION GAMMA(12,NSPE,NSPE)
c     DIMENSION GAMMAD(10,NSPE,NSPE)
      DIMENSION DQIJ(NATIJ),DQIJ2(NATIJ),QDIJ(NATIJ,*),FCM(natfmo*3,*)
      DIMENSION GAMH(*),IAGLOB(*),GAMMA3(10,NSPE,NSPE),QDDQ(NATIJ,*)
C
      DO 200 LAT=1,NATL
c       IF (QL(LAT).EQ.ZERO) GOTO 200
        JSP = ISPE(NATIJ+LAT)
        LGZ = (IAGLOB(LAT+NATIJ)-1)*3
C       for covalent bond
        icind   = lfvesp+(IAGLOB(LAT+NATIJ)-1)*6
        fracespi= x(icind+1)
        SKPLAT  = .false.
        if(fracespi.ne.one.and.fracespi.ne.zero) SKPLAT=.true.
c       IF(SKPLAT) GO TO 200
C
        DO 100 IAT =1,NATIJ
          ISP   = ISPE(IAT)
          IGZ   = (IAGLOB(IAT)-1)*3
C         for covalent bond
          icind   = lfvesp+(IAGLOB(IAT)-1)*6
          fracespi= x(icind+1)
          SKPIAT  = .false.
          if(fracespi.ne.one.and.fracespi.ne.zero) SKPIAT=.true.
c         IF(SKPIAT) GO TO 100
C
C
          DIST2 = (C(1,IAT) - C(1,NATIJ+LAT))**2
     *          + (C(2,IAT) - C(2,NATIJ+LAT))**2
     *          + (C(3,IAT) - C(3,NATIJ+LAT))**2
          DIST  = SQRT(DIST2)
C         DIST3 = DIST2*DIST
          DISTI = ONE/DIST
          DIST2I = DISTI*DISTI
          DIST3I = DIST2I*DISTI
c         IF (DIST.LT.SMALL) GOTO 100
          GAMMAV0= DFTB_GAM2(DIST,DISTI,GAMMA(1,ISP,JSP),DAMPXH,
     *                       DAMPXHE,SPE(ISP),SPE(JSP))
c         GAMMAV1= GAMD_FMO2(DIST,GAMMAD(1,ISP,JSP),DAMPXH,
c    *                       DAMPXHE,SPE(ISP),SPE(JSP))
          IF(DIST.NE.ZERO) THEN
           CALL GAMH_FMO2(GAMMAV1,GAMMAV2,GRD3I,HSS3I,GRD3J,HSS3J,
     *         DIST,NATIJ+LAT, IAT,GAMH)
c         write(6,'("CHK=",2F12.8)') GAMMAV1,GAMTMP
          GAMTMP1 = GAMMAV1
          GAMTMP2 = GAMMAV2
          IF(DFTB3) THEN
C           GAMTMP1=GAMTMP1 +(GRD3I*DQIJ(IAT) + GRD3J*QL(LAT))*ONETHIRD
C           GAMTMP2=GAMTMP2 +(HSS3I*DQIJ(IAT) + HSS3J*QL(LAT))*ONETHIRD
            GAMTMP1=GAMTMP1 + GRD3J*QL(LAT)*ONETHIRD
            GAMTMP2=GAMTMP2 + HSS3J*QL(LAT)*ONETHIRD
            GAMTMP3=          GRD3I*ONETHIRD
            GAMTMP4=          HSS3I*ONETHIRD
          END IF
C         GET ddg/dadb*ql*dqIJ
          if(.not.skpiat.or..not.skplat) then
           DO KI=1,3
             VALI  =  C(KI,IAT)-C(KI,LAT+NATIJ)
             DO KJ=1,3
              VALJ  =  C(KJ,IAT)-C(KJ,LAT+NATIJ)
              VAL   =  VALI*VALJ*GAMTMP2*DIST2I !!/DIST2
     *              -  VALI*VALJ*GAMTMP1*DIST3I !!/DIST3
              IF(KI.EQ.KJ) VAL = VAL + GAMTMP1*DISTI !!/DIST
              VAL   =  VAL*DQIJ(IAT)*QL(LAT)*SCAL
              IF (DFTB3) THEN
                VAL = VAL + DQIJ2(IAT)*QL(LAT)*SCAL*VALI*VALJ*
     *                   (GAMTMP4*DIST2I - GAMTMP3*DIST3I)
                 IF (KI.EQ.KJ) VAL = VAL
     *             + GAMTMP3*DISTI*DQIJ2(IAT)*QL(LAT)*SCAL
              END IF
C             IAT*KI,IAT*KJ
              if(.not.skpiat)
     *        FCM(IGZ+KI,IGZ+KJ)=FCM(IGZ+KI,IGZ+KJ)+VAL
c             LAT*KI,LAT*KJ
              if(.not.skplat)
     *        FCM(LGZ+KI,LGZ+KJ)=FCM(LGZ+KI,LGZ+KJ)+VAL
c             IAT*KI,LAT*KJ
              if(.not.skplat.and..not.skpiat) then
               FCM(IGZ+KI,LGZ+KJ)=FCM(IGZ+KI,LGZ+KJ)-VAL
c             LAT*KI,IAT*KJ
               FCM(LGZ+KI,IGZ+KJ)=FCM(LGZ+KI,IGZ+KJ)-VAL
              end if
             END DO
           END DO
          end if
C          GET dg/dr*ql
           DO KI=1,3
            VALIJ  =  C(KI,IAT)-C(KI,LAT+NATIJ)
C
            VALTMPI =  ZERO
            VALTMPJ =  ZERO
            VALTMP  =  ZERO
            IF(DFTB3) THEN
             VALTMPI=(GRD3I*DQIJ(IAT)*TWO+GRD3J*QL(LAT))*QL(LAT)
C            VALTMPJ=(GRD3J*QL(LAT)*TWO+GRD3I*DQIJ(IAT))*DQIJ(IAT)
             VALTMPJ= GRD3J*QL(LAT)*TWO*DQIJ(IAT) + GRD3I*DQIJ2(IAT)
C            VALTMPI=VALTMPI*VALIJ*ONETHIRD/
             VALTMPI=VALTMPI*VALIJ*ONETHIRD*DISTI
             VALTMPJ=VALTMPJ*VALIJ*ONETHIRD*DISTI !!/DIST
C
             VALTMP =GRD3I*TWO*QL(LAT) * VALIJ*ONETHIRD*DISTI
            END IF
C
C
C           VALL   =  DQIJ(IAT)*GAMMAV1*VALIJ/DIST + VALTMPJ
C           VALIJ  =  QL(LAT)*GAMMAV1*VALIJ/DIST   + VALTMPI
            VALL   =  DQIJ(IAT)*GAMMAV1*VALIJ*DISTI + VALTMPJ
            VALIJ  =  QL(LAT)*GAMMAV1*VALIJ*DISTI   + VALTMPI
c           SHIFT(NI) = SHIFT(NI) + VAL
C           Indice for Hess
            lgixyz  =  IGZ  + KI
            lglxyz  =  LGZ  + KI
C
            OMGD(IAT,lgixyz)= OMGD(IAT,lgixyz) + VALIJ
            OMGD(IAT,lglxyz)= OMGD(IAT,lglxyz) - VALIJ
            IF (DFTB3) THEN
              VALIJ = VALIJ - VALTMP*DQIJ(IAT)
              VALTMP= VALTMP*SCAL
            END IF
C           dg/da*ql*QDIJ^b
            if(.not.skpiat.and..not.skplat) then
             VALIJ = VALIJ*SCAL
             VALL  = VALL *SCAL
             do 10 itmp=1,natij
              igtmp   = iaglob(itmp)
              icind   = lfvesp+(igtmp-1)*6
              fracespi= x(icind+1)
              if(fracespi.ne.one.and.fracespi.ne.zero) go to 10
                ifxyz = (itmp -1)*3
                igxyz = (igtmp-1)*3
                VALIJ1= VALIJ*QDIJ(IAT,ifxyz+1)
                VALIJ2= VALIJ*QDIJ(IAT,ifxyz+2)
                VALIJ3= VALIJ*QDIJ(IAT,ifxyz+3)
                IF (DFTB3) THEN
                  VALIJ1= VALIJ1+VALTMP*QDDQ(IAT,IFXYZ+1)
                  VALIJ2= VALIJ2+VALTMP*QDDQ(IAT,IFXYZ+2)
                  VALIJ3= VALIJ3+VALTMP*QDDQ(IAT,IFXYZ+3)
                END IF
                FCM(igxyz+1,lglxyz)=FCM(igxyz+1,lglxyz)-VALIJ1
                FCM(igxyz+2,lglxyz)=FCM(igxyz+2,lglxyz)-VALIJ2
                FCM(igxyz+3,lglxyz)=FCM(igxyz+3,lglxyz)-VALIJ3
                FCM(igxyz+1,lgixyz)=FCM(igxyz+1,lgixyz)+VALIJ1
                FCM(igxyz+2,lgixyz)=FCM(igxyz+2,lgixyz)+VALIJ2
                FCM(igxyz+3,lgixyz)=FCM(igxyz+3,lgixyz)+VALIJ3
 10          continue
C
C            dg/da*QDL^b*DQIJ
C            dg/db*QDL^a*DQIJ
             do 20 itmp=1,natl
               igtmp=iaglob(itmp+natij)
               icind   = lfvesp+(igtmp-1)*6
               fracespi= x(icind+1)
               if(fracespi.ne.one.and.fracespi.ne.zero) go to 20
C
                 ifxyz = (itmp -1)*3
                 igxyz = (igtmp-1)*3
                 VALIJ1 = VALL*QDL(LAT,ifxyz+1)*TWO
                 VALIJ2 = VALL*QDL(LAT,ifxyz+2)*TWO
                 VALIJ3 = VALL*QDL(LAT,ifxyz+3)*TWO
                 !! Let symmetrization work
                 FCM(igxyz+1,lgixyz)=FCM(igxyz+1,lgixyz)+VALIJ1
                 FCM(igxyz+2,lgixyz)=FCM(igxyz+2,lgixyz)+VALIJ2
                 FCM(igxyz+3,lgixyz)=FCM(igxyz+3,lgixyz)+VALIJ3
                 FCM(igxyz+1,lglxyz)=FCM(igxyz+1,lglxyz)-VALIJ1
                 FCM(igxyz+2,lglxyz)=FCM(igxyz+2,lglxyz)-VALIJ2
                 FCM(igxyz+3,lglxyz)=FCM(igxyz+3,lglxyz)-VALIJ3
 20          continue
            end if
           END DO
          END IF
C
          IF (DFTB3) THEN
c           write(6,'("GAMI=",2I4,F10.7)')  ISP,JSP,DIST
            CALL DFTB_GAM3(DIST,DISTI,GAMI,GAMJ,HUBB(ISP),HUBB(JSP),
     *      GAMMA3(1,ISP,JSP),GAMMA3(1,JSP,ISP),DAMPXH,DAMPXHE,
     *      SPE(ISP),SPE(JSP))
c           write(6,*) "GAMI=",GAMI,HUBDER(ISP)
            GAMI = GAMI * HUBDER(ISP)
            GAMJ = GAMJ * HUBDER(JSP)
c
            GAMTMPIJ= ONETHIRD*TWO*(GAMI*DQIJ(IAT)+GAMJ*QL(LAT))
            GAMTMPKK= ONETHIRD*TWO* GAMJ*DQIJ(IAT)
            GAMTMPKK= GAMTMPKK*SCAL
            GAMTMP  = ONETHIRD*TWO*GAMI
          END IF
C
          IF(DFTB3) THEN
           do itmp=1,natij
            igtmp=iaglob(itmp)
            do ixyz=1,3
             ifxyz = (itmp -1)*3+ixyz
             igxyz = (igtmp-1)*3+ixyz
             OMGD(IAT,igxyz)=OMGD(IAT,igxyz)
     *                     + ONETHIRD*TWO*QDIJ(IAT,ifxyz)*GAMI*QL(LAT)
            end do
           end do
          END IF
C         GET g*d ql/ dr
          DO 30 LAT2=1,NATL
           lgtmp=iaglob(lat2+natij)
           icind   = lfvesp+(lgtmp-1)*6
           fracespi= x(icind+1)
C
           DO JXYZ=1,3
             LXYZ            = (LAT2 -1) * 3 + JXYZ
             LGXYZ           = (lgtmp-1) * 3 + JXYZ
c            IXYZ            = NATIJ*3        + LXYZ
             OMGD(IAT,LGXYZ) = OMGD(IAT,LGXYZ) +QDL(LAT,LXYZ)*GAMMAV0
             IF(DFTB3) OMGD(IAT,LGXYZ)=
     *                 OMGD(IAT,LGXYZ)+QDL(LAT,LXYZ)*GAMTMPIJ
C            g*dql^a*QDIJ^b
             if(fracespi.ne.one.and.fracespi.ne.zero) go to 30
C
             TMP1 = QDL(LAT,LXYZ)*GAMMAV0
             TMP2 = ZERO
             IF (DFTB3) THEN
               TMP1 = TMP1 + QDL(LAT,LXYZ)*(GAMTMPIJ-GAMTMP*DQIJ(IAT))
               TMP2 = GAMTMP*QDL(LAT,LXYZ)*SCAL
             END IF
             TMP1 = TMP1*SCAL
             do 40 itmp=1,natij
               igtmp=iaglob(itmp)
C
               icind   = lfvesp+(igtmp-1)*6
               fracespi= x(icind+1)
               if(fracespi.ne.one.and.fracespi.ne.zero) go to 40
                FCM((igtmp-1)*3+1,LGXYZ)=FCM((igtmp-1)*3+1,LGXYZ)
     *            + TMP1*QDIJ(IAT,(itmp-1)*3+1)
                FCM((igtmp-1)*3+2,LGXYZ)=FCM((igtmp-1)*3+2,LGXYZ)
     *            + TMP1*QDIJ(IAT,(itmp-1)*3+2)
                FCM((igtmp-1)*3+3,LGXYZ)=FCM((igtmp-1)*3+3,LGXYZ)
     *            + TMP1*QDIJ(IAT,(itmp-1)*3+3)
                IF (DFTB3) THEN
                  FCM((igtmp-1)*3+1,LGXYZ)=FCM((igtmp-1)*3+1,LGXYZ)
     *              + TMP2*QDDQ(IAT,(ITMP-1)*3+1)
                  FCM((igtmp-1)*3+2,LGXYZ)=FCM((igtmp-1)*3+2,LGXYZ)
     *              + TMP2*QDDQ(IAT,(ITMP-1)*3+2)
                  FCM((igtmp-1)*3+3,LGXYZ)=FCM((igtmp-1)*3+3,LGXYZ)
     *              + TMP2*QDDQ(IAT,(ITMP-1)*3+3)
                END IF
c               NO b<-->a contributions
 40          continue
             if(dftb3) then
              DO 45 LAT3=1,NATL
               igtmp   =iaglob(lat3+natij)
               icind   =lfvesp+(igtmp-1)*6
               fracespi= x(icind+1)
               if(fracespi.ne.one.and.fracespi.ne.zero) go to 45
               DO KXYZ=1,3
                IGXYZ = (IGTMP-1) * 3 + KXYZ
                LXYZ2 = (LAT3 -1) * 3 + KXYZ
                VAL   = QDL(LAT,LXYZ)*GAMTMPKK*QDL(LAT,LXYZ2)
                FCM(LGXYZ,igxyz)=FCM(LGXYZ,igxyz)+VAL
               END DO
 45           CONTINUE
             end if
           END DO
 30       CONTINUE
C
C
 100    CONTINUE
 200  CONTINUE
C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK getdqijpot
C>    @brief   ESP derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate Q(IJ)-Q(I)-Q(J) etc.
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param IFG       Fragment indice in current for monomer
C>    @param JFG       Fragment indice in current for dimer
C>    @param KFG       Fragment indice in current for trimer
C>    @param NATIJ     Number of atoms for IJK
C>    @param QDI       dQ/da for I
C>    @param NATI      Number of atoms for I
C>    @param QDJ       dQ/da for  J
C>    @param NATJ      Number of atoms for  J
C>    @param QDK       dQ/da for   K
C>    @param NATK      Number of atoms for   K
C>    @param INDAT     Converts global atomic location to fragment index
C>    @param IAGLOB    Global index of atom
C>    @param IALOC     Converts global to local (fragment) atomic location
C>    @param INDAT     Converts global atomic location to fragment index
C>           --- OUTPUT ---
C>    @param QDIJ      dQ/da for IJK
      SUBROUTINE getdqijpot(IFG,JFG,KFG,QDIJ,NATIJ,QDI,NATI,QDJ,NATJ,
     *      QDK,NATK,indat,iaglob,ialoc,indbd)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=2000)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *               maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      dimension QDIJ(NATIJ,*),QDI(NATI,*),QDJ(NATJ,*),QDK(NATK,*)
      dimension indat(*),iaglob(*),ialoc(*),indbd(maxabd,*)
C
c
      do iat=1,nat
        iatg=iaglob(iat)
        iatfg=indat(iatg)
        iatloc=iand(ialoc(iatg),65535)
c
C       if(iatfg.eq.ifg.or.iatfg.eq.jfg) then
        if(iatfg.eq.ifg.or.iatfg.eq.jfg.or.iatfg.eq.kfg) then
          do jat=1,nat
           jatg  = iaglob(jat)
           jatfg = indat(jatg)
           jatloc= iand(ialoc(jatg),65535)
           if(iatfg.eq.jatfg) then
            if(iatfg.eq.ifg) then
             do ixyz=1,3
              iixyz = (jat-1)*3    + ixyz
              jjxyz = (jatloc-1)*3 + ixyz
              qdij(iat,iixyz)=qdij(iat,iixyz)-qdi(iatloc,jjxyz)
             end do
            else if (iatfg.eq.jfg) then
             do ixyz=1,3
              iixyz = (jat-1)*3    + ixyz
              jjxyz = (jatloc-1)*3 + ixyz
              qdij(iat,iixyz)=qdij(iat,iixyz)-qdj(iatloc,jjxyz)
             end do
            else if (iatfg.eq.kfg) then
             do ixyz=1,3
              iixyz = (jat-1)*3    + ixyz
              jjxyz = (jatloc-1)*3 + ixyz
              qdij(iat,iixyz)=qdij(iat,iixyz)-qdk(iatloc,jjxyz)
             end do
            end if
           end if
          end do
        endif
c
c       Find all secondary fragments connected to I' involving atom iat,
c       and subtract now Z(J') for atom IAT that also belongs to fragment J'.
c
        if(nbdfg.ne.0) then
          do iabd=1,maxabd
            ibdfg=indbd(iabd,iatg)
            if(ibdfg.eq.0) goto 100
            jatfg=ishft(ialoc(natfmo+ibdfg),-16)
            jatloc=iand(ialoc(natfmo+ibdfg),65535)
C           if((jatfg.eq.ifg.or.jatfg.eq.jfg).and.jatfg.ne.iatfg) then
            if((jatfg.eq.ifg.or.jatfg.eq.jfg.or.jatfg.eq.kfg)
     *         .and.jatfg.ne.iatfg) then
CXXX        Dose it work for connected system?
C           Check later
             do kat=1,nat
              katg  = iaglob(kat)
              katfg = indat(katg)
              katloc= iand(ialoc(katg),65535)
c             ctij(iat)=ctij(iat)-popmat(jatloc,jatfg)
              if(katfg.eq.jatfg) then
               if(katfg.eq.ifg) then
                do ixyz=1,3
                 iixyz = (kat-1)*3    + ixyz
                 jjxyz = (katloc-1)*3 + ixyz
                 qdij(iat,iixyz)=qdij(iat,iixyz)-qdi(jatloc,jjxyz)
                end do
               else if (katfg.eq.jfg) then
                do ixyz=1,3
                 iixyz = (kat-1)*3    + ixyz
                 jjxyz = (katloc-1)*3 + ixyz
                 qdij(iat,iixyz)=qdij(iat,iixyz)-qdj(jatloc,jjxyz)
                end do
               else if (katfg.eq.kfg) then
                do ixyz=1,3
                 iixyz = (kat-1)*3    + ixyz
                 jjxyz = (katloc-1)*3 + ixyz
                 qdij(iat,iixyz)=qdij(iat,iixyz)-qdk(jatloc,jjxyz)
                end do
               end if
              end if
             end do
            endif
          enddo
  100     continue
        endif
c       write(6,*) 'mul ij=',iat,ctij(iat)
      enddo
C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK GAMH_FMO2
C>    @brief   ESP derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate second derivatives of gamma for DFTB2 and DFTB3
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param DIST      Inter-atomic distance matrix
C>    @param IAT       Number of atoms in fragment I
C>    @param JAT       Number of atoms in fragment J
C>    @param GSMMAH    Some parameters for DFTB2/3 gamma second der.
C>           --- OUTPUT ---
C>    @param GRAD2     d (gamma)/dR  (DFTB2)
C>    @param GRAD2     d2(gamma)/dR2 (DFTB2)
C>    @param GRAD3     d (gamma)/dR  (DFTB3)
C>    @param GRAD3     d2(gamma)/dR2 (DFTB3)
C>    @param GRAD4     d (gamma)/dR  (DFTB3 opposite atom species)
C>    @param GRAD4     d2(gamma)/dR2 (DFTB3 opposite atom species)
      SUBROUTINE GAMH_FMO2(GRAD2,HESS2,GRAD3,HESS3,GRAD4,HESS4,DIST,
     *           IAT,JAT,GSMMAH)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXSPE=10)
C
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
C
      DIMENSION  GSMMAH(11,NSPE,NSPE)
      LOGICAL    HDAMP
      DOUBLE PRECISION H/8HH       /
C
C     for IAT
      NSP1      = ISPE(IAT)
      HUBI      = HUBBL(1,NSP1)
      CHARA1    = SPE(ISPE(IAT))
      HUBDERTMP = HUBDER(NSP1)
C     for JAT
      NSP2      = ISPE(JAT)
      HUBJ      = HUBBL(1,NSP2)
      CHARA2    = SPE(ISPE(JAT))
      IF (DAMPXH.AND.(CHARA1.EQ.H.OR.CHARA2.EQ.H)) THEN
        HDAMP = .TRUE.
      ELSE
        HDAMP = .FALSE.
      END IF
      CALL DFTB_GAMHESSF(GRAD2,HESS2,GRAD3,HESS3,HUBI,HUBJ,HUBDERTMP,
     *  DIST,DAMPXHE,GSMMAH(1,NSP1,NSP2),DFTB3,HDAMP)
C
      IF (DFTB3) THEN
        HUBDERTMP = HUBDER(NSP2)
        CALL DFTB_GAMHESSF(GRAD2,HESS2,GRAD4,HESS4,HUBJ,HUBI,HUBDERTMP,
     *    DIST,DAMPXHE,GSMMAH(1,NSP2,NSP1),DFTB3,HDAMP)
      END IF
C     E (*,'(I3,X,I3,X,F12.6,X,F12.6)')
C    *J,GRAD2(NSEQ),HESS2(NSEQ)
C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK FMO2DER_GETGMH
C>    @brief   ESP derivatives for FMO-DFTB Hessian
C>
C>    @details Prepare some parameters for gamma second derivative
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NSPE      Number of species in the system
C>           --- OUTPUT ---
C>    @param GAMH      Some parameters for DFTB2/3 gamma second der.
      SUBROUTINE FMO2DER_GETGMH(GAMH,NSPE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION  GAMH(11,NSPE,NSPE)
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      PARAMETER (MXSPE=10)
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
C
      CALL VCLR(GAMH,1,11*NSPE*NSPE)
      DO I = 1, NSPE
        HUBI  = HUBBL(1,I)
        DO J = 1, NSPE
          HUBJ = HUBBL(1,J)
          CALL DFTB_PREP_GAMMA_HESS(HUBI,HUBJ,GAMH(1,I,J),DFTB3,DAMPXH)
c         WRITE (6,'("IJPAIR=",2I4)') I,J
c         write (6,'(x,f20.10)') GAMH(1,i,j)
c         write (6,'(x,f20.10)') GAMH(2,i,j)
c         write (6,'(x,f20.10)') GAMH(3,i,j)
c         write (6,'(x,f20.10)') GAMH(4,i,j)
c         write (6,'(x,f20.10)') GAMH(5,i,j)
c         write (6,'(x,f20.10)') GAMH(6,i,j)
c         write (6,'(x,f20.10)') GAMH(7,i,j)
c         write (6,'(x,f20.10)') GAMH(8,i,j)
c         write (6,'(x,f20.10)') GAMH(9,i,j)
c         write (6,'(x,f20.10)') GAMH(10,i,j)
c         write (6,'(x,f20.10)') GAMH(11,i,j)
        END DO
      END DO
C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK FMO2DER_DSCNT
C>    @brief   ESP derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate Hessian contributions of ESP
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NATIJ     Number of atoms for fragment IJK
C>    @param DA        Density matrix
C>    @param WRK       Working array
C>    @param WRK1      Working array
C>    @param SIJ       Overlap matrix in AO basis
C>    @param PS        Derivative of overlap matrix in AO basis
C>    @param L1IJ      Number of basis functions for IJK
C>    @param L2IJ      L1IJ*(L1IJ+1)/2
C>    @param MAPI      Mapping information for framgnet I
C>    @param MAPJ      Mapping information for framgnet  J
C>    @param MAP3      Mapping information for framgnet   K
C>    @param L1I       Number of basis functions for I
C>    @param L1J       Number of basis functions for  J
C>    @param L1K       Number of basis functions for   K
C>    @param NATI      Number of atoms for fragment I
C>    @param NATJ      Number of atoms for fragment  J
C>    @param NATK      Number of atoms for fragment   K
C>    @param IAGLOB    Global label for atom
C>    @param OMGD      Derivative of shift contributions
C>    @param IREC0     Record number to read orbital in the fragments
C>    @param IFG       Fragment indice in current for monomer
C>    @param JFG       Fragment indice in current for dimer
C>    @param KFG       Fragment indice in current for trimer
C>    @param NOCC      Number of occupied orbitals
C>    @param NVIR      Number of virtual orbitals
C>    @param NAI       Number of electrons for fragment I
C>    @param NVIRI     Number of virtual orbitals for fragment I
C>    @param NAJ       Number of electrons for fragment J
C>    @param NVIRJ     Number of virtual orbitals for fragment J
C>    @param NAK       Number of electrons for fragment K
C>    @param NVIRK     Number of virtual orbitals for fragment K
C>    @param YAIJ      U_{mi}^a for fragment IJK
C>    @param YAI       U_{mi}^a for fragment I
C>    @param YAJ       U_{mi}^a for fragment  J
C>    @param YAK       U_{mi}^a for fragment   K
C>    @param SCAL      Scaling of Hessian contributions
C>    @param INDFRG    First atom of each fragment in terms of NATFMOB?
C>    @param IATFRG    Global atom index with NBDFG?
C>           --- OUTPUT ---
C>    @param FCM       Hessian matrix
      SUBROUTINE  FMO2DER_DSCNT(NATIJ,DA,wrk,wrk1,SIJ,PS,L1IJ,L2IJ,
     *       MAPI,MAPJ,MAPK,L1I,L1J,L1K,NATI,NATJ,NATK,IAGLOB,OMGD,FCM,
     *       IREC0,IFG,JFG,KFG,NOCC,NVIR,NAI,NVIRI,NAJ,NVIRJ,NAK,NVIRK,
     *       YAIJ,YAI,YAJ,YAK,SCAL,INDFRG,IATFRG)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL  ISINI
C
      Parameter (MXATM=2000,MXSPE=10)
      Parameter (ONE=1.0D+00,HALF=0.5D+00,ZERO=0.0D+00,TWO=2.0D+00)
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /FMCOM / X(1)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL GOPARR,DSKWRK,MASWRK
C

      DIMENSION DA(*),WRK(*),WRK1(*),SIJ(*),PS(L2IJ,*)
      DIMENSION MAPI(*),MAPJ(*),MAPK(*),IAGLOB(*)
      DIMENSION OMGD(NATIJ,*),FCM(natfmo*3,*)
      DIMENSION YAIJ(NOCC,NVIR,*),YAI(NAI,NVIRI,*),YAJ(NAJ,NVIRJ,*),
     *          YAK(NAK,NVIRK,*)
      DIMENSION INDFRG(*),IATFRG(*)

C     wrk   :  L1 + L2*2 + L3*2
C     wrk1  :  l1 + L2   + L3*2
      L3IJ = L1IJ * L1IJ
      L2I  = (L1I * L1I + L1I)/2
      L3I  =  L1I * L1I
      L2J  = (L1J * L1J + L1J)/2
      L3J  =  L1J * L1J
C
      LDI  = L2IJ + 1
      LDJ  = L2IJ + L2I + 1
C
      L2K  = 0
      L3K  = 0
      LDK  = LDJ
      IF (KFG.NE.0) THEN
        L2K  = (L1K * L1K + L1K)/2
        L3K  =  L1K * L1K
        LDK  = L2IJ + L2I + L2J + 1
      END IF
C
      CALL VALFM(LOADFM)
      LWRK = LOADFM + 1
      LWRKI= LWRK   + L3IJ
      LWRKJ= LWRKI  + L3IJ
      LSHFT= LWRKJ  + L3IJ
      LCHM = LSHFT  + NATIJ
      LAST = LCHM   + NATIJ
      IF(DFTB3) THEN
        LSHIFT3=LAST
        LAST   =LSHIFT3 + NATIJ*2
      END IF
      IF (KFG.NE.0) THEN
        LWRKK  = LAST
        LAST   = LWRKK + L3IJ
      END IF
c
      NEED = LAST   - LOADFM    - 1
      CALL GETFM(NEED)
C
      CALL DAREAD(IDAF,IODA,X(LSHFT),NATIJ,566,0)
C
      CALL DAREAD(IDAF,IODA,X(LCHM),NATIJ,556,0)
      do iii=1,natij
         X(LCHM-1+iii)=X(LCHM-1+iii) - zref(iii)
      end do
c     write(6,'("wwwchk=",F12.8)') (X(LCHM-1+iii),iii=1,natij)
      if(DFTB3) THEN
        CALL DAREAD(IDAF,IODA,X(LSHIFT3),NATIJ*2,567,0)
        CALL DFTB_3RD_SHIFT_FMO(X(LSHFT),X(LCHM),X(LSHIFT3),NATIJ)
      END IF
C     IJ DEN
      CALL DAREAD(IDAF,IODA,da(l2ij+1),l3ij,15,0)
      call dmtx2(wrk1,da(l2ij+1),nocc,l1ij,l1ij,nocc)
C     I  DEN
      IDMREC0K = IFG + IREC0
      CALL RAREADS(IDAFMO,X(LIODFMO),WRK,l3i,IDMREC0K,0)
      call dmtx2(wrk1(LDI),wrk,nai,l1i,l1i,nai)
C     J  DEN
      IDMREC0K = JFG + IREC0
      CALL RAREADS(IDAFMO,X(LIODFMO),WRK,l3J,IDMREC0K,0)
      call dmtx2(wrk1(LDJ),wrk,naj,l1j,l1j,naj)
C     K  DEN
      IF (KFG.NE.0) THEN
        IDMREC0K = KFG + IREC0
        CALL RAREADS(IDAFMO,X(LIODFMO),WRK,L3K,IDMREC0K,0)
        call dmtx2(wrk1(LDK),wrk,nak,l1k,l1k,nak)
      END IF
C
      IF (SCAL.NE.ONE) CALL DSCAL(L2IJ,SCAL,DA,1)
C
C     For IJ fragment
C     d omega/db
      !! DA = D(IJ)-D(I)-D(J)
      DO JAT = 1, NATIJ
        JAZ = (IAGLOB(JAT)-1)*3
        DO JXYZ= 1, 3
          JIXYZ = (JAT-1)*3 + JXYZ
          JZXYZ = JAZ       + JXYZ
          CALL DCOPY(L2IJ,PS(1,JIXYZ),1,WRK(L2IJ*2+1),1)
C         SIJ*OMEGA_AB^b  -->    D*SIJ*OMEG*D
C         GET  SIJ*V*SIJ - SI*V*SI - SJ*V*SJ
          CALL FMO2DER_DVPOT(WRK(L2IJ*2+1),L1IJ,WRK1,L2IJ,WRK1(LDI),L1I,
     *         WRK1(LDJ),L1J,WRK1(LDK),L1K,X(LWRK),X(LWRKI),X(LWRKJ),
     *         X(LWRKK),WRK,MAPI,MAPJ,MAPK,KFG.NE.0)
C
C         Smn*Wmn = (SW)mm
          CALL DFTB_MULLIKEN(L1IJ,L2IJ,SIJ,WRK,        WRK(L2IJ+1))
          CALL DFTB_MULLIKEN(L1IJ,L2IJ,DA ,PS(1,JIXYZ),WRK(L2IJ+L1IJ+1))
          CALL DAXPY(L1IJ,-HALF*SCAL,WRK(L2IJ+1),1,WRK(L2IJ+L1IJ+1),1)
          DO NC = 1, NATIJ
            VAL = ZERO
            DO L = 1, IND(NC+1)-IND(NC)
              MU = IND(NC)+L
              VAL = VAL + WRK(L2IJ+L1IJ+MU)
            END DO
            WRK(NC) = VAL
          END DO
C
C         CALL DGEMV('T',NATIJ,NATFMO*3,ONE,OMGD,NATIJ,WRK,1,ONE,
C    *               FCM(JZXYZ,1),NATFMO*3)
          CALL DGEMV('T',NATIJ,NATFMO*3,ONE,OMGD,NATIJ,WRK,1,ONE,
     *               FCM(1,JZXYZ),1)
        END DO
      END DO
C
c     IF(GOPARR.AND.NXT) CALL DDI_DLBRESET
C
C     U^b*omega*S^a - S^b S^a Omega_AB
      CALL VALFM(LOADFM)
      LCUC = LOADFM + 1
      LAST = LCUC   + L2IJ*NATIJ*3
      NEED2= LAST   - LOADFM    - 1
      CALL GETFM(NEED2)
C
C     PREPARE C*U*C
      DO JPS=1,NATIJ*3
        CALL DGEMM('N','N',L1IJ,NVIR,NOCC,ONE,DA(L2IJ+1),L1IJ,
     *          YAIJ(1,1,JPS),NOCC,ZERO,X(LWRK),L1IJ)
        CALL DGEMM('N','T',L1IJ,L1IJ,NVIR,ONE,X(LWRK),L1IJ,
     *          DA(L2IJ+L1IJ*NOCC+1),L1IJ,ZERO,X(LWRKI),L1IJ)
        CALL SQ2TRI(L1IJ,L1IJ,X(LWRKI),X(LCUC+1+L2IJ*(JPS-1)),TWO*SCAL)
      END DO
C
      DO IAT=1,NATIJ
       IZAT = (IAGLOB(IAT)-1)*3
       DO 200 IXYZ=1,3
C        KOUNT=KOUNT+1
C        IF(GOPARR) THEN
C          IF(NXT) THEN
C            IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
C            IF(NEXT.NE.KOUNT) GOTO 200
C          ELSE
C            IF(MOD(KOUNT,NPROC).NE.ME) GOTO 200
C          ENDIF
C        ENDIF
C        SAVGOP=GOPARR
C        GOPARR=.FALSE.
C
         IPS  = (IAT - 1) * 3 + IXYZ
         CALL SHIFT_TRIANGLE(NATIJ,L2IJ,IND,X(LSHFT),
     *                       PS(1,IPS),WRK(l2ij+1))
C        GET  SIJ*V*SIJ - SI*V*SI - SJ*V*SJ
         CALL FMO2DER_DVPOT(WRK(l2ij+1),L1IJ,WRK1,L2IJ,WRK1(LDI),L1I,
     *        WRK1(LDJ),L1J,WRK1(LDK),L1K,X(LWRK),X(LWRKI),X(LWRKJ),
     *        X(LWRKK),WRK,MAPI,MAPJ,MAPK,KFG.NE.0)
         CALL DSCAL(L2IJ,-half*scal,WRK,1)
C
C
         izxyz = IZAT + IXYZ
         DO JAT=1,NATIJ
          JZAT = (IAGLOB(JAT)-1)*3
          DO JXYZ=1,3
           JPS   = (JAT - 1) * 3 + JXYZ
           VAL   = TWO*DDOT(L2IJ,WRK,1,PS(1,JPS),1)
C
           jzxyz = JZAT + JXYZ
C
           FCM(JZXYZ,IZXYZ) = FCM(JZXYZ,IZXYZ) + VAL
           FCM(IZXYZ,JZXYZ) = FCM(IZXYZ,JZXYZ) + VAL
C
           VAL   = TRACEP(WRK(l2ij+1),X(LCUC+1+L2IJ*(JPS-1)),L1IJ)
           FCM(IZXYZ,JZXYZ) = FCM(IZXYZ,JZXYZ) + VAL
          END DO
         END DO
C
C        GOPARR=savgop
C
 200   CONTINUE
      END DO
C
C     I  VEC
      IDMREC0K = IFG + IREC0
      CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRKI),l3i,IDMREC0K,0)
C     J  VEC
      IDMREC0K = JFG + IREC0
      CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRKJ),l3j,IDMREC0K,0)
C     K  VEC
      IF (KFG.NE.0) THEN
        IDMREC0K = KFG + IREC0
        CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRKK),l3K,IDMREC0K,0)
      END IF
C
C
C     PREPARE C*U*C
      DO JJXYZ=1,NATI*3
        CALL DGEMM('N','N',L1I,NVIRI,NAI,ONE,X(LWRKI),L1I,
     *          YAI(1,1,JJXYZ),NAI,ZERO,X(LWRK),L1I)
        CALL DGEMM('N','T',L1I,L1I,NVIRI,ONE,X(LWRK),L1I,
     *          X(LWRKI+L1I*NAI),L1I,ZERO,wrk1,L1I)
        CALL SQ2TRI(L1I,L1I,wrk1,X(LCUC+L2I*(JJXYZ-1)),TWO*SCAL)
      END DO
      DO JJXYZ=1,NATJ*3
        CALL DGEMM('N','N',L1J,NVIRJ,NAJ,ONE,X(LWRKJ),L1J,
     *          YAJ(1,1,JJXYZ),NAJ,ZERO,X(LWRK),L1J)
        CALL DGEMM('N','T',L1J,L1J,NVIRJ,ONE,X(LWRK),L1J,
     *          X(LWRKJ+L1J*NAJ),L1J,ZERO,wrk1,L1J)
        CALL SQ2TRI(L1J,L1J,wrk1,X(LCUC+L2I*NATI*3+L2J*(JJXYZ-1)),
     *             TWO*SCAL)
      END DO
      IF (KFG.NE.0) THEN
        DO JJXYZ=1,NATK*3
          CALL DGEMM('N','N',L1K,NVIRK,NAK,ONE,X(LWRKK),L1K,
     *            YAK(1,1,JJXYZ),NAK,ZERO,X(LWRK),L1K)
          CALL DGEMM('N','T',L1K,L1K,NVIRK,ONE,X(LWRK),L1K,
     *            X(LWRKK+L1K*NAK),L1K,ZERO,wrk1,L1K)
          CALL SQ2TRI(L1K,L1K,wrk1,
     *      X(LCUC+L2I*NATI*3+L2J*NATJ*3+L2K*(JJXYZ-1)),TWO*SCAL)
        END DO
      END IF
C
      DO IAT=1,NATIJ
       IZAT = (IAGLOB(IAT)-1)*3
       DO 300 IXYZ=1,3
C
C        KOUNT=KOUNT+1
C        IF(GOPARR) THEN
C          IF(NXT) THEN
C            IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
C            IF(NEXT.NE.KOUNT) GOTO 300
C          ELSE
C            IF(MOD(KOUNT,NPROC).NE.ME) GOTO 300
C          ENDIF
C        ENDIF
C        SAVGOP=GOPARR
C        GOPARR=.FALSE.
C
         IPS  = (IAT - 1) * 3 + IXYZ
         CALL SHIFT_TRIANGLE(NATIJ,L2IJ,IND,X(LSHFT),
     *                       PS(1,IPS),WRK(l2ij+1))
         IZXYZ = IZAT + IXYZ
C     EXTRACT ^I
         LOOP  = 0
         DO II = 1, L1IJ
           DO JJ = 1, II
             LOOP = LOOP + 1
             II1  = MAPI(II)
             IJ1  = MAPI(JJ)
             II2  = MAX(II1,IJ1)
             IJ2  = MIN(II1,IJ1)
             ISINI= II1.NE.0.AND.IJ1.NE.0
             if(isini) WRK((II2*II2-II2)/2+IJ2) = WRK(LOOP+L2IJ)
           END DO
         END DO
         RMS = DDOT(L2I,WRK,1,WRK,1)
c        WRITE(6,'("CHECK IFG=",I3,F12.8)') IAT,RMS
         IF(RMS.EQ.ZERO) GO TO 110
C        call prtril(wrk,L1ij)
         INDI   = INDFRG(IFG)
         DO JAT=1,NATI
           JZAT = (IATFRG(INDI+JAT-1)-1)*3
           DO JXYZ=1,3
            JJXYZ = (JAT - 1) * 3 + JXYZ
            JZXYZ = JZAT          + JXYZ
            VAL   = TRACEP(WRK,X(LCUC+L2I*(JJXYZ-1)),L1I)
            FCM(IZXYZ,JZXYZ) = FCM(IZXYZ,JZXYZ) - VAL
           END DO
         END DO
 110     CONTINUE
C
C     EXTRACT (S*OMEG^b)^J
         LOOP=0
         DO II = 1, L1IJ
           DO JJ = 1, II
             LOOP = LOOP + 1
             II1  = MAPJ(II)
             IJ1  = MAPJ(JJ)
             II2  = MAX(II1,IJ1)
             IJ2  = MIN(II1,IJ1)
             ISINI= II1.NE.0.AND.IJ1.NE.0
             if(isini) WRK((II2*II2-II2)/2+IJ2) = WRK(LOOP+L2IJ)
           END DO
         END DO
         RMS = DDOT(L2J,WRK,1,WRK,1)
c        WRITE(6,'("CHECK JFG=",I3,F12.8)') IAT,RMS
         IF(RMS.EQ.ZERO) GO TO 210
         INDI   = INDFRG(JFG)
         DO JAT=1,NATJ
           JZAT = (IATFRG(INDI+JAT-1)-1)*3
           DO JXYZ=1,3
            JJXYZ = (JAT - 1) * 3 + JXYZ
            JZXYZ = JZAT          + JXYZ
            VAL   = TRACEP(WRK,X(LCUC+L2I*NATI*3+L2J*(JJXYZ-1)),L1J)
            FCM(IZXYZ,JZXYZ) = FCM(IZXYZ,JZXYZ) - VAL
           END DO
         END DO
 210     CONTINUE
C
C     EXTRACT (S*OMEG^b)^K
        IF (KFG.NE.0) THEN
         LOOP=0
         DO II = 1, L1IJ
           DO JJ = 1, II
             LOOP = LOOP + 1
             II1  = MAPK(II)
             IJ1  = MAPK(JJ)
             II2  = MAX(II1,IJ1)
             IJ2  = MIN(II1,IJ1)
             ISINI= II1.NE.0.AND.IJ1.NE.0
             if(isini) WRK((II2*II2-II2)/2+IJ2) = WRK(LOOP+L2IJ)
           END DO
         END DO
         RMS = DDOT(L2K,WRK,1,WRK,1)
c        WRITE(6,'("CHECK JFG=",I3,F12.8)') IAT,RMS
         IF(RMS.EQ.ZERO) GO TO 310
         INDI   = INDFRG(KFG)
         DO JAT=1,NATK
           JZAT = (IATFRG(INDI+JAT-1)-1)*3
           DO JXYZ=1,3
            JJXYZ = (JAT - 1) * 3 + JXYZ
            JZXYZ = JZAT          + JXYZ
            VAL   = TRACEP(WRK,X(LCUC+L2I*NATI*3+L2J*NATJ*3
     *                          +L2K*(JJXYZ-1)),L1K)
            FCM(IZXYZ,JZXYZ) = FCM(IZXYZ,JZXYZ) - VAL
           END DO
         END DO
 310     CONTINUE
        END IF
C
C        GOPARR=savgop
 300   CONTINUE
      END DO
      CALL RETFM(NEED2)
C
C     DA IS SCALED SOMEWHERE
      if(maswrk)
     *  CALL FMO2DER_HSPOT(DA,L2IJ,X(LSHFT),IAGLOB,FCM,NATIJ,X(LWRKJ))
C
C     IF (NBODY.EQ.3) THEN
C       DO IXYZ=1,NATFMO*3
C         DO JXYZ=1,IXYZ
C           DUM = (FCM(IXYZ,JXYZ) + FCM(JXYZ,IXYZ))/TWO
C           FCM(IXYZ,JXYZ) = DUM
C           FCM(JXYZ,IXYZ) = DUM
C         END DO
C       END DO
C     END IF
C
C     IF(GOPARR.AND.NXT) CALL DDI_DLBRESET
C
      CALL RETFM(NEED)
C

      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK FMO2DER_DVPOT
C>    @brief   ESP derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate difference of energy-weighted DM
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param VIJ       SIJ*V*SIJ - SI*V*SI - SJ*V*SJ
C>    @param L1IJ      Number of basis functions for fragment IJK
C>    @param DIJ       Density matrix for fragment IJK
C>    @param L2IJ      L1IJ*(L1IJ+1)/2
C>    @param DI        Density matrix for fragment I
C>    @param L1I       Number of basis functions for fragment I
C>    @param DJ        Density matrix for fragment J
C>    @param L1J       Number of basis functions for fragment J
C>    @param DK        Density matrix for fragment K
C>    @param L1K       Number of basis functions for fragment K
C>    @param SCR       Working array
C>    @param WI        Energy-weighted density matrix for I
C>    @param WJ        Energy-weighted density matrix for  J
C>    @param WK        Energy-weighted density matrix for   K
C>    @param MAPI      Mapping information for framgnet I
C>    @param MAPJ      Mapping information for framgnet  J
C>    @param MAPK      Mapping information for framgnet   K
C>    @param FMO3      FMO3 or not
C>           --- OUTPUT ---
C>    @param WIJ       Energy-weighted density matrix for IJK
      SUBROUTINE  FMO2DER_DVPOT(VIJ,L1IJ,DIJ,L2IJ,DI,L1I,
     *      DJ,L1J,DK,L1K,SCR,WI,WJ,WK,WIJ,MAPI,MAPJ,MAPK,FMO3)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION VIJ(*),DIJ(*),DI(*),DJ(*),DK(*)
      DIMENSION SCR(*),WI(*),WJ(*),WK(*),WIJ(*)
      DIMENSION MAPI(*),MAPJ(*),MAPK(*)
C
      LOGICAL  ISINI,FMO3
C     EXTRACT (S*OMEG^b)^I
      LOOP=0
      DO II = 1, L1IJ
        DO JJ = 1, II
          LOOP = LOOP + 1
          II1  = MAPI(II)
          IJ1  = MAPI(JJ)
          II2  = MAX(II1,IJ1)
          IJ2  = MIN(II1,IJ1)
          ISINI= II1.NE.0.AND.IJ1.NE.0
          if(isini) WIJ((II2*II2-II2)/2+IJ2) = VIJ(LOOP)
        END DO
      END DO
C     D^I *(S*OMEG^b)^I*D^I
      CALL CPYTSQ(DI,SCR,l1I,1)
      CALL TFTRI(WI,WIJ,SCR,VIJ(l2ij+1),l1i,l1i,l1i)
C     EXTRACT (S*OMEG^b)^J
      LOOP=0
      DO II = 1, L1IJ
        DO JJ = 1, II
          LOOP = LOOP + 1
          II1  = MAPJ(II)
          IJ1  = MAPJ(JJ)
          II2  = MAX(II1,IJ1)
          IJ2  = MIN(II1,IJ1)
          ISINI= II1.NE.0.AND.IJ1.NE.0
          if(isini) WIJ((II2*II2-II2)/2+IJ2) = VIJ(LOOP)
        END DO
      END DO
C     D^J *(S*OMEG^b)^J*D^J
      CALL CPYTSQ(DJ,SCR,l1J,1)
      CALL TFTRI(WJ,WIJ,SCR,VIJ(l2ij+1),l1j,l1j,l1j)
      IF (FMO3) THEN
C       EXTRACT (S*OMEG^b)^J
        LOOP=0
        DO II = 1, L1IJ
          DO JJ = 1, II
            LOOP = LOOP + 1
            II1  = MAPK(II)
            IJ1  = MAPK(JJ)
            II2  = MAX(II1,IJ1)
            IJ2  = MIN(II1,IJ1)
            ISINI= II1.NE.0.AND.IJ1.NE.0
            if(isini) WIJ((II2*II2-II2)/2+IJ2) = VIJ(LOOP)
          END DO
        END DO
C       D^J *(S*OMEG^b)^J*D^J
        CALL CPYTSQ(DK,SCR,l1K,1)
        CALL TFTRI(WK,WIJ,SCR,VIJ(l2ij+1),l1k,l1k,l1k)
      END IF
C
      CALL CPYTSQ(DIJ,SCR,l1IJ,1)
      CALL TFTRI(WIJ,VIJ,SCR,VIJ(l2ij+1),l1ij,l1ij,l1ij)
C     IJ - I - J
      LOOP=0
      DO II = 1, L1IJ
        DO JJ = 1, II
          LOOP = LOOP + 1
          II1  = MAPI(II)
          IJ1  = MAPI(JJ)
          II2  = MAX(II1,IJ1)
          IJ2  = MIN(II1,IJ1)
          ISINI= II1.NE.0.AND.IJ1.NE.0
          if(isini) WIJ(LOOP)=WIJ(LOOP)-WI((II2*II2-II2)/2+IJ2)
        END DO
      END DO
      LOOP=0
      DO II = 1, L1IJ
        DO JJ = 1, II
          LOOP = LOOP + 1
          II1  = MAPJ(II)
          IJ1  = MAPJ(JJ)
          II2  = MAX(II1,IJ1)
          IJ2  = MIN(II1,IJ1)
          ISINI= II1.NE.0.AND.IJ1.NE.0
          if(isini) WIJ(LOOP)=WIJ(LOOP)-WJ((II2*II2-II2)/2+IJ2)
        END DO
      END DO
C     (IJK - I - J) - K
      IF (FMO3) THEN
        LOOP=0
        DO II = 1, L1IJ
          DO JJ = 1, II
            LOOP = LOOP + 1
            II1  = MAPK(II)
            IJ1  = MAPK(JJ)
            II2  = MAX(II1,IJ1)
            IJ2  = MIN(II1,IJ1)
            ISINI= II1.NE.0.AND.IJ1.NE.0
            if(isini) WIJ(LOOP)=WIJ(LOOP)-WK((II2*II2-II2)/2+IJ2)
          END DO
        END DO
      END IF

C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK FMO2DER_HSPOT
C>    @brief   ESP derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate Hessian contributions of d2H/dadb and d2S/dadb
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param DA        Density matrix
C>    @param L2IJ      L1IJ*(L1IJ+1)/2
C>    @param SHIFT     Shift contributions
C>    @param IAGLOB    Global label for atom
C>    @param NATIJ     Number of atoms for fragment IJK
C>    @param WRK2      Working array
C>           --- OUTPUT ---
C>    @param FCM       Hessian matrix
      SUBROUTINE FMO2DER_HSPOT(DA,L2IJ,SHIFT,IAGLOB,FCM,NATIJ,WRK2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      Parameter (MXATM=2000,MXSPE=10)
      Parameter (Half=0.5D+00,ZERO=0.0D+00,TWO=2.0D+00)
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
C
      DIMENSION  DA(*),SHIFT(*),IAGLOB(*)
      DIMENSION  FCM(natfmo*3,*)
      DIMENSION  WRK2(*)
      DIMENSION  SHSS(3,3)

C     DDIJ * SHFT * S^ab
C
      DO NI   = 1, NATIJ
       IZAT   = (IAGLOB(NI)-1)*3
       SHIFTI = SHIFT(NI)
       DO NJ  = 1, NI
        JZAT  = (IAGLOB(NJ)-1)*3
        DO KI = 1, 3
          DO KJ = 1, KI
           CALL DFTB_DER2(L2IJ,NI,KI,NJ,KJ,NATIJ,IND,C,WRK2,WRK2,
     *          .false.)
c          write(6,*) 'wwwcurdt'
c          call prtri(wrk2,l1ij)
           CALL VCLR(SHSS,1,9)
           VAL  = ZERO
           IF (NI.EQ.NJ) THEN
             DO 30 NK = 1, NATIJ
               IF (NI.EQ.NK) go to 30
               SHIFTJ  = SHIFT(NK)
               SHIFTIJ = (SHIFTI+SHIFTJ)*HALF
               DO L = 1, IND(NK+1) - IND(NK)
                 NU = IND(NK)+L
                 DO M = 1, IND(NI+1) - IND(NI)
                   MU = IND(NI)+M
                   CALL DFTB_CNVSQ(MU,NU,NSEQ)
c                  D2HDR = HDER2(NSEQ)
                   D2SDR = WRK2(NSEQ)
                   TMP   = DA(NSEQ)*SHIFTIJ*D2SDR
                   VAL   = VAL + TMP
                 END DO
               END DO
 30          CONTINUE
             SHSS(KI,KJ) = SHSS(KI,KJ) + VAL*TWO
             IF (KI.NE.KJ) SHSS(KJ,KI) = SHSS(KJ,KI) + VAL*TWO
           ELSE
             SHIFTJ  = SHIFT(NJ)
             SHIFTIJ = (SHIFTI+SHIFTJ)*HALF
             DO L = 1, IND(NJ+1) - IND(NJ)
               NU = IND(NJ)+L
               DO M = 1, IND(NI+1) - IND(NI)
                 MU = IND(NI)+M
                 CALL DFTB_CNVSQ(MU,NU,NSEQ)
c                D2HDR = HDER2(NSEQ)
                 D2SDR = WRK2(NSEQ)
                 TMP   = DA(NSEQ)*SHIFTIJ*D2SDR
                 VAL   = VAL + TMP
               END DO
             END DO
             SHSS(KI,KJ) = SHSS(KI,KJ) - VAL*TWO
             IF (KI.NE.KJ) SHSS(KJ,KI) = SHSS(KJ,KI) - VAL*TWO
           END IF
           FCM(IZAT+1,JZAT+1)= FCM(IZAT+1,JZAT+1)  + SHSS(1,1)
           FCM(IZAT+2,JZAT+1)= FCM(IZAT+2,JZAT+1)  + SHSS(2,1)
           FCM(IZAT+3,JZAT+1)= FCM(IZAT+3,JZAT+1)  + SHSS(3,1)
           FCM(IZAT+1,JZAT+2)= FCM(IZAT+1,JZAT+2)  + SHSS(1,2)
           FCM(IZAT+2,JZAT+2)= FCM(IZAT+2,JZAT+2)  + SHSS(2,2)
           FCM(IZAT+3,JZAT+2)= FCM(IZAT+3,JZAT+2)  + SHSS(3,2)
           FCM(IZAT+1,JZAT+3)= FCM(IZAT+1,JZAT+3)  + SHSS(1,3)
           FCM(IZAT+2,JZAT+3)= FCM(IZAT+2,JZAT+3)  + SHSS(2,3)
           FCM(IZAT+3,JZAT+3)= FCM(IZAT+3,JZAT+3)  + SHSS(3,3)
           IF(IZAT.NE.JZAT) THEN
            FCM(JZAT+1,IZAT+1)= FCM(JZAT+1,IZAT+1) + SHSS(1,1)
            FCM(JZAT+1,IZAT+2)= FCM(JZAT+1,IZAT+2) + SHSS(2,1)
            FCM(JZAT+1,IZAT+3)= FCM(JZAT+1,IZAT+3) + SHSS(3,1)
            FCM(JZAT+2,IZAT+1)= FCM(JZAT+2,IZAT+1) + SHSS(1,2)
            FCM(JZAT+2,IZAT+2)= FCM(JZAT+2,IZAT+2) + SHSS(2,2)
            FCM(JZAT+2,IZAT+3)= FCM(JZAT+2,IZAT+3) + SHSS(3,2)
            FCM(JZAT+3,IZAT+1)= FCM(JZAT+3,IZAT+1) + SHSS(1,3)
            FCM(JZAT+3,IZAT+2)= FCM(JZAT+3,IZAT+2) + SHSS(2,3)
            FCM(JZAT+3,IZAT+3)= FCM(JZAT+3,IZAT+3) + SHSS(3,3)
           END IF
          END DO
        END DO
       END DO
      END DO


      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK FMO2DER_2NDMULL
C>    @brief   ESP derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate part of second-order Mulliken derivative
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NATL      Number of atoms
C>    @param VEC       MO coefficients
C>    @param PS        Overlap derivative in AO basis
C>    @param DEN       Density matrix
C>    @param L1L       Number of basis functions
C>    @param L2L       L1L*(L1L+1)/2
C>    @param YALAG     Alpha orbital relaxation term for entire systems
C>    @param IPTYA     The pointer for YALAG
C>    @param NOCC      Number of occupied orbitals
C>    @param NVIR      Number of virtual orbitals
C>    @param INDFRG    First atom of each fragment in terms of NATFMOB?
C>    @param IATFRG    Global atom index with NBDFG?
C>    @param IFG       Fragment indice in current for monomer
C>    @param SHIFT     Shift contributions
C>    @param WRK       Working array
C>           --- OUTPUT ---
C>    @param FCM       Hessian matrix
      SUBROUTINE FMO2DER_2NDMULL(NATL,VEC,PS,DEN,L1L,L2L,
     *         YALAG,IPTYA,NOCC,NVIR,FCM,INDFRG,IATFRG,IFG,SHIFT,WRK)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXSPE=10)
      PARAMETER (ONE=1.0D+00,ZERO=0.0D+00,TWO=2.0D+00,HALF=0.5D+00)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /FMCOM / X(1)
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION VEC(*),PS(L2L,*),YALAG(*),IPTYA(*)
      DIMENSION FCM(natfmo*3,*),DEN(*),SHIFT(*),WRK(*)
      DIMENSION INDFRG(*),IATFRG(*)
C     Eq(10)
c     write(6,'("CHECK VEC",I3)')  IFG
c     call prsq(VEC,l1l,l1l,l1l)
C
      CALL VALFM(LOADFM)
      LWRK    = LOADFM  + 1
      LWRK1   = LWRK    + L1L*L1L
      LWRK2   = LWRK1   + L1L*L1L
      LAST    = LWRK2   + L1L*L1L
      NEED    = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      INDI = INDFRG(IFG)
      DO IATM=1,NATL
       IAG = IATFRG(INDI+IATM-1)
       CALL IXSTOR(X(LIAGLOB),IATM,IAG)
       DO IXYZ=1,3
        IZX = (IAG-1)*3  + IXYZ
        IPS = (IATM - 1) * 3 + IXYZ
        CALL SHIFT_TRIANGLE(NATL,L2L,IND,SHIFT,PS(1,IPS),X(LWRK))
C
        DO JATM=1,NATL
         JAG = IATFRG(INDI+JATM-1)
         DO JXYZ=1,3
          JZX  = (JAG-1)*3  + JXYZ
          JPS  = (JATM - 1) * 3 + JXYZ
          IPNT = IPTYA(IFG) + (JPS-1)*NOCC*NVIR
C        D*S*D
          CALL CPYTSQ(DEN,X(LWRK1),l1l,1)
          CALL TFTRI(WRK,PS(1,JPS),X(LWRK1),X(LWRK2),l1l,l1l,l1l)
C        C*U*C^T
          CALL DGEMM('N','N',L1L,NVIR,NOCC,ONE,VEC,L1L,
     *            YALAG(IPNT),NOCC,ZERO,X(LWRK1),L1L)
          CALL DGEMM('N','T',L1L,L1L,NVIR,ONE,X(LWRK1),L1L,
     *            VEC(1+L1L*NOCC),L1L,ZERO,X(Lwrk2),L1L)
          CALL SQ2TRI(L1L,L1L,X(LWRK2),X(LWRK1),TWO)
C
          call daxpy(L2L,-HALF,WRK,1,X(LWRK1),1)
          VAL1 = TRACEP(X(LWRK1),X(LWRK),L1L)
C
          IF(MASWRK) THEN
           FCM(IZX,JZX) = FCM(IZX,JZX) + VAL1
           FCM(JZX,IZX) = FCM(JZX,IZX) + VAL1
          END IF
C
         END DO
        END DO
       END DO
      END DO
C
      IF(MASWRK)
     *  CALL FMO2DER_HSPOT(DEN,L2L,SHIFT,X(LIAGLOB),FCM,NATL,WRK)
C
      CALL RETFM(NEED)
C
      RETURN
      END
C
C*MODULE FMOHSS  *DECK DFTB_ESDHSS
C>    @brief   ES-DIM derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate Hessian contributions of ES-DIM approximation
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param DI        Density matrix of fragment I
C>    @param DJ        Density matrix of fragment J
C>    @param IFG       Fragment indice in current for monomer
C>    @param JFG       Fragment indice in current for dimer
C>    @param YALAG     Alpha orbital relaxation term for entire systems
C>    @param IPTYA     The pointer for YALAG
C>    @param IDMREC0   Record number to read orbital
C>    @param NUMFRG    Number of AO basis in the respective fragments
C>    @param NC1       3*NATFMO
C>    @param DIST      Inter-atomic distance matrix
C>    @param DODC      Flag for dispersion correction
C>    @param IEEH      Scaling of Hessian contributions
C>           --- OUTPUT ---
C>    @param FCMWRK    Hessian matrix
      SUBROUTINE DFTB_ESDHSS(DI,DJ,IFG,JFG,YALAG,IPTYA,FCMWRK,
     *          idmrec0,numfrg,NC1,DISTMAT,DODC,IEEH)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXSPE=10)
      LOGICAL DODC
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /FMCOM / X(1)
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
C

      DIMENSION DI(*),DJ(*),YALAG(*),IPTYA(*)
      DIMENSION FCMWRK(NC1,*),idmrec0(*),numfrg(*),DISTMAT(*)
C
      IF (IEEH.EQ.0) RETURN
      IREC0=IDMREC0(1)
      SCAL = IEEH
C     For I frag
      NATI = IXFTCH(X(LNATFRG),IFG)
      L1I  = IAND(NUMFRG(IFG),65535)
      L2I  = (L1I+L1I*L1I)/2
      L3I  = L1I*L1I
      NAI  = ISHFT(NUMFRG(IFG),-16)
      NVIRI= L1I - NAI
c     write(6,'("CHK IFG=",4I4)') NATI,L1I,NAI,NVIRI
C     For J frag
      NATJ = IXFTCH(X(LNATFRG),JFG)
      L1J  = IAND(NUMFRG(JFG),65535)
      L2J  = (L1J+L1J*L1J)/2
      L3J  = L1J*L1J
      NAJ  = ISHFT(NUMFRG(JFG),-16)
      NVIRJ= L1J - NAJ
c     write(6,'("CHK JFG=",4I4)') NATJ,L1J,NAJ,NVIRJ
      NATIJ= NATI + NATJ
C
      CALL VALFM(LOADFM)
      LOMGDI = LOADFM + 1
      LOMGDJ = LOMGDI + NATI * NATIJ * 3
      LOMGI  = LOMGDJ + NATJ * NATIJ * 3
      LOMGJ  = LOMGI  + NATI
      LDQI   = LOMGJ  + NATJ
      LDQJ   = LDQI   + NATI * NATI  * 3
      LQI    = LDQJ   + NATJ * NATJ  * 3
      LQJ    = LQI    + NATI
      LPSI   = LQJ    + NATJ
      LPSJ   = LPSI   + L2I  * NATI  * 3
      LGAMH  = LPSJ   + L2J  * NATJ  * 3
      LWRK   = LGAMH  + 11*NSPE*NSPE
      LCUC   = LWRK   + MAX(L3I,L3J) * 4
      LAST   = LCUC   + 3*MAX(NATI,NATJ)*MAX(L2I,L2J)
C
      NEED = LAST   - LOADFM     - 1
      CALL GETFM(NEED)
C
      CALL VCLR(X(LOMGI) ,1,NATI)
      CALL VCLR(X(LOMGJ) ,1,NATJ)
      CALL VCLR(X(LOMGDI),1,NATI * NATIJ * 3)
      CALL VCLR(X(LOMGDJ),1,NATJ * NATIJ * 3)
C
      CALL FMO2DER_GETGMH(X(LGAMH),NSPE)
C
      lpopmati = lpopmat+(maxnat*nfg)*(icurpop-1)
C     GET QJ^a
C     GET QI^a
      IDMREC0I = IFG + IREC0
      IDMREC0J = JFG + IREC0
      CALL RAREADS(IDAFMO,X(LIODFMO),DI(l2I+1),L3I,IDMREC0I,0)
      CALL RAREADS(IDAFMO,X(LIODFMO),DJ(l2J+1),L3J,IDMREC0J,0)
      call DMTX2(DI,DI(l2i+1),nai,l1i,l1i,nai)
      call DMTX2(DJ,DJ(l2j+1),naj,l1j,l1j,naj)
C
      CALL ESDIM_GETKPOT(NATI,DI,L1I,NATJ,DJ,L1J,X(lpopmati),
     *     YALAG(IPTYA(IFG)),NAI,NVIRI,YALAG(IPTYA(JFG)),NAJ,NVIRJ,
     *     X(LQI),X(LDQI),X(LQJ),X(LDQJ),X(LOMGI),X(LOMGJ),X(LOMGDI),
     *     X(LOMGDJ),X(LWRK),X(LIATFRG),X(LFMOC),X(LISPE),X(LINDFRG),
     *     X(LIAGLOB),X(LPSI),L2I,L3I,X(LPSJ),L2J,L3J,X(LGAMH),
     *     FCMWRK,nc1,IFG,JFG,X(LCUC),SCAL)
C
C     IF(GOPARR) CALL DSCAL(NC1*NC1,1.0D+00/NPROC,FCMWRK,1)
C
      CALL RETFM(NEED)
C
      IF (DODC) THEN
        CALL VALFM(LOADFM)
        LGRAD   = LOADFM + 1
        LHESS   = LGRAD  + NATI*NATJ
        LAST    = LHESS  + NATI*NATJ
        NEED    = LAST   - LOADFM     - 1
        CALL GETFM(NEED)
C
        CALL DFTB_DISP_HESS_ESDIM(IFG,JFG,NATI,NATJ,NC1,NATFMO,
     *         DISTMAT,X(LGRAD),X(LHESS),FCMWRK,X(LNBOND),
     *         X(LINDFRG),X(LIATFRG),X(LISPE),X(LDCTMP),X(LZREF),
     *         X(LFMOC),SCAL)
C
        CALL RETFM(NEED)
      END IF
C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK ESDIM_GETKPOT
C>    @brief   ES-DIM derivatives for FMO-DFTB Hessian
C>
C>    @details Calculate the derivative of Coulomb interaction
C>
C>    @author  Hiroya Nakata
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NATI      Number of atoms for fragment I
C>    @param DI        Density matrix for fragment I
C>    @param L1I       Number of basis functions for fragment I
C>    @param NATJ      Number of atoms for fragment J
C>    @param DJ        Density matrix for fragment J
C>    @param L1J       Number of basis functions for fragment J
C>    @param POPMAT    Mulliken population of each fragment
C>    @param YAI       U_{mi}^{a,I}
C>    @param NAI       Number of electrons for fragment I
C>    @param NVIRI     Number of virtual orbitals for fragment I
C>    @param YAI       U_{mi}^{a,J}
C>    @param NAI       Number of electrons for fragment J
C>    @param NVIRI     Number of virtual orbitals for fragment J
C>    @param QI        Charge Q  in Fragment I
C>    @param DQI       Derivative of Charge Q in Fragment I
C>    @param QJ        Charge Q  in Fragment J
C>    @param DQJ       Derivative of Charge Q in Fragment J
C>    @param OMGI      Omega for fragment I
C>    @param OMGJ      Omega for fragment J
C>    @parma WRK       Working array
C>    @param IATFRG    Global atom index with NBDFG?
C>    @param FMOC      Coordinate for each atom in the system
C>    @param ISPEFMO   ISPE for each atom in the system
C>    @param INDFRG    First atom of each fragment in terms of NATFMOB?
C>    @param IAGLOB    Global index of atom
C>    @param PSI       Overlap derivative in AO basis for fragment I
C>    @param L2I       L1I*(L1I+1)/2
C>    @param L3I       L1I*L1I
C>    @param PSJ       Overlap derivative in AO basis for fragment J
C>    @param L2J       L1J*(L1J+1)/2
C>    @param L3J       L1J*L1J
C>    @param GAMH      Some parameters for DFTB2/3 gamma second der.
C>    @param NC1       3*NATFMO
C>    @param IFG       Fragment indice in current for monomer
C>    @param JFG       Fragment indice in current for dimer
C>    @param CUC       Working array
C>    @param SCAL      Scaling of Hessian contributions
C>           --- OUTPUT ---
C>    @param FCM       Hessian matrix
      SUBROUTINE ESDIM_GETKPOT(NATI,DI,L1I,NATJ,DJ,L1J,popmat,
     *     YAI,NAI,NVIRI,YAJ,NAJ,NVIRJ,QI,DQI,QJ,DQJ,OMGI,OMGJ,
     *     OMGDI,OMGDJ,WRK,IATFRG,FMOC,ISPEFMO,INDFRG,IAGLOB,
     *     PSI,L2I,L3I,PSJ,L2J,L3J,GAMH,FCM,nc1,IFG,JFG,CUC,SCAL)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      Parameter (MXATM=2000,MXSPE=10)
      Parameter (ONE=1.0D+00,ZERO=0.0D+00,HALF=0.5D+00,TWO=2.0D+00)
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /FMCOM / X(1)
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
C
      DIMENSION DI(*),DJ(*),popmat(maxnat,*)
      DIMENSION YAI(NAI,NVIRI,*),YAJ(NAJ,NVIRJ,*)
      DIMENSION QI(*),DQI(NATI,*),QJ(*),DQJ(NATJ,*)
      DIMENSION OMGI(*),OMGJ(*),OMGDI(NATI,*),OMGDJ(NATJ,*)
      DIMENSION WRK(*),IATFRG(*),FMOC(3,*),ISPEFMO(*),INDFRG(*)
      DIMENSION IAGLOB(*),PSI(L2I,*),PSJ(L2J,*),GAMH(*),FCM(nc1,*)
      DIMENSION CUC(MAX(L2I,L2J),*)

C
C     calculate omgi and omgj
      INDI   = INDFRG(IFG)
      JJ     = INDI
      IND(1) = 0
      NAT    = NATI
      DO I = 1, NAT
        IAG = IATFRG(INDI+I-1)
        IAGLOB(I) = IAG
        CALL DCOPY(3,FMOC(1,IAG),1,C(1,I),1)
        ISPE(I)  = ISPEFMO(IAG)
        IND(I+1) = IND(I) + MAXANG(ISPE(I))**2
        QI(I)    = POPMAT(I,IFG) - X(LZREF+JJ-1)
        JJ       = JJ + 1
      END DO
      INDI = INDFRG(JFG)
      JJ     = INDI
      DO I = 1, NATJ
        IAG = IATFRG(INDI+I-1)
        CALL DCOPY(3,FMOC(1,IAG),1,C(1,I+NAT),1)
        ISPE(I+NAT)   = ISPEFMO(IAG)
        IND(NAT+I+1)  = IND(NAT+I) + MAXANG(ISPE(I+NAT))**2
        IAGLOB(NAT+I) = IAG
        QJ(I)    = POPMAT(I,JFG) - X(LZREF+JJ-1)
        JJ       = JJ + 1
      END DO
      NAT     = NAT + NATJ
      CALL ESDHSS_OMEGA(OMGI,NATI,OMGJ,NATJ,QI,QJ,X(LGAMMA),X(LGAMMA3))
C
      INDI   = INDFRG(JFG)
      JJ     = INDI
      IND(1) = 0
      NAT    = NATJ
      DO I = 1, NAT
        IAG = IATFRG(INDI+I-1)
        IAGLOB(I) = IAG
        CALL DCOPY(3,FMOC(1,IAG),1,C(1,I),1)
        ISPE(I)  = ISPEFMO(IAG)
        IND(I+1) = IND(I) + MAXANG(ISPE(I))**2
        QJ(I)    = POPMAT(I,JFG) - X(LZREF+JJ-1)
        JJ       = JJ + 1
      END DO
C
      CALL VCLR(DQJ,1,NAT*NAT*3)
C
c     LD    = 1
      LC    = 1 + L2J
      LVORB = 1 + L2J + L1J*NAJ
      LSL   = 1 + L3J * 2
C     V,D,S,S^a for J fragment
      CALL VCLR(DJ(LSL),1,L2J)
      CALL DFTB_HAM_OVER(1,NAT,DJ(LSL),DJ(LSL),.FALSE.,.TRUE.)
      CALL DFTB_EXTSDER(PSJ,L2J,1,NAT)
C
      DO IXYZ=1,NAT*3
C       C(l1,occ)*U(occ,vir)*C(l1,vir)^T
        CALL DGEMM('N','N',L1J,NVIRJ,NAJ,ONE,DJ(LC),L1J,
     *              YAJ(1,1,ixyz),NAJ,ZERO,WRK,L1J)
        CALL DGEMM('N','T',L1J,L1J,NVIRJ,ONE,WRK,L1J,DJ(LVORB),L1J,
     *              ZERO,WRK(L3J+1),L1J)
        CALL SQ2TRI(L1J,L1J,WRK(L3J+1),CUC(1,IXYZ),TWO)
C       CALL DCOPY(L2J,WRK,1,CUC(1,IXYZ),1)
      END DO
C
      CALL VCLR(WRK(L2J*2+L3J+L1J+1),1,L2J)
      DO IAT = 1, NAT
        IZAT = (IAGLOB(IAT)-1)*3
        DO IXYZ = 1, 3
          IPS = (IAT-1)*3 + IXYZ
C         D*S*D
          CALL CPYTSQ(DJ,WRK(l2J*2+1),L1J,1)
          CALL TFTRI(WRK(L2J+1),PSJ(1,IPS),WRK(l2j*2+1),
     *         WRK(l2j*2+L3J+1),l1j,l1j,l1j)
          CALL DCOPY(L2J,CUC(1,IPS),1,WRK,1)
          call daxpy(L2J,-half,WRK(L2J+1),1,WRK,1)
C
          CALL SHIFT_TRIANGLE(NAT,L2J,IND,OMGJ,WRK(L2J+1),
     *         WRK(L2J*2+1))
          CALL SHIFT_TRIANGLE_DER(NAT,IAT,L2J,IND,OMGJ,PSJ(1,IPS),
     *         WRK(L2J*2+L3J+L1J+1))
          IZXYZ = IZAT + IXYZ
          DO JAT = 1, NAT
            JZAT = (IAGLOB(JAT)-1)*3
            DO JXYZ = 1, 3
              JPS   = (JAT - 1) * 3 + JXYZ
              VAL   = -DDOT(L2J,WRK(L2J*2+1),1,PSJ(1,JPS),1)*SCAL
C
              jzxyz = JZAT + JXYZ
C
              FCM(JZXYZ,IZXYZ) = FCM(JZXYZ,IZXYZ) + VAL
              FCM(IZXYZ,JZXYZ) = FCM(IZXYZ,JZXYZ) + VAL
C
              VAL = DDOT(L2J,CUC(1,JPS),1,WRK(L2J*2+L3J+L1J+1),1)
              FCM(IZXYZ,JZXYZ) = FCM(IZXYZ,JZXYZ) + VAL*TWO*SCAL
            END DO
          END DO
C         GET Mulliken
          CALL DFTB_MULLIKEN(L1J,L2J,WRK,DJ(LSL),WRK(L2J+1))
          CALL DFTB_MULLIKEN(L1J,L2J,DJ,PSJ(1,IPS),WRK(L2J+L1J+1))
C         call daxpy(L1J,ONE,WRK(L2J+L1J+1),1,WRK(L2J+1),1)
          !! VADD may be faster than DAXPY by 10%
          CALL VADD(WRK(L2J+L1J+1),1,WRK(L2J+1),1,WRK(L2J+1),1,L1J)
C         from L1 to NATL
          DO NC = 1, NATJ
            VAL = ZERO
            DO L = 1, IND(NC+1) - IND(NC)
              MU  = IND(NC)+L
              VAL = VAL + WRK(L2J+MU)
            END DO
            DQJ(NC,IPS) = DQJ(NC,IPS) + VAL
          END DO
        END DO
        CALL SHIFT_TRIANGLE_DER_CLEAR(NAT,IAT,L2J,IND,
     *       WRK(L2J*2+L3J+L1J+1))
      END DO
C     Check
c     write(6,'("www Q^a",I3)') JFG
c     call prsq(dqj,nat*3,nat,nat)
C
C
C
      INDI   = INDFRG(IFG)
      JJ     = INDI
      IND(1) = 0
      NAT    = NATI
      DO I = 1, NAT
        IAG       = IATFRG(INDI+I-1)
        IAGLOB(I) = IAG
        ISPE(I)   = ISPEFMO(IAG)
        IND(I+1)  = IND(I) + MAXANG(ISPE(I))**2
        QI(I)     = POPMAT(I,IFG) - X(LZREF+JJ-1)
        JJ        = JJ + 1
        CALL DCOPY(3,FMOC(1,IAG),1,C(1,I),1)
      END DO
C
      CALL VCLR(DQI,1,NAT*NAT*3)
C
c     LD    = 1
      LC    = 1 + L2I
      LVORB = 1 + L2I + L1I*NAI
      LSL   = 1 + L3I * 2
C     V,D,S,S^a for I fragment
      CALL VCLR(DI(LSL),1,L2I)
      CALL DFTB_HAM_OVER(1,NAT,DI(LSL),DI(LSL),.FALSE.,.TRUE.)
      CALL DFTB_EXTSDER(PSI,L2I,1,NAT)
C
      DO IXYZ=1,NAT*3
C       C(l1,occ)*U(occ,vir)*C(l1,vir)^T
        CALL DGEMM('N','N',L1I,NVIRI,NAI,ONE,DI(LC),L1I,
     *              YAI(1,1,ixyz),NAI,ZERO,WRK,L1I)
        CALL DGEMM('N','T',L1I,L1I,NVIRI,ONE,WRK,L1I,DI(LVORB),L1I,
     *              ZERO,WRK(L3I+1),L1I)
        CALL SQ2TRI(L1I,L1I,WRK(L3I+1),CUC(1,IXYZ),TWO)
C       CALL DCOPY(L2I,WRK,1,CUC(1,IXYZ),1)
      END DO
C
      CALL VCLR(WRK(L2I*2+L3I+L1I+1),1,L2I)
      DO IAT = 1, NAT
        IZAT = (IAGLOB(IAT)-1)*3
        DO IXYZ = 1, 3
          IPS = (IAT-1)*3 + IXYZ
C         D*S*D
          CALL CPYTSQ(DI,WRK(l2I*2+1),L1I,1)
          CALL TFTRI(WRK(L2I+1),PSI(1,IPS),WRK(l2i*2+1),
     *         WRK(l2i*2+L3i+1),l1i,l1i,l1i)
          CALL DCOPY(L2I,CUC(1,IPS),1,WRK,1)
          call daxpy(L2I,-half,WRK(L2I+1),1,WRK,1)
C
          CALL SHIFT_TRIANGLE(NAT,L2I,IND,OMGI,WRK(L2I+1),
     *         WRK(L2I*2+1))
          CALL SHIFT_TRIANGLE_DER(NAT,IAT,L2I,IND,OMGI,PSI(1,IPS),
     *         WRK(L2I*2+L3I+L1I+1))
          IZXYZ = IZAT + IXYZ
          DO JAT = 1, NAT
            JZAT = (IAGLOB(JAT)-1)*3
            DO JXYZ = 1, 3
              JPS   = (JAT - 1) * 3 + JXYZ
              VAL   = -DDOT(L2I,WRK(L2I*2+1),1,PSI(1,JPS),1)*SCAL
C
              jzxyz = JZAT + JXYZ
C
              FCM(JZXYZ,IZXYZ) = FCM(JZXYZ,IZXYZ) + VAL
              FCM(IZXYZ,JZXYZ) = FCM(IZXYZ,JZXYZ) + VAL
C
              VAL = DDOT(L2I,CUC(1,JPS),1,WRK(L2I*2+L3I+L1I+1),1)
              FCM(IZXYZ,JZXYZ) = FCM(IZXYZ,JZXYZ) + VAL*TWO*SCAL
            END DO
          END DO
C         GET Mulliken
          CALL DFTB_MULLIKEN(L1I,L2I,WRK,DI(LSL),WRK(L2I+1))
          CALL DFTB_MULLIKEN(L1I,L2I,DI,PSI(1,IPS),WRK(L2I+L1I+1))
C         CALL DAXPY(L1I,ONE,WRK(L2I+L1I+1),1,WRK(L2I+1),1)
          CALL VADD(WRK(L2I+L1I+1),1,WRK(L2I+1),1,WRK(L2I+1),1,L1I)
C         from L1 to NATL
          DO NC = 1, NATI
            VAL = ZERO
            DO L = 1, IND(NC+1) - IND(NC)
             MU  = IND(NC) + L
             VAL = VAL     + WRK(L2I+MU)
            END DO
            DQI(NC,IPS) = DQI(NC,IPS) + VAL
          END DO
        END DO
        CALL SHIFT_TRIANGLE_DER_CLEAR(NAT,IAT,L2I,IND,
     *       WRK(L2I*2+L3I+L1I+1))
      END DO
C     Check
c     write(6,'("www Q^a",I3)') IFG
c     call prsq(dqi,nat*3,nat,nat)
C
      INDI = INDFRG(JFG)
      DO I = 1, NATJ
        IAG = IATFRG(INDI+I-1)
        CALL DCOPY(3,FMOC(1,IAG),1,C(1,I+NAT),1)
        ISPE(I+NAT)   = ISPEFMO(IAG)
        IND(NAT+I+1)  = IND(NAT+I) + MAXANG(ISPE(I+NAT))**2
        IAGLOB(NAT+I) = IAG
      END DO
      NAT     = NAT + NATJ
C
      CALL ESDHSS_DOMEGIJ(OMGDI,NATI,OMGDJ,NATJ,QI,DQI,QJ,DQJ,
     *     X(LGAMMA),FCM,NC1,GAMH,IAGLOB,X(LGAMMA3),SCAL)
C     For I frag
      CALL ESDHSS_CNTSHSS(NATI,OMGI,OMGDI,PSI,L2I,FCM,NC1,WRK,DI,
     *     L1I,IAGLOB,NAT,DI(1+L3I*2),SCAL)
      !! density matrix is scaled with SCAL on exit
C
C     For J frag
      INDI   = INDFRG(JFG)
      IND(1) = 0
      NAT    = NATJ
      DO I = 1, NAT
        IAG      = IATFRG(INDI+I-1)
        IAGLOB(I)= IAG
        CALL DCOPY(3,FMOC(1,IAG),1,C(1,I),1)
        ISPE(I)  = ISPEFMO(IAG)
        IND(I+1) = IND(I) + MAXANG(ISPE(I))**2
      END DO
      INDI = INDFRG(IFG)
      DO I = 1, NATI
        IAG = IATFRG(INDI+I-1)
        CALL DCOPY(3,FMOC(1,IAG),1,C(1,I+NAT),1)
        ISPE(I+NAT)   = ISPEFMO(IAG)
        IND(NAT+I+1)  = IND(NAT+I) + MAXANG(ISPE(I+NAT))**2
        IAGLOB(NAT+I) = IAG
      END DO
      NAT     = NAT + NATI
C
      CALL ESDHSS_CNTSHSS(NATJ,OMGJ,OMGDJ,PSJ,L2J,FCM,NC1,WRK,DJ,
     *     L1J,IAGLOB,NAT,DJ(1+L3J*2),SCAL)
C
C     IF (NBODY.EQ.3) THEN
C       DO IXYZ=1,nc1
C         DO JXYZ=1,IXYZ
C           DUM = (FCM(IXYZ,JXYZ) + FCM(JXYZ,IXYZ))*HALF
C           FCM(IXYZ,JXYZ) = DUM
C           FCM(JXYZ,IXYZ) = DUM
C         END DO
C       END DO
C     END IF
C
      RETURN
      END
C
C*MODULE FMOHSS  *DECK ESDHSS_DOMEGIJ
C>
C>    @brief   FMO-DFTB Hessian
C>
C>    @details Hessian for ESDHSS_DOMEGIJ
C>
C>    @author  hiroya nakata
C>    - Feb, 2016- Subroutine writte
C>
C>           --- INPUT ---
C>    @param NATI    Number of atoms in I fragment
C>    @param NATJ    Number of atoms in J fragment
C>    @param QI      Charge Q  in Fragment I
C>    @param DQI     Derivative of Charge Q  in Fragment I
C>    @param QJ      Charge Q  in Fragment J
C>    @param DQJ     Derivative of Charge Q  in Fragment J
C>    @param DI      Density matrix in Fragment I
C>    @param GAMMA   Gamma
C>    @param NC1     Size of Hessian matrix
C>    @param GAMH    Second derivative of Gamma
C>    @param IAGLOB  label for atoms
C>    @param GAMMA3  Gamma for DFTB3
C>    @param SCAL    Scalefactor
C>           --- OUTPUT ---
C>    @param OMGDI   Derivative of Omega for I fragment
C>    @param OMGDJ   Derivative of Omega for J fragment
C>    @param FCM     Hessian matrix
C>
      SUBROUTINE ESDHSS_DOMEGIJ(OMGDI,NATI,OMGDJ,NATJ,
     *  QI,DQI,QJ,DQJ,GAMMA,FCM,NC1,GAMH,IAGLOB,GAMMA3,SCAL)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXSPE=10)
      PARAMETER (ZERO=0.0D+00,ONETHIRD=1.0D+00/3.0D+00)
      PARAMETER (TWO=2.0D+00,ONE=1.0D+00)
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
c     Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C
C
      DIMENSION OMGDI(NATI,*),OMGDJ(NATJ,*)
      DIMENSION QI(*),DQI(NATI,*),QJ(*),DQJ(NATJ,*)
      DIMENSION GAMMA(12,NSPE,NSPE),GAMH(*),FCM(nc1,*),IAGLOB(*)
      DIMENSION GAMMA3(10,NSPE,NSPE)
C
      DO 200 LAT=1,NATJ
        IF (QJ(LAT).EQ.ZERO) GOTO 200
        JSP = ISPE(NATI+LAT)
        LGZ = (IAGLOB(LAT+NATI)-1)*3
        DO 100 IAT =1,NATI
          ISP   = ISPE(IAT)
          IGZ   = (IAGLOB(IAT)-1)*3
C
          DIST2 = (C(1,IAT) - C(1,NATI+LAT))**2
     *          + (C(2,IAT) - C(2,NATI+LAT))**2
     *          + (C(3,IAT) - C(3,NATI+LAT))**2
          DIST  = SQRT(DIST2)
          DIST3 = DIST2*DIST
          IF (DIST.EQ.ZERO) GOTO 100
          DISTI = 1.0D+00/DIST
          GAMMAV0= DFTB_GAM2(DIST,DISTI,GAMMA(1,ISP,JSP),DAMPXH,
     *                       DAMPXHE,SPE(ISP),SPE(JSP))
C         OMGI & OMGJ XXX
C         OMGI(IAT)= OMGI(IAT)+GAMMAV0*QJ(LAT)
C         OMGJ(LAT)= OMGJ(LAT)+GAMMAV0*QI(IAT)
c         GAMMAV1= GAMD_FMO2(DIST,GAMMAD(1,ISP,JSP),DAMPXH,
c    *                       DAMPXHE,SPE(ISP),SPE(JSP))
          CALL GAMH_FMO2(GAMMAV1,GAMMAV2,GRD3I,HSS3I,GRD3J,HSS3J,DIST,
     *         NATI+LAT, IAT,GAMH)
c         write(6,'("CHK=",2F12.8)') GAMMAV1,GAMTMP
          GAMTMP1 = GAMMAV1
          GAMTMP2 = GAMMAV2
          IF(DFTB3) THEN
            GAMTMP1=GAMTMP1 +(GRD3I*QI(IAT) + GRD3J*QJ(LAT))*ONETHIRD
            GAMTMP2=GAMTMP2 +(HSS3I*QI(IAT) + HSS3J*QJ(LAT))*ONETHIRD
          END IF
C
C         GET ddg/dadb*qi*qJ
          DO KI=1,3
            VALI  =  C(KI,IAT)-C(KI,LAT+NATI)
            DO KJ=1,3
             VALJ  =  C(KJ,IAT)-C(KJ,LAT+NATI)
             VAL   =  VALI*VALJ*GAMTMP2/DIST2
     *             -  VALI*VALJ*GAMTMP1/DIST3
             IF(KI.EQ.KJ) VAL = VAL + GAMTMP1/DIST
             VAL   =  VAL*QI(IAT)*QJ(LAT)*SCAL
C            IAT*KI,IAT*KJ
             FCM(IGZ+KI,IGZ+KJ)=FCM(IGZ+KI,IGZ+KJ)+VAL
c            LAT*KI,LAT*KJ
             FCM(LGZ+KI,LGZ+KJ)=FCM(LGZ+KI,LGZ+KJ)+VAL
c            IAT*KI,LAT*KJ
             FCM(IGZ+KI,LGZ+KJ)=FCM(IGZ+KI,LGZ+KJ)-VAL
c            LAT*KI,IAT*KJ
             FCM(LGZ+KI,IGZ+KJ)=FCM(LGZ+KI,IGZ+KJ)-VAL
C            For symmetry IJ,JI
c            IF(KI.NE.KJ) THEN
c             FCM(IGZ+KJ,IGZ+KI)=FCM(IGZ+KJ,IGZ+KI)+VAL
c             FCM(LGZ+KJ,LGZ+KI)=FCM(LGZ+KJ,LGZ+KI)+VAL
c             FCM(LGZ+KJ,IGZ+KI)=FCM(LGZ+KJ,IGZ+KI)-VAL
c             FCM(IGZ+KJ,LGZ+KI)=FCM(IGZ+KJ,LGZ+KI)-VAL
c            END IF
            END DO
          END DO
C         GET dg/dr*qj
C         GET dg/dr*qi
          DO KI=1,3
           VALIJ  =  C(KI,IAT)-C(KI,LAT+NATI)
C
           VALTMPI =  ZERO
           VALTMPJ =  ZERO
           IF(DFTB3) THEN
            VALTMPI=(GRD3I*QI(IAT)*TWO+GRD3J*QJ(LAT))*QJ(LAT)*ONETHIRD
            VALTMPJ=(GRD3J*QJ(LAT)*TWO+GRD3I*QI(IAT))*QI(IAT)*ONETHIRD
            VALTMPI=VALTMPI*VALIJ/DIST
            VALTMPJ=VALTMPJ*VALIJ/DIST
           END IF
C
C
           VALJI  =  QI(IAT)*GAMMAV1*VALIJ/DIST
           VALIJ  =  QJ(LAT)*GAMMAV1*VALIJ/DIST
C
C
c          SHIFT(NI) = SHIFT(NI) + VAL
C          Indice for Hess
           lgixyz  =  IGZ  + KI
           lglxyz  =  LGZ  + KI
C
C          OMEGA for J potential
           LI      =  (IAT-1)      * 3 + KI
           LJ      =  (LAT-1+NATI) * 3 + KI
           OMGDI(IAT,LI)= OMGDI(IAT,LI) + VALIJ + VALTMPI
           OMGDI(IAT,LJ)= OMGDI(IAT,LJ) - VALIJ - VALTMPI
C          OMEGA for I potential
           LI      =  (IAT-1+NATJ) * 3 + KI
           LJ      =  (LAT-1)      * 3 + KI
           OMGDJ(LAT,LI)= OMGDJ(LAT,LI) + VALJI + VALTMPJ
           OMGDJ(LAT,LJ)= OMGDJ(LAT,LJ) - VALJI - VALTMPJ
C
C          dg/da*ql*QDIJ^b
           IF (SCAL.NE.ONE) THEN
             VALIJ   = VALIJ  *SCAL
             VALJI   = VALJI  *SCAL
             VALTMPI = VALTMPI*SCAL
             VALTMPJ = VALTMPJ*SCAL
           END IF
           do itmp=1,nati
             igtmp=iaglob(itmp)
             do ixyz=1,3
              ifxyz = (itmp -1)*3+ixyz
              igxyz = (igtmp-1)*3+ixyz
              VAL   = (VALIJ+VALTMPI)*DQI(IAT,ifxyz)
C             JFG*IFG couple
              FCM(lglxyz,igxyz)=FCM(lglxyz,igxyz)-VAL
C             IFG*IFG
              FCM(lgixyz,igxyz)=FCM(lgixyz,igxyz)+VAL
c             NO b<-->a contributions
             end do
           end do
C          dg/da*QDL^b*DQIJ
           do itmp=1,natj
             igtmp=iaglob(itmp+nati)
             do ixyz=1,3
              ifxyz = (itmp -1)*3+ixyz
              igxyz = (igtmp-1)*3+ixyz
              VAL   = (VALJI+VALTMPJ)*DQJ(LAT,ifxyz)
C             IFG*LFG couple
              FCM(lgixyz,igxyz)=FCM(lgixyz,igxyz)+VAL
C             LFG*LFG
              FCM(lglxyz,igxyz)=FCM(lglxyz,igxyz)-VAL
             end do
           end do
C
          END DO
C
          IF (DFTB3) THEN
            CALL DFTB_GAM3(DIST,DISTI,GAMI,GAMJ,HUBB(ISP),HUBB(JSP),
     *        GAMMA3(1,ISP,JSP),GAMMA3(1,JSP,ISP),DAMPXH,DAMPXHE,
     *        SPE(ISP),SPE(JSP))
            GAMI = GAMI * HUBDER(ISP)
            GAMJ = GAMJ * HUBDER(JSP)
c
            GAMTMPIJ= ONETHIRD*TWO*(GAMI*QI(IAT)+GAMJ*QJ(LAT))
C           GAMTMPJ = ONETHIRD*TWO*(GAMJ*QJ(LAT)+GAMI*QI(IAT))
C           OMGI & OMGJ XXX
C           TMPI     = ONETHIRD*(TWO*GAMI*QI(IAT)+GAMJ*QJ(LAT))*QJ(LAT)
C           TMPJ     = ONETHIRD*(TWO*GAMJ*QJ(LAT)+GAMI*QI(IAT))*QI(IAT)
C           OMGI(IAT)= OMGI(IAT)+TMPI
C           OMGJ(LAT)= OMGJ(LAT)+TMPJ
C
          END IF
C
C         GET g* dqj/ dr
          DO LAT2=1,NATJ
            lgtmp=lat2+nati
            DO JXYZ=1,3
              LXYZ            = (LAT2 -1) * 3 + JXYZ
              LGXYZ           = (lgtmp-1) * 3 + JXYZ
c             IXYZ            = NATIJ*3        + LXYZ
              OMGDI(IAT,LGXYZ)= OMGDI(IAT,LGXYZ)+DQJ(LAT,LXYZ)*GAMMAV0
              IF(DFTB3) OMGDI(IAT,LGXYZ)=
     *                  OMGDI(IAT,LGXYZ)+DQJ(LAT,LXYZ)*GAMTMPIJ
C
              IF(DFTB3) THEN
                OMGDJ(LAT,LXYZ)= OMGDJ(LAT,LXYZ)
     *                     + TWO*ONETHIRD*GAMJ*QI(IAT)*DQJ(LAT,LXYZ)
              END IF
            END DO
          END DO
C         GET g* dqi/ dr
          DO IAT2=1,NATI
            lgtmp=iat2+natj
            DO JXYZ=1,3
              IXYZ            = (IAT2 -1) * 3  + JXYZ
              IGXYZ           = (lgtmp-1) * 3  + JXYZ
              OMGDJ(LAT,IGXYZ)= OMGDJ(LAT,IGXYZ)+DQI(IAT,IXYZ)*GAMMAV0
              IF(DFTB3) OMGDJ(LAT,IGXYZ)=
     *                  OMGDJ(LAT,IGXYZ)+DQI(IAT,IXYZ)*GAMTMPIJ
C
              IF(DFTB3) THEN
                OMGDI(IAT,IXYZ)= OMGDI(IAT,IXYZ)
     *                     + TWO*ONETHIRD*GAMI*QJ(LAT)*DQI(IAT,IXYZ)
              END IF
            END DO
          END DO
C
C
 100    CONTINUE
 200  CONTINUE
C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK ESDHSS_CNTSHSS
C>
C>    @brief   FMO-DFTB Hessian
C>
C>    @details Hessian for ES-DIMER
C>
C>    @author  hiroya nakata
C>    - Feb, 2016- Subroutine writte
C>
C>           --- INPUT ---
C>    @param NATI    Number of atoms in Fragment I
C>    @param OMG     Omega
C>    @param OMGD    Omega derivatives
C>    @param PS      Derivative of overlap matrix
C>    @param L1      Size of molecular orbital
C>    @param L2      Size of triangular matrix
C>    @param NC1     Size of Hessian matrix
C>    @param WRK     WRK space
C>    @param DI      Density matrix in Fragment I
C>    @param IAGLOB  label for atoms
C>    @param NATIJ   total number of atoms in fragmet I and J
C>    @param SIJ     Overlap matrix
C>    @param SCAL    Scalefactor
C>           --- OUTPUT ---
C>    @param FCM     Hessian matrix
C>
      SUBROUTINE ESDHSS_CNTSHSS(NATI,OMG,OMGD,PS,L2,FCM,NC1,WRK,DI,
     *     L1,IAGLOB,NATIJ,SIJ,SCAL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Parameter (ONE=1.0D+00,HALF=0.5D+00)
      Parameter (MXATM=2000,MXSPE=10)
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
C
      DIMENSION omg(*),OMGD(NATI,*),PS(L2,*)
      DIMENSION FCM(nc1,*)
      DIMENSION WRK(*),DI(*)
      DIMENSION IAGLOB(*),SIJ(*)
C
      L3 = L1*L1
C
      !! WRK has 4*L3 space
      CALL CPYTSQ(SIJ,WRK,L1,1)
      CALL CPYTSQ(DI,WRK(L3+1),L1,1)
      !! SD
      CALL MRARBR(WRK,L1,L1,L1,WRK(L3+1),L1,L1,WRK(L3*2+1),L1)
      DO IATM=1,NATIJ
        IAZ=IAGLOB(IATM)
        DO KI=1,3
          IXYZ = (IATM-1) * 3 + KI
          IZXYZ= (IAZ -1) * 3 + KI
C         SIJ*OMEGA_AB^b  -->    D*SIJ*OMEG*D
          !! D*SHIFT
          CALL CPYTSQ(DI,WRK(L3+1),L1,1)
          CALL DS_SHIFT(L1,NATI,WRK(L3+1),OMGD(1,IXYZ))
          !! (D*SHIFT)*SD
          CALL MRARBR(WRK(L3+1),L1,L1,L1,WRK(L3*2+1),L1,L1,
     *                WRK(L3*3+1),L1)
          CALL DAXPY(L3,-HALF,WRK(L3*3+1),1,WRK(L3+1),1)
          CALL SQ2TRI(L1,L1,WRK(L3+1),WRK(L3*3+1),ONE*SCAL)
C
C         DDA*OMEGA_AB^b
          DO JAT=1,NATI
            JAZ = (IAGLOB(JAT)-1)*3
            JIXYZ = (JAT-1)*3
            NN=IND(JAT)
            FCM(JAZ+1,IZXYZ)  = FCM(JAZ+1,IZXYZ)
     *        + DDOT(L2-NN,WRK(L3*3+1+NN),1,PS(NN+1,JIXYZ+1),1)
            FCM(JAZ+2,IZXYZ)  = FCM(JAZ+2,IZXYZ)
     *        + DDOT(L2-NN,WRK(L3*3+1+NN),1,PS(NN+1,JIXYZ+2),1)
            FCM(JAZ+3,IZXYZ)  = FCM(JAZ+3,IZXYZ)
     *        + DDOT(L2-NN,WRK(L3*3+1+NN),1,PS(NN+1,JIXYZ+3),1)
          END DO
        END DO
      END DO
C
      IF (SCAL.NE.ONE) CALL DSCAL(L2,SCAL,DI,1)
      CALL FMO2DER_HSPOT(DI,L2,omg,IAGLOB,FCM,NATI,WRK)
C
      RETURN
      END
C
C*MODULE FMOHSS  *DECK ESDHSS_OMEGA
C>
C>    @brief   FMO-DFTB Hessian
C>
C>    @details Calculate Omega for ES-DIMER
C>
C>    @author  hiroya nakata
C>    - Feb, 2016- Subroutine writte
C>
C>           --- INPUT ---
C>    @param NATI    Number of atoms in Fragment I
C>    @param NATJ    Number of atoms in Fragment J
C>    @param QI      Charge Q  in Fragment I
C>    @param QJ      Charge Q  in Fragment J
C>    @param GAMMA   Gamma
C>    @param GAMMA3  Gamma for DFTB3
C>           --- OUTPUT ---
C>    @param OMGI    Omega for fragment I
C>    @param OMGJ    Omega for fragment J
C>
      SUBROUTINE ESDHSS_OMEGA(OMGI,NATI,OMGJ,NATJ,QI,QJ,GAMMA,GAMMA3)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXSPE=10)
      PARAMETER (ONETHIRD=1.0D+00/3.0D+00,TWO=2.0D+00)
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
c     Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C
      DIMENSION OMGI(NATI),OMGJ(NATJ),QI(*),QJ(*)
      DIMENSION GAMMA(12,NSPE,NSPE),GAMMA3(10,NSPE,NSPE)
C
C
      DO 200 LAT=1,NATJ
C       IF (QJ(LAT).EQ.ZERO) GOTO 200
        JSP = ISPE(NATI+LAT)
        DO 100 IAT =1,NATI
          ISP   = ISPE(IAT)
          DIST  = (C(1,IAT) - C(1,NATI+LAT))**2
     *          + (C(2,IAT) - C(2,NATI+LAT))**2
     *          + (C(3,IAT) - C(3,NATI+LAT))**2
          IF (DFTB3) THEN
            CALL DFTB_GAM23(0,DIST,GAMMAV,GAMI,GAMJ,
     *           GAMMA(1,ISP,JSP),GAMMA3(1,ISP,JSP),GAMMA3(1,JSP,ISP),
     *           DAMPXH,DAMPXHE,SPE(ISP),SPE(JSP),HUBDER(ISP),
     *           HUBDER(JSP),DFTB3)
            TMPI     = ONETHIRD*(TWO*GAMI*QI(IAT)+GAMJ*QJ(LAT))*QJ(LAT)
            TMPJ     = ONETHIRD*(TWO*GAMJ*QJ(LAT)+GAMI*QI(IAT))*QI(IAT)
            OMGI(IAT)= OMGI(IAT)+TMPI
            OMGJ(LAT)= OMGJ(LAT)+TMPJ
          ELSE
            DIST = SQRT(DIST)
            DISTI = 1.0D+00/DIST
            GAMMAV = DFTB_GAM2(DIST,DISTI,GAMMA(1,ISP,JSP),DAMPXH,
     *        DAMPXHE,SPE(ISP),SPE(JSP))
          END IF
          OMGI(IAT) = OMGI(IAT) + GAMMAV*QJ(LAT)
          OMGJ(LAT) = OMGJ(LAT) + GAMMAV*QI(IAT)
 100    CONTINUE
 200  CONTINUE
C
      RETURN
      END
C
C*MODULE FMOHSS  *DECK DFTB_CALC_QDDQ
C>
C>    @brief   FMO-DFTB Hessian
C>
C>    @details Calculate delta (delta Q)*QIJ^a for FMO-DFTB3
C>
C>    @author  Yoshio Nishimoto
C>    - Feb, 2016- Subroutine writte
C>
C>           --- INPUT ---
C>    @param IFG     Current fragment index I
C>    @param JFG     Current fragment index J
C>    @param KFG     Current fragment index K (FMO3)
C>    @param QD      dq/da for dimer IJ or trimer IJK
C>    @param QDI     dq/da for monomer I
C>    @param QDJ     dq/da for monomer J
C>    @param QDK     dq/da for monomer K
C>    @param CHAMUL  delta q for IJ or IJK
C>    @param NATIJ   Number of atoms for IJ or IJK
C>    @param NATI    Number of atoms for I
C>    @param NATJ    Number of atoms for J
C>    @param NATK    Number of atoms for K
C>    @param INDAT   Converts global atomic location to fragment index
C>    @param IAGLOB  Global index of atom
C>    @param IALOC   Converts global to local (fragment) atomic location
C>    @param INDBD   Something about BDA or BAA
C>    @param INDFRG  First atom of each fragment in terms of NATFMOB?
C>    @param ZREF    Nuclear charges of a given atom
C>    @param POPMAT  Mulliken population
C>           --- OUTPUT ---
C>    @param QDDQ    delta (delta Q)*QIJ^a
C>
C
      SUBROUTINE DFTB_CALC_QDDQ(IFG,JFG,KFG,QD,QDDQ,QDI,QDJ,QDK,CHAMUL,
     *           NATIJ,NATI,NATJ,NATK,INDAT,IAGLOB,IALOC,INDBD,INDFRG,
     *           ZREF,POPMAT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /FMCOM / X(1)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2,MAXRIJ
C
      DIMENSION QD(*),QDDQ(*),QDI(*),QDJ(*),QDK(*),CHAMUL(*),INDFRG(*),
     *          ZREF(*),POPMAT(MAXNAT,*)
C
C     QD: Q derivative
C     DQ: delta Q
      CALL VALFM(LOADFM)
      LDQI   = LOADFM + 1
      LDQJ   = LDQI   + NATI
      LQDI   = LDQJ   + NATJ
      LQDJ   = LQDI   + NATI*NATI*3
      LAST   = LQDJ   + NATJ*NATJ*3
      IF (KFG.NE.0) THEN
        LDQK = LAST
        LQDK = LDQK   + NATK
        LAST = LQDK   + NATK*NATK*3
      END IF
      NEED   = LAST   - LOADFM     - 1
      CALL GETFM(NEED)
C
      CALL DCOPY(NATIJ*NATIJ*3,QD ,1,   QDDQ,1)
      CALL DCOPY(NATI*NATI*3  ,QDI,1,X(LQDI),1)
      CALL DCOPY(NATJ*NATJ*3  ,QDJ,1,X(LQDJ),1)
      IF (KFG.NE.0) CALL DCOPY(NATK*NATK*3,QDK,1,X(LQDK),1)
C
C     (delta QIJ)*QIJ^a
      DO I = 1, NATIJ
        CALL DSCAL(NATIJ*3,CHAMUL(I),QDDQ(I),NATIJ)
      END DO
C
C     Prepare delta QI
      CALL DCOPY(NATI,POPMAT(1,IFG),1,X(LDQI),1)
      INDI = INDFRG(IFG)
      DO I = 1, NATI
        X(LDQI+I-1) = X(LDQI+I-1) - ZREF(INDI+I-1)
      END DO
C     (delta QI)*QI^a
      DO I = 1, NATI
        CALL DSCAL(NATI*3,X(LDQI+I-1),X(LQDI+I-1),NATI)
      END DO
C
      CALL DCOPY(NATJ,POPMAT(1,JFG),1,X(LDQJ),1)
      INDI = INDFRG(JFG)
      DO I = 1, NATJ
        X(LDQJ+I-1) = X(LDQJ+I-1) - ZREF(INDI+I-1)
      END DO
C     (delta QJ)*QJ^a
      DO I = 1, NATJ
        CALL DSCAL(NATJ*3,X(LDQJ+I-1),X(LQDJ+I-1),NATJ)
      END DO
C
C     For (delta QK)*QK^a for FMO3
      IF (KFG.NE.0) THEN
        CALL DCOPY(NATK,POPMAT(1,KFG),1,X(LDQK),1)
        INDI = INDFRG(KFG)
        DO I = 1, NATK
          X(LDQK+I-1) = X(LDQK+I-1) - ZREF(INDI+I-1)
        END DO
        DO I = 1, NATK
          CALL DSCAL(NATK*3,X(LDQK+I-1),X(LQDK+I-1),NATK)
        END DO
      END IF
C
C     (delta QIJ)*QIJ^a - (delta QI)*QI^a - (delta QJ)*QJ^a
      CALL GETDQIJPOT(IFG,JFG,KFG,QDDQ,NATIJ,X(LQDI),NATI,
     *      X(LQDJ),NATJ,X(LQDK),NATK,INDAT,IAGLOB,IALOC,INDBD)
C
      CALL RETFM(NEED)
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_QDDQ
