C 18 Apr 16 - YN  - updates for FMO 5.2
c 22 Sep 15 - HL  - update QuanPol
C 29 Sep 14 - YN  - Implement Density-Functional Tight-Binding Method
C
C*MODULE DFTBX     *DECK DFTBX
C>
C>    @brief General DFTB energy calculation
C>
C>    @details Calculate DFTB energy.  Different from RHFCL and UHFOP,
C>             this subroutine treats both R and U.
C>             Supported wave function:
C>               Restricted closed-shell DFTB
C>               Same-electron restricted open-shell DFTB (not RO-HF)
C>               Unrestricted closed-shell DFTB
C>             This is a copy of RHFCL
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @data Yoshio Nishimoto
C>    - Feb, 2016- Added PCM etc.
C>
C>    @param SZ
C>    @param S2
C>
C
      SUBROUTINE DFTBX(SZ,S2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL PACK2E,OUT,SOME,PRDENS,DIRSCF,FDIFF,SCHWRZ,
     *        CVGED,CVGING,CVDENS,CVENGY,CVDIIS,
     *        DODIIS,DAMPH,EXTRAH,VSHIFT,RSTRCT,RSTRSV,DEM,DEMOFF,
     *        NOTOPN,GOPARR,DSKWRK,MASWRK,TDSKWRK,MASPRT,
     *        ABINIT,MINMEM,VTSCAL,VIROK,LVCLN,IZRFLS,
     *        SOSCF0,SOSCF,EIGAVL,FT15OP,MFRZ,IPCFP,
     *        ISGDDI,PAROUT,INITGDDI,DOAFO,DOAFO1,
     *        FMOEX,FMOPL,LCFLAG,LRINT,LCFLAGS,LRINTS,
     *        SG1,DC,DCCHG,DCABC,locopt,wasgddi,MLGDDI,
     *        UHFCHK,RESET,MOM,inmem15
c    *        CVGSVP,CVGSVPDN,CVGSVPDN1,CVGSVPNR
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB,TBROYDEN
      LOGICAL INGUESS,LETEMP,INORB,MOMFL,DFTD,ROHFGAMESS,mdout
C
      DOUBLE PRECISION MOROKM, MD
      CHARACTER*6 METHOD
C
      DIMENSION TIMSTR(3)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXGSH=30, MXG2=MXGSH*MXGSH,
     *           MXATM=2000, MXFRG=1050, MXAO=8192,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12,
     *           MXRT=100, MXGRID=10)
      PARAMETER (NITDIR=10)
      PARAMETER (MXSPE=10)
C
      COMMON /ACONV / RRSHFT,EXTTOL,DMPTOL,VSHTOL,IEXTIN
      COMMON /ATHEAT/ ATHEAT
      COMMON /CDSPRT/ GCDS,AREACDS
      COMMON /CONV  / DENTOL,EN,ETOT,EHF,EHF0,DIFF,ITER,ICALP,ICBET
      COMMON /DEMOPT/ DEMCUT,IDEM
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBMX/ SIMPLE,ITYPMX,TBROYDEN
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBRE/ REPCUT(MXSPE,MXSPE),NUMREP(MXSPE,MXSPE),
     *                LREPINTV(MXSPE,MXSPE),LREPSHORT(MXSPE,MXSPE),
     *                LREPCOEFF(MXSPE,MXSPE)
      COMMON /DFTBS / LS
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
      COMMON /DFTDC / DC,IDCVER,DCCHG,DCABC,DCSR,DCS6,DCS8,DCALP,DCA1,
     *                DCA2
      COMMON /DFTPAR/ DFTTYP(20),EXENA,EXENB,EXENC,IDFT34,NAUXFUN,
     *                                                    NAUXSHL
      COMMON /DIISSO/ SOGTOL,ETHRSH,MAXDII,IRAF
      COMMON /DMPING/ SHIFTO,SHIFTV,DMPCUT,SWDIIS,DIRTHR
      COMMON /EAIPCM/ LEAIP
      COMMON /EFLDC / EVEC(3),EFLDL !! FOR RAMAN ACTIVITY
      LOGICAL :: EFLDL
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP
      COMMON /EFPBUF/ POLCHG(10),NBUFMO,LBUFF(MXAO),LBF,NAPOL,IAPOL(10)
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /EFPIO / MULMAT(MXFRG)
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT1,SZ1,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FFENGY/ EN12,EN123,EN123R4,EN123B4,EN234W1,ENCHAR,ENLJR,
     *                ENLJD,ENPOL,XENPOL,ENRXN,XENRXN,ENRXNPOL,ENRXNR,
     *                ENCENT,ENUCCH,ENCMAP,ENPOT,ENKIN,ENTOT
      COMMON /FFFIXS/ ENFIXSO,FIXEPS,FIXTOL,FIXA,FIXQ,RALLMM,RALLQM,
     *                RADMM(200),RADQM(200),NRADMM,NRADQM,IFIXSOL,
     *                LFFDAI,LFFDAIT,LFFIDDAI,LFFIDTMP,LFFTMPTS,
     *                LFFAFIX,LFFIDATOM,LFFRFIX,LFFQFIX,NTSATM,
     *                LFFQFIXMP,LFFQFIXTA,LFFQFIXXY,
     *                LFFXTSFIX,LFFYTSFIX,LFFZTSFIX,
     *                LFFVFIX1,LFFVFIX2,NCYCLE,MXFFTS,NFFTS
      COMMON /FFPARM/ NFFAT,NBOND,NANGL,NDIHR,NDIHB,NCMAP,NWAGG,
     *                N1213J,N14J,NLKQMM,IDOCHG,IDOPOL,IDOLJ,IDOCMAP
      COMMON /FMCOM / X(1)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      COMMON /FMODTB/ LGAMMAGLOB,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,MODFD,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,LIACTFG,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FUNCT / ENERGY,EGRAD(3,MXATM)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INDDIP/ TMUX,TMUY,TMUZ,TMUXD,TMUYD,TMUZD,MINMEM
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /LMOEDA/ GDTOLA,GJTOLA,GKTOLA,TKTOLA,VTOLA,
     *                GDTOLB,GJTOLB,GKTOLB,TKTOLB,VTOLB,
     *                ECORL,EXCOR
C     COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /MACHSW/ KDIAGG,ICORFL,IXDR,MODIO,mem10,lpnt10,mem10m
      COMMON /MEXOPT/ MEXSKPGES,MEXSTATE
      COMMON /MFRPAR/ MFRZ,NUMFRZ,NORFRZ,IFRZ(MXAO)
      COMMON /MOM   / MOM,KPROJ
      COMMON /N2ELCT/ N2EL
      COMMON /NEOJOB/ NEORUN,NELERM
      COMMON /NLRC  / LCFLAG,EMU,EMU2,LRFILE
      COMMON /NLRCF / LRINT
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMCHG/ PB,PX,PC,UNZ,QNUC,FN,FE,UNZOR,PORT
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMEFP/ PB_MUL,PC_MUL,PB_POL,PC_POL,P_FF,P_NF,P_FN,P_I,
     *                P_IBIS,P_J,P_NUCC,P_NUCCBIS,ENPCM
      COMMON /PCMITR/ RCUT(2),THRES,IPCMIT,IMUL,MXDIIS,NREG,MXITR1,
     *                MXITR2,MODPAP
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM,IHET
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED,LEPSPCM
      COMMON /PCMPRT/ GCAVP,GCAVS,GDISP,GREP,EHFGAS
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RUNLAB/ TITLE2(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      EQUIVALENCE (TITLE,TITLE2)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
      COMMON /SCFWFN/ AROHF(3),BROHF(3),PACAVO(6),IACAVO,IUHFNO,ICUHF,
     *                MVOQ
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /SOLSMX/ SOLA,SOLB,SOLC,SOLG,SOLH,SOLN,ISMX
      COMMON /SOSYM/  EULANG(4,48),GAM(48,48),IRMON(MXAO)
      COMMON /STBCHK/ UHFCHK,NHOMO,NLUMO
      COMMON /SVPOPT/ ISVP,NSVP,MTHSVP,NCAV,NVLPL,IQP
      COMMON /VIRIAL/ SCALTE,SCALTT,GVIR,VTCONV,MAXVT,VTSCAL,VIROK,LVCLN
      COMMON /VVOPAR/ IVVOS,NVVOS,BNDDEN
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /ZRFPAR/ GZRF,FIND(3),GNUCF,EBORN,DIELEC,IZRF,ICALC
C
C     COSMO INFORMATION
C
      LOGICAL ISEPS, USEPS
      COMMON /ISEPS / ISEPS, USEPS
      LOGICAL COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
      COMMON /COSDAT/ SE2,SECORR,QVCOSMO,ELAST,EMP2COS,EMP2LAST,
     *                COSVOL,COSSAR,EDIEL,EOC1,DEOC_RS,SUMQSC,
     *                SUMQSCOLD,ZSUM,ZSUM2,ZSUM3,FEPSI,RDS,DISEX2,
     *                EPSI,COSRAD,DISEX,OUTCHG,EDIEL_SAVE,
     *                MAXNPS,ICORR,ITRIP,NQS,MP2TRIP,MP2ITER,
     *                ICFREQ,NSPA,NSPH,NPSD,NPS,NPS2,NDEN,NPSPHER,
     *                COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
C
      LOGICAL LRDFLG,MLTINT,DOLRD
      COMMON /LRDISP/ ELRD6,ELRD8,ELRD10,EMULT,LRDFLG,MLTINT,DOLRD
C
      PARAMETER (ZERO=0.0D+00, HALF=0.5D+00, ONE=1.0D+00, TWO=2.0D+00,
     *           FIVE=5.0D+00, TEN=1.0D+01, SMALL=1.0D-08,
     *           PT2=0.2D+00, TWOPT2=2.2D+00, DMPTLC=1.0D-02)
C
      SAVE FT15OP
C
      DATA FT15OP/.FALSE./
C
      DATA RHF/8HRHF     /
      DATA ROHF/8HROHF    /
      DATA UHF/8HUHF     /
      DATA  CHECK/8HCHECK   /, DEBUG/8HDEBUG   /, DBUGME/8HRHFCL   /
      DATA MOROKM/8HMOROKUMA/,  HESS/8HHESSIAN /, OPTMZE/8HOPTIMIZE/
      DATA   AMEX/8HMEX     /,    MD/8HMD      /
      DATA  G3MP2/8HG3MP2   /
      DATA  COMP /8HCOMP    /
      DATA NONE/4HNONE/
      DATA RAMAN/8HRAMAN   /

      DOUBLE PRECISION :: SHIFT(NAT),SHIFT2(NAT),SHIFT3(NAT*2),
     * CTIJ(NAT),CTIJ2(NAT),SHIFTS(NSHELL)

C     LOGICAL :: TEST

      INGUESS = .FALSE.
      INORB   = .FALSE.
      MOMFL   = .FALSE.
      IF (FDIFF) THEN
C       IF (MASWRK) THEN
C         WRITE (IW,*) " FDIFF=.TRUE. IS NOT IMPLEMENTED AT ALL."
C         WRITE (IW,*) " TURN OFF FDIFF FLAG"
C       END IF
        FDIFF   = .FALSE. !! IT'S NOT IMPLEMENTED
      END IF
C
      IF (LRDFTB.AND..NOT.SCC) LRDFTB = .FALSE.
      IF (LRDFTB.AND.MASWRK) THEN
        WRITE (IW,*) "- TURN ON THE PRELIMINARY VERSION OF LONG-RANGE"
        WRITE (IW,*) "  CORRECTION FOR DFTB"
      END IF
      mdout=nfg.eq.0.or.(runefp.ne.md.or.iand(modio,16).eq.0)
c    *      .and.iand(nprfmo,3).lt.2
      if (iand(nprfmo,3).eq.3) mdout=.false.
C
      ROHFGAMESS=.FALSE.
      IF (SCFTYP.EQ.ROHF) THEN
        DO I = 1, NSPE
          DO J = 1, 6
            IF (SPNCST(J,I).NE.ZERO) THEN
              ROHFGAMESS=.TRUE.
              EXIT
            END IF
          END DO
        END DO
      END IF
C
      IF (ROHFGAMESS) THEN
        IF (MASWRK) THEN
          WRITE (IW,*) "WHEN SCFTYP=ROHF, REMOVE SPNCST OPTION"
          WRITE (IW,*) "RO-DFTB HAS NOT BEEN DONE."
        END IF
        CALL ABRT
      END IF
C
      IF (SCFTYP.EQ.UHF.AND..NOT.SCC) THEN
        WRITE (IW,*) " SCFTYP=UHF  + SCC=.FALSE. IS AVAILABLE"
        WRITE (IW,*) " SCFTYP=ROHF + SCC=.FALSE. INSTEAD"
        CALL ABRT
      END IF
C
C     ----- CLOSED SHELL HF-SCF CALCULATION -----
C     C.C.J.ROOTHAAN, REV.MOD.PHYS.  23,69-89(1951)
C
C     ----- UNRESTRICTED HF-SCF CALCULATION -----
C     J.A.POPLE AND R.K.NESBET   J.CHEM.PHYS. 22, 571 (1954)
C
C     ----- HIGH SPIN RESTRICTED OPEN SHELL HF-SCF CALCULATION -----
C     M.F.GUEST AND V.SAUNDERS   MOL.PHYS. 28, 819 (1974)
C     AND SEE ALSO THE GAMESS MANUAL CHAPTER -REFS.DOC- ON THE
C     SUBJECT OF FOLDING F-ALPHA, F-BETA INTO A ROHF FOCK MATRIX.
C     FOR ROHF, WE EXIT WITH F-ALPHA AND F-BETA ON DIRECT ACCESS
C     RECORDS 14 AND 18, AND THE COMBINED FOCK MATRIX ON RECORD 51.
C
      ABINIT = MPCTYP.EQ.NONE
C
      IF (SCFTYP.EQ.RHF) THEN
        METHOD='RDFTB '
        LENMTH = LSTRNG(METHOD,6)
      ELSE IF (SCFTYP.EQ.UHF) THEN
         IF (ICUHF.EQ.0) THEN
           METHOD='UDFTB '
           LENMTH = LSTRNG(METHOD,6)
         ELSE
           METHOD='CUDFTB'
           LENMTH = LSTRNG(METHOD,6)
         ENDIF
      ELSE
         METHOD='RODFTB'
         LENMTH = LSTRNG(METHOD,6)
      END IF
C
      inmem15=iand(modio,64).ne.0.and.scftyp.eq.rhf
      IZRFLS = IZRF.NE.0
      IPCFP=.FALSE.
C
C        SET UP THE CASE OF BOTH EFP AND PCM MODELS BEING USED TOGETHER
C
      IF(IPCM.EQ.1 .AND. IEFP.EQ.1) THEN
         IPCM=0
         IEFP=0
         IPCFP=.TRUE.
      ELSE
         IPCFP=.FALSE.
      END IF
C
      FMOEX=NFG.NE.0.AND.IFMOSTP.EQ.4.AND.IPIEDA.NE.0
      FMOPL=NFG.NE.0.AND.IFMOSTP.EQ.2.AND.IPIEDA.NE.0.AND.IRSTSTP.EQ.2
     *      .AND.MXITFG.EQ.1
      DOAFO=MFRZ.AND.NFG.NE.0.AND.IAND(MODLMO,4).EQ.0
      DOAFO1=.NOT.DOAFO.AND.RFLMO(1).NE.0 !! PREPARE LOCALIZED ORBITALS
C
      OUT    = .FALSE.
      SOME   = .FALSE.
      PRDENS = .FALSE.
      IF(MASWRK) THEN
        OUT    = NPRINT.EQ. 5 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
        SOME   = NPRINT.NE.-5 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
        PRDENS = NPRINT.GT. 8 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
        OUT    = OUT .AND. NPRTGO.NE.2
        SOME   = SOME .AND. NPRTGO.NE.2
        PRDENS = PRDENS .AND. NPRTGO.NE.2
      END IF
      MASPRT = MASWRK  .AND.  NPRTGO.NE.2 .AND.
     *   (NFG.EQ.0.OR.IAND(NPRFMO,3).LE.1).AND. (RUNTYP.NE.MD)
C
      IF(MASPRT.AND.(NFG.EQ.0.OR.NPRINT.NE.-5)) THEN
        IF (SCC) THEN
          WRITE (IW,9001) ! METHOD(1:LENMTH)
        ELSE
          WRITE (IW,9000) !NCC-DFTB
        END IF
        IF(SCFTYP.EQ.UHF  .AND.  ICUHF.EQ.1) WRITE(IW,9002)
      END IF
C
      IF (ETEMP.LE.ZERO) THEN
        LETEMP = .FALSE.
      ELSE
        LETEMP = .TRUE.
        IF (SCFTYP.NE.RHF) THEN
          IF (MASWRK) WRITE (IW,*) "ELECTRONIC TEMPERATURE FOR UHF OR
     * ROHF IS NOT CURRENTLY SUPPORTED."
          LETEMP = .FALSE.
          CALL ABRT
        END IF
      END IF
C
C     ----- START THE CLOCKS -----
C
      TIM0 = ZERO
      TIM1 = ZERO
      CALL TSECND(TIM0)
      TLEFTS = TIMLIM - TIM0
C
C     ----- SELECT CONVERGENCE PROCEDURES(S) -----
C
      EXTRAH = MOD(MCONV,2)  .EQ. 1
      DAMPH  = MOD(MCONV,4)  .GE. 2
      VSHIFT = MOD(MCONV,8)  .GE. 4
      RSTRCT = MOD(MCONV,16) .GE. 8
      DODIIS = MOD(MCONV,32) .GE.16
      DEM    = MOD(MCONV,64) .GE.32
      SOSCF0 = MOD(MCONV,128).GE.64
      LOCOPT = MOD(MCONV,256).GE.128
      reset  = MOD(MCONV,512).GE.256
      RSTRSV = RSTRCT
C        IF WE ARE SWITCHING LATER, WE NEED TO ALLOCATE STORAGE FOR
C        THE SOSCF, BUT BE SURE SOSCF IS TURNED OFF BEFORE ITERS START.
      SOSCF  = SOSCF0 .OR.  SWDIIS.GT.0.0D+00
C
C     ----- SET POINTERS FOR PARTITIONING OF MEMORY -----
C
      IF(RUNTYP.EQ.MOROKM) THEN
C        CALL STRHF(NUM,NA,NB,NE,NST,LL1,LL2,LL3,DOMBAS)
         WRITE (IW,*) " MOROKM SHOULD NOT BE SET FOR DFTB CALCULATION"
         CALL ABRT
      ELSE
         NST = 1
         LL1 = NUM
         LL2 = (LL1*LL1+LL1)/2
         LL3 = LL1*LL1
      END IF
C
      L0 = NQMT
      L1 = NUM
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
C
      MAXIT2=(MAXIT*MAXIT+MAXIT)/2
C
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
C
C     ----- GET MEMORY -----
C
      IFUHF = 1
      IF(SCFTYP.EQ.ROHF) IFUHF=0
C
      CALL VALFM(LOADFM)
      CALL GOTFM(NGOTMX)
      LSCR  = LOADFM + 1
      LIWRK = LSCR   + L1*9!8
      LIWRK1= LIWRK  + MAX(L1,NAT+1)
      LWRK  = LIWRK1 + L1
      LWRK1 = LWRK   + L1
      LWRK2 = LWRK1  + LL3
      LWRK3 = LWRK2  + LL3
      LEIG  = LWRK3  + LL3
      LOCC  = LEIG   + LL1
      LFAO  = LOCC   + L1
      LD    = LFAO   + LL2
      LVEC  = LD     + LL2
      LAST  = LVEC   + LL3
      LAOC  = LOCC
      LDA   = LD
      LFA   = LFAO
      LEA   = LEIG
      LVA   = LVEC
      IF (SCFTYP.EQ.UHF.OR.SCFTYP.EQ.ROHF) THEN
        LVB  = LAST
        LDB  = LVB    + L3 * IFUHF
        LFB  = LDB    + L2
        LEB  = LFB    + L2
        LBOC = LEB    + L1 * IFUHF
        LWRK4= LBOC   + L1
        LAST = LWRK4  + L3
      END IF
      IF(SCFTYP.EQ.ROHF) THEN
         LVB = LVA
         LEB = LEA
      END IF
C
CD    KDIAG=MOD(KDIAGG,100)
CMKL  IF (KDIAG.EQ.4) THEN
CMKL    LSS  = LAST
CMKL    LAST = LSS + LL3
CMKL  END IF
C
      CALL BASCHK(LMAX)
                    NANGM =  4
      IF(LMAX.EQ.2) NANGM =  6
      IF(LMAX.EQ.3) NANGM = 10
      IF(LMAX.EQ.4) NANGM = 15
      IF(LMAX.EQ.5) NANGM = 21
      IF(LMAX.EQ.6) NANGM = 28
      MAXG = NANGM**4
C
      MINTMX=NINTMX
      IF(NINTIC.NE.0) MINTMX=0
C     MEMORY IS ALLOCATED ELSEWHERE
CNB   FANCY OPTIONS (LOOK FOR NINTMX BELOW) WILL NOT WORK WITH
C     IN CORE INTEGRALS
C
      IF(ABINIT) THEN
         IF(DIRSCF) THEN
            LBUF  = LAST
            LIBUF = LAST
            LXINTS= LAST
            LGHOND= LXINTS + NSH2
            LDSH  = LGHOND + MAXG
            LDDIJ = LDSH   + NSH2
            LAST  = LDDIJ  + 49*MXG2
         ELSE
            LXINTS= LAST
            LGHOND= LAST
            LDSH  = LAST
            LDDIJ = LAST
            LBUF  = LAST
            LIBUF = LBUF   + MINTMX
            LAST  = LIBUF  + MINTMX
         END IF
         IF(NINTIC.NE.0) THEN
            LBUF  = LBUFPIC
            LIBUF = LIXIC
         END IF
         LTWOEI= LAST
         LPTOT2= LAST
      ELSE
         LXINTS= LAST
         LGHOND= LAST
         LDSH  = LAST
         LDDIJ = LAST
         LBUF  = LAST
         LIBUF = LAST
         LTWOEI= LAST
         LPTOT2= LTWOEI + N2EL
         LAST  = LPTOT2 + NAT*16
      END IF
C
      IF(DODIIS) THEN
         LADIIS = LAST
         LBDIIS = LADIIS + MAXDII*MAXDII
         LPDIIS = LBDIIS + MAXIT2
         LXDIIS = LPDIIS + MAXIT
         LIODII = LXDIIS + MAXIT
         LAST   = LIODII + 4*MAXDII
      ELSE
         LADIIS = LAST
         LBDIIS = LAST
         LPDIIS = LAST
         LXDIIS = LAST
         LIODII = LAST
      END IF
C
      IF(MOM) THEN
         LIWRK2 = LAST
         LAST  = LIWRK2 + L1
      ENDIF
C
      IF(DEM) THEN
         LWRK4 = LAST
C        LWRK5 = LWRK4 + L3
         LAST  = LWRK4 + L3
      ELSE
C        LWRK4 = LAST
         LWRK5 = LAST
      END IF
C
C      EXTRA MEMORY FOR APPROXIMATE CORRELATION ADAPTED VIRTUAL ORBITALS
C
      IF(IACAVO.EQ.1) THEN
         LKCORE = LAST
         LKVAL  = LKCORE + L2
         LAST   = LKVAL  + L2
      ELSE
         LKCORE = LAST
         LKVAL  = LAST
      END IF
C
C     -- MEMORY FOR SOLVATION METHODS
C        THE ORDER MUST BE PCM, EFP, PCM/EFP.
C
C         THERE IS A BUG WITH DFT+PCM+DIRSCF+FDIFF, AND A
C         WORKAROUND (AS OPPOSED TO A FIX) IS TO TURN FDIFF OFF.
      IF((IPCFP  .OR.  IPCM.EQ.1)   .AND.  NDFTFG.EQ.1
     *                              .AND.  DIRSCF) FDIFF=.FALSE.
C
      CALL PCMMEM3(IPCFP,L2,LAST,NTSPAR,LSOL,LCHG,LDMATM,LQPOT,LQFLD,
     *             LVPOT,LSE,LDE,LQ0,LQ1,LQ2,LQ3,LD0,LQA,LDIMAT,LQREP,
     *             LTMP0,LTMP1,LTMP2,LIPVT,LPOTTMP,LRMUL,LCHG2,
     *             LASCCRD,LASCCHG,LASCDIP,LASCQAD,LDISV,LDIS1,LDIS2,
     *             LCQEF,LQEFF,LELD,LXDINT,LYDINT,LZDINT,LEFLD,MADD,
     *             LABFLD,LVECMP,LVEC_2,LVEC_S,LAPROJ,LFPROJ)
C
      IF((IZRFLS .OR. IEFP.EQ.1 .OR. IPCFP .OR.NFFAT.GT.0)
     *    .AND. (DIRSCF.AND.FDIFF)) THEN
         NDIPER = LAST
         LDIPER = NDIPER  + L2
         LAST   = LDIPER  + L2
      ELSE
         NDIPER = LAST
         LDIPER = LAST
      END IF
C
C         FOR SOSCF CONVERGER
C
      NFT15=15
      IF (SCFTYP.EQ.RHF) THEN
        NPR=(L0-NA)*NA
      ELSE
        NPRA=(L0-NA)*NA
        NPRB=(L0-NB)*NB
        NPRU=NPRA+NPRB
        NPRO=NPRA+(NA-NB)*NB
      END IF
      ITSO=0
      ORBGRD=ZERO
      lbuf15=Last
      maxso=(maxit-1)/nproc+1
      IF (SCFTYP.EQ.RHF) THEN
        IF(SOSCF) THEN
           LGRAD  = LAST
           LHESS  = LGRAD  + NPR
           LPGRAD = LHESS  + NPR
           LDISPL = LPGRAD + NPR
           LAST   = LDISPL + NPR
           lbuf15 = last
           if(inmem15) last = lbuf15 + npr*3*maxso
        ELSE
           LGRAD  = LAST
           LHESS  = LAST
           LPGRAD = LAST
           LDISPL = LAST
        END IF
      END IF
      IF(SCFTYP.EQ.UHF) THEN
         IF(SOSCF) THEN
            LGRADA = LAST
            LGRADB = LGRADA + NPRA
            LGRADU = LGRADB + NPRB
            LHESSA = LGRADU + NPRU
            LHESSB = LHESSA + NPRA
            LHESSU = LHESSB + NPRB
            LPGRADU= LHESSU + NPRU
            LDISPLU= LPGRADU+ NPRU
            LDISPLA= LDISPLU+ NPRU
            LDISPLB= LDISPLA+ NPRA
            LAST   = LDISPLB+ NPRB
         ELSE
            LGRADA = LAST
            LGRADB = LAST
            LGRADU = LAST
            LHESSA = LAST
            LHESSB = LAST
            LHESSU = LAST
            LPGRADU= LAST
            LDISPLU= LAST
            LDISPLA= LAST
            LDISPLB= LAST
         END IF
      END IF
      IF(SCFTYP.EQ.ROHF) THEN
         IF(SOSCF) THEN
            LGRADA = LAST
            LGRADB = LGRADA+ NPRA
            LGRADO = LGRADB+ NPRB
            LHESSO= LGRADO + NPRO
            LPGRADO= LHESSO + NPRO
            LDISPLO= LPGRADO+ NPRO
            LAST = LDISPLO+ NPRO
         ELSE
            LGRADA = LAST
            LGRADB = LAST
            LGRADO = LAST
            LHESSO = LAST
            LPGRADO= LAST
            LDISPLO= LAST
         END IF
      END IF
C
C     ----- ADD IN GRID-BASED DFT MEMORY -----
C
C        ISWOFF=1 MEANS USE RHF UNTIL THE DENSITY GETS BELOW SWOFF,
C        THIS APPLIES ONLY TO THE VERY FIRST GEOMETRY IN THE RUN.
C
      ISWOFF=0
      HFSSAV=DFTTYP(3)
      NDFTSV=NDFTFG
      IDFTSWITCH=0
      ISWDIR=1
C     ISWDIR TELLS HOW MANY TIMES WE PERMIT TO RECOMPUTE THE FOCK MATRIX
C     USING DIRTHR.
      LCFLAGS=LCFLAG
      LRINTS=LRINT
C
C     allocate memory for cuhf
C
      IF(ICUHF.EQ.1) THEN
         LWRK5 = LAST
         LWRK6 = LWRK5 + L3
         LWRK7 = LWRK6 + L3
         LCEIG = LWRK7 + L3
         LAST  = LCEIG + L1
      ELSE
         LWRK5=LAST
         LWRK6=LAST
         LWRK7=LAST
         LCEIG=LAST
      ENDIF
C
C        WE CAN REDUCE MEMORY NEED BY 2N**2 BY DOING MORE DAREADS,
C        TO OVERLAP -H1- AND -WRK1-, -Q- AND -WRK2-, -S- AND -WRK3-.
C        THERE ARE A NUMBER OF EXOTIC OPTIONS THAT DON'T ENSURE
C        THE OVERLAPPING WILL WORK PROPERLY, SO FORCE THEM INTO THE
C        SEPARATE ALLOCATION.
C
      NEED = LAST - LOADFM - 1
      NSAVE = 2*LL2 + LL3
      NEEDI = NEED + NSAVE
      IF((NEEDI.LT.NGOTMX)  .OR.
     * (DEM .OR. VSHIFT .OR. IZRFLS .OR.
     *  IPCFP. OR. IPCM.EQ.1 .OR. IEFP.EQ.1 .OR. NFFAT.GT.0)) THEN
         MINMEM = .FALSE.
         LH1   = LAST
         !! LH1 AND LH0 HAS TO BE DISTINGUISHED ONLY FOR ESP CALCULATIONS
         !! IN FMO.  LH1 CONTAINS ESP CONTRIBUTIONS, CALCULATED IN DFTBESP
         !! SUBORUTINE (SEE DFTB_NCCMAT).  LH0 DOES NOT HAVE ESP, AND IT
         !! WILL BE USED TO CALCULATE THE EXPECTATION VALUE, OR ZERO-TH
         !! ORDER LIKE TERM, ... OR FIRST TERM OF ENERGY EXPRESSION:
         !!  E = \SUM_I < \Psi | H0 | \Psi >
         !!    = \SUM_I \SUM_{\MU \NU} C_{\MU I} C_{\NU I} H_{\MU \NU}
         LH0   = LH1    + LL2 !! LH1 :: HAMILTONIAN + ESP
         LQ    = LH0    + LL2 !! LH0 :: HAMILTONIAN
         LS    = LQ     + LL3
         LAST  = LS     + LL2
         NEED  = LAST -LOADFM -1
      ELSE
         MINMEM = .TRUE.
         IF(SOME) WRITE(IW,9005) NSAVE
         LH1 = LWRK1
         LQ  = LWRK2
         LS  = LWRK3
      END IF
C
      LVLEFP = LEVELEFP()
C
      IF(LVLEFP.EQ.2) THEN
         DO II=1,NFRG
            IF(MULMAT(II).NE.1) THEN
               WRITE(IW,9008)
               CALL ABRT
            END IF
         END DO
C          THIS MEMORY NEEDED ONLY FOR EFP2'S EXREP
         LVMI    = LAST
         LHMO    = LVMI    + LL3
         LVMITR  = LHMO    + LL2
         LSV     = LVMITR  + ((L1*L1)+L1)/2
         LVECLMO = LSV     + L3
         LAST    = LVECLMO + L3
         NEED = LAST - LOADFM - 1
      END IF
C
C     TEMPORARY ARRAY OF MULLIKEN POPULATIONS
C
      IF (SRSCC.OR.SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
        NDIMGAM = NSHELL
        LSHIFTSH = LAST
        LAST     = LSHIFTSH + NSHELL
      ELSE
        NDIMGAM = NAT
      END IF
      LMUL1  = LAST
      LMUL2  = LMUL1   + NUM      !! LMUL1: CURRENT ATOMIC ORBITAL RESOLVED MULLIKEN POPULATION
      LMUL1A = LMUL2   + NUM      !! LMUL2: OLD ATOMIC ORBITAL RESOLVED MULLIKEN
      LMUL2A = LMUL1A  + NAT      !! LMUL1A: CURRENT ATOM RESOLVED MULLIKEN
      LMUL3A = LMUL2A  + NAT      !! LMUL2A: OLD ATOM RESOLVED MULLIKEN
      LMUL1S = LMUL3A  + NAT      !! LMUL3A: X(LMUL1A) - ZREF
      LMUL2S = LMUL1S  + NSHELL   !! LMUL1S: CURRENT SHELL RESOLVED MULLIKEN
      LMUL3S = LMUL2S  + NSHELL   !! LMUL2S: OLD SHELL RESOLVED MULLIKEN
      LGAMMA = LMUL3S  + NSHELL   !! LMUL3S: X(LMUL1A) - QREFL
      LGAMMA2= LGAMMA  + NDIMGAM*(NDIMGAM+1)/2  !! GAMMA MATRIX
      LSHIFT2= LGAMMA2 + NAT      !! GAMMA MATRIX FOR ESP CALCULATION
      LWRKDG = LSHIFT2 + NAT      !! SHIFT MATRIX MADE IN DFTBESP SUBROUTINE
      LD2    = LWRKDG  + L1*34
      LDIST  = LD2     + L2       !! INITIAL DENSITY MATRIX USED ONLY IN FMO-SCC-DFTB GRADIENT
      LAST   = LDIST   + L2       !! DISTANCE MATRIX
      IF (SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
        LMULB  = LAST
        LMULAB = LMULB  + NUM
        LMULSB = LMULAB + NAT
        LAST   = LMULSB + NSHELL
      END IF
      IF (DFTB3) THEN
        LGAM3 = LAST
        LAST  = LGAM3 + NDIMGAM*NDIMGAM
      ELSE
        LGAM3 = LAST
      END IF
      IF (LRDFTB) THEN
        LLR = LAST
        LAST = LLR + NAT*(NAT+1)/2
      END IF
C
      IF (IPCM.EQ.1.OR.ISEPS) THEN
        LZAN  = LAST
        LHVC  = LZAN   + NAT
        LAST  = LHVC   + L2
      END IF
C
      NEED = LAST - LOADFM - 1
C     ----- GET MEMORY -----
C
      CALL GETFM(NEED)
C
C     ----- INITIALIZE OCCUPATION NUMBERS -----
C
      CALL VCLR(X(LOCC),1,L1)
      IF (SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
        DO I = 1, L1
          X(I+LAOC-1) = ZERO
          X(I+LBOC-1) = ZERO
          IF(I.LE.NA) X(I+LAOC-1) = ONE
          IF(I.LE.NB) X(I+LBOC-1) = ONE
        END DO
      ELSE
        IF (NA.EQ.NB) THEN
          DO 120 I = NST,NA+NST-1
            X(LOCC-1+I) = TWO
  120     CONTINUE
        ELSE
          DO 130 I = NST,NB+NST-1
            X(LOCC-1+I) = TWO
  130     CONTINUE
          DO 135 I = NB+NST,NA+NST-1
            X(LOCC-1+I) = ONE
  135     CONTINUE
        END IF
      END IF
C
C     ----- INITIALIZE VARIABLES -----
C
      NOTOPN = .TRUE.
      IF(MAXIT.LE.0) MAXIT = 30
C
C        LOOSEN CONVERGENCE FOR DIRECT SCF BY JUST A BIT
C
      IF(DIRSCF) THEN
         DENTOL = TWO * CONVHF
         ENGTOL = 1.0D-08
         DIITOL = 1.0D-06
      ELSE
         DENTOL = CONVHF
         ENGTOL = 1.0D-09
         DIITOL = 1.0D-07
      END IF
      IF(NDFTFG.NE.1) THEN
C        SW0=ZERO
C        CREATES PROBLEMS IN FMO WHEN MIXING RHF AND DFT.
      ELSE
C        IF(SW0.LT.CONVHF.AND.SW0.NE.0) THEN
         IF(SW0.LT.CONVHF) THEN
            IF(MASWRK) WRITE(IW,9006) SW0,CONVHF
            CALL ABRT
         END IF
      END IF
      SWDFT = SW0
      IF(NDFTFG.NE.1) SWDFT=ZERO
C
C        AT EARLY POINTS IN GEOMETRY OPTS, WE CAN BE A BIT COARSER,
C        WHENEVER THE LAST GEOMETRY'S GRADIENT WAS STILL BIG.
C
      IF((RUNTYP.EQ.OPTMZE  .OR. RUNTYP.EQ.G3MP2 .OR. RUNTYP.EQ.COMP)
     *   .AND. (NEVALS.GT.0.AND.NFG.EQ.0)) THEN
         GRMS = DDOT(3*NAT,EGRAD,1,EGRAD,1)
         GRMS = SQRT(GRMS/(3*NAT))
                               CFACT =  1.0D+00
         IF(GRMS.GT.0.005D+00) CFACT =  5.0D+00
         IF(GRMS.GT.0.020D+00) CFACT = 20.0D+00
         IF(GRMS.GT.0.100D+00) CFACT = 50.0D+00
         DENTOL = CFACT*DENTOL
         ENGTOL = CFACT*ENGTOL
         DIITOL = CFACT*ENGTOL
         SWDFT  = CFACT*SWDFT
      END IF
C
      DTOL2 = TWO * DENTOL
      ETOL2 = TEN * ENGTOL
      CVDIIS = .FALSE.
      CVGING = .FALSE.
      CVGED  = .FALSE.
C
C     CVGSVP KEEPS TRACK OF WHETHER SVP CHARGES/DIPOLES APPEAR CONVERGED
C
c     CVGSVP    = .FALSE.
c     CVGSVPDN  = .FALSE.
c     CVGSVPDN1 = .FALSE.
c     CVGSVPNR  = .FALSE.
C
      ICCFLG=0
      ITDIIS = 1
      MPUNCH = NPUNCH
      EHF = ZERO
      ETOT= ZERO
      EEXC= ZERO
      ECORL=ZERO
      ITERV= 0
      ICALP = 0
      DAMP = ZERO
      DAMP0 = ZERO
      IF(DMPCUT .LE. ZERO) DMPCUT = ZERO
      RRSHFT = ZERO
      ERDIIS=ZERO
      DIFF = ZERO
      DIFFP= ZERO
CD    DIFFA= ZERO
      DIFFB= ZERO
      DELE = ZERO
      DEAVG = ZERO
      NDAF = 15
      NDAFD = 23
      NDAFA = 23
      NDAFB = 26
      IF(DAMPH .OR. VSHIFT) DAMP = ONE
      NUMDEM = 0
C     FROM UHFOP
      ETHSAV = ETHRSH
CD    ETHNEW = ETHRSH
CD    SOGSAV = SOGTOL
      SOGNEW = SOGTOL
      DIISDMP= 0.9D+00
      NONDMX = 5
      ITNOND = NONDMX
C
      II = 0
      DO 140 I = 1,L1
         IA(I) = II
         II = II + I
  140 CONTINUE
C
C --  C. AMOVILLI AND B. MENNUCCI
C     PCM CALCULATION OF DISPERSION INTERACTION
C     THREE STAGE PROCEDURE:
C      1) IN VACUO CALCULATION
C      2) SOLUTE AVERAGE TRANSITION FREQUENCY
C      3) ADDITION OF SOLVENT INTERACTION MATRICES:
C         ELECTROSTATIC + DISPERSION (+ REPULSION IF IRPCM=1)
C
C      PCM STAGE 1) IN VACUO CALCULATION
C
      ISD=1
      IF(IPCM.EQ.1  .AND.  IDP.EQ.1) THEN
        EN=EN-UNZ
        ISD=0
      END IF
      WA = ZERO
C
C        READ INVERSE D MATRIX FOR PCM (SKIP FOR ITERATIVE SOLVER)
C
      CALL DERCHK(NDER)
      IF(IPCMIT.EQ.0  .AND.  (IPCM.EQ.1 .OR. IPCFP)) THEN
         NTS3 = NTS*NTS
         CALL SEQREW(NFT26)
         IF(NDER.EQ.1.AND.IPCDER.EQ.1) THEN
            CALL SEQADV(NFT26)
            CALL SEQADV(NFT26)
            CALL SEQADV(NFT26)
            CALL SEQADV(NFT26)
         END IF
         IF(IEF.GT.0.AND.IEF.LT.3) THEN
            CALL SEQADV(NFT26)
            CALL SEQADV(NFT26)
            CALL SQREAD(NFT26,X(LSE),NTS3)
            CALL SQREAD(NFT26,X(LDE),NTS3)
         END IF
         CALL SQREAD(NFT26,X(LDMATM),NTS3)
         CALL SEQREW(NFT26)
      END IF
C
C     PCM STAGE 3) ADDITION OF SOLVENT INTERACTION MATRICES:
C
  333 CONTINUE
      IF(IPCM.EQ.1 .AND. IDP.EQ.1 .AND. ISD.EQ.1) THEN
         EN=EN+UNZ
         IF(SOME) WRITE(IW,9007) UNZ,EN
         IF(SOME) WRITE(IW,*)
         IF(DIRSCF  .AND.  FDIFF) THEN
            IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
            CALL DAWRIT(IDAF,IODA,X(LH1),LL2,14,0)
            CALL VCLR(X(LWRK1),1,L2)
         END IF
         GO TO 101
      END IF
C
      IF (IPCM.EQ.1.OR.ISEPS) THEN
        CALL DCOPY(NAT,ZAN,1,X(LZAN),1)
        CALL DCOPY(NAT,ZREF,1,ZAN,1)
      END IF
C
C     ----- CALCULATE EREP -----
C     EN : REPULSION ENERGY (ORIGINALLY NUCLEAR REPULSION)
C
      CALL VCLR(X(LDIST),1,L2)
      CALL DFTB_EREP(NAT,C,ISPE,NSPE,NUMREP,REPCUT,X(LREPINTV(1,1)),
     &       X(LREPSHORT(1,1)),X(LREPCOEFF(1,1)),EN,X(LDIST),ZREF,QREF)
C     IF (IPCM.EQ.1.AND.(IEF.EQ.1.OR.IEF.EQ.0)) THEN
      IF (IPCM.EQ.1.AND.IPCMIT.EQ.0) THEN
         EN=EN+UNZ
         IF(SOME) WRITE(IW,9007) UNZ,EN
         IF(SOME) WRITE(IW,*)
      END IF
C
C     ----- PRINT SCF OPTIONS -----
C
      IF(MASPRT.AND.(NFG.EQ.0.OR.NPRINT.NE.-5)) THEN
         IF(SOME) WRITE(IW,9010) EN,EN*27.21138386D+00,
     &                  MAXIT,MPUNCH,EXTRAH,DAMPH,
     *                  VSHIFT,RSTRCT,DODIIS,DEM,SOSCF
         IF(NDFTFG.NE.1) THEN
            WRITE(IW,9012) DENTOL
         ELSE
            WRITE(IW,9013) DENTOL,SWDFT,SWOFF
         END IF
         IF(SOME  .AND.  VTSCAL) WRITE(IW,9015) VTSCAL,MAXVT,VTCONV
         IF(SOME  .AND.  ROHFGAMESS) WRITE(IW,9031)
     *                              (AROHF(I),I=1,3),(BROHF(I),I=1,3)
         IF(SOME  .AND.  SOSCF) THEN
           IF (SCFTYP.EQ.RHF) THEN
             WRITE(IW,9017) NPR,SOGTOL
           ELSE IF(SCFTYP.EQ.ROHF) THEN
              WRITE(IW,9018) NPRO,SOGTOL
           ELSE
              WRITE(IW,9019) NPRA,NPRB,SOGTOL
           END IF
         END IF
         IF(SOME) THEN
           IF (SCFTYP.EQ.RHF) THEN
             WRITE(IW,9020) NEED
           ELSE
             WRITE(IW,9021) NEED
           END IF
          END IF
      END IF
C
C     ----- GET GAMMA VALUES -----
C
      IF (SCC) THEN
        CALL DFTB_GAMMA(DAMPXHE,HUBBL,X(LGAMMA),X(LDIST),NAT,NSPE,
     *    ISPE,MAXANG,SPE,DAMPXH,SRSCC)
        IF (DFTB3) THEN
          IF (SRSCC) THEN
             WRITE (IW,*) "SORRY, DFTB3=.TRUE. AND SRSCC=.TRUE. NOT YET"
C            CALL ABRT
          END IF
          CALL VCLR(X(LGAM3),1,NDIMGAM*NDIMGAM)
          CALL DFTB_GAMMA3(NAT,HUBBL,X(LGAM3),X(LDIST))
        END IF
        IF (LRDFTB) THEN
          !! numerical intergration
          ELR = 0.0D+00
          omega = 0.33d+00
          omega = dampxhe
          WRITE (*,*) "CALCULATE GAMMA VALUES FOR RANGE-SEPARATED DFTB"
          WRITE (*,*) "OMEGA = ", OMEGA
          pi = 3.14159265359d+00
          DO I = 1, NAT
            DO J = 1, I
              DIST = (C(1,I)-C(1,J))**2
     *             + (C(2,I)-C(2,J))**2
     *             + (C(3,I)-C(3,J))**2
              DIST = SQRT(DIST)
              R = DIST
              ta = HUBB(ISPE(I))*3.2D+00
              tb = HUBB(ISPE(J))*3.2D+00
              ta4 = ta**4.0d+00
              tb4 = tb**4.0d+00
              tmp = 0.0d+00
              CALL DFTB_CNVSQ(I,J,NSEQ)
              IF (DIST.GT.0.0D+00) THEN
                do K = 1, 10000
                  xval = dble(K)/1.0d+03
                  tval = sin(xval*r)/
     *              (xval*(xval*xval+ta*ta)**two*(xval*xval+tb*tb)**two)
     *              * exp(-xval*xval/(omega**two*4.0d+00))
                  tmp = tmp + tval/1.0d+04
C                 if (tval.le.1.0d-08) exit
                end do
                X(LLR+NSEQ-1) = tmp*two*ta4*tb4/(pi*r)
              ELSE
                do K = 1, 10000
                  xval = dble(K)/1.0d+03
                  tval = 1.0d+00/
     *              (xval*(xval*xval+ta*ta)**two*(xval*xval+tb*tb)**two)
     *              * exp(-xval*xval/(omega**two*4.0d+00))
                  tmp = tmp + tval/1.0d+04
C                 if (tval.le.1.0d-08) exit
                end do
                X(LLR+NSEQ-1) = tmp*two*ta4*tb4/pi
              END IF
C             WRITE (*,*) I, J, X(LLR+NSEQ-1)
            END DO
          END DO
        END IF
      END IF
C
C     ----- EXCHANGE INTEGRALS FOR DIRECT SCF THRESHOLD TESTS -----
C
      NINT=0
      NSCHWZ=0
      IF(DIRSCF.AND.ABINIT) THEN
         SCHWRZ = ISCHWZ.GT.0
         IF(MASPRT) WRITE(IW,9030) SCHWRZ,FDIFF,DIRTHR,NITDIR
         IF(SCHWRZ) CALL EXCHNG(X(LXINTS),X(LGHOND),X(LDDIJ),
     *                          NSH2,MAXG,INTTYP)
      ELSE
         SCHWRZ=.FALSE.
      END IF
C
C     ----- READ BARE NUCLEUS HAMILTONIAN -----
C     ----- READ OVERLAP INTEGRALS -----
C     ----- READ INITIAL DENSITY MATRIX -----
C     ----- READ SYMMETRY ADAPTED Q MATRIX -----
C     L0 = NUMBER OF CANONICAL ORTHONORMAL VECTORS KEPT.
C
      IF(.NOT.MINMEM) THEN
C        !! BARE NUCLEUS HAMILTONIAN INTEGRALS
         CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
C        !! OVERLAP INTEGRALS
         CALL DAREAD(IDAF,IODA,X(LS) ,LL2,12,0)
C        !! SYMMETRY ADAPTED Q MATRIX
         CALL DAREAD(IDAF,IODA,X(LQ) ,LL3,45,0)
C        !! SYMMETRY ADAPTED Q MATRIX
         IF (NFG.GT.0.AND.SCC) THEN
           IF (DOAFO1) THEN
             CALL VCLR(X(LH0),1,LL2)
             CALL VCLR(SHIFT2,1,NAT)
             IF (DFTB3) CALL VCLR(SHIFT3,1,NAT*2)
           ELSE
             CALL DAREAD(IDAF,IODA,X(LH0),LL2,564,0)
             CALL DAREAD(IDAF,IODA,SHIFT2,NAT,566,0)
             IF (DFTB3) THEN
               CALL DAREAD(IDAF,IODA,SHIFT3,NAT*2,567,0)
C              CALL DCOPY(NAT,SHIFT2,1,X(LSHIFT2),1)
             END IF
           END IF
         ELSE
           CALL DAREAD(IDAF,IODA,X(LH0),LL2,11,0)
C          CALL DCOPY(L2,X(LH1),1,X(LH0),1)
         END IF
      END IF
      !! ALPHA DENSITY MATRIX
C     CALL DAREAD(IDAF,IODA,X(LD),LL2,16,0)
C
C     INITIALIZE X(LVEC), X(LD), X(LWRK1)
C
      CALL VCLR(X(LVEC),1,LL3)
      CALL VCLR(X(LD),1,LL2)
      CALL VCLR(X(LEIG),1,LL1)
      CALL VCLR(X(LWRK1),1,LL3)
      IF (SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
        CALL VCLR(X(LVB),1,LL3)
        CALL VCLR(X(LDB),1,LL2)
        CALL VCLR(X(LFB),1,LL2)
        CALL VCLR(X(LEB),1,LL1)
        CALL VCLR(X(LSHIFTSH),1,NSHELL)
      END IF
      CALL VCLR(SHIFTS,1,NSHELL)
      IF (IPCM.EQ.1.OR.NFMOPCM.NE.0) THEN
        IF (IODA(16).NE.-1) THEN
          CALL DAREAD(IDAF,IODA,X(LD),LL2,16,0)
        ELSE
          NSEQ = 0
          DO IAT = 1, NAT
            DO M = 1, MAXANG(ISPE(IAT))*MAXANG(ISPE(IAT))
              MU = IND(IAT)+M
              NSEQ = NSEQ + MU
              IF (M.EQ.1) X(LD+NSEQ-1) = QREF(ISPE(IAT))
            END DO
          END DO
        END IF
        IF (NFMOPCM.EQ.0) THEN
          IF (IODA(565).NE.-1) THEN
            CALL DAREAD(IDAF,IODA,X(LHVC),LL2,565,0)
          ELSE
            LHVC = 0
          END IF
        END IF
      END IF
C
C     ----- IF NOT INITIAL CALCULATION, CALCULATE MULLIKEN ATOMIC POPULATION -----
C
      IF (.NOT.EFLDL.OR.NFG.NE.0) THEN
        IF (.NOT. IODA(556).EQ.-1) INGUESS = .TRUE.
        IF (.NOT. IODA(557).EQ.-1) INGUESS = .TRUE.
      END IF
      IF (INGUESS) THEN
        IF (MASWRK.AND.SOME) WRITE (IW,*) "    INITIAL GUESS IS READ"
C       CALL DAREAD(IDAF,IODA,X(LD),LL2,16,0)
        IF (.NOT.SRSCC) THEN
          CALL DAREAD(IDAF,IODA,X(LMUL1A),NAT,556,0)
          CALL DCOPY(NAT,X(LMUL1A),1,X(LMUL2A),1)
        END IF
        IF (SRSCC.OR.SCFTYP.EQ.UHF) THEN
          CALL DAREAD(IDAF,IODA,X(LMUL1S),NSHELL,557,0)
C         write (*,*) "guess shell charge"
C         do i = 1, nshell
C           write (*,*) i,x(lmul1s+I-1)
C         end do
          CALL DFTB_SHIFT_SHTOA(X(LMUL1S),X(LMUL2A),NAT,NSHELL,NSPE,
     *      ISPE,MAXANG)
          CALL DCOPY(NAT,X(LMUL2A),1,X(LMUL1A),1)
          CALL DCOPY(NSHELL,X(LMUL1S),1,X(LMUL2S),1)
        END IF
        IF (IODA(558).NE.-1.AND.SCFTYP.EQ.UHF)
     *    CALL DAREAD(IDAF,IODA,X(LMULSB),NSHELL,558,0)
        IF (NFG.NE.0.AND.SCC.AND.JCURFG.NE.0.AND.NDER.GT.0) then
          CALL DAREAD(IDAF,IODA,x(LD2),LL2,16,0)
          CALL DCOPY(L2,X(LD2),1,X(LD),1)
        END IF
      ELSE
        IF (NFG.EQ.0) CALL DFTB_INIT_CS(X(LMUL2A),X(LMUL2S),X(LMULSB),
     *    ZREF,QREFL,NAT,NSHELL,NSPE,ISPE,IND,MAXANG,INGUESS,SRSCC,
     *    SCFTYP.EQ.UHF)
        IF (.NOT.INGUESS) THEN
          DO I = 1, NAT
            X(LMUL2A+I-1) = ZREF(I)
          END DO
          IF (SRSCC) THEN
            ISH = 0
            DO I = 1, NAT
              DO J = 1, MAXANG(ISPE(I))
                ISH = ISH + 1
                X(LMUL2S+ISH-1) = QREFL(J,ISPE(I))
              END DO
            END DO
          END IF
        END IF
        CALL DCOPY(NAT,X(LMUL2A),1,X(LMUL1A),1)
        IF (SRSCC) CALL DCOPY(NSHELL,X(LMUL2S),1,X(LMUL1S),1)
      END IF
      IF (LRDFTB) THEN
        N = 0
        DO I = 1, NAT
          DO J = 1, MAXANG(ISPE(I))**2
            N = N + 1
            X(LMUL2+N-1) = X(LMUL2A+ISPE(I)-1)/(MAXANG(ISPE(I))**2)
          END DO
        END DO
        CALL DCOPY(L1,X(LMUL2),1,X(LMUL1),1)
      END IF
C
      IF (IODA(15).NE.-1) INORB=.TRUE.
      IF (INORB) THEN
        IF (MASWRK.AND.SOME) WRITE (IW,*)
     *          "    INITIAL ORBITAL IS READ"
        CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
        IF (IODA(19).NE.-1.AND.SCFTYP.EQ.UHF)
     *    CALL DAREAD(IDAF,IODA,X(LVB),LL3,19,0)
        IF (.NOT.INGUESS) THEN
          IF (MASWRK) WRITE (IW,*)
     *            "    INITIAL GUESS IS MADE FROM ORBITALS"
          IF (OUT) THEN
            WRITE (*,*) "DEBUG OUTPUT OF INITIAL ORBITAL"
            CALL PREV(X(LVEC),X(LEIG),L0,L1,L1)
          END IF
          INGUESS = .TRUE.
          CALL DFTB_DMTOCC(X(LD),X(LVEC),X(LOCC),X(LWRK3),L1,L1)
          CALL DFTB_MULLIKEN(L1,L2,X(LD),X(LS),X(LMUL1))
          CALL DFTB_MULSA(X(LMUL1),X(LMUL1S),X(LMUL1A),NUM,NSHELL,NAT)
          IF (SCFTYP.EQ.UHF) THEN
            CALL DFTB_DMTOCC(X(LDB),X(LVB),X(LBOC),X(LWRK3),L1,L1)
            CALL DFTB_MULLIKEN(L1,L2,X(LDB),X(LS),X(LMULB))
            CALL DFTB_MULSA(X(LMULB),X(LMULSB),X(LMULAB),NUM,NSHELL,NAT)
            CALL DAXPY(NAT,ONE,X(LMULAB),1,X(LMUL1A),1)
            CALL DCOPY(NSHELL,X(LMUL1S),1,X(LWRK),1)
            CALL DAXPY(NAT,ONE,X(LMULSB),1,X(LMUL1S),1)
            CALL VSUB(X(LMULSB),1,X(LWRK),1,X(LMULSB),1,NSHELL)
          END IF
          CALL DCOPY(NAT,X(LMUL1A),1,X(LMUL2A),1)
          IF (SRSCC) THEN
            ISH = 0
            DO I = 1, NAT
              DO J = 1, MAXANG(ISPE(I))
                ISH = ISH + 1
                X(LMUL1S+ISH-1) = X(LMUL1S+ISH-1) - QREFL(J,ISPE(I))
              END DO
            END DO
            CALL DCOPY(NSHELL,X(LMUL1S),1,X(LMUL2S),1)
          END IF
          IF (OUT) THEN
            WRITE (*,*) "DEBUG OUTPUT OF MULLIKEN CHARGES"
            DO I = 1, NAT
              WRITE (*,'(I3,X,F8.5)') I,X(LMUL1A+I-1)
            END DO
          END IF
        END IF
      ELSE
        CALL VCLR(X(LVEC),1,L3)
        CALL DAWRIT(IDAF,IODA,X(LVEC),L3,15,0)
        IF (SCFTYP.EQ.UHF) CALL DAWRIT(IDAF,IODA,X(LVB),L3,19,0)
      END IF
C
      DO I = 1, NAT
        X(LMUL3A+I-1) = X(LMUL1A+I-1) - ZREF(I)
      END DO
      IF (SRSCC) THEN
        ISH = 0
        DO I = 1, NAT
          DO J = 1, MAXANG(ISPE(I))
            ISH = ISH + 1
            X(LMUL3S+ISH-1) = X(LMUL1S+ISH-1) - QREFL(J,ISPE(I))
          END DO
        END DO
      END IF
C
      TBROYDEN=.TRUE.
      MEMMIX = 0
      IF (ITYPMX.EQ.-1) THEN
        TBROYDEN=.FALSE.
      ELSE
        SOSCF  = .FALSE.
        SOSCF0 = .FALSE.
        DODIIS = .FALSE.
        DAMPH  = .FALSE.
        EXTRAH = .FALSE.
        CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
        IF (IODA(19).NE.-1.AND.SCFTYP.EQ.UHF)
     *    CALL DAREAD(IDAF,IODA,X(LVA),LL3,19,0)
      END IF
C
      IF (SOSCF.AND.LETEMP) THEN
        WRITE (IW,*) " SOSCF CANNOT BE COMBINED WITH ELECTRONIC
     * TEMPERATURE."
        WRITE (IW,*)
        CALL ABRT
      END IF
C
      IF(SOSCF) THEN
         CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
         CALL DAREAD(IDAF,IODA,X(LEIG),LL1,17,0)
         if (.not.inmem15) then
           TDSKWRK = DSKWRK
           DSKWRK = .FALSE.
           IF(.NOT.FT15OP) THEN
              FT15OP = .TRUE.
             CALL SEQOPN(NFT15,'WORK15','UNKNOWN',.FALSE.,'UNFORMATTED')
              CALL SEQREW(NFT15)
           ELSE
              CALL SEQREW(NFT15)
           END IF
           DSKWRK = TDSKWRK
          end if
      END IF
      IF (DODIIS) THEN
        CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
        IF (SCFTYP.EQ.UHF) CALL DAREAD(IDAF,IODA,X(LVB),LL3,19,0)
        !! MAKE DIIS INITIAL GUESS
        NSEQ = 1
        NN = 1
        DO I = 1, NAT
          DO J = 1, MAXANG(ISPE(I))
            DO K = J, J*J
              IF (J.EQ.1) X(LD+NSEQ-1) = QREFL(J,ISPE(I))
              IF (J.EQ.2) X(LD+NSEQ-1) = QREFL(J,ISPE(I))*0.33333333D+00
              IF (J.EQ.3) X(LD+NSEQ-1) = QREFL(J,ISPE(I))*0.2D+00
              NN = NN + 1
              NSEQ = NSEQ + NN
            END DO
          END DO
        END DO
        CALL DSCAL(L2,DBLE(NA)/DBLE(L1),X(LD),1)
      END IF
C
C     ----- SWITCH OFF ELECTRONIC TEMPERATURE IF SOSCF -----
C     ELECTRONIC TEMPERATURE DOES NOT FIT WELL WITH SOSCF MAYBE BECAUSE
C     EIGENVALUES ARE NOT UPDATED.
      IF (SOSCF .AND. LETEMP) THEN
        LETEMP = .FALSE.
        WRITE (IW,*) " ELECTRONIC TEMPERATURE IS SWITCHED OFF"
        WRITE (IW,*) " USE DIIS FOR FRACTIONAL OCCUPATION"
      END IF
C
C     ----- PREVIOUS DENSITY IS ZERO, PREVIOUS FOCK MAT. IS HCORE -----
C
      IF(DIRSCF  .AND.  FDIFF) THEN
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
         CALL DAWRIT(IDAF,IODA,X(LH1),LL2,14,0)
         CALL VCLR(X(LWRK1),1,L2)
      END IF
C
C     ----- IF SCRF SAVE PRISTINE ONE ELEC. HAM. -----
C     -----    AND READ IN DIPOLE INTEGRALS      -----
C
      IF(IZRFLS) THEN
         CALL DAREAD(IDAF,IODA,X(LXDINT),LL2,95,0)
         CALL DAREAD(IDAF,IODA,X(LYDINT),LL2,96,0)
         CALL DAREAD(IDAF,IODA,X(LZDINT),LL2,97,0)
      END IF
      IF(IZRFLS  .OR.  IEFP.EQ.1  .OR.  IPCFP  .OR.  ISVP.EQ.1  .OR.
     *   NFFAT.GT.0 ) THEN
         CALL DAWRIT(IDAF,IODA,X(LH1),LL2,87,0)
      END IF
C
      IF(EXETYP.EQ.CHECK) THEN
         GO TO 520
      END IF
C
C     CHECK DISPERSION AGAIN (DFTINP INITIALIZES DC FLAG)
C
      DFTD = .FALSE.
      IF (IDFTBD.NE.0) DC = .TRUE.
      IF (IDFTBD.EQ.3) DFTD = .TRUE.
C
C     ----- PRINT OUT THE DIAGONALIZATION METHOD -----
C     DIAGONALIZATION WITH MATH KERNEL LIBRARY (KDIAG=4) IS THE FASTEST
C
C     IF (MASWRK.AND.SOME) THEN
C       IF (KDIAG.EQ.0) THEN
C         WRITE (IW,'(" KDIAG = ", I2,X,"(",A8,")")') KDIAG, "EVVRSP ?"
C       ELSE IF (KDIAG.EQ.1) THEN
C         WRITE (IW,'(" KDIAG = ", I2,X,"(",A8,")")') KDIAG, " EVVRSP "
C       ELSE IF (KDIAG.EQ.2) THEN
C         WRITE (IW,'(" KDIAG = ", I2,X,"(",A8,")")') KDIAG, " GIVEIS "
C       ELSE IF (KDIAG.EQ.3) THEN
C         WRITE (IW,'(" KDIAG = ", I2,X,"(",A8,")")') KDIAG, " JACOBI "
C       ELSE IF (KDIAG.EQ.4) THEN
C         WRITE (IW,'(" KDIAG = ", I2,X,"(",A8,")")') KDIAG, " DSYGV  "
C       END IF
C     END IF
C
C     ----- PRINT ITERATION HEADER -----
C
      IF(MASPRT) THEN
         IF(NBUFMO.GT.0) THEN
            WRITE(IW,9039)
         END IF
         IF(DAMPH  .OR.  VSHIFT) THEN
            IF(SOSCF) THEN
               IF(.NOT.DIRSCF) WRITE(IW,9040)
               IF(     DIRSCF) WRITE(IW,9050)
            ELSE
               IF(.NOT.DIRSCF) WRITE(IW,9045)
               IF(     DIRSCF) WRITE(IW,9055)
            END IF
         ELSE
            IF(SOSCF) THEN
               IF(.NOT.DIRSCF) WRITE(IW,9060)
               IF(     DIRSCF) WRITE(IW,9070)
            ELSE
               IF(.NOT.DIRSCF) WRITE(IW,9065)
               IF(     DIRSCF) WRITE(IW,9075)
            END IF
         END IF
         CALL FLSHBF(IW)
      END IF
C
C     ----- CALCULATE GUESSED-DENSITY MATRIX FOR ONSAGER MODEL -----
C     CHARGES ARE NOT CONSIDERED AT ALL.
C
      IF (IZRFLS) THEN
        K = 0
        DO I = 1, NAT
          NREFORB = MAXANG(ISPE(I))**2
          PUTEL = QREF(ISPE(I))/DBLE(NREFORB)
          DO J = 1, NREFORB
            K = K + 1
            NSEQ = K*(K-1)/2 + K
            X(LD+NSEQ-1) = PUTEL
          END DO
        END DO
      END IF
C
C     ----- RESTORE PRISTINE HAMILTONIAN -----
C     DICTIONARY 11 CONTAINS PERTURBED HAMILTONIAN WITH DIPOLE
C     INTEGRALS WHICH CAN BE EVALUATE AT DFTB APPROXIMATELY.
C     ...TO TELL THE TRUTH, IN DFTB, 94 AND SHOULD BE SAME.
C
      IF (EFLDL.AND.RUNTYP.EQ.RAMAN.AND.NFG.EQ.0) THEN
        CALL DAREAD(IDAF,IODA,X(LH1),L2,94,0)
        !! RESET INITIAL GUESS, BECAUSE THIS COULD BE PERTURBED BY
        !! DIFFERENT ELECTRIC FIELD
        IF (.NOT.INGUESS) THEN
          DO I = 1, NAT
            X(LMUL1A+I-1) = ZREF(I)
            X(LMUL2A+I-1) = ZREF(I)
          END DO
        END IF
      end if
C
C           *****************************
C     ***** START RHF/UHF/ROHF ITERATIONS *****
C           *****************************
C
101   TFOCK = ZERO
      TSOLVE = ZERO
      ITDIR=0
      SOSCF = SOSCF0
      ETOT0 = 0.0D+00
      ETEMP0 = ETEMP
      CALL VCLR(SHIFT,1,NAT)
C
C     MAXIT = 200
      DO 300 ITER=1,MAXIT
C
      CALL TSECND(TITER0)
      !! COPY X(LH1) TO X(LFAO)
      CALL DCOPY(L2,X(LH1),1,X(LFAO),1)
      IF (SCC .AND. (ITER.NE.1 .OR. INGUESS) ) THEN
        CALL VCLR(SHIFT,1,NAT)
C
C     ------ ADD SECOND-ORDER HAMILTONIAN TO ZEROTH-ORDER HAMILTONIAN -----
C
        IF (SRSCC) THEN
          CALL VCLR(X(LSHIFTSH),1,NSHELL)
          CALL DFTB_2ND_SHIFT(X(LSHIFTSH),X(LMUL3S),X(LGAMMA),NSHELL)
          IF (DFTB3) THEN
            CALL DFTB_3RD_SHIFT_SRSCC(X(LSHIFTSH),X(LMUL3S),X(LGAM3),
     *                                NSHELL,NAT,MAXANG,ISPE,X(LMUL3A))
          END IF
C         write (*,*) "shiftsh"
C         do i = 1, nshell
C           write (*,'(i3,x,2f20.10)') i,x(lshiftsh+i-1),x(lmul3s+i-1)
C         end do
        ELSE
          CALL DFTB_2ND_SHIFT(SHIFT,X(LMUL3A),X(LGAMMA),NAT)
          IF (DFTB3) THEN
            CALL DFTB_3RD_SHIFT(SHIFT,X(LMUL3A),X(LGAM3),NAT)
            IF (NFG.NE.0)
     *        CALL DFTB_3RD_SHIFT_FMO(SHIFT,X(LMUL3A),SHIFT3,NAT)
          END IF
C         write (*,*) "shift"
C         do i = 1, nat
C           write (*,'(i3,x,2f20.10)') i,shift(i),x(lmul3a+i-1)
C         end do
        END IF
C
C     ----- ADD ELECTRIC FIELD (NOT WELL TESTED) -----
C
        IF (EFLDL) CALL DFTB_EFIELD_SHIFT(SHIFT,EVEC,C,NAT)
C
C                      ----- COSMO -----
C     ADD IN CORRECTION DUE TO SOLVENT SCREENING SELF-CONSISTENTLY
C     FIXED SCREENING CHARGES FOR HF PART WITHIN MP2 (MP2ITER=1)
C
        IF(ISEPS) THEN
          CALL DAWRIT(IDAF,IODA,X(LMUL1A),NAT,556,0)
          CALL DAWRIT(IDAF,IODA,X(LD),LL2,16,0)
          CALL COSADD(.TRUE.)
          CALL DFTB_COSADD(SHIFT)
        END IF
C
C       ----- GB SHIFT -----
C
C       IF (DOGB) CALL DFTB_2ND_SHIFT(SHIFT,X(LMUL3A),X(LGAMGB),NAT)
C
C       ----- ADD SPIN CONTRIBUTIONS FOR SCFTYP.EQ.UHF -----
C       FOCK MATRIX NOW DOES NOT CONTAINS SPIN CONTRIBUTION.
C       THEREFORE ALPHA AND BETA FOCK MATRICES ARE IDENTICAL
C
        IF (SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
          IF (.NOT.SRSCC) CALL DFTB_SHIFT_ATOSH(SHIFT,X(LSHIFTSH),NAT,
     *      NSHELL,NSPE,ISPE,MAXANG)
C       if (.not.srscc) then
C         write (*,*) "shell-resolved shiftsh"
C         do i = 1, nshell
C           write (*,'(i3,x,f20.10)') i,x(lshiftsh+i-1)
C         end do
C       end if
          CALL DCOPY(L2,X(LFAO),1,X(LFB),1)
          CALL VCLR(SHIFTS,1,NSHELL)
          CALL DFTB_SPIN_SHIFT(SHIFTS,X(LMULSB),SPNCST,NAT,NSHELL,
     *      NSPE,ISPE,MAXANG)
C         write (*,*) "spin shift"
C         do i = 1, nshell
C           write (*,'(i3,x,f20.10)') i,shifts(i)
C         end do
          CALL DFTB_SHIFT_FOCK_UHF(X(LFA),X(LFB),SHIFTS,X(LSHIFTSH),
     *      X(LS),NAT,L2,NSHELL,NSPE,ISPE,MAXANG)
        ELSE IF (SRSCC) THEN
          CALL DFTB_SHIFT_FOCK_SRSCC(X(LFA),X(LSHIFTSH),X(LS),NAT,L1,L2,
     *      NSHELL,NSPE,ISPE,MAXANG)
        ELSE
          CALL DFTB_SHIFT_FOCK(SHIFT,X(LFAO),X(LS),NAT,L2,NSPE,ISPE,
     *      IND,MAXANG)
        END IF
C
        IF (LRDFTB) THEN
          IF (.NOT.ITER.EQ.1)
     *    CALL DFTB_LRSHIFT(L1,NAT,X(LLR),X(LFAO),X(LS),X(LD),
     *                      X(LMUL1),ELR)
        END IF
      ELSE
        IF(SCFTYP.EQ.UHF.OR.ROHFGAMESS) CALL DCOPY(L2,X(LFA),1,X(LFB),1)
      END IF
C
C           AT THIS POINT, THE SKELETON 2E- FOCK OPERATOR IS FINISHED
C
      IF(OUT) THEN
         WRITE(IW,*) '*** START OF DEBUG OUTPUT FOR ITERATION',ITER
         IF (SCFTYP.EQ.RHF) THEN
            WRITE(IW,*) 'SKELETON FOCK MATRIX'
            CALL PRTRIL(X(LFAO),L1)
         ELSE
            WRITE(IW,*) 'ALPHA SKELETON FOCK MATRIX'
            CALL PRTRIL(X(LFA),L1)
            WRITE(IW,*) 'BETA SKELETON FOCK MATRIX'
            CALL PRTRIL(X(LFB),L1)
         END IF
      END IF
      CALL TSECND(TITER1)
C
C     * * * * * SOLVATION MODEL CORRECTIONS TO 1E- TERM * * * * *
C
C                ----- ONSAGER REACTION FIELD -----
C     GET PRISTINE ONE ELEC. HAM., CALC. INDUCED DIPOLES, ADD PERTURB.
C
      IF(IZRFLS) THEN
C      ORIGINAL RHFCL SUBROUTINE ADDS THE CONTRIBUTION DIRECTLY TO
C      X(LH1) MATRIX, HOWEVER IT IS BETTER TO ADD X(LFAO) IN TERMS OF
C      SCF CONVERGENCE (AT LEAST FOR DFTB).
C      I'M NOT SURE HOW THIS AFFECTS TO THE GRADIENT CALCULATIONS AND
C      SO ON. ENERGY AND PROPERTY SEEM TO BE FINE.
C           CALL RCNFLD(X(LH1),DUMMY,DUMMY,X(LD),DUMMY,
C    *                  DUMMY,X(LXDINT),X(LYDINT),X(LZDINT),L2,L1,0)
            CALL RCNFLD(X(LFAO),DUMMY,DUMMY,X(LD),DUMMY,
     *                  DUMMY,X(LXDINT),X(LYDINT),X(LZDINT),L2,L1,0)
      END IF
C
C     ----- SURFACE AND VOLUME POLARIZATION FOR ELECTROSTATICS -----
C
      IF(ISVP.EQ.1) THEN
         call abrt
c        define IADDR_SVP,ILAST_SVP
c        CALL SVPCHG(X(LD),X(LD),X(LH1),X(LWRK1),IADDR_SVP,ILAST_SVP,
c    1                LL2,LL1,ESVP,ITER,
c    2                CVGSVPDN,CVGSVPDN1,CVGSVPNR,CHGDIF,CVGSVP)
      END IF
C
C     ----- POLARIZABLE CONTINUUM MODEL CALCULATION -----
C
      IF(IPCM.EQ.1) THEN
         call stopwa(7,0)
C
C      IF BUFFER MOS ARE THERE, USE THE 'BUFFERLESS' DENSITY IN PCMFLD
C
         IF(NBUFMO.GT.0) THEN
            CALL DCOPY(L2,X(LD),1,X(LWRK1),1)
            CALL DAREAD(IDAF,IODA,X(LVEC),L3,15,0)
            CALL DMTX(X(LWRK2),X(LVEC),X(LOCC),NBUFMO,L1,L1)
            CALL VSUB(X(LWRK2),1,X(LD),1,X(LWRK2),1,L2)
            IF(NB.GT.0) THEN
              CALL DAREAD(IDAF,IODA,X(LVB),L3,19,0)
              CALL DMTX(X(LWRK3),X(LVB),X(LBOC),NBUFMO,L1,L1)
              CALL VSUB(X(LWRK3),1,X(LWRK2),1,X(LWRK2),1,L2)
            END IF
         ELSE
            CALL DCOPY(L2,X(LD),1,X(LWRK1),1)
           IF (SCFTYP.EQ.UHF) CALL VADD(X(LDA),1,X(LDB),1,X(LWRK1),1,L2)
         END IF
         !! MULLIKEN POPULATION
         CALL DAWRIT(IDAF,IODA,X(LMUL1A),NAT,556,0)
         CALL PCMFLD(X(LFAO),X(LFB),X(LWRK1),X(LSOL),X(LCHG),X(LWRK1),
     *               X(LDISV),X(LDIS1),X(LDIS2),X(LWRK3),X(LSCR),
     *               X(LDMATM),X(LCQEF),X(LQEFF),X(LELD),X(LQPOT),
     *               X(LQFLD),X(LVPOT),X(LSE),X(LDE),
     *               X(LQ0),X(LQ1),X(LQ2),X(LQ3),
     *               X(LD0),X(LQA),X(LDIMAT),X(LQREP),
     *               X(LTMP0),X(LTMP1),X(LTMP2),X(LIPVT),
     *               X(LPOTTMP),X(LRMUL),TCH,QET,QETN,QESC,ISD,NFT27,
     *               IPCFP,L1,L2,NTSPAR,X(LAXYZCT),X(LAXYZCT+MXTS),
     *               X(LAXYZCT+MXTS*2),X(LXYZCT2),X(LXYZCT2+MXTS),
     *               X(LXYZCT2+MXTS*2),X(LAXYZCT+MXTS*3),X(LQSN),
     *               X(LQSE),X(LQSED),X(LQFS),
     *               X(LVECMUL),X(LCHG2),X(LQIND+MXTS),X(LPEL),
     *               X(LASCCRD),X(LASCCHG),X(LASCDIP),X(LASCQAD),
     *               X(LXYZRE),X(LXYZRE+MXSP),X(LXYZRE+MXSP*2),
     *               X(LXYZRE+MXSP*3),X(LISPHE),X(LLIST),X(LEPSPCM))
         call stopwa(7,1)
      END IF
      IF(NFMOPCM.NE.0) THEN
        IF (SCFTYP.EQ.UHF) CALL VADD(X(LDA),1,X(LDB),1,X(LWRK1),1,L2)
        CALL DAREAD(IDAF,IODA,X(LWRK2),L2,311,0)
        IF (SCFTYP.EQ.RHF) THEN
          PX=-TRACEP(X(LD),X(LWRK2),L1)
        ELSE IF (SCFTYP.EQ.UHF) THEN
          PX=-TRACEP(X(LWRK1),X(LWRK2),L1)
        END IF
      ENDIF
C     GOTO 1050
C
C        SAVE THE FOCK MATRIX TO DISK.  NOTE THAT THIS DOES NOT
C        CONTAIN THE DFT EXCHANGE, BUT MUST BE SAVED HERE SO THAT
C        THE FDIFF OPTION WORKS PROPERLY.
C        SEE THE NOTE ABOUT DFT EXCHANGE ABOVE, IT CANNOT BE FDIFF'ED.
C
      CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,14,0)
      IF (SCFTYP.EQ.UHF) CALL DAWRIT(IDAF,IODA,X(LFB),LL2,18,0)
      IF(CVGED  .AND.  ICCFLG.GT.0) GO TO 710
C
C         SKIP SOSCF AND DIIS IF THIS IS THE FIRST ITERATION
C         MAYBE THIS IS NOT NEEDED IF INITIAL GUESS IS USED
C
!     IF (ITER.EQ.1 .AND. .NOT.INGUESS) THEN
      IF (ITER.EQ.1) THEN
        CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,23,0)
        CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,24,0)
        CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,25,0)
        IF (SCFTYP.EQ.UHF) THEN
          CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,26,0)
          CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,27,0)
          CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,28,0)
        END IF
        CALL TSECND(TITER1)
        GO TO 1050
      END IF
C
C     IF PCM: ADD SOLUTE-SOLVENT DISPERSION ENERGY
C
C     IF(IPCM.EQ.1  .AND.  IDP.EQ.1  .AND.  ISD.EQ.1)
C    *  EHF2=EHF2+TRACEP(X(LD),X(LDIS1),L1)
C
C   SUBTRACT INTERACTION OF THE EFP WITH THE BUFFER ZONE DENSITY.
C   IF EFP + PCM, REMOVE CONTRIBUTIONS FROM NUCLEI AND ELECTRONS
C   INTERACTING WITH THE NUCLEAR INDUCED CHARGE
C   CALCULATE THE DENSITY OF THE BUFFER ZONE (FIRST NBUFMO MO-S)
C
C   HERE WE DEFINE EEFP AS THE INTERACTION OF THE EFP(MULTIPOLE
C   POINTS AND POLARIZABLE POINTS) WITH THE BUFFER ZONE DENSITY
C   I.E. (1)BUFFER ELECTRON -- MULTIPOLE POINTS
C        (2)BUFFER ELECTRON -- POLARIZABLE POINTS(INDUCED DIPOLE)
C   ANY PCM ASC ASSOCIATED INTERACTION IS NOT CONSIDERED AS A
C   PART OF EEFP.
C
      IF(NBUFMO.GT.0) THEN
         CALL DAREAD(IDAF,IODA,X(LVEC),L3,15,0)
         CALL DAREAD(IDAF,IODA,X(LWRK2),L2,319,0)
         CALL VSUB(X(LWRK2),1,X(LH1),1,X(LWRK2),1,L2)
C
        IF(IPCMIT.EQ.0) THEN
           IF(IPCM.EQ.1) THEN
              CALL DAREAD(IDAF,IODA,X(LWRK3),L2,263,0)
              CALL VSUB(X(LWRK3),1,X(LWRK2),1,X(LWRK2),1,L2)
              CALL DAREAD(IDAF,IODA,X(LWRK3),L2,264,0)
              CALL VSUB(X(LWRK3),1,X(LWRK2),1,X(LWRK2),1,L2)
           END IF
           IF(IPCFP) THEN
              CALL DAREAD(IDAF,IODA,X(LWRK3),L2,263,0)
              CALL VSUB(X(LWRK3),1,X(LWRK2),1,X(LWRK2),1,L2)
              CALL DAREAD(IDAF,IODA,X(LWRK3),L2,264,0)
              CALL VSUB(X(LWRK3),1,X(LWRK2),1,X(LWRK2),1,L2)
              CALL VSUB(X(LVEC_2),1,X(LWRK2),1,X(LWRK2),1,L2)
           END IF
        END IF
C
         CALL DMTX(X(LWRK3),X(LVEC),X(LOCC),NBUFMO,L1,L1)
CD       EEFP= TRACEP(X(LWRK3),X(LWRK2),L1)
      ELSE
CD       EEFP = ZERO
      END IF
C
      EHF0 = ZERO
      EHF  = ZERO
C
C     MO FREEZING REQUIRES TRANSFORMATION TO THE MO BASIS,
C     ZEROING OUT THE OFF-DIAGONAL FOCK MATRIX FROZEN ROW/COLUMN
C     ELEMENTS AND THEN BACKTRANSFORMATION TO THE AO BASIS.
C
C     TO KEEP THE FROZEN ORBITALS EVEN MORE STEADIER, THE INITIAL
C     MO-S (DAF 318) WILL BE USED FOR TRANSFORMATION TO MO BASIS.
C
      IF(MFRZ) THEN
         IF(NFG.NE.0.AND.ITER.GT.1)
     *     CALL DAWRIT(IDAF,IODA,X(LVEC),LL3,15,0)
        CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,317,0)
C
        CALL DAREAD(IDAF,IODA,X(LVEC),LL3,318,0)
        CALL TFTRI(X(LWRK1),X(LFAO),X(LVEC),X(LWRK),L0,L1,L1)
         IF(DOAFO) THEN
            CALL FRFOCK1(X(LWRK1),L1)
         ELSE
            CALL FRFOCK(X(LWRK1),L1)
         ENDIF
C        IF(NUMFRZ.GT.1) CALL PRTRI(X(LWRK1),L1)
        IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),LL2,12,0)
        CALL TFTRIB(X(LFAO),X(LWRK1),X(LS),X(LVEC),X(LWRK2),
     *              X(LIWRK),L0,L1,L2,L3)
        IF(.NOT.FDIFF  .AND.  NDFTFG.NE.1)
     *      CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,14,0)
CD       EHF1C = TRACEP(X(LD),X(LFAO),L1)
C        WRITE(6,*) 'E CORRECTED',EHF+(EHF1C-EHF1)/TWO+EN
         IF(NFG.NE.0) THEN
CD         EHF=EHF+(EHF1C-EHF1)/TWO
CD         EHF1=EHF1C
         ENDIF
         IF(NFG.NE.0.AND.ITER.GT.1)
     *     CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
C        IS THAT OF ANY USE?
      END IF
C
C     COSMO CORRECTS ENERGY FOR CREATION OF CAVITY
C
      IF(ISEPS) EHF = EHF - SECORR
C
CUHF? ETOT0= ETOT
CUHF? ETOT = EHF+EN
C
C     ----- DEBUG PRINT OF ENERGY, FOCK MATRIX, AND LAGRANGIAN -----
C     -FV- AND -EIJ- AT LWRK1 AND LWRK2 ARE SQUARE MATRICES
C
C     IF(NPRINT.EQ.5 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME)
C    *    CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
      IF(OUT) THEN
         CALL MAKFV(X(LFAO),X(LVEC),X(LWRK1),X(LWRK),IA,1,NA,L1,L1)
         CALL MAKEIJ(X(LVEC),X(LWRK1),X(LWRK2),X(LWRK),L0,L0,L1,L0,L1)
         WRITE(IW,*) 'LAGRANGE MULTIPLIER MATRIX'
         CALL PRSQ(X(LWRK2),NA,L0,L1)
      END IF
C
      IF(FMOEX.AND.ITER.EQ.1) THEN
         E0SCF(1)=ETOT-ENVENE(L1,X(LD))
C        WRITE(6,*) 'WWWEX',E0SCF(1)
         IF(NORBPROJ.NE.0) THEN
            CALL DAREAD(IDAF,IODA,X(LWRK1),L2,312,0)
            EPROJ=TRACEP(X(LD),X(LWRK1),L1)
            E0SCF(1)=E0SCF(1)-EPROJ
C           WRITE(6,*) 'WWWEPROJ',EPROJ,E0SCF(1)
         ENDIF
      ENDIF
      IF(FMOPL.AND.ITER.EQ.1) THEN
        E0SCF(2)=ENVENE(L1,X(LD))
        E0SCF(1)=ETOT-E0SCF(2)
C       WRITE(6,*) 'WWWRHF',E0SCF(1),E0SCF(2)
      ENDIF
C
      IF(ITER.EQ.1) E0 = ETOT
      DELE0 = DELE
      DELE  = ETOT-ETOT0
      IF(ITER.EQ.1) DEAVG = ZERO
      IF(ITER.EQ.2) DEAVG = ABS(DELE)
      IF(ITER.GE.3) DEAVG = (ABS(DELE)+ ABS(DELE0)+PT2*DEAVG)/TWOPT2
      CALL TSECND(TITER1)
C
C     KURT'S TRICK TO MAKE DIIS SWITCH OFF IF ENERGY RISES
C     ON ANY ITERATION MORE THAN IT WENT DOWN ON THE PREVIOUS
C     ITERATION.  PRESENTLY APPLIED ONLY FOR THE UHF CASE, WHICH
C     SOMETIMES DOES THIS, LOCKING ONTO A LESS SPIN-CONTAMINATED
C     HIGHER ENERGY SOLUTION.  HOPEFULLY, SHUTTING DIIS OFF
C     WILL LET THE PROGRAM CONTINUE DOWNWARD IN ENERGY, UNTIL
C     EVENTUALLY DIIS CAN TURN ON AGAIN (NOTE THAT -DIISDMP-
C     LOWERS THE ETHRSH FOR EVENTUALLY RE-ENGAGING DIIS).
C     THE NON-DIIS ITERATION COUNTER ENSURES THAT IF DIIS
C     GOES OFF, IT SHOULD STAY OFF FOR -NONDMX- ITERATIONS.
C     DIISDMP AND NONDMX ARE CLEARLY ADJUSTABLE PARAMETERS.
C     SET UP FOR EXTRAPOLATION/DAMPING WHILE DIIS IS OFF.
C
C     IF(reset.and.SCFTYP.EQ.UHF  .AND.  ICUHF.EQ.0  .AND.
C    *   DODIIS  .AND.  ITDIIS.NE.1  .AND.  ITNOND.GT.NONDMX  .AND.
C    *   DELE.GT.ZERO  .AND.  DELE.LT.0.005D+00  .AND.
C    *  (DELE+DELE0).GT.1.0D-06) THEN
CC          READ IN FOCK MATRIX FROM ONE OR TWO ITERATIONS BEFORE
C        LRAFFA= MAXDII*2
C        LRAFFB= MAXDII*3
CC          IF THE LAST TWO ITERS HAVE BEEN UPHILL, GRAB TWO ITERS AGO.
CC          IF ONLY THE LAST ITER IS UPHILL, GRAB FROM ONE ITER AGO.
C        IF (DELE0 .GT. 0) THEN
C          IDUMMY = MOD(ITDIIS-3,MAXDII) + 1
C        ELSE
C          IDUMMY = MOD(ITDIIS-2,MAXDII) + 1
C        END IF
CC          JUST TO BE SAFE (DON'T WANT NONEXISTANT RECORDS)
C        IF (IDUMMY .LT. 1) IDUMMY = 1
C        LFCKA = LRAFFA + IDUMMY
C        LFCKB = LRAFFB + IDUMMY
C        CALL RAREAD(IRAF,X(LIODII),X(LFA),L2,LFCKA,0)
C        CALL RAREAD(IRAF,X(LIODII),X(LFB),L2,LFCKB,0)
C
C        ITDIIS=1
C        ITNOND=0
C        IF(.NOT.NOTOPN) CALL RACLOS(20,'DELETE')
C        NOTOPN=.TRUE.
C        ETHNEW = MIN(ERDIIS,ETHRSH) * DIISDMP
C        IF(MASPRT) WRITE(IW,9235) NONDMX,ETHNEW
C        CVGING=.FALSE.
C        ITERLV=0
C        RRSHFT=ZERO
C        IF(DAMPH .OR. VSHIFT) DAMP = ONE
C        CALL WDISK(X(LFA),X(LFA),X(LFA),NDAFA,L2)
C        CALL WDISK(X(LFB),X(LFB),X(LFB),NDAFB,L2)
C            MAKE SURE WE DON'T ACCIDENTALLY SWITCH TO FINE DFT GRID
C        IF(NDFTFG.EQ.1) SWGROK=.FALSE.
C     END IF
C
C     NOW STOP SOSCF IF NEEDED
C
      IF(reset.and.SCFTYP.EQ.UHF  .AND.  ICUHF.EQ.0
     *       .AND.  SOSCF  .AND. ITSO.GT.0 .AND.
     *   DELE.GT.ZERO  .AND.  DELE.LT.0.005D+00  .AND.
     *  (DELE+DELE0).GT.1.0D-08) THEN
         ITSO=0
         ITNOND = 0
         SOGNEW = MIN(ORBGRD,SOGTOL) * DIISDMP
         CVGING=.FALSE.
         ITERLV=0
         RRSHFT=ZERO
         IF(DAMPH .OR. VSHIFT) DAMP = ONE
         IF(MASPRT) WRITE(IW,9236) NONDMX,SOGNEW
         CALL WDISK(X(LFA),X(LFA),X(LFA),NDAFA,L2)
         CALL WDISK(X(LFB),X(LFB),X(LFB),NDAFB,L2)
CD       IF(NDFTFG.EQ.1) SWGROK=.FALSE.
      END IF
C
      ITNOND = ITNOND+1
      ETHRSH = ETHSAV
      SOGTOL = SOGNEW
      IF(ITNOND.LE.NONDMX) ETHRSH = ZERO
      IF(ITNOND.LE.NONDMX) SOGTOL = ZERO
C
C     MAKE FOCK MATRICES FOR CONSTRAINED UHF
C
      IF(SCFTYP.EQ.UHF  .AND.  ICUHF.EQ.1) THEN
         IF(ITER.EQ.1) then
            CALL DAREAD(IDAF,IODA,X(LVA),L3,15,0)
            CALL DAREAD(IDAF,IODA,X(LVB),L3,19,0)
         endif
         call dcopy(l2,x(lda),1,x(lwrk5),1)
         call dcopy(l2,x(ldb),1,x(lwrk6),1)
         call vadd(x(lwrk5),1,x(lwrk6),1,x(lwrk5),1,L2)
         CALL UHFNOS(x(LCEIG),x(liwrk),X(LSCR),X(lwrk5),x(lwrk6),
     *               X(lwrk1),x(lwrk7),X(LQ),L0,L1,L2,0)
         if(OUT) then
            WRITE(IW,*) 'UHF natural orbitals'
            CALL PREVNL(X(lwrk1),x(LCEIG),L0,L1,1)
         endif
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
         CALL CUHF(X(LFA),X(LFB),X(lwrk5),x(lwrk6),X(lwrk1),
     *             X(LSCR),X(LS),X(lwrk7),NA,NB,L0,L1,L2,L3,OUT)
      END IF
C
C     ----- POSSIBLE SECOND ORDER SCF -----
C     ON THE VERY FIRST ITERATION OF THE VERY FIRST GEOMETRY, WE MUST
C     DO A DIAGONALIZATION TO GET EIGENVALUES TO APPROX. THE HESSIAN.
C     ALL THREE -LWRK- WORK ARRAYS ARE AVAILABLE FOR SCRATCH USAGE.
C     HESSIAN RUNS MAY NOT HAVE CANONICAL VIRTUAL ORBITALS READ IN,
C     AND IT IS PROBABLY A GOOD IDEA TO DIAGONALIZE ONCE ANYWAY, JUST
C     TO MIX SYMMETRIES UP WELL DURING NUMERICAL RUNS.
C
C     FMO DOES NOT ALWAYS HAVE ORTHONORMALISED INITIAL ORBITALS.
C     DUE TO THIS OR OTHER REASON, SOSCF RUNS WITHOUT PRECEEDING DIIS
C     CONVERGE TO TOTALLY WRONG ENERGIES. ALL OF THIS HAPPENS ONLY
C     WITH DIMERS WHEN INITIAL GUESS IS COOKED FROM MONOMERS (NOTE
C     THAT IN ANY CASE THE INITIAL DENSITY IS PHYSICALLY MEANINGFUL,
C     BUT IT DOES NOT ALWAYS EXACTLY CORRESPOND TO INITIAL ORBITALS).
C     DIIS USES ONLY DENSITY.  SECONDLY, NOW FMO WRITES FAKE INITIAL
C     ORBITALS EXCEPT WHEN DOING DFT.
C
      EIGAVL = ITER.GT.1  .OR.  NEVALS.GE.1
      IF(RUNTYP.EQ.HESS)   EIGAVL = ITER.GT.1
      IF(NFG.NE.0)         EIGAVL = ITER.GT.1
C
      IF(SOSCF .AND.  EIGAVL.AND.SCFTYP.EQ.RHF) THEN
         CALL SOGRAD(X(LGRAD),X(LFAO),X(LVEC),X(LSCR),NPR,NA,
     *               L0,L1,ORBGRD)
C             SEE COMMENTS BELOW AT SIMILAR B'CASTS.
         IF(ISGDDI) CALL DDI_BCAST(2421,'F',ORBGRD,1,MASTER)
         IF(ORBGRD.LT.SMALL) THEN
            DIFF = ZERO
            CVGING=.TRUE.
            GO TO 700
         END IF
         IF(ORBGRD.LT.SOGTOL  .OR.  ITSO.GT.0) THEN
            IF(ITSO.EQ.0) THEN
               DAMP = ZERO
               RRSHFT = ZERO
               IF(MASPRT) WRITE(IW,9200)
               CALL SOHESS(X(LHESS),X(LEIG),NPR,L0,NA,NA)
            END IF
C
            ITSO = ITSO+1
            CALL SONEWT(X(LHESS),X(LGRAD),X(LPGRAD),X(LDISPL),
     *                  X(LWRK1),X(LWRK2),X(LWRK3),
     *                  X(LWRK1+NPR),X(LWRK2+NPR),X(LWRK3+NPR),
     *                  ORBGRD,NPR,ITSO,NFT15,x(lbuf15),inmem15)
            IF(ORBGRD.EQ.-123) GO TO 350
            CALL SOTRAN(X(LDISPL),X(LVEC),X(LWRK1),X(LSCR),
     *                  NPR,L0,L1,NA,NA,ORBGRD)
            CALL DCOPY(NPR,X(LGRAD),1,X(LPGRAD),1)
            GO TO 800
         END IF
      END IF
C
      IF(SOSCF .AND.  EIGAVL.AND.(SCFTYP.EQ.UHF.OR.SCFTYP.EQ.ROHF)) THEN
         IF(SCFTYP.EQ.ROHF) THEN
            IF (NDFTFG.EQ.0) THEN
               CALL DAWRIT(IDAF,IODA,X(LFA)  ,L2,51,0)
            ELSE
               CALL DAREAD(IDAF,IODA,X(LWRK1),L2,14,0)
               CALL DAWRIT(IDAF,IODA,X(LWRK1),L2,51,0)
            END IF
         END IF
C
         IF(ITER.EQ.1) CALL DAREAD(IDAF,IODA,X(LVA),L3,15,0)
         CALL SOGRAD(X(LGRADA),X(LFA),X(LVA),X(LSCR),NPRA,NA,
     *               L0,L1,ORBGRA)
         IF(NB.GT.0) THEN
            IF(ITER.EQ.1) CALL DAREAD(IDAF,IODA,X(LVB),L3,19,0)
            CALL SOGRAD(X(LGRADB),X(LFB),X(LVB),X(LSCR),NPRB,NB,
     *                  L0,L1,ORBGRB)
         ELSE
            ORBGRB=ZERO
         END IF
         ORBGRD = MAX(ORBGRA,ORBGRB)
         IF(SCFTYP.EQ.UHF) THEN
            CALL DCOPY(NPRA,X(LGRADA),1,X(LGRADU)     ,1)
            CALL DCOPY(NPRB,X(LGRADB),1,X(LGRADU+NPRA),1)
         END IF
         IF(SCFTYP.EQ.ROHF) CALL SOGRRO(X(LGRADO),X(LGRADA),
     *                                  X(LGRADB),NPRO,NPRA,NPRB,
     *                                  L0,NA,NB,ORBGRD)
C
         IF(ORBGRD.LT.SOGTOL  .OR.  ITSO.GT.0) THEN
            ITERLV=0
            RRSHFT=ZERO
            IF(DAMPH .OR. VSHIFT) DAMP = ONE
            IF(ITSO.EQ.0) THEN
              DAMP = ZERO
              RRSHFT = ZERO
              IF(MASPRT) WRITE(IW,9200)
              IF(SCFTYP.EQ.UHF) THEN
                CALL SOHESS(X(LHESSA),X(LEA),NPRA,L0,NA,NA)
                IF(NB.GT.0) CALL SOHESS(X(LHESSB),X(LEB),NPRB,L0,NB,NB)
                CALL DCOPY(NPRA,X(LHESSA),1,X(LHESSU)     ,1)
                CALL DCOPY(NPRB,X(LHESSB),1,X(LHESSU+NPRA),1)
              ELSE
                CALL SOHESS(X(LHESSO),X(LEA),NPRO,L0,NA,NB)
              END IF
            END IF
C
            ITSO = ITSO+1
            IF(SCFTYP.EQ.UHF) THEN
               CALL SONEWT(X(LHESSU),X(LGRADU),X(LPGRADU),X(LDISPLU),
     *                     X(LWRK1),X(LWRK2),X(LWRK3),
     *                     X(LWRK1+NPRU),X(LWRK2+NPRU),X(LWRK3+NPRU),
     *                     ORBGRD,NPRU,ITSO,NFT15,dum,.false.)
               IF(ORBGRD.EQ.-123) GO TO 400
               CALL DCOPY(NPRU,X(LGRADU),1,X(LPGRADU),1)
               CALL DCOPY(NPRA,X(LDISPLU),1,X(LDISPLA),1)
               CALL DCOPY(NPRB,X(LDISPLU+NPRA),1,X(LDISPLB),1)
               CALL SOTRAN(X(LDISPLA),X(LVA),X(LWRK1),X(LSCR),
     *                     NPRA,L0,L1,NA,NA,ORBGRA)
               IF(NB.GT.0)
     *         CALL SOTRAN(X(LDISPLB),X(LVB),X(LWRK1),X(LSCR),
     *                     NPRB,L0,L1,NB,NB,ORBGRB)
            END IF
            IF(SCFTYP.EQ.ROHF) THEN
               CALL SONEWT(X(LHESSO),X(LGRADO),X(LPGRADO),X(LDISPLO),
     *                     X(LWRK1),X(LWRK2),X(LWRK3),
     *                     X(LWRK1+NPRO),X(LWRK2+NPRO),X(LWRK3+NPRO),
     *                     ORBGRD,NPRU,ITSO,NFT15,dum,.false.)
               IF(ORBGRD.EQ.-123) GO TO 400
               CALL SOTRAN(X(LDISPLO),X(LVA),X(LWRK1),X(LSCR),
     *                       NPRO,L0,L1,NA,NB,ORBGRD)
               CALL DCOPY(NPRO,X(LGRADO),1,X(LPGRADO),1)
            END IF
            GO TO 900
         END IF
      END IF
C
C     ----- ASSEMBLE THE HIGH SPIN ROHF TOTAL FOCK MATRIX -----
C     -LWRK1- IS TRIANGULAR, -LWRK2- IS SQUARE SCRATCH STORAGE.
C
      IF(ROHFGAMESS) THEN
         IF(ITER.EQ.1) CALL DAREAD(IDAF,IODA,X(LVA),L3,15,0)
         IF (NDFTFG.EQ.0) THEN
            CALL DAWRIT(IDAF,IODA,X(LFA)  ,L2,51,0)
         ELSE
            CALL DAREAD(IDAF,IODA,X(LWRK1),L2,14,0)
            CALL DAWRIT(IDAF,IODA,X(LWRK1),L2,51,0)
         END IF
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
         CALL ROFOCK(X(LFA),X(LFB),X(LWRK1),X(LVEC),X(LSCR),X(LS),
     *               X(LWRK2),NA,NB,0,L0,L1,L2,L3,OUT)
         CALL DAWRIT(IDAF,IODA,X(LFA),L2,14,0)
      END IF
C
C     ----- POSSIBLE DIIS INTERPOLATION -----
C     (RHF)
C     THE RHF ERROR MATRIX ERR = FDS-SDF IS FORMED AT -LWRK3-
C     SQUARE FORMS OF -F- AND -S- ARE HELD AT -LWRK1- AND -LWRK2-
C     IF DIIS GETS TURNED ON BY -DIIS-, ITDIIS WILL BE .GT. 1
C     (ROHF/UHF)
C     THE TOTAL DIIS ERROR MATRIX IS FORMED AT -LWRK3-
C     FOR ROHF, ERR = F*D*S-S*D*F, WHERE D=DA+DB.
C     FOR  UHF, ERR = FA*DA*S-S*DA*FA + FB*DB*S-S*DB*FB.
C     -LWRK1,LWRK2,LWRK3- ARE USED AS SQUARE STORAGE.
C
      IF(DODIIS) THEN
         IF (SCFTYP.EQ.RHF.OR.(SCFTYP.EQ.ROHF.AND..NOT.ROHFGAMESS)) THEN
           IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),LL2,12,0)
           CALL EXPND(X(LFAO),X(LWRK1),L1,0)
           CALL EXPND(X(LS),X(LWRK2),L1,0)
           CALL DIISER(X(LWRK1),X(LD),X(LWRK2),X(LWRK3),X(LWRK),
     *                 L1,L2,1,1)
           IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LQ),LL3,45,0)
           CALL DIIS(RHF,IW,ITDIIS,X(LQ),X(LFAO),DMY,X(LWRK3),DMY,
     *               X(LWRK1),X(LADIIS),X(LXDIIS),X(LPDIIS),X(LBDIIS),
     *               X(LIODII),X(LWRK),L1,L2,L3,MAXIT,MAXIT2,4*MAXDII,
     *               ERDIIS,NOTOPN,MASPRT)
         ELSE
           IF(SCFTYP.EQ.ROHF) THEN
              CALL VADD(X(LDB),1,X(LDA),1,X(LDA),1,L2)
              IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
              CALL EXPND(X(LFA),X(LWRK1),L1,0)
              CALL EXPND(X(LS),X(LWRK2),L1,0)
              CALL DIISER(X(LWRK1),X(LDA),X(LWRK2),X(LWRK3),X(LSCR),
     *                    L1,L2,1,1)
              CALL VSUB(X(LDB),1,X(LDA),1,X(LDA),1,L2)
           END IF
           IF(SCFTYP.EQ.UHF) THEN
              IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
              CALL EXPND(X(LS),X(LWRK2),L1,0)
              CALL EXPND(X(LFA),X(LWRK1),L1,0)
              CALL DIISER(X(LWRK1),X(LDA),X(LWRK2),X(LWRK3),X(LSCR),
     *                    L1,L2,1,1)
              CALL EXPND(X(LFB),X(LWRK1),L1,0)
              CALL DIISER(X(LWRK1),X(LDB),X(LWRK2),X(LWRK4),X(LSCR),
     *                    L1,L2,1,1)
           END IF
           IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LQ),L3,45,0)
           CALL DIIS(SCFTYP,IW,ITDIIS,X(LQ),X(LFA),X(LFB),X(LWRK3),
     *               X(LWRK4),X(LWRK1),X(LADIIS),X(LXDIIS),X(LPDIIS),
     *               X(LBDIIS),X(LIODII),X(LSCR),L1,L2,L3,MAXIT,MAXIT2,
     *               4*MAXDII,ERDIIS,NOTOPN,MASWRK)
           IF(ITDIIS.GT.1) THEN
              ITERLV=0
              RRSHFT=ZERO
              IF(DAMPH .OR. VSHIFT) DAMP = ONE
           END IF
         END IF
      END IF
C
C                    ******************
C                    * ALPHA ORBITALS *
C                    ******************
C
C     ----- BEGIN CONVERGENCE ACCELERATION PROCEDURES -----
C        SKIP ALL OF THESE IF THE RUN IS CONVERGING
C        OR IF DIIS INTERPOLATION IS ON (ITDIIS.GT.1).
C
C     ----- DAMP AND EXTRAPOLATE THE ALPHA FOCK MATRIX -----
C     -LFA-   CURRENT FOCK MATRIX.
C     -LWRK1- SCRATCH AREA WITH OLD FOCK MATRIX (N-1 TH MATRIX)
C     -LWRK2- SCRATCH AREA WITH ANCIENT FOCK MATRIX (N-2 TH MATRIX)
C     -LWRK3- SCRATCH AREA WITH PREHISTORIC FOCK MATRIX (N-3 TH MATRIX)
C
C     ----- DAMP AND EXTRAPOLATE THE FOCK MATRIX -----
C     DAMPD COMPUTES THE DAMP FACTOR, EXTRAP ACTUALLY DOES THE DAMPING
C     LWRK1,LWRK2,LWRK3 HOLD THE 3 PREVIOUS SYMMETRIC FOCK MATRICES
C
C     CONVERGENCE ACCELERATIONS ARE SKIPPED IF WE ARE CONVERGING
C
c     IF((DAMPH.AND.ITER.GT.2)  .AND.  ITDIIS.EQ.2
c    *          .AND.   .NOT.CVGING .AND..NOT.INGUESS)
c    *   CALL DAMPD(DELE,DELE0,DEAVG,DAMP,DENTOL,DIFF,DIFFP,DMPTLC)
      IF((DAMPH.AND.ITER.GT.2)  .AND.  ITDIIS.EQ.1
     *          .AND.   .NOT.CVGING .AND. INGUESS)
     *   CALL DAMPD(DELE,DELE0,DEAVG,DAMP,DENTOL,DIFF,DIFFP,DMPTLC)
      IF(DAMP .LT. DMPCUT) DAMP = DMPCUT
C
      IF((DAMPH.OR.EXTRAH)  .AND.  ITDIIS.EQ.1  .AND.  .NOT.CVGING)
     *    CALL EXTRAP(DELE,DAMP,DAMP0,X(LFAO),X(LWRK1),X(LWRK2),
     *                X(LWRK3),L1,L2,LL2,NDAFD,ITERV,1,1)
C
C     ----- OPTIONAL DIRECT ENERGY MINIMIZATION -----
C     ON RETURN, -LVEC- WILL BE THE ORBITALS FROM THE DEM SEARCH,
C     AND -LWRK1- WILL HOLD THE FOCK OPERATOR IN THAT BASIS.  THIS
C     MUST BE BROUGHT INTO AO SPACE AT -LFAO- FOR FOLLOWING STEPS.
C     LWRK2 AND LWRK3 ARE SYMMETRIC, LWRK4 IS SQUARE WORK STORAGE
C
      NUMDEM = 0
      IF(DEM.AND.(DIFF.GT.DEMCUT .OR. ITER.EQ.1).AND.SCFTYP.EQ.RHF) THEN
         DEMOFF = .FALSE.
         RSTRCT = .TRUE.
         CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
         CALL TFTRI(X(LWRK1),X(LFAO),X(LVEC),X(LWRK),L0,L1,L1)
         CALL DEMHF(IW,OUT,EHF,EN,X(LWRK3),X(LWRK1),X(LWRK2),X(LEIG),
     *              X(LOCC),IA,X(LSCR),X(LIWRK),X(LWRK4),X(LVEC),X(LD),
     *              X(LH1),X(LS),X(LWRK5),X(LBUF),X(LIBUF),
     *              L0,L1,L2,L3,NA,NINTMX,NUMDEM,NOPK)
         CALL TFTRIB(X(LFAO),X(LWRK1),X(LS),X(LVEC),X(LWRK4),X(LSCR),
     *               L0,L1,L2,L3)
         CALL DAREAD(IDAF,IODA,X(LD),LL2,16,0)
      ELSE
         DEMOFF = .TRUE.
         RSTRCT = RSTRSV
      END IF
C
C     ----- OPTIONAL LEVEL SHIFTING -----
C     LWRK1,LWRK2 USED AS SYMMETRIC, LWRK3 AS SQUARE SCRATCH STORAGE
C
      IF(VSHIFT  .AND.  ITDIIS.EQ.1) THEN
        IF (SCFTYP.EQ.RHF) THEN
          IF(DEMOFF) CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
          CALL LEVELS(X(LFAO),X(LS),X(LVEC),X(LWRK1),X(LWRK2),X(LWRK3),
     *                X(LWRK),L0,L1,L2,L3,ITER,NA,0,DELE,DELE0,DIFF,
     *                ITERV,1,EXTRAH,CVGING)
        ELSE
          IF(ITER.EQ.1) CALL DAREAD(IDAF,IODA,X(LVA),L3,15,0)
          IF(SCFTYP.EQ.ROHF) THEN
             NDOCC = NB
             NHOCC = NA - NB
          ELSE
             NDOCC = NA
             NHOCC = 0
          END IF
          ITERLV=ITERLV+1
          CALL LEVELS(X(LFA),X(LS),X(LVA),X(LWRK1),X(LWRK2),X(LWRK3),
     *                X(LSCR),L0,L1,L2,L3,ITERLV,NDOCC,NHOCC,DELE,DELE0,
     *                DIFF,ITERV,1,EXTRAH,CVGING)
        END IF
      END IF
C
C     ----- TRANSFORM FOCK OPERATOR TO THE -Q- MATRIX BASIS -----
C     ----- DIAGONALIZE THE CURRENT FOCK MATRIX -----
C     ----- BACK-TRANSFORM THE EIGENVECTORS TO AO BASIS -----
C     FOCK OPERATOR IN ONB FOR DIAGONALIZATION MUST BE AT -LWRK1-
C
C memo
C TFTRI: TRANSFORM THE TRIANGULAR MATRIX F USING VECTORS T
C          H = T-DAGGER * F * T (X(LWRK1) = X(LQ)-DAGGER*X(LFAO)*X(LQ)
C TFSQB: BACK TRANSFORM V = Q * V (X(LVEC) = X(LQ)*X(LVEC))
1050  IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LQ),LL3,45,0)
CMKL  IF (KDIAG.EQ.4) THEN
CMKL    CALL CPYTSQ(X(LFAO),X(LWRK2),L1,1)
CMKL    CALL CPYTSQ(X(LS),X(LSS),L1,1)
CMKL    CALL DSYGV(1,'V','U',L1,X(LWRK2),L1,X(LSS),L1,X(LEIG),X(LWRKDG),
CMKL &             34*L1,INFO)
CMKL    CALL DCOPY(L3,X(LWRK2),1,X(LVEC),1)
CMKL  ELSE
        CALL TFTRI(X(LWRK1),X(LFAO),X(LQ),X(LWRK),L0,L1,L1)
C       CALL GLDIAG(L1,L1,L1,X(LWRK1),X(LSCR),X(LEIG),X(LVEC),
C    *              IGERR,X(LIWRK))
        CALL SYMDIA(X(LWRK1),X(LVEC),X(LEIG),X(LSCR),X(LIWRK),L0,L2,L1)
C       IF(IGERR.NE.0) CALL ABRT
        CALL TFSQB(X(LVEC),X(LQ),X(LWRK),L0,L1,L1)
CMKL  END IF
  800 CONTINUE
C
C                   *****************
C                   * BETA ORBITALS *
C                   *****************
C
C     FOR ROHF, WE JUST NEED TO FORM THE DENSITY MATRICES.
C
      IF(NB.EQ.0) GO TO 900
      IF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) GO TO 900
C
C     ----- DAMP AND EXTRAPOLATE THE BETA FOCK MATRIX -----
C     -LWRK1-, -LWRK2-, -LWRK3- USED AS TRIANGULAR SCRATCH SPACE
C
      IF(EXTRAH  .AND.  ITDIIS.EQ.1  .AND.  .NOT.CVGING)
     *    CALL EXTRAP(DELE,DAMP,DAMP0,X(LFB),X(LWRK1),X(LWRK2),
     *                X(LWRK3),L1,L2,L2,NDAFB,ITERV,2,1)
C
C     ----- OPTIONAL LEVEL SHIFTING OF BETA FOCK MATRIX -----
C     LWRK1,LWRK2 USED AS SYMMETRIC, LWRK3 AS SQUARE SCRATCH STORAGE
C
      IF(VSHIFT  .AND.  ITDIIS.EQ.1) THEN
         IF(ITER.EQ.1) CALL DAREAD(IDAF,IODA,X(LVB),L3,19,0)
         NDOCC = NB
         NHOCC = 0
         CALL LEVELS(X(LFB),X(LS),X(LVB),X(LWRK1),X(LWRK2),X(LWRK3),
     *               X(LSCR),L0,L1,L2,L3,ITERLV,NDOCC,NHOCC,DELE,DELE0,
     *               DIFF,ITERV,2,EXTRAH,CVGING)
      END IF
C
C     ----- TRANSFORM BETA FOCK MATRIX TO -Q- ORTHONORMAL BASIS -----
C     ----- DIAGONALIZE BETA FOCK MATRIX -----
C     ----- BACK-TRANSFORM TO AO BASIS -----
C
      IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LQ),LL3,45,0)
CMKL  IF (KDIAG.EQ.4) THEN
CMKL    CALL CPYTSQ(X(LFB),X(LWRK2),L1,1)
CMKL    CALL CPYTSQ(X(LS),X(LSS),L1,1)
CMKL    CALL DSYGV(1,'V','U',L1,X(LWRK2),L1,X(LSS),L1,X(LEB),X(LWRKDG),
CMKL &             34*L1,INFO)
CMKL    CALL DCOPY(L3,X(LWRK2),1,X(LVB),1)
CMKL  ELSE
        CALL TFTRI(X(LWRK1),X(LFB),X(LQ),X(LWRK),L0,L1,L1)
C       CALL GLDIAG(L1,L1,L1,X(LWRK1),X(LSCR),X(LEB),X(LVB),
C    *              IGERR,X(LIWRK))
C       IF(IGERR.NE.0) CALL ABRT
        CALL SYMDIA(X(LWRK1),X(LVB),X(LEB),X(LSCR),X(LIWRK),L0,L2,L1)
        CALL TFSQB(X(LVB),X(LQ),X(LWRK),L0,L1,L1)
CMKL  END IF
      CONTINUE
C
  900 CONTINUE
C
C     ----- OPTIONAL RESTRICTION OF ORBITAL INTERCHANGES -----
C     READ PREVIOUS ITERATION'S ORBITALS TO -LWRK1-
C
      IF((RSTRCT.OR.MFRZ).AND..NOT.DOAFO) THEN
         IF (NFG.NE.0.AND.RSTRCT) THEN
           CALL DETMOMFL(MOMFL,NFG,ICURFG,JCURFG,X(LEAIP))
         ELSE
           MOMFL = .TRUE.
         END IF
C          MOMFL = .TRUE. !! 140611
C        IF (ITER.EQ.1) THEN
C          IF (.NOT.INORB) MOMFL = .FALSE.
C          WRITE (*,*) "MOMFL = ", MOMFL
C        END IF
        IF (MOMFL) THEN
          IF (ITER.EQ.1) WRITE (IW,*) "RSTRCT IS TURNED ON"
          IVREC=15
          IF(NFG.NE.0.AND.ITER.EQ.1) IVREC=318
C         USE FROZEN LMOS IN OVLSEL ON ITERATION 1.
          CALL DAREAD(IDAF,IODA,X(LWRK1),LL3,IVREC,0)
          IF (OUT) THEN
            CALL PREV(X(LWRK1),X(LEIG),L0,L1,L1)
          END IF
          IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),LL2,12,0)
          idum=0
          IF (MOM) THEN
          !! TEST PURPOSE
          CALL OVLSEL(X(LVEC),X(LEIG),X(LWRK1),X(LS),X(LWRK2),X(LWRK),
     *                X(LIWRK),X(LIWRK1),KPROJ,NA,L0,L1,L2,.TRUE.,L0)
          ELSE
          CALL OVLSEL(X(LVEC),X(LEIG),X(LWRK1),X(LS),X(LWRK2),X(LWRK),
     *                X(LIWRK),X(LWRK),IDUM,IDUM,L0,L1,L2,.FALSE.,L0)
          END IF
        END IF
      ELSE IF(MOM) THEN
         CALL DAREAD(IDAF,IODA,X(LWRK1),L3,15,0)
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
         CALL OVLSEL(X(LVA),X(LEA),X(LWRK1),X(LS),X(LWRK2),X(LSCR),
     *              X(LIWRK),X(LIWRK2),KPROJ,NA,L0,L1,L2,MOM,L0)
         IF(SCFTYP.EQ.UHF  .AND.  NB.GT.0) THEN
            CALL DAREAD(IDAF,IODA,X(LWRK1),L3,19,0)
            IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
            CALL OVLSEL(X(LVB),X(LEB),X(LWRK1),X(LS),X(LWRK2),X(LSCR),
     *                  X(LIWRK),X(LIWRK2),KPROJ,NB,L0,L1,L2,MOM,L0)
         END IF
      END IF
C     TEST = .false.
C     IF (TEST) THEN
C       CALL SCFSAV(X(LVEC),X(LD),X(LEIG),NDAF,LL1,LL2,LL3)
C       WRITE (*,*) "BEFORE LOCALIZATION"
C       CALL PREV(X(LVEC),X(LEIG),L0,L1,L1)
C       CALL LMOLOC(3)
C       WRITE (*,*) "AFTER LOCALIZATION"
C       CALL DAREAD(IDAF,IODA,X(LVEC),LL3,71,0)
C       CALL PREV(X(LVEC),X(LEIG),L0,L1,L1)
C     END IF
C
      IF(OUT) THEN
         IF (SCFTYP.EQ.RHF) THEN
           WRITE(IW,*) 'NEW ORBITALS'
           CALL PREV(X(LVEC),X(LEIG),L0,L1,L1)
         ELSE
           WRITE(IW,*) 'NEW ALPHA ORBITALS'
           CALL PREV(X(LVA),X(LEA),L0,L1,L1)
           IF(SCFTYP.EQ.UHF  .AND.  NB.GT.0) THEN
              WRITE(IW,*) 'NEW BETA ORBITALS'
              CALL PREV(X(LVB),X(LEB),L0,L1,L1)
           END IF
         END IF
      END IF
C---  CALL CPU_TIME(T5)
C
      IF (OUT) THEN
        if (iter.eq.1)
     *  WRITE (IW,'(" HOMO-LUMO GAP = ", F12.7)')
     *        X(LEIG+NA)-X(LEIG+NA-1)
      END IF
      IF (LETEMP) THEN
C       IF (SCFTYP.EQ.UHF) THEN
C    *    CALL DFTB_ETEMP(L0,NA,X(LEIG),X(LOCC),ETEMP,EMERMIN,EF)
C    *    CALL DFTB_ETEMP(L0,NB,X(LEB),X(LBOC),ETEMP,EMERMIN,EF)
C       ELSE
          CALL DFTB_ETEMP(L0,NE,X(LEIG),X(LOCC),ETEMP,EMERMIN,EF)
C       END IF
      END IF
C
C     ----- FORM THE NEW DENSITY MATRIX, AND ITS MAXIMUM CHANGE -----
C     OLD DENSITY IS COPIED TO LWRK1, AS A SYMMETRIC MATRIX
C
      CALL DCOPY(L2,X(LD),1,X(LWRK1),1)
      CALL DFTB_DMTOCC(X(LD),X(LVEC),X(LOCC),X(LWRK3),L1,L1)
      DIFFP = DIFF
      CALL DDIFF(X(LWRK1),X(LD),L2,DIFF)
      IF(NB.GT.0.AND.(SCFTYP.EQ.UHF.OR.ROHFGAMESS)) THEN
         CALL DCOPY(L2,X(LDB),1,X(LWRK2),1)
         CALL DFTB_DMTOCC(X(LDB),X(LVB),X(LBOC),X(LWRK3),L1,L1)
         CALL DDIFF(X(LWRK2),X(LDB),L2,DIFFB)
      ELSE
         CALL VCLR(X(LWRK2),1,L2)
         IF(SCFTYP.EQ.ROHF) THEN
            CALL VCLR(X(LDB),1,L2)
         ELSE IF (SCFTYP.EQ.UHF) THEN
            CALL ZEROD(X(LVB),X(LDB),X(LEB),L1,L2,L3)
         END IF
         DIFFB=ZERO
      END IF
      DIFFP = DIFF
      DIFF  = DIFF+DIFFB
      IF(OUT) THEN
         IF (SCFTYP.EQ.RHF) THEN
           WRITE(IW,*) 'NEW DENSITY MATRIX'
           CALL PRTRIL(X(LD),L1)
         ELSE
           WRITE(IW,*) 'NEW ALPHA DENSITY MATRIX'
           CALL PRTRIL(X(LDA),L1)
           WRITE(IW,*) 'NEW BETA DENSITY MATRIX'
           CALL PRTRIL(X(LDB),L1)
         END IF
         WRITE(IW,*) '*** END OF DEBUG OUTPUT FOR ITERATION',ITER
      END IF
C
C     ----- SAVE MO-S + DENSITY + ORBITAL ENERGIES -----
C
C     CALL SCFSAV(X(LVEC),X(LD),X(LEIG),NDAF,LL1,LL2,LL3)
C
      CALL TSECND(TITER2)
      TFOCK  = TFOCK  + (TITER1-TITER0)
      TSOLVE = TSOLVE + (TITER2-TITER1)
      IF(ITER.EQ.1) TFOCK1 = TITER1 - TITER0
      TFOCKN = TITER1 - TITER0
C
C     ----- CALCULATE MULLIKEN ATOMIC POPULATIONS/CHARGES -----
C
      CALL DFTB_MULLIKEN(L1,L2,X(LD),X(LS),X(LMUL1))
      CALL DFTB_MULSA(X(LMUL1),X(LMUL1S),X(LMUL1A),NUM,NSHELL,NAT)
      IF (SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
        CALL DFTB_MULLIKEN(L1,L2,X(LDB),X(LS),X(LMULB))
        CALL DFTB_MULSA(X(LMULB),X(LMULSB),X(LMULAB),NUM,NSHELL,NAT)
        CALL VADD(X(LMULAB),1,X(LMUL1A),1,X(LMUL1A),1,NAT)
        CALL DCOPY(NSHELL,X(LMUL1S),1,X(LWRK),1)
        CALL VADD(X(LMULSB),1,X(LMUL1S),1,X(LMUL1S),1,NSHELL)
        CALL VSUB(X(LMULSB),1,X(LWRK),1,X(LMULSB),1,NSHELL)
C       DO I = 1, NAT
C         X(LMUL1A+I-1) = X(LMUL1A+I-1) + X(LMULAB+I-1)
C       END DO
      END IF
      DO I = 1, NAT
        X(LMUL3A+I-1) = X(LMUL1A+I-1) - ZREF(I)
      END DO
      IF (SRSCC) THEN
        ISH = 0
        DO I = 1, NAT
          DO J = 1, MAXANG(ISPE(I))
            ISH = ISH + 1
            X(LMUL3S+ISH-1) = X(LMUL1S+ISH-1) - QREFL(J,ISPE(I))
          END DO
        END DO
      END IF
C     write (*,*)" shell resolved populations"
C     do i = 1, nshell
C       write (*,'(i3,x,f20.10,x,f20.10)') i,x(lmul1s+i-1),x(lmulsb+i-1)
C     end do
C
C     ----- CALCULATE NCC BAND ENERGY -----
C     SOSCF: SLOW.  EIGENVALUES ARE NOT UPDATED, SO DFTB HAS TO CALCULATE
C            THE ENERGY BY
C              \SUM_{I,A,B} \SUM_{\MU \IN A} \SUM_{\NU \IN B}
C                                  N_I C_{\MU I} C_{\NU I} H_{\MU \NU}^0
C            IT TAKES MUCH TIME ESPECIALLY FOR LARGE MOLECULES
C     DIIS : BETTER.  CALCULATION OF OF THIS ENERGY IS IGNORABLE
C
      ENCC = ZERO
      IF (SOSCF.OR.LRDFTB.OR.ROHFGAMESS.OR.IPCM.NE.0.OR.MFRZ) THEN
C       IF (MASWRK .AND. ITER.EQ.1) THEN
C         WRITE (IW,*) "CALCULATION OF NCC BAND ENERGY FOR SOSCF IS"
C         WRITE (IW,*) "EXTREMELY SLOW, BECAUSE EIGENVALUES ARE NOT"
C         WRITE (IW,*) "UPDATED, WHICH IS USED FOR NCC ENERGY."
C       END IF
       IF (IPCM.EQ.1.AND.LHVC.NE.0) THEN
       CALL DFTB_CALC_ENCC_SOSCF(ENCC,X(LDA),X(LDB),X(LHVC),L1,L2,
     *  SCFTYP,ROHFGAMESS)
       ELSE
       CALL DFTB_CALC_ENCC_SOSCF(ENCC,X(LDA),X(LDB),X(LH0),L1,L2,SCFTYP,
     *  ROHFGAMESS)
       END IF
      ELSE
        IF (NFG.GT.0.AND.SCC) CALL DAXPY(NAT,ONE,SHIFT2,1,SHIFT,1)
        IF (SRSCC) THEN
          CALL DFTB_CALC_ENCC(ENCC,X(LAOC),X(LEA),X(LBOC),X(LEB),
     *      X(LMUL1S),X(LSHIFTSH),L1,NSHELL,SCC,ROHFGAMESS,SCFTYP)
        ELSE
          CALL DFTB_CALC_ENCC(ENCC,X(LAOC),X(LEA),X(LBOC),X(LEB),
     *      X(LMUL1A),SHIFT,L1,NAT,SCC,ROHFGAMESS,SCFTYP)
        END IF
      END IF
C     write (*,*) "shell population"
C     do i = 1, nshell
C       write (*,'(i3,x,f20.10)') i,x(lmul1s+i-1)
C     end do
C     WRITE (*,'(A,F20.10)') "ENCC = ", ENCC
C     write (*,*) "shell-resolved charges"
C     do i = 1, nshell
C       write (*,'(i3,x,f20.10)') i,x(lmul3s+i-1)
C     end do
C
C     ----- CALCULATE SCC ENERGY ----
C
      ESCC = ZERO
      ESCC3 = ZERO
      IF (SCC) THEN
        IF (SRSCC) THEN
          CALL DFTB_CALC_ESCC(ESCC,ESCC3,X(LGAMMA),X(LGAM3),X(LMUL3S),
     *      NSHELL,DFTB3,.TRUE.,NAT,MAXANG,ISPE)
        ELSE
          CALL DFTB_CALC_ESCC(ESCC,ESCC3,X(LGAMMA),X(LGAM3),X(LMUL3A),
     *      NAT,DFTB3,.FALSE.,NAT,MAXANG,ISPE)
        END IF
        IF (EFLDL) THEN !! USE EVEC(1:3)
          DO IEVEC = 1, 3
            IF (EVEC(IEVEC).EQ.ZERO) CYCLE
            TEVEC = EVEC(IEVEC)
            DO I = 1, NAT
              ESCC = ESCC + X(LMUL3A+I-1)*C(IEVEC,I)*TEVEC
            END DO
          END DO
        END IF
        IF (LRDFTB) then
          ESCC = ESCC + ELR
C         WRITE (*,*) "ELR  = ", ELR
        END IF
C       WRITE (*,*) "ESCC = ", ESCC
C
C     ----- ELECTRON EMBEDDING ENERGY FOR FMO -----
C
        if(nfg.ne.0) then
          lpopmati=lpopmat+(maxnat*nfg)*(icurpop-1)
          !! 2nd order part
          esccesp=DDOT(NAT,X(LMUL3A),1,SHIFT2,1)
          IF (DFTB3) THEN
            TMP = 0.0D+00
            !! 3rd order part
            DO I = 1, NAT
              TMP = TMP + SHIFT3(NAT+I)*X(LMUL3A+I-1)
     *                  + SHIFT3(I)*X(LMUL3A+I-1)*X(LMUL3A+I-1)
            END DO
            ESCCESP = ESCCESP + TMP
          END IF
C         WRITE (*,'(A,F20.10)') "ESCC w/o ESP",escc
          escc=escc+esccesp
C         WRITE (*,'(A,F20.10)') "ESCC w   ESP",escc
          edft(1)=esccesp
C         WRITE (*,*) "EESPFMO", esccesp
        END IF
C       write (*,*) "ESCC = ", escc
        ESPIN = ZERO
        IF (SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
          !! CALCULATE SHELL-RESOLVED POPULATION (X(LMUL1S))
C         CALL DCOPY(NSHELL,X(LMUL1S),1,X(LWRK),1)
C         CALL DAXPY(NSHELL,ONE,X(LMULSB),1,X(LMUL1S),1)
          !! CALCULATE SPIN DENSITY (X(LMULSB))
C         CALL DSCAL(NSHELL,-ONE,X(LMULSB),1)
C         CALL DAXPY(NSHELL,ONE,X(LWRK),1,X(LMULSB),1)
          !! CALULATE SPIN ENERGY AND ENCC CORRECTION
          CALL DFTB_CALC_ESPIN(ENCC,ESPIN,SHIFTS,X(LMULSB),
     *      SPNCST,NAT,NSHELL,NSPE,ISPE,MAXANG,SCC,SOSCF.OR.IPCM.EQ.1)
C         write (*,*) "epin = ", espin
          EKIN = ESPIN
        END IF
      END IF
C
      ETOT0 = ETOT
      ETOT  = ENCC + ESCC + EN + ESPIN
C     IF (MFRZ) ETOT = ETOT + EHF1C
C       write (*,*) "ETOT = ", etot
C
C        ---- SOLVENT ENERGY CORRECTIONS ----
C
C     NOTE: ONSAGER MODEL PUT FREE ENERGY CORRECTIONS INTO -EN- ALREADY
C
C     IF PCM: CALCULATE THE CORRECT VARIATIONAL FREE ENERGY
C
      IF(IPCMIT.EQ.0) THEN
C        IF((IPCM.EQ.1.AND.ISD.EQ.1).OR.IPCFP) ETOT=ETOT-HALF*(PB-PC)
         IF((IPCM.EQ.1.AND.ISD.EQ.1).OR.IPCFP) ETOT=ETOT+HALF*(PB+PC+PX)
      ELSE
C        IF((IPCM.EQ.1.AND.ISD.EQ.1).OR.IPCFP) ETOT=ETOT+HALF*PX
         !! PX CONTAINS ONLY (SOLUTE NUCLEI)-(POLARIZATION ELECTRONIC
         !! CHARGES) INTERACTION (EQUAL TO PC). USE ENPCM WHICH ALSO
         !! INCLUDES (SOLUTE ELECTRONS)-(POLARIZATION ELECTRONIC
         !! CHARGES) INTERACTION.
         !! IT'S BECAUSE THE CALCULATION OF (SOLUTE) ELECTRONIC ENERGY
         !! IS DIFFERENT FROM HF/DFT
         IF((IPCM.EQ.1.AND.ISD.EQ.1).OR.IPCFP) ETOT=ETOT+HALF*ENPCM
      END IF
      IF(NFMOPCM.NE.0) ETOT=ETOT+HALF*(PC+PX)
C
      IF(IPCM.EQ.1 .OR. IPCFP) THEN
         ETOT=ETOT+(GCAVP+GDISP+GREP)/627.509541D+00
      END IF
      IF(ISEPS) ETOT = ETOT - SECORR
C
C     SVP MODEL'S FREE ENERGY CORRECTION
C
C     IF(ISVP.EQ.1) ETOT=ETOT+HALF*ESVP
C
C     MINNESOTA SOLVATION MODELS
C
      IF((ISMX.EQ.1.OR.ISMX.EQ.2).AND.(IPCM.EQ.1.OR.IPCFP)) THEN
         IF (ITER.EQ.1) CALL CDSSET(ISMX)
         ETOT=ETOT-(GCAVP+GDISP+GREP)/627.509541D+00+GCDS/627.509541D+00
      END IF
      IF(ISMX.EQ.3  .AND.  ISVP.EQ.1) THEN
         IF (ITER.EQ.1) CALL CDSSET(ISMX)
      END IF
C
      IF (LETEMP) ETOT = ETOT + EMERMIN
c       write (*,*) "ETOT = ", etot
c       write (*,*) "EN   = ", en
      DELE  = ETOT-ETOT0
C     WRITE (IW,*) "ETOT = ",ETOT
C     WRITE (IW,*) "ENCC = ",ENCC
C     WRITE (IW,*) "ESCC = ",ESCC
C     WRITE (IW,*) "EREP = ",EN
C
C     LMUL2A: CURRENT CHARGE
C     LMUL1A: UPDATED CHARGE
C
      IF (OUT) THEN
        WRITE (IW,'(" DEBUG PRINT OF MULLIKEN CHARGES")')
        DO I = 1, NAT
          WRITE (IW,'(X,I3,X,A8,X,F10.5,X,F10.5)')
     *    I,SPE(ISPE(I)),ZREF(I)-X(LMUL1A+I-1), X(LMUL1A+I-1)
        END DO
        WRITE (IW,'(" DEBUG PRINT OF SPIN-RESOLVED MULLIKEN CHARGES")')
        IF (SRSCC.OR.SCFTYP.EQ.UHF) THEN
          WRITE (IW,'(" #IND, SPE, POPULATION, SPIN-POPULATION")')
          DO I = 1, NSHELL
            WRITE (IW,'(X,I3,X,F10.5,X,F10.5)')
     *      I,X(LMUL1S+I-1),X(LMULSB+I-1)
          END DO
        END IF
      END IF
C
      IF (TBROYDEN) THEN
        iter0=iter
        IF (LRDFTB) THEN
          CALL DFTB_MIXER(ITER0,L1,X(LMUL2),X(LMUL1),
     *                    MEMMIX,ERDIIS,ETOT)
          CALL DCOPY(L1,X(LMUL1),1,X(LMUL2),1)
          CALL VCLR(X(LMUL1A),1,NAT)
          N = 0
          DO I = 1, NAT
            DO J = 1, MAXANG(ISPE(I))**2
              N = N + 1
              X(LMUL1A+I-1) = X(LMUL1A+I-1) + X(LMUL2+N-1)
            END DO
          END DO
          CALL DCOPY(NAT,X(LMUL1A),1,X(LMUL2A),1)
        ELSE
          IF (SRSCC) THEN
            CALL DFTB_MIXER(ITER0,NSHELL,X(LMUL2S),X(LMUL1S),
     *                      MEMMIX,ERDIIS,ETOT)
            CALL DCOPY(NSHELL,X(LMUL1S),1,X(LMUL2S),1)
            ISH = 0
            DO I = 1, NAT
              DO J = 1, MAXANG(ISPE(I))
                ISH = ISH + 1
                X(LMUL3S+ISH-1) = X(LMUL1S+ISH-1) - QREFL(J,ISPE(I))
              END DO
            END DO
            !! ATOM-RESOLVED MULLIKEN POPULATIONS
            ISH = 0
            DO I = 1, NAT
              TMP = ZERO
              DO J = 1, MAXANG(ISPE(I))
                ISH = ISH + 1
                TMP = TMP + X(LMUL1S+ISH-1)
              END DO
              X(LMUL1A+I-1) = TMP
            END DO
          ELSE
            CALL DFTB_MIXER(ITER0,NAT,X(LMUL2A),X(LMUL1A),
     *                      MEMMIX,ERDIIS,ETOT)
            CALL DCOPY(NAT,X(LMUL1A),1,X(LMUL2A),1)
          END IF
C         CALL DCOPY(NAT,X(LMUL2A),1,X(LMUL1A),1)
        END IF
        DO I = 1, NAT
          X(LMUL3A+I-1) = X(LMUL1A+I-1) - ZREF(I)
        END DO
      END IF
C
C     ----- CHECK CONVERGENCE BEHAVIOR -----
C
  700 CONTINUE
      IF(SOSCF) THEN
         ERRORC = ORBGRD
      ELSE
         ERRORC = ERDIIS
      END IF
      IF(MASPRT) THEN
         IF(DAMPH  .OR.  VSHIFT) THEN
            IF(DIRSCF) THEN
               WRITE(IW,9090) ITER,ICALP,NUMDEM,ETOT,DELE,DIFF,ERRORC,
     *                        RRSHFT,DAMP,NINT,NSCHWZ
            ELSE
               WRITE(IW,9090) ITER,ICALP,NUMDEM,ETOT,DELE,DIFF,ERRORC,
     *                        RRSHFT,DAMP
            END IF
         ELSE
            IF(DIRSCF) THEN
               WRITE(IW,9100) ITER,ICALP,NUMDEM,ETOT,DELE,DIFF,ERRORC,
     *                        NINT,NSCHWZ
            ELSE
               WRITE(IW,9100) ITER,ICALP,NUMDEM,ETOT,DELE,DIFF,ERRORC
            END IF
         END IF
      END IF
      CALL FLSHBF(IW)
C
C     ----- EXIT IF NCC-DFTB CALCULATION -----
C
      IF (.NOT.SCC) THEN
        WRITE (IW,'(/"          NCC-DFTB CALCULATION FINISHED"/)')
        GOTO 400
      END IF
C
C     WILL THIS CURE MYSTERIOUS HANG-UPS?  (IN PARALLEL RUNS)
C     IT SEEMS THAT IN MIXED NODE ENVIRONMENT ONE MAY GET SOME NODE
C     CONVERGED AND OTHERS NOT (ACTUALLY, THIS IS SUPPOSED TO HOLD
C     TRUE NOT JUST FOR GDDI BUT ANY PARALLEL RUNS). TRY JUST GDDI 1ST.
C     POSSIBLE AGGRAVATION COMES FROM MINUTE NUMERIC ERRORS DUE TO
C     ADDING SMALL/LARGE NUMBERS (FROM FMO PROJECTORS).
C     SO THE PROBLEM IS POSSIBLY ENHANCED BY (BUT NOT LIMITED TO)
C     A) RUNNING FMO
C     B) USING SMART BLAS LIBRARIES THAT MAY GIVE SLIGHTLY DIFFERENT
C        ANSWERS ON DIFFERENT CPUS.
C     ISGDDI SHOULD REALLY BE GOPARR, PERHAPS, TO GET NON-FMO RUNS.
C
      IF(ISGDDI) THEN
         CALL DDI_BCAST(2422,'F',DIFF,1,MASTER)
         CALL DDI_BCAST(2423,'F',DELE,1,MASTER)
         IF(DODIIS) CALL DDI_BCAST(2424,'F',ERDIIS,1,MASTER)
      ENDIF
C
      ICALP = ICALP+1
      CVDENS = (DIFF.LT.DENTOL  .AND.  ABS(DELE).LT.ETOL2) .OR.
     *         (DIFF.LT.DENTOL/FIVE)
      CVENGY = ABS(DELE).LT.ENGTOL  .AND.  DIFF.LT.DTOL2
      IF(DODIIS) CVDIIS = ERDIIS.LT.DIITOL  .AND.  DIFF.LT.DTOL2
      CVGED  = (CVGING  .AND.  (CVDENS.OR.CVENGY.OR.CVDIIS))
      IF (IPCM.NE.0.AND.NAT.EQ.1) CVGED=(CVGING.AND.(CVENGY.OR.CVDIIS))
      CVGED  = CVGED  .AND.  ISWOFF.EQ.0
      IF(NEORUN.EQ.1)
     *   CVGED  = (CVGING  .AND.  (CVDENS.AND.CVENGY.OR.CVDIIS))
      CVGING = CVDENS.OR.CVENGY.OR.CVDIIS
C
C
C         TURN ON THE DFT IF PRELIMINARY SCF IS BECOMING CONVERGED.
C
      IDFTSWITCH_SAVE=IDFTSWITCH
      IF(ISWOFF.GT.0.AND.DIFF.LT.SWOFF) THEN
        IF(MASWRK) WRITE(IW,9355)
        DFTTYP(3)=HFSSAV
        NDFTFG=NDFTSV
        LCFLAG=LCFLAGS
        LRINT=LRINTS
        ISWOFF=0
        IDFTSWITCH=1
      END IF
C
      IF(DIRSCF.AND.FDIFF.AND.ABS(DELE).LT.DIRTHR.AND.ISWDIR.GT.0) THEN
        ITDIR=ITDIR+1
        IF(ITDIR.GE.NITDIR) THEN
           ITDIR=0
           IF(MASWRK) WRITE(IW,9370)
           IDFTSWITCH=3
C          THIS IS NOT REALLY A DFT SWITCH BUT IT WILL DO THE TRICK
           ISWDIR=ISWDIR-1
        ENDIF
      ELSE
        ITDIR=0
      ENDIF

C
C       SWITCH FROM DIIS TO SOSCF!
C       OBVIOUSLY SUCH SWITCH CAN BE DONE ONLY ONCE IN ANY RUN.
C       NOTE THAT DENSITY DIFFERENCING (FDIFF) NEED NOT BE RESET.
C       POSTPONE SWITCH DIIS->SOSCF IF WE HAVE JUST SWITCHED SCF-->DFT
C       AND ARE USING DIRSCF+FDIFF (DOUBLE SWITCH IS NOT WORKING NOW).
C       THIS POSTPONEMENT WAS PUT IN SEPTEMBER 2009
C
C---  IF(DODIIS  .AND.  SWDIIS.GT.0.0D+00  .AND.  DIFF.LT.SWDIIS) THEN
      IF(DODIIS  .AND.  SWDIIS.GT.0.0D+00  .AND.  DIFF.LT.SWDIIS  .AND.
     *   (IDFTSWITCH.EQ.IDFTSWITCH_SAVE.OR.DIRSCF.AND..NOT.FDIFF)) THEN
        IF (.NOT.MOMFL) THEN
          ITDIIS=1
          IF(.NOT.NOTOPN) CALL RACLOS(20,'DELETE')
          NOTOPN=.TRUE.
          DODIIS=.FALSE.
          SOSCF=.TRUE.
          IF(NFG.EQ.0) MCONV = MCONV - 16 + 64
          IF(MASWRK) WRITE(IW,9380)
          IDFTSWITCH=4
        END IF
      END IF
C
C         ANY SUCH SWITCH IN GRIDS OR CONVERGERS MUST RESET CONVERGERS,
C         AND PERHAPS RESET THE DIFFERENTIAL FOCK FORMATION.
C
      IF(IDFTSWITCH.NE.0) THEN
        CVGED=.FALSE.
        CVGING=.FALSE.
        CVENGY=.FALSE.
        CVDIIS=.FALSE.
        CVDENS=.FALSE.
        if(.not.locopt) then
           EXTRAH = .FALSE.
           DAMPH  = .FALSE.
           VSHIFT = .FALSE.
           DEM    = .FALSE.
        endif
        IF(DODIIS) THEN
          ITDIIS=1
          IF(.NOT.NOTOPN) CALL RACLOS(20,'DELETE')
          NOTOPN=.TRUE.
        END IF
        IF(SOSCF) ITSO=0
        IF(ABINIT .AND. DIRSCF .AND. FDIFF .AND. IDFTSWITCH.NE.4) THEN
           IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
           CALL DAWRIT(IDAF,IODA,X(LH1),LL2,14,0)
           CALL VCLR(X(LWRK1),1,L2)
        END IF
        IDFTSWITCH=0
      END IF
C
C         IF WE ARE FINISHED, CANONICALIZE THE 2ND ORDER SCF ORBITALS
C
      EMP2S=0
      IF(CVGED.AND.DOAFO.AND.NUMFRZ.GT.0
     *      .AND.IAND(MODLMO,1048576).EQ.0) THEN
         LFXC = LAST !! DUMMY, ONLY FOR DFT
         EHF1=zero
         CALL FMOAFOC(NDAF,ABINIT,MINMEM,X(LVEC),X(LFAO),X(LS),X(LQ),
     *                X(LD),X(LFXC),X(LIWRK),X(LWRK),X(LWRK1),X(LWRK2),
     *                X(LEIG),X(LOCC),X(LSCR),L0,L1,L2,L3,ETOT,EHF,EHF1)
      ELSE IF(CVGED  .AND.  SOSCF) THEN
C        DOES NOT NEED TO CALCULATE SHIFT ARRAY AGAIN.
         IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LQ),LL3,45,0)
         CALL TFTRI(X(LWRK1),X(LFAO),X(LQ),X(LWRK),L0,L1,L1)
C        CALL GLDIAG(L1,L1,L1,X(LWRK1),X(LSCR),X(LEIG),X(LVEC),
C    *            IGERR,X(LIWRK))
         CALL SYMDIA(X(LWRK1),X(LVEC),X(LEIG),X(LSCR),X(LIWRK),
     *               L0,L2,L1)
         CALL TFSQB(X(LVEC),X(LQ),X(LWRK),L0,L1,L1)
C
         IF((RSTRCT.OR.MFRZ).AND..NOT.DOAFO) THEN
            CALL DAREAD(IDAF,IODA,X(LWRK1),LL3,15,0)
            IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),LL2,12,0)
            CALL OVLSEL(X(LVEC),X(LEIG),X(LWRK1),X(LS),X(LWRK2),X(LWRK),
     *                  X(LIWRK),X(LWRK),IDUM,IDUM,L0,L1,L2,.FALSE.,L0)
         END IF
C
         IF(NB.EQ.0) GO TO 910
         IF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) GO TO 910
C
         CALL TFTRI(X(LWRK1),X(LFB),X(LQ),X(LWRK),L0,L1,L1)
C        CALL GLDIAG(L1,L1,L1,X(LWRK1),X(LSCR),X(LEB),X(LVB),
C    *               IGERR,X(LIWRK))
         CALL SYMDIA(X(LWRK1),X(LVB),X(LEB),X(LSCR),X(LIWRK),
     *               L0,L2,L1)
         CALL TFSQB(X(LVB),X(LQ),X(LWRK),L0,L1,L1)
C
         CALL DFTB_DMTOCC(X(LD),X(LVEC),X(LOCC),X(LWRK3),L1,L1)
         CALL SCFSAV(X(LVEC),X(LD),X(LEIG),NDAF,LL1,LL2,LL3)
         IF(NB.GT.0.AND.(SCFTYP.EQ.UHF.OR.ROHFGAMESS)) THEN
            CALL DFTB_DMTOCC(X(LDB),X(LVB),X(LBOC),X(LWRK3),L1,L1)
         ELSE
            CALL VCLR(X(LWRK2),1,L2)
            IF(SCFTYP.EQ.ROHF) THEN
               CALL VCLR(X(LDB),1,L2)
            ELSE IF (SCFTYP.EQ.UHF) THEN
               CALL ZEROD(X(LVB),X(LDB),X(LEB),L1,L2,L3)
            END IF
         END IF
C
         IF(RSTRCT.OR.MFRZ) THEN
            CALL DAREAD(IDAF,IODA,X(LWRK1),L3,15,0)
            IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
            CALL OVLSEL(X(LVB),X(LEB),X(LWRK1),X(LS),X(LWRK2),X(LSCR),
     *                  X(LIWRK),X(LSCR),IDUM,IDUM,L0,L1,L2,.FALSE.,L0)
         END IF
C
  910    CALL DFTB_MULLIKEN(L1,L2,X(LD),X(LS),X(LMUL1))
         CALL DFTB_MULSA(X(LMUL1),X(LMUL1S),X(LMUL1A),NUM,NSHELL,NAT)
         IF (SCFTYP.EQ.UHF) THEN
           CALL DFTB_MULLIKEN(L1,L2,X(LDB),X(LS),X(LMULB))
           CALL DFTB_MULSA(X(LMULB),X(LMULSB),X(LMULAB),NUM,NSHELL,NAT)
           CALL VADD(X(LMULAB),1,X(LMUL1A),1,X(LMUL1A),1,NAT)
           CALL DCOPY(NSHELL,X(LMUL1S),1,X(LWRK),1)
           CALL VADD(X(LMULSB),1,X(LMUL1S),1,X(LMUL1S),1,NSHELL)
           CALL VSUB(X(LMULSB),1,X(LWRK),1,X(LMULSB),1,NSHELL)
         END IF
         DO I = 1, NAT
           X(LMUL3A+I-1) = X(LMUL1A+I-1) - ZREF(I)
         END DO
         IF (SRSCC) THEN
           ISH = 0
           DO I = 1, NAT
             DO J = 1, MAXANG(ISPE(I))
               ISH = ISH + 1
               X(LMUL3S+ISH-1) = X(LMUL1S+ISH-1) - QREFL(J,ISPE(I))
             END DO
           END DO
         END IF
C     SRP: STORING VEC AND EIG FOR EFMO RUNS USING SHORT RANGE EFP2 TERMS
C
          IF(IEFMORUN.GT.0.AND.IMODEFD.NE.0)THEN
           CALL DAWRIT(IDAF,IODA,X(LVEC),LL3,615,0)
           CALL DAWRIT(IDAF,IODA,X(LEIG),LL1,617,0)
          ENDIF
C
          CALL VCLR(SHIFT,1,NAT)
          IF (SRSCC) THEN
            CALL VCLR(X(LSHIFTSH),1,NSHELL)
            CALL DFTB_2ND_SHIFT(X(LSHIFTSH),X(LMUL3S),X(LGAMMA),NSHELL)
            IF (DFTB3) THEN
              CALL DFTB_3RD_SHIFT(X(LSHIFTSH),X(LMUL3S),X(LGAM3),NSHELL)
            END IF
          ELSE
            CALL DFTB_2ND_SHIFT(SHIFT,X(LMUL3A),X(LGAMMA),NAT)
            IF (DFTB3) THEN
              CALL DFTB_3RD_SHIFT(SHIFT,X(LMUL3A),X(LGAM3),NAT)
              IF (NFG.GT.0)
     *          CALL DFTB_3RD_SHIFT_FMO(SHIFT,X(LMUL3A),SHIFT3,NAT)
            END IF
          END IF
C
          IF (EFLDL) CALL DFTB_EFIELD_SHIFT(SHIFT,EVEC,C,NAT)
C
          IF (SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
            IF (.NOT.SRSCC) CALL DFTB_SHIFT_ATOSH(SHIFT,X(LSHIFTSH),NAT,
     *        NSHELL,NSPE,ISPE,MAXANG)
            CALL DCOPY(L2,X(LFAO),1,X(LFB),1)
            CALL VCLR(SHIFTS,1,NSHELL)
            CALL DFTB_SPIN_SHIFT(SHIFTS,X(LMULSB),SPNCST,NAT,NSHELL,
     *        NSPE,ISPE,MAXANG)
            CALL DFTB_SHIFT_FOCK_UHF(X(LFA),X(LFB),SHIFTS,X(LSHIFTSH),
     *        X(LS),NAT,L2,NSHELL,NSPE,ISPE,MAXANG)
          ELSE IF (SRSCC) THEN
            CALL DFTB_SHIFT_FOCK_SRSCC(X(LFA),X(LSHIFTSH),X(LS),NAT,L1,
     *        L2,NSHELL,NSPE,ISPE,MAXANG)
          ELSE
            CALL DFTB_SHIFT_FOCK(SHIFT,X(LFAO),X(LS),NAT,L2,NSPE,
     *        ISPE,IND,MAXANG)
          END IF
C
          IF (IPCM.EQ.1) THEN
            NSEQ = 0
            IF (SRSCC) THEN
              ISH0 = 0
              DO IAT = 1, NAT
                ISH = ISH0
                DO K = 1, MAXANG(ISPE(IAT))*MAXANG(ISPE(IAT))
                  MU = IND(IAT) + K
                  NSEQ = NSEQ + MU
                  IF (K.EQ.1.OR.K.EQ.2.OR.K.EQ.5) THEN
                    ISH = ISH + 1
                    X(LSHIFTSH+ISH-1)=X(LSHIFTSH+ISH-1) + X(LSOL+NSEQ-1)
                  END IF
                END DO
                ISH0 = ISH0 + MAXANG(ISPE(IAT))
              END DO
            ELSE
              DO IAT = 1, NAT
                DO K = 1, MAXANG(ISPE(IAT))*MAXANG(ISPE(IAT))
                  MU = IND(IAT) + K
                  NSEQ = NSEQ + MU
                  IF (K.EQ.1) SHIFT(IAT) = SHIFT(IAT) + X(LSOL+NSEQ-1)
                END DO
              END DO
            END IF
          END IF
C
C     CALCULATE ENERGY AGAIN FOR SOSCF AT DFTB.
C     NCC NEVER REACHES THIS PART.
C
          ENCC = ZERO
          IF (NFG.GT.0.AND.SCC) CALL DAXPY(NAT,ONE,SHIFT2,1,SHIFT,1)
          IF (SRSCC) THEN
            CALL DFTB_CALC_ENCC(ENCC,X(LAOC),X(LEA),X(LBOC),X(LEB),
     *        X(LMUL1S),X(LSHIFTSH),L1,NSHELL,SCC,ROHFGAMESS,SCFTYP)
          ELSE
            CALL DFTB_CALC_ENCC(ENCC,X(LAOC),X(LEA),X(LBOC),X(LEB),
     *        X(LMUL1A),SHIFT,L1,NAT,SCC,ROHFGAMESS,SCFTYP)
          END IF
C
          ESCC = ZERO
          ESCC3 = ZERO
          IF (SRSCC) THEN
            CALL DFTB_CALC_ESCC(ESCC,ESCC3,X(LGAMMA),X(LGAM3),X(LMUL3S),
     *        NSHELL,DFTB3,.TRUE.,NAT,MAXANG,ISPE)
          ELSE
            CALL DFTB_CALC_ESCC(ESCC,ESCC3,X(LGAMMA),X(LGAM3),X(LMUL3A),
     *        NAT,DFTB3,.FALSE.,NAT,MAXANG,ISPE)
          END IF
C
          IF (EFLDL) THEN !! USE EVEC(1:3)
            DO IEVEC = 1, 3
              IF (EVEC(IEVEC).EQ.ZERO) CYCLE
              TEVEC = EVEC(IEVEC)
              DO I = 1, NAT
                ESCC = ESCC + X(LMUL3A+I-1)*C(IEVEC,I)*TEVEC
              END DO
            END DO
          END IF
C
          IF (LRDFTB) then
            ESCC = ESCC + ELR
          END IF
C
          if(nfg.ne.0) then
            lpopmati=lpopmat+(maxnat*nfg)*(icurpop-1)
            esccesp=DDOT(NAT,X(LMUL3A),1,SHIFT2,1)
            IF (DFTB3) THEN
              TMP = 0.0D+00
              DO I = 1, NAT
                TMP = TMP + SHIFT3(NAT+I)*X(LMUL3A+I-1)
     *                    + SHIFT3(I)*X(LMUL3A+I-1)**2
              END DO
              ESCCESP = ESCCESP + TMP
            END IF
            escc=escc+esccesp
            edft(1)=esccesp
          end if
          ESPIN = ZERO
          IF (SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
            !! CALCULATE SHELL-RESOLVED POPULATION (X(LMUL1S))
C           CALL DCOPY(NSHELL,X(LMUL1S),1,X(LWRK),1)
C           CALL DAXPY(NSHELL,ONE,X(LMULSB),1,X(LMUL1S),1)
            !! CALCULATE SPIN DENSITY (X(LMULSB))
C           CALL DSCAL(NSHELL,-ONE,X(LMULSB),1)
C           CALL DAXPY(NSHELL,ONE,X(LWRK),1,X(LMULSB),1)
            !! CALULATE SPIN ENERGY AND ENCC CORRECTION
            CALL DFTB_CALC_ESPIN(ENCC,ESPIN,SHIFTS,X(LMULSB),
     *        SPNCST,NAT,NSHELL,NSPE,ISPE,MAXANG,SCC,.FALSE.)
C           write (*,*) "epin = ", espin
            EKIN = ESPIN
          END IF
          ETOT0 = ETOT
          ETOT  = ENCC + ESCC + EN + ESPIN
      END IF
      IF(CVGED.AND.DOAFO.AND.NUMFRZ.EQ.0) THEN
        CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,317,0)
C       NO FROZEN ORBITALS - NO NEED TO RELAX CORE,
C       NO CORE-VIRTUAL ELEMENTS TO ZERO OUT; JUST USE THE
C       FOCK MATRIX (WITH VIRTUAL AFO PROJECTED).
      ENDIF
  710 CONTINUE
C
      IF(CVGED) THEN
C
C     --- PCM DISPERSION INTERACTION PROCEDURE ---
C     PCM STAGE 2) SOLUTE AVERAGE TRANSITION FREQUENCY
C
         IF(IPCM.EQ.1  .AND.  IDP.EQ.1  .AND.  ISD.EQ.0) THEN
C                RESET ALL CONVERGER INFORMATION
            CVGED=.FALSE.
            CVGING=.FALSE.
            CVENGY=.FALSE.
            CVDIIS=.FALSE.
            CVDENS=.FALSE.
            if(.not.locopt) then
               EXTRAH = .FALSE.
               DAMPH  = .FALSE.
               VSHIFT = .FALSE.
               DEM    = .FALSE.
            endif
            IF(DODIIS) THEN
              ITDIIS=1
              IF(.NOT.NOTOPN) CALL RACLOS(20,'DELETE')
              NOTOPN=.TRUE.
            END IF
            IF(SOSCF) ITSO=0
            IF(ABINIT .AND. DIRSCF .AND. FDIFF) THEN
               IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LH1),LL2,11,0)
               CALL DAWRIT(IDAF,IODA,X(LH1),LL2,14,0)
               CALL VCLR(X(LWRK1),1,L2)
            END IF
C                  TURN ON THE SOLUTE TERMS
            EVAC=ETOT
            CALL WTRANSA(X(LEIG),L1)
            CALL JMATDIS(X(LS),X(LH1),X(LWRK1),X(LWRK2),X(LWRK3),L1,L2,
     *                   X(LAXYZCT),X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),
     *                   X(LQSN))
            ISD=1
            GO TO 333
         END IF
C
C             DFT FOCK MATRIX LEFT ON DISK MUST INCLUDE EXCHANGE TERMS
         IF(NDFTFG.EQ.1.AND.ABINIT.AND.DIRSCF.AND.FDIFF) THEN
            CALL DAREAD(IDAF,IODA,X(LFAO),LL2,308,0)
            CALL DAWRIT(IDAF,IODA,X(LFAO),LL2,14,0)
         END IF
C
         IF(CVDENS) THEN
            IF(MASPRT) WRITE(IW,9110)
            GO TO 400
         END IF
         IF(CVDIIS) THEN
            IF(MASPRT) WRITE(IW,9120)
            GO TO 400
         END IF
         IF(CVENGY) THEN
            IF(MASPRT) WRITE(IW,9130)
            GO TO 400
         END IF
      END IF
C
C     ----- EXIT IN CASE OF TIME LIMIT -----
C
      CALL TSECND(TIM1)
      TLEFT = TIMLIM - TIM1
      TIM0 = TIM1
      IF(TLEFT .GT. 2.0D+00*(TLEFTS-TLEFT)/ITER) GO TO 300
      IF(CVGING) THEN
         IF(MASPRT) WRITE(IW,9140)
         GO TO 400
      ELSE
         ETOT = ZERO
         EHF = -EN
         IF(MASPRT) WRITE(IW,9150)
         GO TO 400
      END IF
  300 CONTINUE
C
C           *********************
C     ***** END OF RHF ITERATIONS *****
C           *********************
C
C     FALLING OUT OF LOOP 300 MEANS WE HAVE FAILED TO CONVERGE
C
      IF(MASPRT) WRITE(IW,9160)
      IF (MASWRK.AND.NFG.NE.0.AND.JCURFG.NE.0) THEN
        WRITE (IW,*)
        WRITE (IW,*) " *********************************************"
        WRITE (IW,*) "  WARNING! DIMER CALCULATION DID NOT CONVERGE "
        WRITE (IW,*) " *********************************************"
        WRITE (IW,*)
      END IF
      ITER = MAXIT
  350 CONTINUE
      ETOT = ZERO
      EHF = -EN
C
C     BRANCH TO HERE ON SUCCESFUL CONVERGENCE
C
  400 CONTINUE
      IF (SCFTYP.EQ.RHF) THEN
        CALL SCFSAV(X(LVEC),X(LD),X(LEIG),NDAF,LL1,LL2,LL3)
        CALL DAWRIT(IDAF,IODA,X(LFAO),L2,18,0)
      ELSE IF (SCFTYP.EQ.ROHF) THEN
        CALL DCOPY(L1,X(LOCC),1,X(LWRK),1)
        DO I = 1, L1
          X(I+LAOC-1) = ZERO
          X(I+LBOC-1) = ZERO
          IF(I.LE.NA) X(I+LAOC-1) = ONE
          IF(I.LE.NB) X(I+LBOC-1) = ONE
        END DO
        CALL DFTB_DMTOCC(X(LD),X(LVEC),X(LAOC),X(LWRK3),L1,L1)
C       call prtril(x(ld),l1)
        CALL SCFSAV(X(LVEC),X(LD),X(LEIG),NDAF,LL1,LL2,LL3)
        CALL DAWRIT(IDAF,IODA,X(LFAO),L2,18,0)
        CALL DFTB_DMTOCC(X(LDB),X(LVB),X(LBOC),X(LWRK3),L1,L1)
        CALL SCFSAV(X(LVB),X(LDB),X(LEB),19,LL1,LL2,LL3)
C       call prtril(x(ldb),l1)
        CALL DCOPY(L1,X(LWRK),1,X(LOCC),1)
      ELSE IF (SCFTYP.EQ.UHF) THEN
        CALL SCFSAV(X(LVEC),X(LD),X(LEIG),NDAF,LL1,LL2,LL3)
        CALL DAWRIT(IDAF,IODA,X(LFB),L2,18,0)
        CALL SCFSAV(X(LVB),X(LDB),X(LEB),19,LL1,LL2,LL3)
      END IF
C
C     ----- TEST ----
C
C     WRITE (IW,*) "CALCULATE DENSITY"
C     NATO = 71
C     DO N = 1, L1
C       DENFR1 = 0.0D+00
C       DENFR2 = 0.0D+00
C       DENINT = 0.0D+00
C       NNN    = (N-1)*L1 !! SHIFT FOR MOLECULAR ORBITAL INDEX
C       DO I = 1, L1
C         DO J = 1, L1
C           NSEQ = MAX(I,J)*(MAX(I,J)-1)/2+MIN(I,J)
C           IF (I.LE.NATO .AND. J.LE.NATO) THEN
C             DENFR1
C    *      = DENFR1 + X(LVEC+NNN+I-1)*X(LVEC+NNN+J-1)*X(LS+NSEQ-1)
C           ELSE IF (I.GT.NATO .AND. J.GT.NATO) THEN
C             DENFR2
C    *      = DENFR2 + X(LVEC+NNN+I-1)*X(LVEC+NNN+J-1)*X(LS+NSEQ-1)
C           ELSE
C             DENINT
C    *      = DENINT + X(LVEC+NNN+I-1)*X(LVEC+NNN+J-1)*X(LS+NSEQ-1)
C           END IF
C         END DO
C       END DO
C       WRITE (IW,'(X,I3,3(X,F10.5))') N, DENFR1, DENFR2, DENINT
C     END DO
C
C     PUT ZERO VALUE FOR ELECTRON-ELECTRON, NUCLEAR-ELECTRON,
C     NUCLEAR-NUCLEAR POTENTIAL.  THEY WILL NOT BE USED.
C
      IF (CVGED) THEN
        E1    = ENCC
        E2    = ESCC
        ENUCR = EN
        VEE   = ESCC
        ETOT  = E1 + E2 + ENUCR
        IF (SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
          ETOT = ETOT + ESPIN
          !! EKIN IS USED AS A TENTATIVE STORAGE
          EKIN = ESPIN
        END IF
C       E1 = ZERO
C       E2 = ZERO
C       VEE = ESCC
C       ETOT = ENUCR
        IF (LETEMP) THEN
          ETOT = ETOT + EMERMIN
          !! EERD IS USED FOR TENTATIVE STORAGE
          EERD = EMERMIN
        END IF
        ETEMP = ETEMP0
        !! ADD PCM ENERGIES AGAIN
        IF(IPCMIT.EQ.0) THEN
C          IF(IPCM.EQ.1.OR.IPCFP) ETOT=ETOT-HALF*(PB-PC)
           IF(IPCM.EQ.1.OR.IPCFP) ETOT=ETOT+HALF*(PB+PC+PX)
        ELSE
C          IF(IPCM.EQ.1.OR.IPCFP) ETOT=ETOT+HALF*PX
           IF(IPCM.EQ.1.OR.IPCFP) ETOT=ETOT+HALF*ENPCM
        END IF
        IF(NFMOPCM.NE.0) ETOT=ETOT+HALF*(PC+PX)
        IF(IPCM.EQ.1 .OR. IPCFP) THEN
          ETOT=ETOT+(GCAVP+GDISP+GREP)/627.509541D+00
        END IF
        IF(ISEPS) ETOT = ETOT - SECORR
        IF (IPCM.EQ.1.OR.ISEPS) CALL DCOPY(NAT,X(LZAN),1,ZAN,1)
      END IF
C     IF (LETEMP) THEN
      IF (LETEMP.AND.SOME) THEN
        WRITE (IW,*) "EIGENVALUES, OCCUPATION NUMBERS, AND CHARGES"
        DO I = 1, NAT
          WRITE (IW,'(X,I3,3(X,F20.14))') I, X(LEIG+I-1),
     *    X(LOCC+I-1),X(LMUL1A+I-1)
        END DO
        DO I = NAT+1, L1
          WRITE (IW,'(X,I3,3(X,F20.14))') I, X(LEIG+I-1),
     *    X(LOCC+I-1),ZERO
        END DO
        WRITE (IW,'(" FERMI ENERGY AT CONVERGENCE = ",F20.14)') EF
        WRITE (IW,'(" EMERMIN = ",F20.10)') EMERMIN
        WRITE (IW,'(" ETOT    = ",F20.10)') ETOT
      END IF
C
C     ----- SAVE MULLIKEN POPULATION AND OCCUPATION NUMBER -----
C
      IF(MPUNCH.GT.0 .AND. MASPRT) THEN
        !! MAKE ATOM-RESOLVED SPIN DENSITY
        IF (SCFTYP.EQ.UHF) THEN
          ISH = 0
          DO I = 1, NAT
            TMP = ZERO
            DO J = 1, MAXANG(ISPE(I))
              ISH = ISH + 1
              TMP = TMP + X(LMULSB+ISH-1)
            END DO
            X(LWRK+I-1) = TMP
          END DO
        END IF
        CALL DFTB_DAMP_MULLIKEN(X(LMUL3A),X(LMUL3S),X(LWRK),X(LMULSB),
     *    NAT,NSHELL,IP,SRSCC,SCFTYP.EQ.UHF)
      END IF
      CALL DAWRIT(IDAF,IODA,X(LMUL1A),NAT,556,0)
      !! SHELL-RESOLVED POPULATION
      CALL DAWRIT(IDAF,IODA,X(LMUL1S),NSHELL,557,0)
C     CALL DAWRIT(IDAF,IODA,X(LMUL1),NUM,902,0)
      CALL DAWRIT(IDAF,IODA,X(LOCC),NUM,562,0)
      IF (SCFTYP.EQ.UHF) THEN
        !! SHELL-RESOLVED SPIN POPULATION
        CALL DAWRIT(IDAF,IODA,X(LMULSB),NSHELL,558,0)
        CALL DAWRIT(IDAF,IODA,SHIFTS,NSHELL,561,0)
        CALL DAWRIT(IDAF,IODA,X(LBOC),NUM,563,0)
      END IF
      IF (SRSCC) CALL DAWRIT(IDAF,IODA,X(LSHIFTSH),NSHELL,560,0)
      !! SAVE SHIFT MATRIX TO DICTNRY 559 FOR GRADIENT CALCULATION
      IF (SCC.AND.NDER.GT.0) THEN
        !! RECONSTRUCT SHIFT MATRIX
        IF (IPCM.EQ.1) THEN
          NSEQ = 0
          IF (.NOT.SOSCF) THEN
            IF (SRSCC) THEN
              ISH0 = 0
              DO IAT = 1, NAT
                ISH = ISH0
                DO K = 1, MAXANG(ISPE(IAT))*MAXANG(ISPE(IAT))
                  MU = IND(IAT) + K
                  NSEQ = NSEQ + MU
                  IF (K.EQ.1.OR.K.EQ.2.OR.K.EQ.5) THEN
                    ISH = ISH + 1
                    tmp = x(lshiftsh+ish-1)
                    X(LSHIFTSH+ISH-1)=X(LSHIFTSH+ISH-1) + X(LSOL+NSEQ-1)
                  END IF
                END DO
                ISH0 = ISH0 + MAXANG(ISPE(IAT))
              END DO
            ELSE
              DO IAT = 1, NAT
                DO K = 1, MAXANG(ISPE(IAT))*MAXANG(ISPE(IAT))
                  MU = IND(IAT) + K
                  NSEQ = NSEQ + MU
                  tmp = shift(iat)
                  IF (K.EQ.1) SHIFT(IAT) = SHIFT(IAT) + X(LSOL+NSEQ-1)
                END DO
              END DO
            END IF
            IF (IPCMIT.EQ.0) THEN
              IF (SRSCC) THEN
                CALL VCLR(X(LWRK),1,NSHELL)
                CALL DFTB_QSHIFT(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *               X(LAXYZCT+MXTS*2),X(LQSN),SHIFT)
                CALL DFTB_SHIFT_ATOSH(X(LWRK),X(LWRK1),NAT,NSHELL,
     *               NSPE,ISPE,MAXANG)
                CALL DAXPY(NSHELL,ONE,X(LWRK1),1,SHIFT,1)
              ELSE
                CALL DFTB_QSHIFT(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *               X(LAXYZCT+MXTS*2),X(LQSN),SHIFT)
              END IF
            END IF
          END IF
          IF (SRSCC)
     *      CALL DAWRIT(IDAF,IODA,X(LSHIFTSH),NSHELL,560,0)
        ELSE IF (NFMOPCM.NE.0) THEN
          CALL DAREAD(IDAF,IODA,X(LWRK),L2,565,0) !! PCM CONTRIBUTION
          NSEQ = 0
          DO IAT = 1, NAT
            DO K = 1, MAXANG(ISPE(IAT))*MAXANG(ISPE(IAT))
              MU = IND(IAT) + K
              NSEQ = NSEQ + MU
              IF (K.EQ.1) SHIFT(IAT) = SHIFT(IAT) + X(LWRK+NSEQ-1)
            END DO
          END DO
        END IF
        !! IN FMO CALCULATION, THE SHIFT MATRIX INCLUDES ESP FROM OTHER
        !! FRAGMENTS.  IT HAS TO BE SUBTRACTED FOR GRADIENT CALCULATION,
        !! BECAUSE WE WANT TO GET INTERNAL GRADIENTS.
        IF (NFG.GT.0) THEN
          CALL DAXPY(NAT,-ONE,SHIFT2,1,SHIFT,1) !! SUBTRACT 2ND-ORDER
          IF (DFTB3) THEN
            !! CALCULATE V_{\rho \sigma} FOR 3RD-ORDER GRADIENT.
            !! THE MATRIX DEPENDS ON THE THE CHARGE IN THE SYSTEM.
            DO I = 1, NAT
              SHIFTI = X(LMUL3A+I-1)*SHIFT3(I)*TWO+SHIFT3(NAT+I)
              SHIFT(I) = SHIFT(I) - SHIFTI !! SUBTRACT 3RD-ORDER
              DO K = 1, MAXANG(ISPE(I))**2
                M = IND(I)+K
                DO J = 1, I
                  SHIFTJ = X(LMUL3A+J-1)*SHIFT3(J)*TWO+SHIFT3(NAT+J)
                  SHIFTIJ = SHIFTI + SHIFTJ
                  SHIFTIJ = SHIFTIJ * HALF
                  DO L = 1, MAXANG(ISPE(J))**2
                    N = IND(J)+L
                    CALL DFTB_CNVSQ(M,N,NSEQ)
                    X(LFMOESPA+NSEQ-1) = X(LFMOESPA+NSEQ-1)
     *                                 + X(LS+NSEQ-1)*SHIFTIJ
                  END DO
                END DO
              END DO
            END DO
            call dcopy(l2,x(lfmoespa),1,x(lfmoespb),1)
          END IF
        END IF
        CALL DAWRIT(IDAF,IODA,SHIFT,NAT,559,0)
      END IF
C
C     ----- RELEASE MEMORY USED IN DFTB CHARGE MIXING, IF ALLOCATED -----
C
      IF (MEMMIX.GT.0) CALL RETFM(MEMMIX)
C
C     LH0 IS NEEDED TO BE SAVED FOR FMO CALCULATIONS TO GET CORRECT
C     ONE AND TWO ELECTRON ENERGIES
      IF (NFG.GT.0 .AND. SCC) CALL DAWRIT(IDAF,IODA,X(LH0),LL2,11,0)
C
      TFITER = TFOCK/ITER
      TSITER = TSOLVE/ITER
      IF(MASPRT  .AND.  ISD.EQ.1) THEN
          IF(DIRSCF) THEN
             WRITE(IW,9300) TFOCK,TFITER,TFOCK1,TFOCKN,TSOLVE,TSITER
          ELSE
             WRITE(IW,9310) TFOCK,TFITER,TSOLVE,TSITER
          END IF
      END IF
C
C     ----- POSSIBLE AB INITIO - FRAGMENT EXCHANGE REPULSION
C
C     IF(LVLEFP.EQ.2) THEN
C        CALL EFHFDR(X(LHMO),X(LVMI),X(LVMITR),EEXCH,L1,CVGED)
C     END IF
C     ETOT = ETOT + EEXCH
C     IF (IEFPFMO.EQ.1) ETOT = ETOT - EFPEFP
C
C     ----- DISPERSION CORRECTIONS -----
C
      IF(DC) THEN
         IF (DFTD) THEN
           CALL DFTD3(1,EDISP,DUMMY)
         ELSE
           X(LIWRK+NAT) = ZERO
           IF (NFG.NE.0.AND.IDFTBD.EQ.4) THEN
             CALL IXSTOR(X(LIWRK+NAT),1,NFG)
             CALL DFTB_FMONBOND(NAT,X(LIAGLOB),X(LNBOND),X(LIWRK))
           END IF
           CALL DFTB_DISP(QREF,X(LDIST),EDISP,X(LIWRK))
          END IF
         ETOTD = ETOT
         IF(ETOT.NE.ZERO) ETOT = ETOT + EDISP
      ELSE
         EDISP=0.0D+00
      END IF
C
C     ----- LOCAL RESPONSE DISPERSION CORRECTIONS
C
      IF(DOLRD) THEN
         EDISP = ELRD6 + ELRD8 + ELRD10 + EMULT
         ETOTD = ETOT
         IF(ETOT.NE.ZERO) ETOT = ETOT + EDISP
         CALL PRTLRD
      END IF
      if(nfg.ne.0.and.scc.and.jcurfg.ne.0) then
         lpopmati=lpopmat+(maxnat*nfg)*(icurpop-1)
C
c        call calcedij(x(llayfrg),x(lpopmati),x(ls),x(ld),
c    *                 x(lshift),x(ledij))
        if(kcurfg.eq.0) then
          call ctpaira(icurfg,jcurfg,X(LMUL1A),X(LPOPMATI),x(lindat),
     &                 x(liaglob),x(lialoc),X(lindbd),ctij)
        else
          call cttrim(icurfg,jcurfg,kcurfg,X(LMUL1A),ZREF,X(LPOPMATI),
     &                 x(lindat),x(liaglob),x(lialoc),X(lindbd),ctij,
     *                 ctij2,x(lzref),x(lindfrg),dftb3)
        end if
        edft(2)=DDOT(NAT,CTIJ,1,SHIFT2,1)
C       write (*,*) "edft(2) 2nd   = ", edft(2)
        IF (DFTB3) THEN
          TMP = 0.0D+00
          !! THIS CTIJ IS CTIJ(I) = DQ(IJ) - DQ(I) - DQ(J)
          DO I = 1, NAT
            TMP = TMP + SHIFT3(NAT+I) * CTIJ(I)
          END DO
C         write (*,*) "        3rd-1 = ", tmp/3.0D+00
          !! X(LMUL3A) contains DQ(IJ)
          if (kcurfg.eq.0) 
     *    call ctpairb(icurfg,jcurfg,X(LMUL3A),X(LPOPMATI),x(lindat),
     &                 x(liaglob),x(lialoc),X(lindbd),ctij2,2,x(lzref),
     *                 x(lindfrg))
          !! THIS CTIJ2 IS CTIJ2(I) = DQ(IJ)**2 - DQ(I)**2 - DQ(J)**2
CD        TMP2 = TMP
          DO I = 1, NAT
            TMP = TMP + SHIFT3(I) * CTIJ2(I)
          END DO
C         write (*,*) "        3rd-2 = ", (tmp-tmp2)/3.0D+00
C         write (*,*) "edft(2) 3rd   = ", tmp/3.0D+00
          EDFT(2) = EDFT(2) + TMP
C         write (*,*) "edft(2)       = ", edft(2)
        END IF
c       write(6,*) 'delta-DV term is',edft(2)
        IF (NDER.gt.0) then
          !! calculate the charge transfer density matrix (P = P(IJ) - P(I) - P(J))
          !! X(LD)  :: CURRENT DENSITY MATRIX (P(IJ))
          !! X(LD2) :: GUESS DENSITY MATRIX (P(I) + P(J))
          CALL DCOPY(L2,X(LD),1,X(LWRK1),1) !! NEEDED FOR LAGRANGIAN-LIKE TERM
          CALL DAXPY(L2,-1.0D+00,X(LD2),1,X(LD),1)
          !! X(LD)   :: DIFFERENCE DM (DP(IJ)=P(IJ)-P(I)-P(J))
          !! X(LD2)  :: GUESS DENSITY MATRIX (P(I) + P(J))
          !! X(LWRK1):: CURRENT DENSITY MATRIX (P(IJ))
          CALL DFTB_ESPGRAD(x(LD),X(LWRK1),x(lfmode),CTIJ,X(LPOPMATI),
     & x(liaglob),x(lindfrg),X(LSHIFTCT),X(LZREF),
     * X(LGAMMAGLOB),X(LGAMMAD),X(LSHIFTG),X(LFMOC),X(LISPE),
     * X(LINDBD),X(LIALOC),X(LINDAT),CTIJ2,X(LMUL3A),X(LGAMMA),
     * X(LGAM3))
          CALL DCOPY(L2,X(LWRK1),1,X(LD),1)
C         LD = LWRK1
        END IF
      endif
C
C     ----- PRINT FINAL RESULTS -----
C
      EXCOR = EEXC
      IF(MASPRT) THEN
         WRITE(IW,9170) METHOD(1:LENMTH),ETOT,ITER
         IF(MPCTYP.NE.NONE  .AND.  ETOT.NE.ZERO) THEN
            DELTAH = ETOT*627.52791D+00 + ATHEAT
            WRITE(IW,9175) DELTAH
         END IF
C              PRINT DISPERSION CORRECTIONS
         IF(DC) THEN
            IF (IDFTBD.EQ.1) THEN
              WRITE(IW,9511) EDISP
              WRITE(IW,9501) ETOTD
            ELSE IF (IDFTBD.EQ.2.OR.IDFTBD.EQ.4) THEN
              WRITE(IW,9512) EDISP
              WRITE(IW,9501) ETOTD
            ELSE IF (IDFTBD.EQ.3) THEN
              WRITE(IW,9510) EDISP
              WRITE(IW,9501) ETOTD
            END IF
         END IF
C
         IF(LRDFLG) THEN
            WRITE(IW,9550) ETOTD
         END IF
      END IF
C
C     ----- SPIN EXPECTATION VALUES -----
C     -LWRK1- USED AS TRIANGULAR SCRATCH SPACE
C
      IF (SCFTYP.EQ.UHF) THEN
        IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
        CALL SPIN(SZ,S2,X(LDA),X(LDB),X(LS),X(LWRK1),X(LSCR),
     *            IA,NA,NB,L1,L2)
        IF(MASPRT) WRITE(IW,9148) SZ,S2
      END IF
C
      IF(MASPRT.AND.NFFAT.GT.0) THEN
         ENRXN = ENRXN + ENRXNPOL
         IF(IFIXSOL.EQ.1) THEN
            WRITE(IW,'(/1X,A,F20.10,A,A,I8)')
     *       'FIXSOL TOTAL SURFACE AREA =',FIXA,' A**2,',
     *       ' NFFTS=',NFFTS
            WRITE(IW,'(A,I3,A,F11.6)')
     *       ' FIXSOL CONVERGED IN ',NCYCLE,
     *       ' ITERATIONS, TOTAL SURFACE CHARGE=',FIXQ
         END IF
         WRITE(IW,'(/1X,A,A)')
     *        'FINAL ENERGY INCLUDES QUANPOL FORCE FIELD TERMS:'
         WRITE(IW,1200)'BOND STRETCH     ENERGY =', EN12
         WRITE(IW,1200)'BOND ANGLE BEND  ENERGY =', EN123
         WRITE(IW,1200)'STRETCH BEND     ENERGY =', EN12312
         WRITE(IW,1200)'DIHEDRAL ROT     ENERGY =', EN123R4
         WRITE(IW,1200)'DIHEDRAL BEND    ENERGY =', EN123B4
         WRITE(IW,1200)'CMAP             ENERGY =', ENCMAP
         WRITE(IW,1200)'WAGGING          ENERGY =', EN234W1
         WRITE(IW,1200)'UMBRELLA BIAS    ENERGY =', ENBIAS
         WRITE(IW,1200)'LJ REPULSION     ENERGY =', ENLJR
         WRITE(IW,1200)'LJ DISPERSION    ENERGY =', ENLJD
         WRITE(IW,1200)'CHARGE           ENERGY =', ENCHAR
         WRITE(IW,1200)'INDUCED DIPOLE   ENERGY =', ENPOL
         WRITE(IW,1200)'SPHSOL           ENERGY =', ENRXN
         WRITE(IW,1200)'FIXSOL           ENERGY =', ENFIXSO
         WRITE(IW,1200)'QM CENTER        ENERGY =', ENCENT
         WRITE(IW,1200)'SPHERE           ENERGY =', ENRXNR
         WRITE(IW,1200)'AND QM-MM INTERACTION ENERGY (NOT SHOWN).'
 1200    FORMAT(1X,A,F30.10)
      END IF
C
C         SOLVATION OUTPUT FOR COSMO MODEL
C
      IF(ISEPS .AND. MPLEVL.EQ.0) THEN
        CALL DFTB_GET_ZAN(0,NAT,X(LZAN),ZAN)
        CALL COSOCE(ETOT)
        CALL DFTB_GET_ZAN(1,NAT,X(LZAN),ZAN)
      END IF
C
C         SOLVATION OUTPUT FOR PCM MODEL
C
      IF(IPCFP) THEN
         IPCM=1
         IEFP=1
         IPCFP=.FALSE.
      END IF
C
      IF(IPCM.EQ.1) THEN
         QTT=0.0D+00
         DO I=0,NTS-1
CCC         QT=   QSE(I) +  QSN(I) + Q_FS(I) + Q_IND(I)
            QT=X(LQSE+I)+X(LQSN+I)+X(LQFS+I)+X(LQIND+I)
            QTT=QTT+QT
         ENDDO
         IF(MASPRT) THEN
            IF(IPCMIT.EQ.0) THEN
               WRITE(IW,*)
               WRITE(IW,*) '--- INDUCED PCM ELECTRONIC CHARGES ---'
               IF(ICOMP.EQ.0) WRITE(IW,1000) QET, TCH
               IF(ICOMP.EQ.1) WRITE(IW,1100) QET, TCH, QETN
               IF(ICOMP.EQ.2) WRITE(IW,1100) QET, TCH, QETN
               IF(ICOMP.EQ.3) WRITE(IW,1110) QET, TCH, QESC, QETN
            END IF
            IF(IPCMIT.EQ.1) THEN
               WRITE(IW,*) ' '
               IF(ICOMP.EQ.0) WRITE(IW,1005) 'PCM ASC=',QTT
               IF(ICOMP.EQ.2) WRITE(IW,1120) QTT,QESC
            END IF
            WRITE(IW,1005) 'GCAVP  =',GCAVP/627.509541D+00
            WRITE(IW,1005) 'GDISP  =',GDISP/627.509541D+00
            WRITE(IW,1005) 'GREP   =', GREP/627.509541D+00
         END IF
      END IF
C
C         SOLVATION OUTPUT FOR SVP MODEL
C
      IF(ISVP.EQ.1  .AND.  MASWRK) THEN
c        CALL SVPOUT(X(LD),X(LD),ETOT,ECHIP,NPRINT,'RHFCL ')
c        has to have arguments added
      END IF
C
C         SOLVATION OUTPUT FOR ONSAGER OR EFP MODELS
C
      IF(IZRFLS .OR. IEFP.EQ.1) THEN
      IF(MASPRT) WRITE(IW,9165) TMUX,TMUXD,TMUY,TMUYD,TMUZ,TMUZD
      END IF
C
C     MODIFICATION OF THE VIRTUAL SPACE ORBITALS, WHICH MAKE NO
C     MAKES NO SENSE AT ALL FOR MOROKUMA RUNS, AND ARE INCOMPATIBLE
C     WITH GRADIENTS OR HESSIANS DUE TO NOT HAVING CANONICAL VIRTUALS.
C
C     ----- MODIFIED VIRTUAL ORBITALS -----
C     FMO,DENSITY AT LWRK1,LWRK2 ARE SYMMETRIC MATRICES
C     -LWRK3- IS USED AS A SCRATCH SQUARE MATRIX
C
      IF(MVOQ.NE.0  .AND.  RUNTYP.NE.MOROKM) THEN
         NFROZ = NA
         CALL MVOS(X(LVEC),X(LEIG),X(LFAO),X(LWRK1),X(LSCR),
     *             X(LIWRK),X(LWRK3),X(LWRK2),X(LBUF),X(LIBUF),
     *             X(LDSH),X(LGHOND),X(LDDIJ),X(LXINTS),
     *             DIRSCF,SCHWRZ,NOPK,NINTMX,INTTYP,
     *             L0,L1,L2,L3,NSH2,MAXG,NFROZ,MVOQ,NE)
      END IF
C
C     --- GENERAL CORRELATION ADAPTED VIRTUAL ORBITALS ---
C     STORE SYMMETRIC -DCORE-, -DVAL- AT -WRK1-, WRK2-
C     STORE SYMMETRIC -JCORE-, -JVAL- AT -FAO-, -D-
C     STORE SQUARE -Q- MATRIX AT -WRK3-
C     BUT WE STILL NEED TWO ADDITIONAL SYMMETRIC MATRICS.
C
      IF(IACAVO.EQ.1  .AND.  RUNTYP.NE.MOROKM) THEN
         NFROZ = NA
         TDSKWRK = DSKWRK
         DSKWRK  = .TRUE.
         CALL ACAVO(PACAVO,X(LVEC),X(LEIG),X(LWRK1),X(LWRK2),
     *              X(LFAO),X(LD),X(LKCORE),X(LKVAL),
     *              X(LWRK3),X(LSCR),X(LIWRK),X(LBUF),X(LIBUF),
     *              NOPK,NINTMX,L0,L1,L2,L3,NFROZ)
         DSKWRK = TDSKWRK
      END IF
C
C     ----- RHF STABILITY ANALYSIS ----
C
      IF(SCFTYP.EQ.RHF .AND. UHFCHK) THEN
         NOCC=NA
         NPRINT = 2
         LHOMO = NHOMO
         LLUMO = NLUMO
C
         IF (LHOMO .LT. -(NOCC-1)) THEN
             WRITE(IW,9400)
             CALL ABRT
         ELSE IF (LHOMO .GT. 0 .OR. LLUMO .LT. 0) THEN
             WRITE(IW,9410)
             CALL ABRT
         ELSE IF ((2 + LLUMO-LHOMO) .GT. L0) THEN
             WRITE(IW,9420)
             CALL ABRT
         END IF
C
C     ---- INTEGRAL TRANSFORMATION FROM AO TO MO BASIS ----
C
         ICORBS = NOCC - 1 + LHOMO
         IORBS  = NOCC + 1 + LLUMO
         IORB   = NOCC + 1 + LLUMO
         CALL TRFMCX(NPRINT,ICORBS,IORBS,IORB,.FALSE.,
     *              .FALSE.,.FALSE.,.FALSE.,
     *              .FALSE.,.FALSE.,.FALSE.,
     *              .FALSE.,.FALSE.,.TRUE.)
C
C     ---- MEMORY ALLOCATION ----
C
         CALL VALFM(LOADFM)
         LXBUF  = LOADFM + 1
         LIXBUF = LXBUF  + NINTMX
         LEIG   = LIXBUF + NINTMX
         LAST   = LEIG   + LL1
         NEEDC  = LAST   - LOADFM - 1
         CALL GETFM(NEEDC)
C
C     ---- OBTAIN INTEGRALS FOR STABILITY ANALYSIS ----
C
         IF (MASWRK) WRITE(IW,9430)
         CALL STBINTS(IPK,X(LXBUF),X(LIXBUF),
     *                X(LEIG),LL1,L0,NOCC,NINTMX)
         IF (MASWRK) WRITE(IW,9440)
C
         CALL RETFM(NEEDC)
      END IF
C
C
      IF(EXETYP.EQ.CHECK) GO TO 520
C
C     ----- ASSIGN SYMMETRY LABELS, AND PRINT FINAL RESULTS -----
C     -SYMBMO- AT X(LWRK)
C     NOTE THAT THE CALL TO SYMMOS WILL DESTROY THE -Q- MATRIX
C
      CALL DAREAD(IDAF,IODA,X(LVEC),LL3,15,0)
      CALL DAREAD(IDAF,IODA,X(LD)  ,LL2,16,0)
      CALL DAREAD(IDAF,IODA,X(LEIG),LL1,17,0)
      IF(MINMEM) THEN
         CALL DAREAD(IDAF,IODA,X(LS),LL2,12,0)
         CALL DAREAD(IDAF,IODA,X(LQ),LL3,45,0)
      END IF
      CALL SYMMOS(X(LWRK),X(LQ),X(LS),X(LVEC),X(LSCR),L0,L1,L0,L1)
      CALL DAWRIT(IDAF,IODA,X(LWRK),LL1,255,1)
      CALL DAWRIT(IDAF,IODA,IRMON,L1,356,1)
      IF(SCFTYP.EQ.ROHF) CALL DAWRIT(IDAF,IODA,IRMON,L1,357,1)
C     IF(ETOLLZ.NE.0) CALL LZMOS(X(LEIG),X(LVEC),L0,L1,L1,L2,L3)
C     IF(SOME.AND.(RUNTYP.NE.MOROKM)) THEN
C        CALL PRSELMO(X(LVEC),X(LEIG),X(LWRK),L0,L1,L1)
C     END IF
      IF(SOME) THEN
         IF(SCFTYP.EQ.UHF) WRITE(IW,9155)
         WRITE(IW,9156)
         CALL PREVS(X(LVA),X(LEA),X(LWRK),L0,L1,L1,1)
      END IF
      IF(PRDENS) THEN
         WRITE(IW,9190)
         CALL PRTRIL(X(LD),L1)
      END IF
C
C     ----- OUTPUT BETA ORBITAL RESULTS -----
C
      IF(NB.EQ.0) GO TO 750
      IF(SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) GO TO 750
C
      CALL DAREAD(IDAF,IODA,X(LVB),L3,19,0)
      CALL DAREAD(IDAF,IODA,X(LDB),L2,20,0)
      CALL DAREAD(IDAF,IODA,X(LEB),L1,21,0)
      CALL DAREAD(IDAF,IODA,X(LQ) ,L3,45,0)
      IF(MINMEM) CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      CALL SYMMOS(X(LIWRK),X(LQ),X(LS),X(LVB),X(LSCR),L0,L1,L0,L1)
      CALL DAWRIT(IDAF,IODA,X(LIWRK),L1,256,1)
C     CALL DAWRIT(IDAF,IODA,IRMON,L1,357,1)
C     IF(ETOLLZ.NE.0) CALL LZMOS(X(LEB),X(LVB),L0,L1,L1,L2,L3)
      IF(SOME) THEN
         WRITE(IW,9166)
         WRITE(IW,9156)
         CALL PREVS(X(LVB),X(LEB),X(LIWRK),L0,L1,L1,1)
      END IF
      IF(PRDENS) THEN
         WRITE(IW,9190)
         CALL PRTRIL(X(LDB),L1)
      END IF
C
C     ----- PUNCH THE ORBITALS -----
C
  750 CONTINUE
      IF(MPUNCH.GT.0 .AND. MASPRT) THEN
        CALL TMDATE(TIMSTR)
        IF (SCFTYP.EQ.RHF.OR.SCFTYP.EQ.ROHF) THEN
          IF(NFG.NE.0) THEN
            WRITE(IP,8005) TIMSTR,ICURFG,JCURFG,KCURFG,METHOD(1:LENMTH),
     *                     ETOT,EN,ITER
          ELSE
            WRITE(IP,8000) TIMSTR,TITLE2,METHOD(1:LENMTH),ETOT,EN,ITER
          ENDIF
        ELSE IF (SCFTYP.EQ.UHF) THEN
          IF(NFG.NE.0) THEN
            WRITE(IP,8006) TIMSTR,ICURFG,JCURFG,KCURFG,METHOD(1:LENMTH),
     *                     ETOT,EN,ITER
          ELSE
            WRITE(IP,8001) TIMSTR,TITLE2,METHOD(1:LENMTH),ETOT,EN,ITER
          ENDIF
        END IF
        LPUN = NA
        IF(MPUNCH .EQ. 2) LPUN = L0
        IF(RUNTYP.NE.AMEX) THEN
                           WRITE(IP,8010) ' $VEC   '
        ELSE
         IF(MEXSTATE.EQ.1) WRITE(IP,8010) ' $VEC1  '
         IF(MEXSTATE.EQ.2) WRITE(IP,8010) ' $VEC2  '
        END IF
        CALL PUSQL(X(LVEC),LPUN,L1,L1)
        IF(SCFTYP.EQ.UHF  .AND.  NB.GT.0) THEN
           LPUN = NB
           IF(MPUNCH.EQ.2) LPUN = L0
           CALL PUSQL(X(LVB),LPUN,L1,L1)
        END IF
                           WRITE(IP,8010) ' $END   '
      END IF
C     -H.K.-N.-
C     CALL PRTOVM(X(LS),L1)
C     CALL PREVSCE(X(LVEC),X(LEIG),X(LIWRK),L0,L1,L1,1)
C
C     IF MFRZ WE COMPUTE THE LAGRANGIAN FOR THE GEOMETRY OPTIMIZATION
C
      IF(MFRZ.AND.NDER.GT.0) THEN
C         READ IN THE NON-ZEROED FOCK MATRIX IN AO BASIS
          CALL DAREAD(IDAF,IODA,X(LWRK1),LL2,317,0)
          CALL RHFLAG(X(LWRK1),X(LD),X(LWRK2),X(LWRK),L1,L2,L3,OUT)
C         CALL DAWRIT(IDAF,IODA,X(LWRK2),LL2,36,0)
      END IF
C
C     --- IF NEO RUN OUPUT NUCLEAR MOS ---
C
      IF(SOME .AND. NEORUN.EQ.1) THEN
         CALL NMOOUT(MPUNCH)
      END IF
C
C     ----- TIDY UP AND EXIT -----
C
  520 CONTINUE
      IF(CVGED) IREST = 0
C
C       SOSCF FILE IS OPENED ONLY BY THE MASTER IN NON-GROUP RUNS,
C       BUT WHEN IN GROUPS, IT IS OPENED BY EVERY COMPUTE PROCESS,
C       ALTHOUGH ONLY THE MASTER OF EACH GROUP USES IT.
C       THE DISK WORK SETTING BELOW HANDLES BOTH CASES CORRECTLY.
C
      IF(FT15OP.and.iand(modio,32).eq.0) THEN
        TDSKWRK = DSKWRK
        DSKWRK  = ISGDDI
        CALL SEQCLO(NFT15,'DELETE')
        DSKWRK = TDSKWRK
        FT15OP=.FALSE.
      ENDIF
      IF(.NOT.NOTOPN) CALL RACLOS(20,'DELETE')
      NOTOPN=.TRUE.
      CALL RETFM(NEED)
C
      IF((SCFTYP.EQ.RHF) .AND. MASPRT)
     *   WRITE(IW,FMT='('' ...... END OF RDFTB CALCULATION ......'')')
      IF((SCFTYP.EQ.UHF) .AND. MASPRT)
     *  WRITE(IW,FMT='('' ...... END OF UDFTB CALCULATION ......'')')
      IF((SCFTYP.EQ.ROHF) .AND. MASPRT)
     *  WRITE(IW,FMT='('' ...... END OF RODFTB CALCULATION ......'')')
      if(mdout.and.(nfg.eq.0.or.iand(modio,256).eq.0)) CALL TIMIT(1)
C
      RETURN
C
 8000 FORMAT('--- CLOSED SHELL ORBITALS --- GENERATED AT ',3A8/10A8/
     *       'E(',A,')=',F20.10,', E(NUC)=',F16.10,',',I5,' ITERS')
 8005 FORMAT('--- CLOSED SHELL ORBITALS --- GENERATED AT ',3A8/,
     *       'FMO ORBITALS',3I6/,
     *       'E(',A,')=',F20.10,', E(NUC)=',F16.10,',',I5,' ITERS')
 8001 FORMAT('--- OPEN SHELL ORBITALS --- GENERATED AT ',3A8/10A8/
     *    'E(',A,')=',F20.10,', E(NUC)=',F16.10,',',I5,' ITERS')
 8006 FORMAT('--- OPEN SHELL ORBITALS --- GENERATED AT ',3A8/,
     *       'FMO ORBITALS',3I6/,
     *       'E(',A,')=',F20.10,', E(NUC)=',F16.10,',',I5,' ITERS')
 8010 FORMAT(A8)
C
C9000 FORMAT(/10X,26(1H-)/10X,A10,' SCF CALCULATION'/10X,26(1H-))
 9000 FORMAT(/10X,26(1H-)/10X,'   NCC-DFTB CALCULATION'/10X,26(1H-))
 9001 FORMAT(/10X,26(1H-)/10X,'   SCC-DFTB CALCULATION'/10X,26(1H-))
 9002 FORMAT(10X,'  CONSTRAINED UHF BY J.N.BYRD AND J.A.MONTGOMERY,'/
     *       10X,'PRODUCING SPIN-RESTRICTED RESULTS ALA HIGH SPIN ROHF')
 9005 FORMAT(/1X,'OVERLAPPING STORAGE FOR H,S,Q MATRICES,',
     *        1X,'TO SAVE',I10,' WORDS.'/1X,'ADDING THIS AMOUNT',
     *        1X,'MAY IMPROVE EFFICIENCY SOMEWHAT.')
 9006 FORMAT(1X,'* * * ERROR * * *'/
     *       1X,'IT IS ILLOGICAL FOR THE GRID SWITCHING VALUE',
     *          ' $DFT SWITCH=',1P,E7.1/
     *       1X,'    TO BE SMALLER THAN THE DENSITY CONVERGEN',
     *          'CE $SCF CONV=',1P,E7.1)
 9007 FORMAT(5X,'NUCLEI-NUCLEAR POLARIZATION CHARGE INTERACTION = '
     *         ,F20.10,/
     *      ,5X,'TOTAL NUCLEAR ENERGY                           = '
     *         ,F20.10)
 9008 FORMAT(/1X,'AB INITIO/EFP2 EX-REP NOT CODED FOR OPEN',
     *           ' SHELL EFP''S')
 9010 FORMAT(/5X,'REPULSIVE ENERGY = ',F20.10,' H (',F20.10,' eV)'/
     *       5X,'MAXIT =',I5,5X,'NPUNCH=',I5/
     *       5X,'EXTRAP=',L1,'  DAMP=',L1,'  SHIFT=',L1,
     *          '  RSTRCT=',L1,'  DIIS=',L1,'  DEM=',L1,'  SOSCF=',L1)
 9012 FORMAT(5X,'DENSITY MATRIX CONV=',1P,E10.2)
 9013 FORMAT(5X,'    DENSITY MATRIX CONVERGENCE THRESHOLD=',1P,E10.2/
     *       5X,'COARSE -> FINE DFT GRID SWITCH THRESHOLD=',1P,E10.2,
     *          ' (SWITCH IN $DFT)'/
     *       5X,'              HF -> DFT SWITCH THRESHOLD=',1P,E10.2,
     *          ' (SWOFF IN $DFT)')
 9015 FORMAT(5X,'VTSCAL=',L1,'  MAXVT=',I3,'  VTCONV=',F12.8)
 9017 FORMAT(5X,'SOSCF WILL OPTIMIZE',I8,' ORBITAL ROTATIONS, SOGTOL=',
     *          F8.3)
 9018 FORMAT(5X,'SOSCF WILL OPTIMIZE',I8,' ORBITAL ROTATION ANGLES.',
     *          ' SOGTOL=',1P,E10.3)
 9019 FORMAT(5X,'SOSCF WILL OPTIMIZE',I8,' ALPHA AND',I8,
     *          ' BETA ROTATION ANGLES.'/5X,'SOGTOL=',1P,E10.3)
 9020 FORMAT(5X,'MEMORY REQUIRED FOR RHF ITERS=',I10,' WORDS.')
 9021 FORMAT(5X,'MEMORY REQUIRED FOR UHF/ROHF ITERS=',I10,' WORDS.')
 9030 FORMAT(/1X,'DIRECT SCF CALCULATION, SCHWRZ=',L1,'   FDIFF=',L1,
     *       ',  DIRTHR=',E10.2,' NITDIR=',I2)
 9031 FORMAT(5X,'ROHF CANONICALIZATION PARAMETERS'/
     *       5X,8X,'C-C',5X,'O-O',5X,'V-V'/
     *       5X,'ALPHA',3F8.4/5X,'BETA ',3F8.4)
 9039 FORMAT(/1X,'THE BUFFER ZONE DENSITY WILL BE EXCLUDED FROM THE ',
     *        'INTERACTION WITH THE EFP')
 9040 FORMAT(/' ITER EX DEM    TOTAL ENERGY       E CHANGE  DENSITY ',
     *        'CHANGE     ORB. GRAD      VIR. SHIFT       DAMPING')
 9050 FORMAT(/115X,'NONZERO     BLOCKS'/
     *        ' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE     ORB. GRAD      VIR. SHIFT       DAMPING',
     *        '        INTEGRALS    SKIPPED')
 9045 FORMAT(/' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR      VIR. SHIFT       DAMPING')
 9055 FORMAT(/115X,'NONZERO     BLOCKS'/
     *        ' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR      VIR. SHIFT       DAMPING',
     *        '        INTEGRALS    SKIPPED')
 9060 FORMAT(/' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE     ORB. GRAD')
 9070 FORMAT(/83X,'NONZERO     BLOCKS'/
     *        ' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE     ORB. GRAD      INTEGRALS    SKIPPED')
 9065 FORMAT(/' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR')
 9075 FORMAT(/83X,'NONZERO     BLOCKS'/
     *        ' ITER EX DEM     TOTAL ENERGY        E CHANGE  DENSITY ',
     *        'CHANGE    DIIS ERROR      INTEGRALS    SKIPPED')
 9090 FORMAT(1X,3I3,F20.10,F17.10,2F14.9,2F16.9,I15,I11)
 9100 FORMAT(1X,3I3,F20.10,F17.10,2F14.9,I15,I11)
 9110 FORMAT(/10X,17(1H-)/10X,17HDENSITY CONVERGED/10X,17(1H-))
 9120 FORMAT(/10X,14(1H-)/10X,14HDIIS CONVERGED/10X,14(1H-))
 9130 FORMAT(/10X,16(1H-)/10X,16HENERGY CONVERGED/10X,16(1H-))
 9140 FORMAT(/1X,'... SCF HAS ALMOST CONVERGED BUT ROUTINE STOPPED',
     *           ' FOR TIMLIM BEFORE ULTIMATE CYCLE ...')
 9148 FORMAT(/10X,20(1H-)/10X,12HSPIN SZ   = ,F8.3/
     *        10X,12HS-SQUARED = ,F8.3/10X,20(1H-))
 9150 FORMAT(/1X,'SCF IS UNCONVERGED, TOO LITTLE TIME LEFT')
 9160 FORMAT(/1X,'SCF IS UNCONVERGED, TOO MANY ITERATIONS')
 9155 FORMAT(/1X,' ----- ALPHA SET ----- ')
 9166 FORMAT(/1X,' ----- BETA SET ----- ')
 9156 FORMAT(/10X,12(1H-)/10X,12HEIGENVECTORS/10X,12(1H-))
 9165 FORMAT(/10X,'INDUCED DIPOLE',5X,'ATOMIC UNITS',10X,'DEBYE',
     *       /10X,'      X(IND)  ',5X,F12.5,5X,F12.5,
     *       /10X,'      Y(IND)  ',5X,F12.5,5X,F12.5,
     *       /10X,'      Z(IND)  ',5X,F12.5,5X,F12.5)
 9170 FORMAT(/1X,'FINAL ',A,' ENERGY IS',F20.10,' AFTER',I4,
     *           ' ITERATIONS')
 9175 FORMAT(/1X,'HEAT OF FORMATION IS',F15.5,' KCAL/MOL')
 9510 FORMAT(1X,'GRIMME''S DISPERSION ENERGY                     =',
     *           F20.10)
 9511 FORMAT(1X,'UFF-TYPE DISPERSION ENERGY                     =',
     *           F20.10)
 9512 FORMAT(1X,'SLATER-KIRKWOOD DISPERSION ENERGY              =',
     *           F20.10)
c9500 FORMAT(1X,'ENERGY WITHOUT GRIMME''S DISPERSION CORRECTION IS',
c    *           F20.10)
 9501 FORMAT(1X,'ENERGY WITHOUT DISPERSION CORRECTION IS         ',
     *           F20.10)
 9550 FORMAT(1X,'ENERGY WITHOUT LRD CORRECTION IS',F20.10)
 9190 FORMAT(/10X,14(1H-)/10X,14HDENSITY MATRIX/10X,14(1H-))
 9200 FORMAT(10X,15(1H-),'START SECOND ORDER SCF',15(1H-))
C9235 FORMAT(1X,'NEXT ENERGY RISES: SWITCHING DIIS OFF FOR',I3,
C    *          ' ITERS, NEW ETHRSH=',1P,E9.2)
 9236 FORMAT(1X,'NEXT ENERGY RISES: SWITCHING SOSCF OFF FOR',I3,
     *          ' ITERS, NEW SOGTOL=',1P,E9.2)
 9300 FORMAT(5X,'TIME TO FORM FOCK OPERATORS=',F10.1,' SECONDS (',
     *          F10.1,' SEC/ITER)'/
     *       5X,'FOCK TIME ON FIRST ITERATION=',F10.1,
     *          ', LAST ITERATION=',F10.1/
     *       5X,'TIME TO SOLVE SCF EQUATIONS=',F10.1,' SECONDS (',
     *          F10.1,' SEC/ITER)')
 9310 FORMAT(5X,'TIME TO FORM FOCK OPERATORS=',F10.1,' SECONDS (',
     *          F10.1,' SEC/ITER)'/
     *       5X,'TIME TO SOLVE SCF EQUATIONS=',F10.1,' SECONDS (',
     *          F10.1,' SEC/ITER)')
 9355 FORMAT(1X,'CONVERGED TO SWOFF, SO DFT CALCULATION IS NOW',
     *          ' SWITCHED ON.')
 9370 FORMAT(1X,'ENERGY IS NOT DECREASING: FOCK MATRIX WILL BE ',
     *          'RECOMPUTED.')
 9380 FORMAT(9X,'SWDIIS THRESHOLD HAS BEEN REACHED:',
     *          ' SWITCHING DIIS OFF.')
 9400 FORMAT(/1X,'ERROR:',
     *       /1X,'THE NHOMO VALUE IS LESS THAN',
     *       /1X,'THE NUMBER OF OCCUPIED ORBITALS',/)
 9410 FORMAT(/1X,'ERROR:',
     *       /1X,'THE NHOMO VALUE MUST BE ZERO OR NEGATIVE',
     *       /1X,'THE NLUMO VALUE MUST BE ZERO OR POSITIVE',/)
 9420 FORMAT(/1X,'ERROR:',
     *       /1X,'THE NLUMO VALUE IS MORE THAN',
     *       /1X,'THE NUMBER OF VIRTUAL ORBITALS',/)
 9430 FORMAT(/,1X,50('-'),
     *       /,1X,'STABILITY TEST FOR RHF WAVEFUNCTION AGAINST UHF',
     *       /,1X,50('-')
     *     //,1X,'ORBITAL PAIR             ETA           RHF STABILITY',
     *       /,1X,12('-'),13X,3('-'),11X,13('-'))
 9440 FORMAT(/,1X,'END OF THE STABILITY TEST',
     *       /,1X,50('-'))
C
 1005 FORMAT(1X,A10,F18.10)
 1000 FORMAT(1X,'CALCULATED ',F10.5,' THEORETICAL ',
     * F10.5,' NOT RENORMALIZED',F10.5)
 1100 FORMAT(1X,'CALCULATED ',F10.5,' THEORETICAL ',
     * F10.5,' RENORMALIZED',F10.5)
 1110 FORMAT(1X,'CALCULATED',F10.5,' (THEOR= ',
     * F10.5,')  ESCAPED',F10.5,' FINAL', F10.5)
 1120 FORMAT(2X,'PCM ASC=',F18.10,' ( UNNORMALIZED=',F18.10,' )')
C
      END SUBROUTINE DFTBX
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_GAMMA
C>
C>    @brief Calculate DFTB2 gamma
C>
C>    @details Calculate DFTB2 gamma
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param DAMPXHE Exponent of X-H damping
C>    @param HUBL Shell-resolved Hubbard values
C>    @param GAMMA DFTB2 gamma
C>    @param DISTMAT Array of inter-atomic distance
C>    @param NAT Number of atoms
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param SPE Name of species
C>    @param MAXANG Maximum angular momentum of species
C>    @param DAMPXH Whether X-H damping or not
C>    @param SRSCC Shell-resolved SCC or not
C>           --- OUTPUT ---
C>    @param GAMMA DFTB2 gamma
C>
C
      SUBROUTINE DFTB_GAMMA(DAMPXHE,HUBBL,GAMMA,DISTMAT,NAT,
     *  NSPE,ISPE,MAXANG,SPE,DAMPXH,SRSCC)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: NSPE
      DOUBLE PRECISION,INTENT(IN) :: DAMPXHE,HUBBL(3,NSPE),
     *  DISTMAT(*),SPE(*)
      DOUBLE PRECISION, INTENT(OUT) :: GAMMA(*)
      INTEGER,INTENT(IN) :: NAT,ISPE(NAT),MAXANG(NSPE)
      LOGICAL,INTENT(IN) :: DAMPXH,SRSCC
C
      INTEGER :: I,II,J,JJ,NSEQ,NSEQD,ISH,ISH0,JSH,JSH0
C
      DOUBLE PRECISION :: TAUA,TAUB,DIST,HUBA,HUBB,DFTB_GAMMA2F,
     *  CHARA1,CHARA2
      LOGICAL :: HDAMP
      DOUBLE PRECISION H/8HH       /
C
C     ----- HERE CALCULATES \GAMMA_{\ALPHA \BETA} VALUES -----
C
      NSEQ = 0
      NSEQD = 0
      IF (SRSCC) THEN
        ISH0 = 0
        DO I = 1, NAT
          CHARA1 = SPE(ISPE(I))
          JSH0 = 0
          DO J = 1, I
            NSEQD = NSEQD + 1
            DIST = DISTMAT(NSEQD)
            CHARA2 = SPE(ISPE(J))
            DO II = 1, MAXANG(ISPE(I))
              ISH = ISH0 + II
              DO JJ = 1, MAXANG(ISPE(J))
                JSH = JSH0 + JJ
C               NSEQ = NSEQ + 1
                HUBA = HUBBL(II,ISPE(I))
                TAUA = 3.2D+00 * HUBA
                HUBB = HUBBL(JJ,ISPE(J))
                TAUB = 3.2D+00 * HUBB
                IF (DAMPXH.AND.(CHARA1.EQ.H.OR.CHARA2.EQ.H)) THEN
                  HDAMP = .TRUE.
                ELSE
                  HDAMP = .FALSE.
                END IF
                CALL DFTB_CNVSQ(ISH,JSH,NSEQ)
                GAMMA(NSEQ) = DFTB_GAMMA2F(DIST,HUBA,HUBB,TAUA,TAUB,
     *            DAMPXHE,HDAMP)
C             WRITE (*,'(5I4,2F20.10)') I, J, II, JJ,
C    *        nSEQ,GAMMA(NSEQ), 1.0/DIST
                IF (I.EQ.J.AND.II.EQ.JJ) EXIT
              END DO
            END DO
            JSH0 = JSH0 + MAXANG(ISPE(J))
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(I))
        END DO
      ELSE
        DO I = 1, NAT
          CHARA1 = SPE(ISPE(I))
          HUBA = HUBBL(1,ISPE(I))
          TAUA = 3.2D+00 * HUBA
          DO J = 1, I
            NSEQ = NSEQ + 1
            DIST = DISTMAT(NSEQ)
            CHARA2 = SPE(ISPE(J))
            HUBB = HUBBL(1,ISPE(J))
            TAUB = 3.2D+00 * HUBB
            IF (DAMPXH.AND.(CHARA1.EQ.H.OR.CHARA2.EQ.H)) THEN
              HDAMP = .TRUE.
            ELSE
              HDAMP = .FALSE.
            END IF
            GAMMA(NSEQ) = DFTB_GAMMA2F(DIST,HUBA,HUBB,TAUA,TAUB,DAMPXHE,
     *        HDAMP)
C           WRITE (*,'(3I4,2F20.10)') I, J, nSEQ,GAMMA(NSEQ), 1.0/DIST
          END DO
        END DO
      END IF

      RETURN

      END SUBROUTINE DFTB_GAMMA
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_GAMMA2F
C>
C>    @brief Calculate DFTB2 gamma
C>
C>    @details Function which calculates DFTB2 gamma
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param DIST Distance between atom A and B
C>    @param HUBA,HUBB Hubbard values of atom A and B
C>    @param TAUA,TAUB TAUA=HUBA*16/5
C>    @param DAMPXHE Exponent of X-H damping
C>    @param HDAMP Whether X-H damping or not, decided before calling
C>           this function
C>           --- OUTPUT ---
C>    @param DFTB_GAMMA2F DFTB2 gamma
C>
      DOUBLE PRECISION FUNCTION DFTB_GAMMA2F(DIST,HUBA,HUBB,TAUA,TAUB,
     *  DAMPXHE,HDAMP)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION, INTENT(IN) :: DIST,HUBA,HUBB,TAUA,TAUB,DAMPXHE
      LOGICAL, INTENT(IN) :: HDAMP
C
      DOUBLE PRECISION :: TAUMEAN,TMP,DISTI
      DOUBLE PRECISION, PARAMETER :: DISTTOL=1.00D-08,HUBTOL=1.00D-04,
     *  ONE=1.0D+00,HALF=0.5D+00
C
      IF (DIST.LE.DISTTOL) THEN
        IF (ABS(HUBA-HUBB).LE.HUBTOL) THEN
          DFTB_GAMMA2F = HALF*(HUBA+HUBB)
        ELSE ! This is for OrbitalResolvedSCC = Yes
          DFTB_GAMMA2F = HALF*((TAUA*TAUB)/(TAUA+TAUB)
     &              + (TAUA*TAUB)**2/(TAUA+TAUB)**3)
        END IF
      ELSE IF
     &     (ABS(HUBA-HUBB).LE.HUBTOL) THEN
        TAUMEAN = 0.5D+00 * (TAUA + TAUB)
        DISTI = ONE/DIST
        DFTB_GAMMA2F = exp(-TAUMEAN*DIST)
     &  * (DISTI + 0.6875D+00*TAUMEAN
     &  + 0.1875D+00*DIST*(TAUMEAN**2)
     &  + 0.0208333333333D+00*(DIST**2)*(TAUMEAN**3))
        IF (HDAMP) THEN
          TMP = (0.5D+00*(HUBA+HUBB))**DAMPXHE
          DFTB_GAMMA2F = DFTB_GAMMA2F * EXP(-TMP*(DIST**2))
        END IF
        DFTB_GAMMA2F = DISTI - DFTB_GAMMA2F
      ELSE
        DFTB_GAMMA2F = EXP(-TAUA*DIST)
     &  * ( (0.5D+00*TAUB**4*TAUA/(TAUA**2-TAUB**2)**2)
     &  - (TAUB**6-3.0D+00*TAUB**4*TAUA**2)/(DIST*(TAUA**2-TAUB**2)
     &  **3))
     &  + EXP(-TAUB*DIST)
     &  * ( (0.5D+00*TAUA**4*TAUB/(TAUB**2-TAUA**2)**2)
     &  - (TAUA**6-3.0D+00*TAUA**4*TAUB**2)/(DIST*(TAUB**2-TAUA**2)
     &  **3))
        IF (HDAMP) THEN
          TMP = (HALF*(HUBA+HUBB))**DAMPXHE
          DFTB_GAMMA2F = DFTB_GAMMA2F * EXP(-TMP*DIST**2)
        END IF
        DFTB_GAMMA2F = ONE/DIST - DFTB_GAMMA2F
      END IF
C
      RETURN
C
      END FUNCTION DFTB_GAMMA2F
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_MULLIKEN
C>
C>    @brief Calculate Mulliken population
C>
C>    @details Calculate Mulliken population for each AO
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Possibly performance improvement
C>
C>           --- INPUT ---
C>    @param L1 Number of basis funcitons
C>    @param L2 L1*(L1+1)/2
C>    @param DMAT Density matrix (AO basis)
C>    @param OVER Overlap matrix (AO basis)
C>           --- OUTPUT ---
C>    @param MUL Mulliken populations (AO basis)
C
      SUBROUTINE DFTB_MULLIKEN(L1,L2,DMAT,OVER,MUL)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: L1,L2
      DOUBLE PRECISION,INTENT(IN)  :: DMAT(L2),OVER(L2)
      DOUBLE PRECISION,INTENT(OUT) :: MUL(L1)
C
      INTEGER :: I, J, IJ
      DOUBLE PRECISION :: VAL(2)
C
C     | a b d | | A B D |   | aA+bB+dD aB+bC+dE aD+bE+dF |
C     | b c e | | B C E | = | bA+cB+eD bB+cC+eE bD+cE+eF |
C     | d e f | | D E F |   | dA+eB+fD dB+eC+fE dD+eE+fF |
C
C     IF A AND B MATRICES ARE SYMMETRIC,
C     C(I,I) = \SUM A(I,J)*B(J,I) = \SUM A(I,J)*B(I,J)
C
      IJ = 0
      CALL VCLR(MUL,1,L1)
      DO I = 1, L1
        VAL(2) = 0.0D+00
        DO J = 1, I-1
         IJ = IJ + 1
         VAL(1) = DMAT(IJ)*OVER(IJ)
         VAL(2) = VAL(2) + VAL(1)
         MUL(J) = MUL(J) + VAL(1)
        END DO
        IJ = IJ + 1
        MUL(I) = VAL(2) + DMAT(IJ)*OVER(IJ)
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_MULLIKEN
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_MULSA
C>
C>    @brief Calculate Mulliken population
C>
C>    @details Calculate Mulliken population for each shell and atom.
C>             MUOSA should have been calculated with DFTB_MULLIKEN
C>             in AO basis, and this subroutine integrates into
C>             shell-resolved and atom-resolved Mulliken populatinos.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param MULSAO AO-resolved Mulliken populations
C>    @param NUM Number of basis functions
C>    @param NSHELL Number of shells
C>    @param NAT Number of atoms
C>           --- OUTPUT ---
C>    @param MULSH Shell-resolved Mulliken populations
C>    @param MULAT Atom-resolved Mulliken populations
C
      SUBROUTINE DFTB_MULSA(MULAO,MULSH,MULAT,NUM,NSHELL,NAT)

      IMPLICIT NONE

      INTEGER,PARAMETER :: MXATM=2000, MXSPE=10
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      DOUBLE PRECISION :: ETEMP,DFTBDP,DAMPXHE,HUBDER,ZREF,SPNCST,SPE
      INTEGER :: NSPE,MAXANG,ISPE,IND,IDFTBD
C
      INTEGER,INTENT(IN)           :: NUM,NSHELL,NAT
      DOUBLE PRECISION,INTENT(IN)  :: MULAO(NUM)
      DOUBLE PRECISION,INTENT(OUT) :: MULSH(NSHELL)
      DOUBLE PRECISION,INTENT(OUT) :: MULAT(NAT)
C
      INTEGER :: I, J, SHELL, N
C
      CALL VCLR(MULSH,1,NSHELL)
      CALL VCLR(MULAT,1,NAT)
      SHELL = 0
      N     = 0
      DO I = 1, NAT
        DO J = 1, MAXANG(ISPE(I))
          SHELL = SHELL + 1
          IF (J.EQ.1) THEN
            MULSH(SHELL) = MULSH(SHELL) + MULAO(N+1)
            N = N + 1
          ELSE IF (J.EQ.2) THEN
            MULSH(SHELL) = MULSH(SHELL)
     *        + MULAO(N+1) + MULAO(N+2) + MULAO(N+3)
            N = N + 3
          ELSE IF (J.EQ.3) THEN
            MULSH(SHELL) = MULSH(SHELL)
     *        + MULAO(N+1) + MULAO(N+2) + MULAO(N+3)
     *        + MULAO(N+4) + MULAO(N+5)
            N = N + 5
          END IF
          MULAT(I) = MULAT(I) + MULSH(SHELL)
        END DO
      END DO

C     WRITE (IW,*)
C     WRITE (IW,*) " ATOMIC ORBITRAL RESOLVED MULLIKEN"
C     DO I = 1, NUM
C       WRITE (IW,'(X,I3,X,F8.5)') I,MULAO(I)
C     END DO
C     WRITE (IW,*)
C     WRITE (IW,*) " SHELL RESOLVED MULLIKEN"
C     DO I = 1, NSHELL
C       WRITE (IW,'(X,I3,X,F8.5)') I,MULSH(I)
C     END DO
C     WRITE (IW,*)
C     WRITE (IW,*) " ATOM RESOLVED MULLIKEN"
C     DO I = 1, NATOM
C       WRITE (IW,'(X,I3,X,A8,X,F8.5)') I,SPE(ISPE(I)),MULAT(I)
C     END DO

      END SUBROUTINE DFTB_MULSA
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_ETEMP
C>
C>    @brief Calculate fractional occupation numbers (FONs)
C>
C>    @details Calculate fractional occupation number of each orbital.
C>             Only Fermi-Dirac distribution function is implemented.
C>             I'm not sure other function is correctly stationary with
C>             respect to the change of MO coefficients.
C>             Refer, for instance, Warren, R. et al. Chem. Phys. Lett.
C>             1996, 262, 384-392.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NORB Number of orbitals
C>    @param NE Number of electrons
C>    @param EIGVAL Eigenvalue of each orbital
C>    @param ETEMP Electronic tempererature in Kelvin unit
C>           --- OUTPUT ---
C>    @param OCC Occupation number of each orbital
C>    @param EMERMIN Mermin free energy correction
C>    @param FE Fermi-level
C>
C>    @todo Unrestricted?
C>
C
      SUBROUTINE DFTB_ETEMP(NORB,NE,EIGVAL,OCC,ETEMP,EMERMIN,FE)

      IMPLICIT NONE

      INTEGER         , INTENT(IN)  :: NORB
      INTEGER         , INTENT(IN)  :: NE
      DOUBLE PRECISION, INTENT(IN)  :: EIGVAL(NORB)
      DOUBLE PRECISION, INTENT(OUT) :: OCC(NORB)
      DOUBLE PRECISION, INTENT(IN)  :: ETEMP
      DOUBLE PRECISION, INTENT(OUT) :: EMERMIN
      DOUBLE PRECISION, INTENT(OUT) :: FE
C     LOGICAL         , INTENT(IN)  :: UHF

      INTEGER :: NEA, I, NDEG, IDEG!, NEB
      DOUBLE PRECISION :: BETA, ETOL, NEMAX, NEMIN, NEC, LFE, UFE
      DOUBLE PRECISION :: ECOUNT, TOCC

      DOUBLE PRECISION,PARAMETER :: BOLTZ = 3.1668114D-06
      INTEGER,PARAMETER :: IW = 6

C     WRITE (IW,*) "ETEMP IS CALLED"
C     DO I = 1, NORB
C       WRITE (IW,*) EIGVAL(I)
C     END DO
C     WRITE (IW,*) ETEMP
C     WRITE (IW,*) NE

C     INITIALIZE OCCUPATION NUMBER
      CALL VCLR(OCC,1,NORB)
C     BECAUSE RESTRTICTED CALCULATION
      NEA = INT(NE/2.0D+00 + 1.0D-02)
C     NEB = INT(NE/2.0D+00 + 1.0D-02)
C     EXIT IF NUMBER OF ELECTRON IS SMALL
      IF (NE.LT.1.0D-05) RETURN
C     ZERO FILL, IF ELECTRONIC TEMPERATURE IS SUFFICIENTLY SMALL
      IF (ETEMP.LE.1.0D-06) THEN
        FE = 0.5D+00*(EIGVAL(NEA+1)+EIGVAL(NEA)) !! FERMI ENERGY
C          --- IF DEGENERATED ---
        IF (ABS(EIGVAL(NE/2)-FE).LT.1.0D-04) THEN
C         COUNT THE NUMBER OF DEGENERATION
          NDEG = 0
          DO I = 1, NORB
            IF (ABS(EIGVAL(I)-FE).LT.1.0D-04) THEN
              NDEG = NDEG + 1
            ELSE
              OCC(I) = 2.0D+00
              IDEG = I + 1
            END IF
          END DO
          DO I = 1, NDEG
            IF (ABS(EIGVAL(I)-FE).LT.1.0D-04) THEN
              OCC(IDEG+I-1) = 2.0D+00 / NDEG
            END IF
          END DO
          RETURN
        ELSE
        !! IF NOT DEGENERATED
          DO I = 1, INT(DBLE(NE)/2.0D+00-1.0D+00)
            OCC(I) = 2.0D+00
          END DO
        END IF
        RETURN
      END IF
C
C     ----- FERMI-DIRAC DISTRIBUTION -----
C                      1
C     n = -------------------------
C               EIGVALUE-\mu
C          EXP (------------) + 1
C                    kT
C     EIGVAUE: EIGENVALUE (EIGAL)
C     n      : OCCUPATION NUMBER (OCC)
C     \mu    : CHEMICAL POTENTIAL
C
      BETA = 1.0D+00/(BOLTZ*ETEMP)
      ETOL = 1.0D-15 !!    ???
C
C     --- DETERMINE (TRUE) FERMI-LEVEL ---
C
      NEMAX = ECOUNT(EIGVAL(NORB),EIGVAL(1:NORB),BETA,NORB)
      UFE = EIGVAL(NORB)
      NEMIN = ECOUNT(EIGVAL(1),EIGVAL(1:NORB),BETA,NORB)
      LFE = EIGVAL(1)
      DO WHILE (NEMIN .GT. NE)
        LFE = 2.0D+00*(LFE-UFE) + LFE
        NEMIN = ECOUNT(LFE,EIGVAL(1:NORB),BETA,NORB)
      END DO
      DO WHILE (NEMAX .LT. NE)
        UFE = 2.0D+00*(UFE-LFE) + LFE
        NEMAX = ECOUNT(UFE,EIGVAL(1:NORB),BETA,NORB)
      END DO

      FE = 5.0D-01*(UFE+LFE)
      NEC = ECOUNT(FE,EIGVAL(1:NORB),BETA,NORB)

      DO WHILE (ABS(NE-NEC).GT.ETOL .AND. (ABS(UFE-LFE).GE.ETOL))
        IF ((NEMAX.GE.NEMIN).EQV.(NE.GE.NEC)) THEN
          LFE = FE
          NEMIN = NEC
        ELSE
          UFE = FE
          NEMAX = NEC
        END IF
        FE = 5.0D-01*(UFE+LFE)
        NEC = ECOUNT(FE,EIGVAL(1:NORB),BETA,NORB)
      END DO

C     WRITE (iw,*) "NEC = ",NEC

      IF (ABS(NE-NEC).GT.1.0D-07) THEN
        WRITE (IW,*) " FERMI LEVEL SEARCH DID NOT CONVERGE"
        CALL ABRT
      END IF

      DO I = 1, NORB
        OCC(I) = 2.0D+00/(1.0D+00+EXP((EIGVAL(I)-FE)*BETA))
      END DO

      IF (ABS(SUM(OCC(:))-NE).GT.1.0D-03) THEN
        WRITE (IW,*) " FAILED IN FILLING ELECTRONS"
        CALL ABRT
      END IF
C
C     CALCULATE ENETROPY OF ELECTRONS
C     TS = TS - E*LOG(E) + (1-E)*LOG(1-E)
C
      EMERMIN = 0.0D+00
      DO I = 1, NORB
        TOCC = OCC(I) * 0.5D+00
        IF (TOCC.LE.0.999999999D+00) THEN
          IF (TOCC.GE.1.0D-10) THEN
            EMERMIN = EMERMIN + TOCC * LOG(TOCC)
     *                + (1.0D+00 - TOCC) * LOG(1.0D+00 - TOCC)
          ELSE
            GOTO 20
          END IF
        END IF
      END DO

20    EMERMIN = EMERMIN * BOLTZ * ETEMP * 2.0D+00
C
C     DO I = 1, NORB
C       IF (OCC(I).GE.0.0001 .AND. OCC(I).LE.1.9999)
C    &      WRITE (IW,'(X,I3,X,F8.5)') I, OCC(I)
C     END DO

      RETURN

      END SUBROUTINE DFTB_ETEMP
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_ETEMP
C>
C>    @brief Calculate fractional occupation numbers (FONs)
C>
C>    @details Calculate sum of occupation numbers at given Fermi-level.
C>             We decide Fermi-level so as to keep the number of
C>             electrons in the system constant.  This simplifies the
C>             equation and implementation of 1st- and 2nd-order
C>             derivatives.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param FE Fermi-level
C>    @param EIGVAL Eigenvalue of each orbital
C>    @param BETA 1/(kT)
C>    @param NORB Number of orbitals
C>           --- OUTPUT ---
C>    @param ECOUNT Sum of occupation numbers
C>
C>    @todo Unrestricted?
C>
C
      DOUBLE PRECISION FUNCTION ECOUNT(FE,EIGVAL,BETA,NORB)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: NORB
      DOUBLE PRECISION,INTENT(IN) :: FE
      DOUBLE PRECISION,INTENT(IN) :: EIGVAL(NORB)
      DOUBLE PRECISION,INTENT(IN) :: BETA
C
      DOUBLE PRECISION :: VAL
      INTEGER :: I
C
      ECOUNT = 0.0D+00
      DO I = 1, NORB
        VAL = (EIGVAL(I)-FE)*BETA
        ECOUNT = ECOUNT + 2.0D+00/(1.0D+00+EXP(VAL))
      END DO
C
      RETURN
C
      END FUNCTION ECOUNT
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_DIPOLE
C>
C>    @brief Calculate dipole moment
C>
C>    @details Calculate dipole moment for DFTB in a classical way,
C>             as written below
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date May, 2015- Yoshio Nishimoto
C>    - Charges for TD-DFTB (use excited state density matrix)
C>
C>           --- INPUT ---
C>    @param DA,DB Alpha and beta density matrix
C>    @param L2 L1*(L1+1)/2
C>           --- OUTPUT ---
C>    @param DMX,DMY,DMZ Dipole moment of x,y,z direction in Debye unit
C>    @param CHARGE Sum of Mulliken populations
C>    @param DIP Length of dipole moments
C>
C
      SUBROUTINE DFTB_DIPOLE(DMX,DMY,DMZ,CHARGE,DIP,DA,DB,L2)
C
C     THIS SUBROUTINE CALCULATES THE DIPOLE MOMENT FOR DFTB. BECAUSE
C     DFTB CANNOT CALCULATE (ONE-ELECTRON) INTEGRALS, DIPOLE MOMENT
C     HAS TO BE CALCULATE IN A CLASSICAL MANNER.
C
C     D = (CHARGE)*(DISTANCE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXSPE=10)
      PARAMETER (ONE=1.0D+00)
C
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DOUBLE PRECISION, INTENT(OUT) :: DMX, DMY, DMZ, CHARGE, DIP
      INTEGER, INTENT(IN) :: L2
      DOUBLE PRECISION, INTENT(IN) :: DA(L2),DB(L2)
C
      DATA RNONE/8HNONE    /,UHF/8HUHF     /
C
      L1 = NUM
C
      IF (TDDFTYP.EQ.RNONE) THEN
        CALL VALFM(LOADFM)
        CALL GOTFM(NGOTMX)
        LMUL   = LOADFM + 1
        LAST   = LMUL  + NAT      !! LMUL1A: MULLIKEN POPULATION (NOT CHARGE)
        NEED   = LAST - LOADFM - 1
        CALL GETFM(NEED)
C
        IF (IODA(556).EQ.-1) THEN
          WRITE (IW,*) "CANNOT CALCULATE DIPOLE MOMENTS"
          CALL DCOPY(NAT,ZREF,1,X(LMUL),1)
        ELSE
          CALL DAREAD(IDAF,IODA,X(LMUL),NAT,556,0)
        END IF
      ELSE
        NSHELL = 0
        DO I = 1, NAT
          NSHELL = NSHELL + MAXANG(ISPE(I))
        END DO
C
        CALL VALFM(LOADFM)
        CALL GOTFM(NGOTMX)
        LMUL     = LOADFM + 1
        LS       = LMUL   + L1
        LMULA    = LS     + L2
        LMULS    = LMULA  + NAT
        LAST     = LMULS  + NSHELL
        IF (SCFTYP.EQ.UHF) THEN
          LMULB  = LAST
          LMULSB = LMULB  + L1
          LMULAB = LMULSB + NSHELL
          LAST   = LMULAB + NAT
        END IF
        NEED   = LAST - LOADFM - 1
        CALL GETFM(NEED)
C
        CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
        CALL DFTB_MULLIKEN(L1,L2,DA,X(LS),X(LMUL))
        CALL DFTB_MULSA(X(LMUL),X(LMULS),X(LMULA),L1,NSHELL,NAT)
        IF (SCFTYP.EQ.UHF) THEN
          CALL DFTB_MULLIKEN(L1,L2,DB,X(LS),X(LMULB))
          CALL DFTB_MULSA(X(LMULB),X(LMULSB),X(LMULAB),L1,NSHELL,NAT)
          CALL DAXPY(NAT,ONE,X(LMULAB),1,X(LMULA),1)
        END IF
        LMUL = LMULA
      END IF
C
      DMX = 0.0D+00
      DMY = 0.0D+00
      DMZ = 0.0D+00
      CHARGE = 0.0D+00
C
      DO I = 1, NAT
C       PTM = X(LMUL+I-1) !! POPULATION TEMP
        CTM = ZREF(I) - X(LMUL+I-1) !! CHARGE TEMP
C       CHARGE = CHARGE + PTM
        CHARGE = CHARGE + CTM
        DMX = DMX + CTM * C(1,I)
        DMY = DMY + CTM * C(2,I)
        DMZ = DMZ + CTM * C(3,I)
      END DO
C
      CALL RETFM(NEED)
C
C     CONVERSION FROM AU TO DEBYE
C
      DMX = DMX * 2.541746675D+00
      DMY = DMY * 2.541746675D+00
      DMZ = DMZ * 2.541746675D+00
      DIP = SQRT(DMX*DMX+DMY*DMY+DMZ*DMZ)

      RETURN

      END SUBROUTINE DFTB_DIPOLE
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_MIXER
C>
C>    @brief Charge mixing deriver
C>
C>    @details Charge mixing (= accerelate SCF convergence) with the
C>             following three methods:
C>               ITYPMX = 0 :: BROYDEN'S METHOD
C>               ITYPMX = 1 :: ANDERSON'S METHOD (N/A)
C>               ITYPMX = 2 :: DIIS
C>               ITYPMX = 3 :: SIMPLE MIXER
C>               ITYPMX = 4 :: BROYDEN -> DIIS
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NITER Current iteration number
C>    @param NAT Number of atoms
C>    @param ETOT Total energy?
C>           --- OUTPUT ---
C>    @param VECIN Vector in the old cycle on entry, and the vector
C>           which is NOT extrapolated (interpolated?) vecotr on exit
C>    @param VECOUT Newly calculated vector in the current cycle on
C>           entry, and extrapolated (interpolated?) vector on exit
C>    @param MEMMIX Memory required by subroutine.  This memory will be
C>           released after SCF convergence.
C>    @param ERDIIS Error of DIIS vector
C>
C>    @todo Anderson's method?
C>
C
      SUBROUTINE DFTB_MIXER(NITER,NAT,VECIN,VECOUT,MEMMIX,ERDIIS,ETOT)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: NITER, NAT
      INTEGER,INTENT(OUT) :: MEMMIX
      DOUBLE PRECISION, INTENT(INOUT) :: ERDIIS,VECIN(NAT),VECOUT(NAT)
      COMMON /DFTBMX/ SIMPLE,ITYPMX,TBROYDEN
      DOUBLE PRECISION :: SIMPLE
      INTEGER :: ITYPMX
      LOGICAL :: TBROYDEN
C
      DOUBLE PRECISION :: ALPHA,ETOT
C
C     VECIN  :: CHARGE OF THE CURRENT CYCLE, | n(m)out >
C     VECOUT :: CHARGE OF THE INPUT OF THE CURRENT CYCLE, | n(m) >
C
      IF (NITER.EQ.0) MEMMIX = 0
      ALPHA = 0.2D+00
      IF (ITYPMX.EQ.0)
     &      CALL DFTB_MIX_BROYDEN(NITER,NAT,500,MEMMIX,ALPHA,
     *           VECIN,VECOUT,ERDIIS)
C     IF (ITYPMX.EQ.1) CALL DFTB_MIX_ANDERSON(NITER,NAT,ALPHA,VECIN,
C    &                      VECOUT)
      IF (ITYPMX.EQ.2)
     &      CALL DFTB_MIX_DIIS(NITER,NAT,VECIN,VECOUT,MEMMIX,
     *                         ERDIIS,ALPHA,ETOT)
      IF (ITYPMX.EQ.3) CALL DFTB_MIX_SIMPLE(NITER,NAT,VECIN,VECOUT)
      IF (ITYPMX.EQ.4) CALL DFTB_MIX_BRDIIS(NITER,NAT,500,MEMMIX,ALPHA,
     *           VECIN,VECOUT,ERDIIS,ETOT)

      END SUBROUTINE DFTB_MIXER
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_MIX_BRDIIS
C>
C>    @brief Charge mixing
C>
C>    @details Charge mixing with Broyden and DIIS
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NITER Current iteration number
C>    @param NAT Number of atoms
C>    @param MXITER Maximum iterations allowed to do
C>    @param ALPHA Parameter for simple mixing done in the first cycle
C>    @param ETOT Total energy?
C>           --- OUTPUT ---
C>    @param NEED Memory required by this subroutine
C>    @param VECIN Vector in the old cycle on entry, and the vector
C>           which is NOT extrapolated (interpolated?) vecotr on exit
C>    @param VECOUT Newly calculated vector in the current cycle on
C>           entry, and extrapolated (interpolated?) vector on exit
C>    @param ERDIIS Error of DIIS vector
C>
C
      SUBROUTINE DFTB_MIX_BRDIIS(NITER,NAT,MXITER,NEED,
     *     ALPHA,VECIN,VECOUT,ERDIIS,ETOT)

      IMPLICIT NONE

      DOUBLE PRECISION, PARAMETER :: ONE = 1.0D+00, W0 = 1.0D-02
      INTEGER         , PARAMETER :: NGEN = 6

      INTEGER         , INTENT(IN)    :: NITER, NAT, MXITER
      INTEGER         , INTENT(INOUT) :: NEED
      DOUBLE PRECISION, INTENT(IN)    :: ALPHA
      DOUBLE PRECISION, INTENT(INOUT) :: VECIN(NAT)
      DOUBLE PRECISION, INTENT(INOUT) :: VECOUT(NAT)
      DOUBLE PRECISION, INTENT(OUT)   :: ERDIIS
      DOUBLE PRECISION, INTENT(IN)    :: ETOT

      COMMON /FMCOM / X(1)
      DOUBLE PRECISION :: X

      INTEGER          :: I, J, K, ITMP, ITMP1, ITMP2, NSIZE, NSIZE1
      INTEGER          :: LL, LLL, LMX1, LMX2, L1, L2, L3, LOADFM,
     *                    LAST, NEEDLOC, INFO, LF, LDQ, LU, LDF,
     *                    LWRK1, LWRK2, LBETA, LBETASQ, LC, LAD, LADSQ,
     *                    LB, LSCR
      INTEGER          :: IPIV(501)
      INTEGER, SAVE    :: LF_PREV, LQ_PREV, LU_HIST, LDF_HIST, LW, LA,
     *                    LF_HIST, LQ_HIST, LETOT
      DOUBLE PRECISION :: DFNORM, DFNORMI, DNRM2, DDOT,
     *                    W, GM, W2, DELE, DELE1, THRESHOLD, DET(2)
      LOGICAL          :: DODIIS!, DOBRYDN
      DOUBLE PRECISION :: XNRM2, XDOT
C
C     ----- BROYDEN'S AND DIIS CHARGE MIXING -----
C
C     CHANGE BROYDEN'S CHARGE MIXING TO DIIS IF ENERGY DIFFERENCE
C     BECOMES LESS THAN A THRESHOLD.
C     THIS IS THE COPY OF DFTB_MIX_DIIS AND DFTB_MIX_BROYDEN SUBROUTINES
C
      IF (NITER.EQ.MXITER) THEN
        WRITE (*,*) " CONVERGENCE IS NOT ACHIEVED WITHIN 500 ITERATIONS"
        WRITE (*,*) " TOO MANY ITERATIONS FOR DFTB_MIX_BROYDEN"
        CALL ABRT
      END IF
C
      IF (NITER.EQ.1) THEN
        LL   = NAT * MXITER
        LLL  = NAT * NGEN
        LMX1 = MXITER
        LMX2 = (LMX1*LMX1+LMX1)/2
C
C     ----- ALLOCATE MEMORY USED DURING SCF CYCLE -----
C
        CALL VALFM(LOADFM)
        LF_PREV  = LOADFM   + 1
        LQ_PREV  = LF_PREV  + NAT
        LU_HIST  = LQ_PREV  + NAT
        LDF_HIST = LU_HIST  + LL
        LW       = LDF_HIST + LL
        LA       = LW       + LMX1
        LF_HIST  = LA       + LMX2 !! LOWER TRIANGLE
        LQ_HIST  = LF_HIST  + LLL
        LETOT    = LQ_HIST  + LLL
        LAST     = LETOT    + NGEN
        NEED     = LAST - LOADFM - 1
        CALL GETFM(NEED)
C         INITIALIZE
        CALL VCLR(X(LF_PREV) ,1,NAT )
        CALL VCLR(X(LQ_PREV) ,1,NAT )
        CALL VCLR(X(LU_HIST) ,1,LL  )
        CALL VCLR(X(LDF_HIST),1,LL  )
        CALL VCLR(X(LW)      ,1,LMX1)
        CALL VCLR(X(LA)      ,1,LMX2)
        CALL VCLR(X(LF_HIST) ,1,LLL )
        CALL VCLR(X(LQ_HIST) ,1,LLL )
        CALL VCLR(X(LETOT)   ,1,NGEN)
        !! DIIS PART
        CALL DCOPY(NAT,VECIN,1,X(LQ_HIST),1)
        DO I = 1, NAT
          X(LF_HIST+I-1) = VECOUT(I) - VECIN(I)
        END DO
        X(LETOT-1) = ETOT
C
C       STORE
C         F_PREV (= CHARGE DIFFERENCE, Q(out) - Q(in))
C       WHICH IS JUST THE CHARGE DIFFERENCE OF CURRENT CYCLE.
C       AND, THE INPUT DENTITY FOR Q_PREV.  THIS IS USED IN THE
C       NEXT CYCLE.
C
        CALL DCOPY(NAT,VECOUT,1,X(LF_PREV),1)
        CALL DAXPY(NAT,-ONE,VECIN,1,X(LF_PREV),1)
        CALL DCOPY(NAT,VECIN,1,X(LQ_PREV),1)
C
C       DO SIMPLE MIXING FOR THE FIRST ITERATION, AND RETURN
C
        CALL DCOPY(NAT,VECIN,1,VECOUT,1)
        CALL DAXPY(NAT,ALPHA,X(LF_PREV),1,VECOUT,1)
        RETURN
      END IF
C     FOR DIIS
      IF (NITER.LE.NGEN) THEN
        NSIZE = NITER
      ELSE IF (NITER.GT.NGEN) THEN
        NSIZE = NGEN
      END IF
C
      NSIZE1 = NSIZE + 1
C
C     ----- NITER .GE. 2 -----
C
      L1 = NITER-1
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      CALL VALFM(LOADFM)
      LSCR     = LOADFM   + 1
      !! DIIS PART
      LAD      = LSCR     + NSIZE
      LADSQ    = LAD      + (NSIZE1*NSIZE1+NSIZE1)/2
      LB       = LADSQ    + NSIZE1 * NSIZE1
      LF       = LB       + NSIZE1
      !! BROYDEN PART
      LDQ      = LF       + NAT  !! PREVIOUS F(m-1) MATRIX
      LU       = LDQ      + NAT  !! | dQ(m-1) > MATRIX
      LDF      = LU       + NAT  !! | u(m-1) > MATRIX
      LWRK1    = LDF      + NAT  !! | dF(m-1) > = | F(m) > - | F(m-1) >
      LWRK2    = LWRK1    + L3
      LBETA    = LWRK2    + NAT
      LC       = LBETA    + L2   !! TRIANGULAR MATRIX FOR BETA
      LBETASQ  = LC       + L1   !! c_k^m MATRIX
      LAST     = LBETASQ  + L3   !! SQUARE MATRIX FOR BETA
      NEEDLOC  = LAST - LOADFM - 1
      CALL GETFM(NEEDLOC)
C
C     ----- UPDATE VECTOR INFORMATION -----
C
C     !! DIIS PART
      IF (NITER.LE.NGEN) THEN
        NSIZE = NITER
        ITMP = NAT*(NSIZE-1)
      ELSE IF (NITER.GT.NGEN) THEN
        NSIZE = NGEN
        ITMP = NAT*(NSIZE-1)
        CALL DCOPY(ITMP,X(LF_HIST+NAT),1,X(LSCR),1)
        CALL DCOPY(ITMP,X(LSCR),1,X(LF_HIST),1)
        CALL VCLR(X(LF_HIST+ITMP),1,NAT)

        CALL DCOPY(ITMP,X(LQ_HIST+NAT),1,X(LSCR),1)
        CALL DCOPY(ITMP,X(LSCR),1,X(LQ_HIST),1)
        CALL VCLR(X(LQ_HIST+ITMP),1,NAT)

        CALL DCOPY(NSIZE-1,X(LETOT+1),1,X(LSCR),1)
        CALL DCOPY(NSIZE-1,X(LSCR),1,X(LETOT),1)
      END IF
      CALL DCOPY(NAT,VECIN,1,X(LQ_HIST+ITMP),1)
      DO I = 1, NAT
        X(LF_HIST+ITMP+I-1) = VECOUT(I) - VECIN(I)
      END DO
      X(LETOT+NSIZE-1) = ETOT
C     !! BROYDEN PART
      CALL DCOPY(NAT,VECIN,1,X(LDQ),1)
      CALL DAXPY(NAT,-ONE,X(LQ_PREV),1,X(LDQ),1)
      CALL DCOPY(NAT,VECOUT,1,X(LF),1)
      CALL DAXPY(NAT,-ONE,VECIN,1,X(LF),1)
      CALL DCOPY(NAT,X(LF),1,X(LDF),1)
      CALL DAXPY(NAT,-ONE,X(LF_PREV),1,X(LDF),1)
C
      DFNORM  = DNRM2(NAT,X(LDF),1)
      DFNORMI = ONE / DFNORM
      CALL DCOPY(NAT,X(LDQ),1,X(LU),1)
      CALL DAXPY(NAT,ALPHA,X(LDF),1,X(LU),1)
      CALL DSCAL(NAT,DFNORMI,X(LU) ,1) !! FINALIZE  | u  >
      CALL DSCAL(NAT,DFNORMI,X(LDF),1) !! NORMALIZE | dF >
      ITMP = NAT*(NITER-2)
      CALL DCOPY(NAT,X(LU),1,X(LU_HIST+ITMP),1)
      CALL DCOPY(NAT,X(LDF),1,X(LDF_HIST+ITMP),1)
      CALL DCOPY(NAT,X(LF),1,X(LF_PREV),1)
      CALL DCOPY(NAT,VECIN,1,X(LQ_PREV),1)
C
      W = DNRM2(NAT,X(LF),1)
      IF (W.GT.1.0D-07) THEN
        W = 1.0D-02 / W
      ELSE
        W = 1.0D+05
      END IF
      IF (W.LT.ONE) W = ONE
      X(LW+NITER-2) = W
C
C     ----- DECIDE WHICH IS PERFORMED -----
C
      DELE  = X(LETOT+NSIZE-1) - X(LETOT+NSIZE-2)
      DELE1 = X(LETOT+NSIZE-2) - X(LETOT+NSIZE-3)
      THRESHOLD = 5.0D-05
      IF (ABS(DELE).LE.THRESHOLD.AND.NITER.GE.NGEN) THEN
        DODIIS  = .TRUE.
C       DOBRYDN = .FALSE.
      ELSE
        DODIIS  = .FALSE.
C       DOBRYDN = .TRUE.
      END IF
      IF (ABS(DELE).LE.THRESHOLD.AND.ABS(DELE1).GE.THRESHOLD) THEN
        WRITE (*,*) " CHANGE TO DIIS"
      ELSE IF (ABS(DELE).GE.THRESHOLD.AND.ABS(DELE1).LE.THRESHOLD) THEN
        WRITE (*,*) " CHANGE TO BROYDEN"
      END IF
C
C     ----- PERFORME ONE OF TWO METHODS -----
C
      IF (DODIIS) THEN
        CALL VCLR(X(LAD),1,NSIZE1*NSIZE1)
        CALL VCLR(X(LB),1,NSIZE1)
        ITMP = 0
        DO I = 1, NSIZE
          DO J = 1, I
            ITMP = ITMP + 1
            X(LAD+ITMP-1) =
     *        DDOT(NAT,X(LF_HIST+(I-1)*NAT),1,X(LF_HIST+(J-1)*NAT),1)
            IF (I.EQ.J) X(LSCR+I-1) = X(LAD+ITMP-1)
          END DO
        END DO
        DO J = 1, NSIZE
          ITMP = ITMP + 1
          X(LAD+ITMP-1) = -1.0D+00 !! K = {(I+1)-1} * NAT = (NSIZE-1)*NAT
        END DO
        CALL CPYTSQ(X(LAD),X(LADSQ),NSIZE1,1)
        X(LB+NSIZE  ) = -1.0D+00
C
        CALL SLVLEQ(X(LADSQ),X(LB),IPIV,NSIZE1,NSIZE1,0,INFO)
        IF (INFO.NE.0) THEN
          WRITE (*,*)
          WRITE (*,*) "ERROR IN SOLVING DIIS EQUATION"
          WRITE (*,*) "INFO = ", INFO
          WRITE (*,*)
          CALL ABRT
        END IF
C
        CALL DCOPY(NAT,VECOUT,1,VECIN,1)
        CALL VCLR(VECOUT,1,NAT)
        DO I = 1, NSIZE
          K = (I-1) * NAT
          DO J = 1, NAT
           VECOUT(J) = VECOUT(J)
     *               + X(LB+I-1)*(X(LF_HIST+K+J-1)+X(LQ_HIST+K+J-1))
          END DO
        END DO
        ERDIIS = X(LB+NSIZE) !! USE LAMBDA BUT THIS IS NOT DIIS ERROR
C       IF (NITER.LE.NGEN) THEN
C         CALL DAXPY(NAT,ALPHA,X(LF_HIST+NAT*(NITER-1)),1,VECOUT,1)
C       END IF
      ELSE
        IF (NITER.GE.3) THEN
          ITMP1 = (NITER-2)*(NITER-1)/2
          DO I = 1, NITER-2
            ITMP = NAT*(I-1)
            CALL DCOPY(NAT,X(LDF_HIST+ITMP),1,X(LWRK2),1)
            ITMP2 = ITMP1 + I
            X(LA+ITMP2-1) = DDOT(NAT,X(LWRK2),1,X(LDF),1)
            X(LC+I-1)     = DDOT(NAT,X(LWRK2),1,X(LF),1)
          END DO
        END IF
        ITMP = (NITER-1)*NITER/2
        X(LA+ITMP-1)  = ONE
        X(LC+NITER-2) = DDOT(NAT,X(LDF),1,X(LF),1)
C
        ITMP = 0
        W2   = W0*W0
        DO I = 1, NITER-1
          DO J = 1, I
            ITMP = ITMP + 1
            X(LBETA+ITMP-1) = X(LA+ITMP-1) * X(LW+I-1) * X(LW+J-1)
            IF (I.EQ.J) X(LBETA+ITMP-1) = X(LBETA+ITMP-1) + W2
          END DO
        END DO
C
        CALL CPYTSQ(X(LBETA),X(LBETASQ),L1,1)
        CALL DGEFA(X(LBETASQ),L1,L1,IPIV,INFO)
CMKL    CALL DGETRF(L1,L1,X(LBETASQ),L1,IPIV,INFO)
        IF (INFO.NE.0) THEN
          WRITE (*,*)
          WRITE (*,*) "ERROR IN LU FACTORIZATION"
          WRITE (*,*) "INFO = ", INFO
          WRITE (*,*)
          CALL ABRT
        END IF
C
        INFO = 1
        CALL DGEDI(X(LBETASQ),L1,L1,IPIV,DET,X(LWRK1),INFO)
CMKL    CALL DGETRI(L1,X(LBETASQ),L1,IPIV,X(LWRK1),
CMKL *              L3,INFO)
CMKL    IF (INFO.NE.0) THEN
CMKL      WRITE (*,*)
CMKL      WRITE (*,*) "ERROR IN SOLVING BETA INVERSE"
CMKL      WRITE (*,*) "INFO = ", INFO
CMKL      WRITE (*,*)
CMKL      CALL ABRT
CMKL    END IF
C
        CALL DCOPY(NAT,VECOUT,1,VECIN,1)
        CALL DCOPY(NAT,X(LQ_PREV),1,VECOUT,1)
        CALL DAXPY(NAT,ALPHA,X(LF),1,VECOUT,1)
        DO I = 1, NITER-1
          ITMP = NAT*(I-1)
          CALL DCOPY(NAT,X(LU_HIST+ITMP),1,X(LU),1)
          ITMP = (NITER-1)*(I-1)
          CALL DCOPY(NITER-1,X(LBETASQ+ITMP),1,X(LWRK1),1)
          GM = 0.0D+00
          DO J = 1, NITER-1
            GM = GM + X(LC+J-1)*X(LWRK1+J-1)*X(LW+J-1) !! EQ.(15b)
          END DO
          CALL DAXPY(NAT,-GM*X(LW+I-1),X(LU),1,VECOUT,1) !! EQ.(15a)
        END DO
        ERDIIS = DFNORM !! IT IS NOT CORRECT
      END IF
C
      CALL RETFM(NEEDLOC)
C     WRITE (*,*) "VECIN AND VECOUT"
C     DO I = 1, NAT
C       WRITE (*,'(X,I3,X,F10.5,X,F10.5)') I, VECIN(I), VECOUT(I)
C     END DO
C
      RETURN
C
      END SUBROUTINE DFTB_MIX_BRDIIS
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_MIX_DIIS
C>
C>    @brief Charge mixing
C>
C>    @details Charge mixing with DIIS
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NITER Current iteration number
C>    @param NAT Number of atoms
C>    @param ALPHA Parameter for simple mixing done in the first cycle
C>    @param ETOT Total energy?
C>           --- OUTPUT ---
C>    @param NEED Memory required by this subroutine
C>    @param VECIN Vector in the old cycle on entry, and the vector
C>           which is NOT extrapolated (interpolated?) vecotr on exit
C>    @param VECOUT Newly calculated vector in the current cycle on
C>           entry, and extrapolated (interpolated?) vector on exit
C>    @param ERDIIS Error of DIIS vector
C>
C
      SUBROUTINE DFTB_MIX_DIIS(NITER,NAT,VECIN,VECOUT,NEED,
     &                         ERDIIS,ALPHA,ETOT)

      IMPLICIT NONE

      INTEGER,INTENT(IN) :: NITER, NAT
      DOUBLE PRECISION,INTENT(INOUT) :: VECIN(NAT)  !! | n(m)    >
      DOUBLE PRECISION,INTENT(INOUT) :: VECOUT(NAT) !! | n(m)out >
      DOUBLE PRECISION,INTENT(INOUT) :: ALPHA, ERDIIS

      COMMON /FMCOM / X(1)
      DOUBLE PRECISION :: X

      INTEGER,PARAMETER  :: NGEN = 6
      INTEGER :: IWRK(NGEN)
      INTEGER :: LOADFM, LSCR, LA, LB, NEED, NEED1, LAST, LASQ
      INTEGER, SAVE :: LF, LNIN, LETOT
      INTEGER :: I, J, K, JOB, INFO, NSIZE, NSIZE1, ITMP
      DOUBLE PRECISION :: DDOT
      DOUBLE PRECISION :: ETOT
      DOUBLE PRECISION :: XDOT
C
C     ----- DIIS EXTRAPOLATION FOR ATOMIC CHARGES -----
C
C     THE FOCK MATRIX OF SCC-DFTB INDIRECTLY DEPENDS ON DENSITY MATRIX,
C     BUT DIRECTLY DEPENDS ON ATOMIC CHARGES.  THEREFORE, RATHER THAN
C     EXTRAPOLATING A DENSITY MATRIX, WORKING WITH ATOMIC CHARGES IS
C     LESS COMPUTATIONALLY DEMANDING.
C
      IF (NITER.EQ.1) THEN
C       MEMORY ALLOCATION FOR GLOBAL
        CALL VALFM(LOADFM)
        LF   = LOADFM + 1
        LNIN = LF     + NAT * NGEN
        LETOT= LNIN   + NAT * NGEN
        LAST = LETOT  +       NGEN
        NEED = LAST - LOADFM - 1
        CALL GETFM(NEED)
        CALL VCLR(X(LF   ),1,NAT*NGEN)
        CALL VCLR(X(LNIN ),1,NAT*NGEN)
        CALL VCLR(X(LETOT),1,    NGEN)
      END IF
C
      IF (NITER.LE.NGEN) THEN
        NSIZE = NITER
      ELSE IF (NITER.GT.NGEN) THEN
        NSIZE = NGEN
      END IF
C
      NSIZE1 = NSIZE + 1
C
C     MEMORY ALLOCATION FOR LOCAL
C
      CALL VALFM(LOADFM)
      LSCR  = LOADFM + 1
      LA    = LSCR   + NSIZE
      LASQ  = LA     + (NSIZE1*NSIZE1+NSIZE1)/2
      LB    = LASQ   + NSIZE1 * NSIZE1
      LAST  = LB     + NSIZE1
      NEED1 = LAST -LOADFM -1
      CALL GETFM(NEED1)
C
      !! SHIFT X(LF), FIRST, COPY X(LF+NAT:X(LF+
      IF (NITER.LE.NGEN) THEN
        NSIZE = NITER
        ITMP = NAT*(NSIZE-1)
      ELSE IF (NITER.GT.NGEN) THEN
        NSIZE = NGEN
        ITMP = NAT*(NSIZE-1)
        CALL DCOPY(ITMP,X(LF+NAT),1,X(LSCR),1)
        CALL DCOPY(ITMP,X(LSCR),1,X(LF),1)
        CALL VCLR(X(LF+ITMP),1,NAT)

        CALL DCOPY(ITMP,X(LNIN+NAT),1,X(LSCR),1)
        CALL DCOPY(ITMP,X(LSCR),1,X(LNIN),1)
        CALL VCLR(X(LNIN+ITMP),1,NAT)

        CALL DCOPY(NSIZE-1,X(LETOT+1),1,X(LSCR),1)
        CALL DCOPY(NSIZE-1,X(LSCR),1,X(LETOT),1)
      END IF

      CALL DCOPY(NAT,VECIN,1,X(LNIN+ITMP),1)
      !! STORE "RESIDUAL" (=ERROR) VECTOR, CHARGE DIFFERENCE IN OTHER WORDS
C     CALL DCOPY(NAT,VECOUT,1,X(LF+ITMP),1)
      DO I = 1, NAT
        X(LF+ITMP+I-1) = VECOUT(I) - VECIN(I)
      END DO
      X(LETOT+NSIZE-1) = ETOT
C
      !! CALCULATE "RESIDUAL" (=ERROR) VECTOR, CHARGE DIFFERENCE IN OTHER WORDS
      CALL VCLR(X(LA),1,NSIZE1*NSIZE1)
      CALL VCLR(X(LB),1,NSIZE1)
      ITMP = 0
      DO I = 1, NSIZE
        DO J = 1, I
          ITMP = ITMP + 1
CEDIIS    IF (NITER.LE.NGEN+1) THEN
CEDIIS      X(LA+ITMP-1) =  X(LETOT+I-1) -
CEDII*        DDOT(NAT,X(LF+(I-1)*NAT+1),1,X(LF+(J-1)*NAT+1),1)
CEDIIS      IF (I.EQ.J) X(LSCR+I-1) = X(LETOT+I-1) - X(LA+ITMP-1)
CEDIIS    ELSE
            X(LA+ITMP-1) =
     *        DDOT(NAT,X(LF+(I-1)*NAT),1,X(LF+(J-1)*NAT),1)
            IF (I.EQ.J) X(LSCR+I-1) = X(LA+ITMP-1)
CEDIIS    END IF
        END DO
      END DO
      DO J = 1, NSIZE
        ITMP = ITMP + 1
        X(LA+ITMP-1) = -1.0D+00 !! K = {(I+1)-1} * NAT = (NSIZE-1)*NAT
      END DO
C     COPY TRIANGLE X(LA) TO SQUARE X(LASQ)
      CALL CPYTSQ(X(LA),X(LASQ),NSIZE1,1)
C
      X(LB+NSIZE  ) = -1.0D+00
C
      !! \SUM_{i}^{m} c_i B_{ki} = LAMBDA
      JOB = 0
      CALL SLVLEQ(X(LASQ),X(LB),IWRK,NSIZE1,NSIZE1,JOB,INFO)
      IF (INFO.NE.0) THEN
        WRITE (*,*)
        WRITE (*,*) "ERROR IN SOLVING DIIS EQUATION"
        WRITE (*,*) "INFO = ", INFO
        WRITE (*,*)
        CALL ABRT
      END IF
C     WRITE (*,*)
C     WRITE (*,*) "X(LB) AFTER SLVLEQ"
C     WRITE (*,'(6(X,F10.5))') X(LB:LB+NSIZE)
C
      CALL DCOPY(NAT,VECOUT,1,VECIN,1)
      CALL VCLR(VECOUT,1,NAT)
      DO I = 1, NSIZE
        K = (I-1) * NAT
        DO J = 1, NAT
          VECOUT(J) = VECOUT(J) + X(LB+I-1)*(X(LF+K+J-1)+X(LNIN+K+J-1))
        END DO
      END DO
C
      ERDIIS = X(LB+NSIZE) !! USE LAMBDA BUT THIS IS NOT DIIS ERROR
C
CEDIISDO I = 1, NSIZE
CEDIIS  ERDIIS = ERDIIS + X(LB+I-1) * X(LSCR+I-1)
CEDIISEND DO
C
C     ADD SIMPLE MIXING IF NITER IS LESS THAN THE SIZE OF DIIS.
C
      IF (NITER.LE.NGEN) THEN
        CALL DAXPY(NAT,ALPHA,X(LF+NAT*(NITER-1)),1,VECOUT,1)
      END IF
C
      CALL RETFM(NEED1)
C
      END SUBROUTINE DFTB_MIX_DIIS
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_MIX_SIMPLE
C>
C>    @brief Charge mixing
C>
C>    @details Simple linear charge mixing
C>             It is the least recommended choice.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NITER Current iteration number
C>    @param NAT Number of atoms
C>           --- OUTPUT ---
C>    @param NEED Memory required by this subroutine
C>    @param VECIN Vector in the old cycle on entry, and the vector
C>           which is NOT extrapolated (interpolated?) vecotr on exit
C>    @param VECOUT Newly calculated vector in the current cycle on
C>           entry, and extrapolated (interpolated?) vector on exit
C>    @param ERDIIS Error of DIIS vector
C>
C
      SUBROUTINE DFTB_MIX_SIMPLE(NITER,NAT,VECIN,VECOUT)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: NITER, NAT
      DOUBLE PRECISION,INTENT(INOUT) :: VECIN(NAT)  !! | n(m)    >
      DOUBLE PRECISION,INTENT(INOUT) :: VECOUT(NAT) !! | n(m)out >
C
      COMMON /DFTBMX/ SIMPLE,ITYPMX,TBROYDEN
      INTEGER :: ITYPMX
      DOUBLE PRECISION :: SIMPLE
      LOGICAL :: TBROYDEN
C
      DOUBLE PRECISION :: QDIFF(NAT)
C
      IF (NITER.EQ.1) RETURN
      !! COPY VECOUT -> QDIFF
      !! CALCULATE: | F(m) > = | n(m)out > - | n(m) >
      !!             QDIFF  = VECOUT + (-1) * VECIN
      !!   CALCULATE: VECIN = VECIN + SIMPLE*QDIFF
      SIMPLE = 0.05D+00
      CALL DCOPY(NAT,VECOUT,1,QDIFF,1)
      CALL DAXPY(NAT,-1.0D+00,VECIN,1,QDIFF,1)
      CALL DAXPY(NAT,SIMPLE,QDIFF,1,VECIN,1)
C
      END SUBROUTINE DFTB_MIX_SIMPLE
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_MIX_BROYDEN
C>
C>    @brief Charge mixing
C>
C>    @details Charge mixing with BROYDEN.  This is the default choice
C>             for DFTB, because this works best to my experience.
C>             For the case of small band gap, DIIS may be good.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NITER Current iteration number
C>    @param NAT Number of atoms
C>    @param MXITER Maximum iteration
C>    @param ALPHA Parameter for simple mixing done in the first cycle
C>           --- OUTPUT ---
C>    @param NEED Memory required by this subroutine
C>    @param VECIN Vector in the old cycle on entry, and the vector
C>           which is NOT extrapolated (interpolated?) vecotr on exit
C>    @param VECOUT Newly calculated vector in the current cycle on
C>           entry, and extrapolated (interpolated?) vector on exit
C>    @param ERDIIS Error of DIIS vector
C>
C
      SUBROUTINE DFTB_MIX_BROYDEN(NITER,NAT,MXITER,NEED,
     *     ALPHA,VECIN,VECOUT,ERDIIS)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION, PARAMETER :: ZERO = 0.0D+00, ONE = 1.0D+00,
     *  W0 = 1.0D-02
C
      INTEGER         , INTENT(IN)    :: NITER, NAT, MXITER
      INTEGER         , INTENT(INOUT) :: NEED
      DOUBLE PRECISION, INTENT(IN)    :: ALPHA
      DOUBLE PRECISION, INTENT(INOUT) :: VECIN(NAT)
      DOUBLE PRECISION, INTENT(INOUT) :: VECOUT(NAT)
      DOUBLE PRECISION, INTENT(OUT)   :: ERDIIS
C
      COMMON /FMCOM / X(1)
      DOUBLE PRECISION :: X
C
      INTEGER          :: I, J, ITMP, ITMP1, ITMP2
      INTEGER          :: LL, LMX1, LMX2, L1, L2, L3, LOADFM,
     *                    LAST, NEEDLOC, INFO, LF, LDQ, LU, LDF,
     *                    LWRK1, LWRK2, LBETA, LBETASQ, LC
      INTEGER          :: IPIV(501)
      INTEGER, SAVE    :: LF_PREV, LQ_PREV, LU_HIST, LDF_HIST, LW, LA
      DOUBLE PRECISION :: DFNORM, DFNORMI, DNRM2, DDOT,
     *                    W, GM, W2, DET(2)
      DOUBLE PRECISION :: XNRM2, XDOT
C
C     ----- BROYDEN'S CHARGE MIXING -----
C     Reference: D. D. Johnson, Phys. Rev. B 1998, 38, 12807.
C
C     VECOUT :: CURRENT CHARGE AFTER SCC ON ENTRY
C               UPDATED CHARGE           ON EXIT
C     VECIN  :: (NUCLEAR CHARGE ON FIRST ITERATION)
C               PREVIOUS UPDATED CHARGE  ON ENTRY
C               CURRENT CHARGE AFTER SCC ON EXIT
C
      IF (NITER.EQ.MXITER) THEN
        WRITE (6,*) " CONVERGENCE IS NOT ACHIEVED WITHIN 200 ITERATIONS"
        WRITE (6,*) " TOO MANY ITERATIONS FOR DFTB_MIX_BROYDEN"
        CALL ABRT
      END IF
C
      IF (NITER.EQ.1) THEN
        LL   = NAT * MXITER
        LMX1 = MXITER
        LMX2 = (LMX1*LMX1+LMX1)/2
C
C     ----- ALLOCATE MEMORY USED DURING SCF CYCLE -----
C
        CALL VALFM(LOADFM)
        LF_PREV  = LOADFM   + 1
        LQ_PREV  = LF_PREV  + NAT
        LU_HIST  = LQ_PREV  + NAT
        LDF_HIST = LU_HIST  + LL
        LW       = LDF_HIST + LL
        LA       = LW       + LMX1
        LAST     = LA       + LMX2 !! LOWER TRIANGLE
        NEED     = LAST - LOADFM - 1
        CALL GETFM(NEED)
C         INITIALIZE
        CALL VCLR(X(LF_PREV) ,1,NAT )
        CALL VCLR(X(LQ_PREV) ,1,NAT )
        CALL VCLR(X(LU_HIST) ,1,LL  )
        CALL VCLR(X(LDF_HIST),1,LL  )
        CALL VCLR(X(LW)      ,1,LMX1)
        CALL VCLR(X(LA)      ,1,LMX2)
C
C       STORE
C         F_PREV (= CHARGE DIFFERENCE, Q(out) - Q(in))
C       WHICH IS JUST THE CHARGE DIFFERENCE OF CURRENT CYCLE.
C       AND, THE INPUT DENTITY FOR Q_PREV.  THIS IS USED IN THE
C       NEXT CYCLE.
C
        CALL DCOPY(NAT,VECOUT,1,X(LF_PREV),1)
        CALL DAXPY(NAT,-ONE,VECIN,1,X(LF_PREV),1)
        CALL DCOPY(NAT,VECIN,1,X(LQ_PREV),1)
C
C       DO SIMPLE MIXING FOR THE FIRST ITERATION, AND RETURN
C
        CALL DCOPY(NAT,VECIN,1,VECOUT,1)
        CALL DAXPY(NAT,ALPHA,X(LF_PREV),1,VECOUT,1)
        RETURN
      END IF
C
C     ----- NITER .GE. 2 -----
C
      L1 = NITER-1
      L2 = (L1*L1+L1)/2
      L3 = L1*L1
      CALL VALFM(LOADFM)
      LF       = LOADFM   + 1
      LDQ      = LF       + NAT  !! PREVIOUS F(m-1) MATRIX
      LU       = LDQ      + NAT  !! | dQ(m-1) > MATRIX
      LDF      = LU       + NAT  !! | u(m-1) > MATRIX
      LWRK1    = LDF      + NAT  !! | dF(m-1) > = | F(m) > - | F(m-1) >
      LWRK2    = LWRK1    + L3
      LBETA    = LWRK2    + NAT
      LC       = LBETA    + L2   !! TRIANGULAR MATRIX FOR BETA
      LBETASQ  = LC       + L1   !! c_k^m MATRIX
      LAST     = LBETASQ  + L3   !! SQUARE MATRIX FOR BETA
      NEEDLOC  = LAST - LOADFM - 1
      CALL GETFM(NEEDLOC)
C
C                    VECIN(I)-X(LQ_PREV+I-1)     = | dQ(m-1) >
      CALL DCOPY(NAT,VECIN,1,X(LDQ),1)
      CALL DAXPY(NAT,-ONE,X(LQ_PREV),1,X(LDQ),1)
C        X(LF+I-1) = VECOUT(I) - VECIN(I)        = | F(m) >
      CALL DCOPY(NAT,VECOUT,1,X(LF),1)
      CALL DAXPY(NAT,-ONE,VECIN,1,X(LF),1)
C        X(LDF+I-1) = X(LF+I-1) - X(LF_PREV+I-1) = | dF(m-1) >
      CALL DCOPY(NAT,X(LF),1,X(LDF),1)
      CALL DAXPY(NAT,-ONE,X(LF_PREV),1,X(LDF),1)
C
C     ----- NORMALIZE | dF(m-1) > AND MAKE | u(m-1) > MATRIX -----
C
      DFNORM  = DNRM2(NAT,X(LDF),1)
      IF (DFNORM.EQ.ZERO) THEN !! CONVERGED
        CALL RETFM(NEEDLOC)
        RETURN
      END IF
      DFNORMI = ONE / DFNORM
C        X(LU) = X(LDQ) + ALPHA*X(LDF)
C        | u > = G(1) * | dF > + | dQ >
      CALL DCOPY(NAT,X(LDQ),1,X(LU),1)
      CALL DAXPY(NAT,ALPHA,X(LDF),1,X(LU),1)
C
      CALL DSCAL(NAT,DFNORMI,X(LU) ,1) !! FINALIZE  | u  >
      CALL DSCAL(NAT,DFNORMI,X(LDF),1) !! NORMALIZE | dF >
C
C     ----- SAVE | u > AND | dF > MATRICES GROBALLY -----
C
      ITMP = NAT*(NITER-2)
      CALL DCOPY(NAT,X(LU),1,X(LU_HIST+ITMP),1)
      CALL DCOPY(NAT,X(LDF),1,X(LDF_HIST+ITMP),1)
C
C     ----- SAVE CURRENT | F > AND q_in FOR NEXT CYCLE -----
C
      CALL DCOPY(NAT,X(LF),1,X(LF_PREV),1)
      CALL DCOPY(NAT,VECIN,1,X(LQ_PREV),1)
C
C     ----- CONSTRUCT a_{ij} and c_k^m MATRIX -----
C     The paper has a typo in Eq. (13a)
C
      IF (NITER.GE.3) THEN
        ITMP1 = (NITER-2)*(NITER-1)/2
        DO I = 1, NITER-2
          ITMP = NAT*(I-1)
          CALL DCOPY(NAT,X(LDF_HIST+ITMP),1,X(LWRK2),1)
C
          ITMP2 = ITMP1 + I
          !! EQ. (13a) W/O w COEFF.
          X(LA+ITMP2-1) = DDOT(NAT,X(LWRK2),1,X(LDF),1)
          !! EQ. (15b) W/O w COEFF.
          X(LC+I-1)     = DDOT(NAT,X(LWRK2),1,X(LF),1)
        END DO
      END IF
C     !! FILL FOR (NITER-1)-TH CYCLE
      ITMP = (NITER-1)*NITER/2
      X(LA+ITMP-1)  = ONE
      X(LC+NITER-2) = DDOT(NAT,X(LDF),1,X(LF),1)
C
C     ----- DETERMINE w -----
C
      W = DNRM2(NAT,X(LF),1)
      IF (W.GT.1.0D-07) THEN
        W = 1.0D-02 / W
      ELSE
        W = 1.0D+05
      END IF
C
      IF (W.LT.ONE) W = ONE
      X(LW+NITER-2) = W !! PUT INTO W(NITER-1)
C
C     ----- CONSTRUCT (w0*E + a_{ij}) MATRIX ----- EQ.(13a)
C     X(LA) :: SYMMETRIC
C     X(LBETA) :: SYMMETRIC -> X(LBETASQ) :: SQUARE
C
C  MAYBE LBETA CAN BE PUT GROBALLY?
C
      ITMP = 0
      W2   = W0*W0
      DO I = 1, NITER-1
        DO J = 1, I
          ITMP = ITMP + 1
          X(LBETA+ITMP-1) = X(LA+ITMP-1) * X(LW+I-1) * X(LW+J-1)
          IF (I.EQ.J) X(LBETA+ITMP-1) = X(LBETA+ITMP-1) + W2
        END DO
      END DO
C
C     ----- CALCULATE BETA MATRIX ----- Eq.(13a)
C
      CALL CPYTSQ(X(LBETA),X(LBETASQ),L1,1)
      CALL DGEFA(X(LBETASQ),L1,L1,IPIV,INFO)
CMKL  CALL DGETRF(L1,L1,X(LBETASQ),L1,IPIV,INFO)
      IF (INFO.NE.0) THEN
        WRITE (*,*)
        WRITE (*,*) "ERROR IN LU FACTORIZATION"
        WRITE (*,*) "INFO = ", INFO
        WRITE (*,*)
        CALL ABRT
      END IF
C
      INFO = 1
      CALL DGEDI(X(LBETASQ),L1,L1,IPIV,DET,X(LWRK1),INFO)
CMKL  CALL DGETRI(L1,X(LBETASQ),L1,IPIV,X(LWRK1),
CMKL *            L3,INFO)
CMKL  IF (INFO.NE.0) THEN
CMKL    WRITE (*,*)
CMKL    WRITE (*,*) "ERROR IN SOLVING BETA INVERSE"
CMKL    WRITE (*,*) "INFO = ", INFO
CMKL    WRITE (*,*)
CMKL    CALL ABRT
CMKL  END IF
C
      CALL DCOPY(NAT,VECOUT,1,VECIN,1)
C
C     ----- CALCULATE NEXT CHARGE -----
C
      !! | n(m) > + G(1) | F(m) >
      CALL DCOPY(NAT,X(LQ_PREV),1,VECOUT,1)
      CALL DAXPY(NAT,ALPHA,X(LF),1,VECOUT,1)
      DO I = 1, NITER-1
        ITMP = NAT*(I-1)
        CALL DCOPY(NAT,X(LU_HIST+ITMP),1,X(LU),1)
        ITMP = (NITER-1)*(I-1)
        CALL DCOPY(NITER-1,X(LBETASQ+ITMP),1,X(LWRK1),1)
        GM = 0.0D+00
        DO J = 1, NITER-1
          GM = GM + X(LC+J-1)*X(LWRK1+J-1)*X(LW+J-1) !! EQ.(15b)
        END DO
        CALL DAXPY(NAT,-GM*X(LW+I-1),X(LU),1,VECOUT,1) !! EQ.(15a)
      END DO
C
      ERDIIS = DFNORM !! IT IS NOT CORRECT
C
      CALL RETFM(NEEDLOC)
C
      RETURN
C
      END SUBROUTINE DFTB_MIX_BROYDEN
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_DISP
C>
C>    @brief Dispersion correction of DFTB
C>
C>    @details Calculate dispersion correction energy of DFTB.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Added Slater-Kirkwoor (Hybrid-polarized)
C>
C>           --- INPUT ---
C>    @param ZREF Nuclear charges of a given atom.  In FMO-DFTB, ZREF
C>           of BDA or BAA is differet from QREF
C>    @param QREF Nuclear charges of a given species.  This is taken
C>           from Slater-Koster files
C>    @param DISTMAT Matrix of inter-atomic distances
C>           --- OUTPUT ---
C>    @param EDISP Dispersion correction energy
C>
C
      SUBROUTINE DFTB_DISP(QREF,DISTMAT,EDISP,IWRK)
C
      IMPLICIT NONE
C
      INTEGER,PARAMETER :: MXATM=2000,MXSPE=10
      DOUBLE PRECISION, PARAMETER :: TWO=2.0D+00
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     &                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      INTEGER :: NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      DOUBLE PRECISION :: ZAN,C
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      DOUBLE PRECISION :: ETEMP,DFTBDP,DAMPXHE,HUBDER,ZREF,SPNCST,SPE
      INTEGER :: NSPE,MAXANG,ISPE,IND,IDFTBD
C
      INTEGER :: I,J,NSP1,NSP2,NSEQ
      DOUBLE PRECISION :: R5,R6,R10,R12,C0,C1,C2,CR0,RI,RJ,DI,DJ,DIST,
     * RIJ,DIJ,R0,TMP,RDMAT(3,NSPE,NSPE),CI,CJ,C6A,C6B,C6AB,R0A,R0B,
     * R0AB,NEA,PA,NEB,PB,R0AB7I,DISTI,DIST6I,DAMP1,DAMP4,
     * VEXP,DIST7
      DOUBLE PRECISION, INTENT(IN) :: QREF(*),DISTMAT(*)
      DOUBLE PRECISION, INTENT(OUT) :: EDISP
      INTEGER, INTENT(INOUT) :: IWRK(*)
C
      NSP1 = 0
      NSP2 = 0
      EDISP = 0.0D+00
      IF (IDFTBD.EQ.1) THEN
        C0 = 1.584D+01 !! 396/25
        C1 = 4.78947150872246D+01 !! 2^(5/6)*672/25
        C2 = 3.50498152274578D+01 !! 2^(2/3)*552/25
        CR0 = 8.908987181D-01
        !! FIRST CALCULATE SOME CONSTANTS FOR ALL PAIRS OF SPECIES
        DO I = 1, NSPE
          RI = DFTBDP(I*2-1)
          DI = DFTBDP(I*2  )
          DO J = I, NSPE
            RJ = DFTBDP(J*2-1)
            DJ = DFTBDP(J*2  )
            RIJ = SQRT(RI*RJ) !! van der Waals distance
            DIJ = SQRT(DI*DJ) !! well depth
            R0 = CR0*RIJ
            RDMAT(1,I,J) = R0
            RDMAT(2,I,J) = RIJ
            RDMAT(3,I,J) = DIJ
            RDMAT(1,J,I) = R0
            RDMAT(2,J,I) = RIJ
            RDMAT(3,J,I) = DIJ
          END DO
        END DO
        !! CALCULATE DISPERSION CORRECTION
        DO I = 1, NAT
          NSP1 = ISPE(I)
          CI = ZREF(I)/QREF(NSP1)
          DO J = I+1, NAT
            NSP2 = ISPE(J)
            CJ = ZREF(J)/QREF(NSP2)
            R0  = RDMAT(1,NSP1,NSP2)
            RIJ = RDMAT(2,NSP1,NSP2)
            DIJ = RDMAT(3,NSP1,NSP2)
            CALL DFTB_CNVSQ(I,J,NSEQ)
            DIST = DISTMAT(NSEQ)
            DIJ = DIJ * CI * CJ
            IF (DIST.GE.R0) THEN !! ATTRACTIVE POTENTIAL
              TMP = RIJ/DIST
              R6 = TMP**6
              R12 = R6**2
              TMP = DIJ*(-TWO*R6+R12)
            ELSE !! REPULSIVE POTENTIAL
              TMP = DIST/RIJ
              R5 = TMP**5
              R10 = R5**2
              TMP = DIJ*(C0-C1*R5+C2*R10)
            END IF
            EDISP = EDISP + TMP
          END DO
        END DO
      ELSE IF (IDFTBD.EQ.2) THEN
        !! FIRST CALCULATE SOME CONSTANTS FOR ALL PAIRS OF SPECIES
        DO I = 1, NSPE
          PA  = DFTBDP(I*3-2)
          R0A = DFTBDP(I*3-1)
          NEA = DFTBDP(I*3  )
          C6A = 7.5D-01*SQRT(NEA*PA*PA*PA)
          DO J = I, NSPE
            PB  = DFTBDP(J*3-2)
            R0B = DFTBDP(J*3-1)
            NEB = DFTBDP(J*3  )
            C6B = 7.5D-01*SQRT(NEB*PB*PB*PB)
C
            C6AB = (2.0D+00*C6A*C6B*PA*PB) / (PA*PA*C6B+PB*PB*C6A)
            R0AB = (R0A**3 + R0B**3) / (R0A**2 + R0B**2)
            R0AB7I = 1.0D+00 / R0AB**7
            RDMAT(1,I,J) = C6AB
            RDMAT(2,I,J) = R0AB7I
            RDMAT(1,J,I) = C6AB
            RDMAT(2,J,I) = R0AB7I
          END DO
        END DO
C       MEMO :: LATENCY AND THROUGHPUT
C       VDIVPD  : 45- 44 clocks (/)
C       VMULPD  :  5-  1 clocks (*)
C       VADDPD  :  3-  1 clocks (+)
C       VSUBPD  :  3-  1 clocks (-)
C       VRCPPS  :  7-  1 clocks (inverse)
C       VSQRTPD : 45- 44 clocks (SQRT)
        !! CALCULATE DISPERSION CORRECTION
        DO I = 1, NAT
          NSP1 = ISPE(I)
          CI = ZREF(I)/QREF(NSP1)
          DO J = I+1, NAT
            NSP2 = ISPE(J)
            CJ = ZREF(J)/QREF(NSP2)
            C6AB   = RDMAT(1,NSP1,NSP2)
            R0AB7I = RDMAT(2,NSP1,NSP2)
            CALL DFTB_CNVSQ(I,J,NSEQ)
            DIST = DISTMAT(NSEQ)
            C6AB = C6AB * CI * CJ
            DISTI = 1.0D+00 / DIST
            DIST6I = DISTI**6
            DIST7  = DIST**7
            VEXP = EXP(-3.0D+00*R0AB7I*DIST7)
            DAMP1 = 1.0D+00 - VEXP
            DAMP4 = DAMP1**4 !! THIS IS THE DAMPING FUNCTION (f(R))
            TMP = -1.0D+00 * DAMP4 * C6AB * DIST6I
            EDISP = EDISP + TMP
          END DO
        END DO
      ELSE IF (IDFTBD.EQ.4) THEN
        IF (IWRK(NAT+1).EQ.0) THEN
          !! COUNT NUMBER OF BONDS FOR ALL ATOMS
          CALL VICLR(IWRK,1,NAT)
          NSEQ = 0
          DO I = 1, NAT
            NSP1 = ISPE(I)
            R0A = DFTBDP(NSP1*14-13) !! COVALENT RADIUS
            DO J = 1, I-1
              NSP2 = ISPE(J)
              R0B = DFTBDP(NSP2*14-13)
              NSEQ = NSEQ + 1
              DIST = DISTMAT(NSEQ)
              IF (DIST.LT.(R0A+R0B)) THEN
                IWRK(I) = IWRK(I) + 1
                IWRK(J) = IWRK(J) + 1
              END IF
            END DO
            NSEQ = NSEQ + 1 !! SKIP THE INDEX FOR SAME ATOM
          END DO
          DO I = 1, NAT
            IF (IWRK(I).GT.5) IWRK(I) = 5 !! MAX NEIGHBORS SHOULD BE 5
          END DO
        END IF
        !! SKIP PREPARATION OF SOME CONSTANTS
        !! CALCULATE DISPERSION CORRECTION
        NSEQ = 0
        DO I = 1, NAT
          NSP1 = ISPE(I)
          PA   = DFTBDP(NSP1*14-12+IWRK(I))
          R0A  = DFTBDP(NSP1*14- 6+IWRK(I))
          NEA  = DFTBDP(NSP1*14)
          C6A  = 7.5D-01*SQRT(NEA*PA*PA*PA)
          CI   = ZREF(I)/QREF(NSP1)
          DO J = 1, I-1
            NSP2 = ISPE(J)
            PB   = DFTBDP(NSP2*14-12+IWRK(J))
            R0B  = DFTBDP(NSP2*14- 6+IWRK(J))
            NEB  = DFTBDP(NSP2*14)
            C6B  = 7.5D-01*SQRT(NEB*PB*PB*PB)
            CJ   = ZREF(J)/QREF(NSP2)
            C6AB = (2.0D+00*C6A*C6B*PA*PB) / (PA*PA*C6B+PB*PB*C6A)
            R0AB = (R0A**3 + R0B**3) / (R0A**2 + R0B**2)
            R0AB7I = 1.0D+00 / R0AB**7
            NSEQ = NSEQ + 1
            DIST = DISTMAT(NSEQ)
            C6AB = C6AB * CI * CJ
            DISTI = 1.0D+00 / DIST
            DIST6I = DISTI**6
            DIST7  = DIST**7
            VEXP = EXP(-3.0D+00*R0AB7I*DIST7)
            DAMP1 = 1.0D+00 - VEXP
            DAMP4 = DAMP1**4 !! THIS IS THE DAMPING FUNCTION (f(R))
            TMP = -1.0D+00 * DAMP4 * C6AB * DIST6I
            EDISP = EDISP + TMP
          END DO
          NSEQ = NSEQ + 1
        END DO
      END IF
C
      END SUBROUTINE DFTB_DISP
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_GAMMA3
C>
C>    @brief Calculate DFTB3 gamma
C>
C>    @details Calculate DFTB3 gamma
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - SRSCC is possible?
C>
C>           --- INPUT ---
C>    @param NAT     Number of atoms
C>    @param C       Coordinates
C>    @param HUBL    Shell-resolved Hubbard values
C>    @param DISTMAT Array of inter-atomic distance
C>           --- OUTPUT ---
C>    @param GAMMA3  DFTB3 gamma
C>
C
      SUBROUTINE DFTB_GAMMA3(NAT,HUBBL,GAMMA3,DISTMAT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB,HDAMP
C
      PARAMETER (MXATM=2000,MXSPE=10,MXGTOT=20000,MXSH=5000)
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /FMCOM / X(1)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
      DIMENSION HUBBL(3,NSPE),DISTMAT(*),GAMMA3(*),ISHELL(NSHELL)
      DOUBLE PRECISION H/8HH       /
C
C     CALCULATE THE CAPITAL GAMMA VALUES
C
      IF (SRSCC) THEN
        NNN = 0
        DO I = 1, NSPE
          NNN = NNN + MAXANG(I)
        END DO
      ELSE
        NNN = NSPE
      END IF
      CALL VALFM(LOADFM)
      LTMP     = LOADFM  + 1
      LAST     = LTMP    + 8*NNN*NNN
      IF (SRSCC) THEN
        LINDTMP= LAST
        LAST   = LINDTMP + NAT+1
      END IF
      NEED     = LAST  - LOADFM - 1
      CALL GETFM(NEED)
C
      IF (SRSCC) THEN
        CALL DCOPY(NAT+1,IND,1,X(LINDTMP),1)
        IND(1) = 0
        DO I = 2, NSPE
          IND(I) = IND(I-1) + MAXANG(I-1)
        END DO
        ISH = 0
        JSH = 0
        DO I = 1, NAT
          JSH = IND(ISPE(I))
          DO J = 1, MAXANG(ISPE(I))
            ISH = ISH + 1
            ISHELL(ISH) = JSH + J
          END DO
        END DO
        ISH = 0
        DO I = 1, NSPE
          DO II = 1, MAXANG(I)
            ISH = ISH + 1
            HUBA = HUBBL(II,I)
            JSH = 0
            DO J = 1, NSPE
              DO JJ = 1, MAXANG(J)
                JSH = JSH + 1
                HUBB = HUBBL(JJ,J)
                CALL DFTB_PREP_GAMMA3(HUBA,HUBB,
     *            X(LTMP + 8*(ISH-1) + 8*NNN*(JSH-1)))
              END DO
            END DO
          END DO
        END DO
        CALL DCOPY(NAT+1,X(LINDTMP),1,IND,1)
C
        ISH0 = 0
        DO I = 1, NAT
          CHARA1 = SPE(ISPE(I))
          JSH0 = 0
          DO J = 1, I
            CHARA2 = SPE(ISPE(J))
            CALL DFTB_CNVSQ(I,J,NSEQ)
            DIST = DISTMAT(NSEQ)
            IF (DAMPXH.AND.(CHARA1.EQ.H.OR.CHARA2.EQ.H)) THEN
              HDAMP = .TRUE.
            ELSE
              HDAMP = .FALSE.
            END IF
            DO II = 1, MAXANG(ISPE(I))
              ISH = ISH0 + II
              HUBA = HUBBL(II,ISPE(I))
              NSP1 = ISHELL(ISH)
              HUBDER1 = HUBDER(NSP1)
              DO JJ = 1, MAXANG(ISPE(J))
                JSH = JSH0 + JJ
                HUBB = HUBBL(JJ,ISPE(J))
                NSP2 = ISHELL(JSH)
                HUBDER2 = HUBDER(NSP2)
                CALL DFTB_GAMMA3F(GAMMA3(ISH+NSHELL*(JSH-1)),
     *               GAMMA3(JSH+NSHELL*(ISH-1)),
     *               HUBA,HUBB,HUBDER1,HUBDER2,DIST,DAMPXHE,
     *               X(LTMP+8*(NSP1-1)+8*NNN*(NSP2-1)),
     *               X(LTMP+8*(NSP2-1)+8*NNN*(NSP1-1)),HDAMP)
C         WRITE (*,*) Ish, Jsh, GAMMA3(ish+nshell*(JSH-1))
C         WRITE (*,*) Jsh, Ish, GAMMA3(jsh+NSHELL*(ISH-1))
                IF (I.EQ.J.AND.II.EQ.JJ) EXIT
              END DO
            END DO
            JSH0 = JSH0 + MAXANG(ISPE(J))
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(I))
        END DO
      ELSE
        DO I = 1, NSPE
          HUBA  = HUBBL(1,I)
          DO J = 1, NSPE
            HUBB = HUBBL(1,J)
            CALL DFTB_PREP_GAMMA3(HUBA,HUBB,
     *        X(LTMP + 8*(I-1) + 8*NNN*(J-1)))
          END DO
        END DO
C
        DO I = 1, NAT
          NSP1 = ISPE(I)
          HUBA = HUBBL(1,NSP1)
          CHARA1 = SPE(ISPE(I))
          HUBDER1 = HUBDER(NSP1)
          DO J = 1, I
            NSP2 = ISPE(J)
            HUBB = HUBBL(1,NSP2)
            CHARA2 = SPE(ISPE(J))
            HUBDER2 = HUBDER(NSP2)
            CALL DFTB_CNVSQ(I,J,NSEQ)
            DIST = DISTMAT(NSEQ)
            IF (DAMPXH.AND.(CHARA1.EQ.H.OR.CHARA2.EQ.H)) THEN
              HDAMP = .TRUE.
            ELSE
              HDAMP = .FALSE.
            END IF
            CALL DFTB_GAMMA3F(GAMMA3(I+NAT*(J-1)),GAMMA3(J+NAT*(I-1)),
     *           HUBA,HUBB,HUBDER1,HUBDER2,DIST,DAMPXHE,
     *           X(LTMP+8*(NSP1-1)+8*NNN*(NSP2-1)),
     *           X(LTMP+8*(NSP2-1)+8*NNN*(NSP1-1)),HDAMP)
C           WRITE (*,*) I, J, GAMMA3(i+nat*(J-1))
C           WRITE (*,*) J, I, GAMMA3(J+NAT*(I-1))
          END DO
        END DO
      END IF
C
      CALL RETFM(NEED)
C
      RETURN
C
      END SUBROUTINE DFTB_GAMMA3
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_PREP_GAMMA3
C>
C>    @brief Calculate DFTB3 gamma
C>
C>    @details Prepare some constants for gamma calculation
C>
C>    @author Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param HUBA Hubbard value of atom A
C>    @param HUBB Hubbard value of atom B
C>           --- OUTPUT ---
C>    @param TMP  Some constants used later
C>
C
      SUBROUTINE DFTB_PREP_GAMMA3(HUBA,HUBB,TMP)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (HUBTOL=1.0D-04,ONE=1.0D+00,TWO=2.0D+00,THREE=3.0D+00,
     * HALF=5.0D-01,ZERO=0.0D+00,ONE_48=ONE/4.8D+01)
C
      DIMENSION TMP(8)
C
      TAUA  = 3.2D+00*HUBA
      TAUA2 = TAUA*TAUA
      TAUA3 = TAUA*TAUA2
      TAUA4 = TAUA2*TAUA2
      TAUA6 = TAUA2*TAUA4
      TAUB  = 3.2D+00*HUBB
      TAUB2 = TAUB*TAUB
      TAUB3 = TAUB*TAUB2
      TAUB4 = TAUB2*TAUB2
      TAUB6 = TAUB2*TAUB4
      IF (ABS(HUBA-HUBB).LE.HUBTOL) THEN
        TMP(1) = -3.125D-01
        TMP(2) = -3.125D-01*TAUA
        TMP(3) = -1.25D-01*TAUA2
        TMP(4) = -ONE_48*TAUA3
        TMP(5) = 6.875D-01*TAUA
        TMP(6) = 1.875D-01*TAUA2
        TMP(7) = ONE_48*TAUA3
        TMP(8) = ZERO
      ELSE
        TAUAB = TAUA2 - TAUB2
        TAUABI = ONE/TAUAB
        TAUABI2 = TAUABI*TAUABI
        TAUABI3 = TAUABI*TAUABI2
        TAUABI4 = TAUABI2*TAUABI2
        TMP(1) = -HALF*(TAUB6+THREE*TAUA2*TAUB4)*TAUABI3
        TMP(2) = -1.2D+01*TAUB4*TAUA3*TAUABI4
        TMP(3) = HALF*TAUA*TAUB4*TAUABI2
        TMP(4) = -(TAUB6-THREE*TAUA2*TAUB4)*TAUABI3
        TMP(5) = -TWO*TAUA3*TAUB3*TAUABI3
        TMP(6) = 1.2D+01*TAUB4*TAUA3*TAUABI4
        TMP(7) = HALF*TAUB*TAUA4*TAUABI2
        TMP(8) = (TAUA6-THREE*TAUB2*TAUA4)*TAUABI3
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_PREP_GAMMA3
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_GAMMA3F
C>
C>    @brief Calculate DFTB3 gamma
C>
C>    @details Actual function that calculates DFTB3 gamma
C>
C>    @author Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param HUBA    Hubbard value of atom A
C>    @param HUBB    Hubbard value of atom B
C>    @param DUDQ1   Hubbard derivative of atom A
C>    @param DUDQ2   Hubbard derivative of atom B
C>    @param DIST    Distance betwee A-B
C>    @param DAMPXHE Damping exponent
C>    @param TMP1    "Some constants" of atom pair A-B
C>    @param TMP2    "Some constants" of atom pair B-A
C>    @param HDAMP   Damping is applied or not
C>           --- OUTPUT ---
C>    @param GAM3I   \Gamma_{AB}
C>    @param GAM3J   \Gamma_{BA}
C>
C
      SUBROUTINE DFTB_GAMMA3F(GAM3I,GAM3J,HUBA,HUBB,DUDQ1,DUDQ2,
     *  DIST,DAMPXHE,TMP1,TMP2,HDAMP)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (HUBTOL=1.0D-04,DISTTOL=1.0D-08,ONE=1.0D+00,
     * HALF=5.0D-01,ZERO=0.0D+00,TWO=2.0D+00,THREE=3.0D+00)
C
      DIMENSION TMP1(8),TMP2(8)
      LOGICAL HDAMP
C
      TAUA = 3.2D+00*HUBA
      TAUB = 3.2D+00*HUBB
      EXPH = ONE
      SAB = ZERO
      SBA = ZERO
      DH_DU = ZERO
c     CALL DFTB_CNVSQ(I,J,NSEQ)
      IF (DIST.LE.DISTTOL) THEN
        IF (ABS(HUBA-HUBB).LE.HUBTOL) THEN
          GAM3I = DUDQ1*HALF
          GAM3J = DUDQ2*HALF
        ELSE
          TAUABI= ONE/(TAUA+TAUB)
          TAUA  = TAUA*TAUABI
          TAUB  = TAUB*TAUABI
          GAM3I = DUDQ1*1.6D+00*(TAUB
     *          - TAUA*TAUB
     *          + TWO*TAUA*TAUB*TAUB
     *          - THREE*TAUA*TAUA*TAUB*TAUB)
          GAM3J = DUDQ2*1.6D+00*(TAUA
     *          - TAUA*TAUB
     *          + TWO*TAUB*TAUA*TAUA
     *          - THREE*TAUA*TAUA*TAUB*TAUB)
        END IF
      ELSE
        EXPA = EXP(-TAUA*DIST)
        IF (ABS(HUBA-HUBB).LE.HUBTOL) THEN
          !! DS^g/Da
          DIST2 = DIST**2
          DIST3 = DIST2*DIST
          DSAB_DR = EXPA*(TMP1(1)+TMP1(2)*DIST
     *      + TMP1(3)*DIST2+TMP1(4)*DIST3)
          IF (HDAMP) THEN
            DISTI = ONE/DIST
            HUBMEAN = HALF*(HUBA+HUBB)
            HUBMEANEXP1 = HUBMEAN**(DAMPXHE-ONE)
            HUBMEANEXP = HUBMEANEXP1*HUBMEAN
            EXPH = EXP(-(HUBMEAN**DAMPXHE)*DIST2)
            SAB = EXPA * (DISTI + TMP1(5) +
     `        TMP1(6)*DIST + TMP1(7)*DIST2)
            DH_DU = -DIST2*DAMPXHE*HUBMEANEXP1*EXPH*HALF
          END IF
          GAM3I = -(DSAB_DR*EXPH*3.2D+00+SAB*DH_DU)*DUDQ1
          GAM3J = GAM3I
        ELSE
          EXPB = EXP(-TAUB*DIST)
          DISTI = ONE/DIST
          !! DS^f/Da
          DFAB_DA = TMP1(1)+TMP1(2)*DISTI
          FAB     = TMP1(3)+TMP1(4)*DISTI
          DFBA_DA = TMP1(5)+TMP1(6)*DISTI
          FBA     = TMP1(7)+TMP1(8)*DISTI
          DFAB_DB = TMP2(5)+TMP2(6)*DISTI
          DFBA_DB = TMP2(1)+TMP2(2)*DISTI
          DSAB_DR = EXPA*(DFAB_DA-DIST*FAB)+EXPB*DFBA_DA
          DSBA_DR = EXPB*(DFBA_DB-DIST*FBA)+EXPA*DFAB_DB
          IF (HDAMP) THEN
            DIST2 = DIST**2
            HUBMEAN = HALF*(HUBA+HUBB)
            HUBMEANEXP1 = HUBMEAN**(DAMPXHE-ONE)
            HUBMEANEXP = HUBMEANEXP1*HUBMEAN
            EXPH = EXP(-HUBMEANEXP*DIST2)
            SAB = EXPA*FAB + EXPB*FBA
            SBA = SAB
            DH_DU = -DIST2*DAMPXHE*HUBMEANEXP1*EXPH*HALF
          END IF
          GAM3I = -(DSAB_DR*EXPH*3.2D+00+SAB*DH_DU)*DUDQ1
          GAM3J = -(DSBA_DR*EXPH*3.2D+00+SBA*DH_DU)*DUDQ2
        END IF
      END IF
C     WRITE (*,*) I, J, GAMMA(I,J)
C     WRITE (*,*) J, I, GAMMA(J,I)
C
      RETURN
C
      END SUBROUTINE DFTB_GAMMA3F
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_LRSHIFT
C>
C>    @brief Long-Range DFTB
C>
C>    @details Calculate shift contribution in Long-Range DFTB
C>             This is completely experimental, and I even don't use it.
C>             See the reference:
C>               Niehaus, T. A; Sala, F. D. Phys. Status Solidi B
C>               2012, 249, 237-244.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param L1 Number of basis functions
C>    @param NAT Number of atoms
C>    @param GAMMA DFTB2 gamma
C>    @param S Overlap matrix in AO basis
C>    @param P Density matrix in AO basis
C>    @param MULA Atom-resolved Mulliken populations
C>    @param MULAO AO-resolved Mulliken populations
C>    @param ELR ?
C>           --- OUTPUT ---
C>    @param FAO Fock (Hamilton) matrix in AO basis
C>
C
      SUBROUTINE DFTB_LRSHIFT(L1,NAT,GAMMA,FAO,S,P,MULAO,ELR)
C
      IMPLICIT NONE
C
      INTEGER,PARAMETER :: MXATM=2000,MXSPE=10
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      DOUBLE PRECISION :: ETEMP,DFTBDP,DAMPXHE,HUBDER,ZREF,SPNCST,SPE
      INTEGER :: NSPE,MAXANG,ISPE,IND,IDFTBD
C
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
      DOUBLE PRECISION SKDIM,SKSPIN,QREFL,HUBBL,QREF,HUBB,SKCUT2
      INTEGER NEEDSK,LSKHTAB,LSKSTAB,LSKGRID,LSKSELF
C
      INTEGER :: L1,NAT
      DOUBLE PRECISION :: GAMMA(*),FAO(*),S(*),P(*),MULAO(*),
     * FAOTMP(L1*(L1+1)/2),ELR
      INTEGER :: I,J,K,L,M,N,II,JJ,KK,LL,MM,NN,NSEQ,IIND(L1),L2
      DOUBLE PRECISION :: ONE_EIGHT,SHIFT,ST1,ST2,G1,G2,G3,G4,DP,TMP,
     * MUL(L1),GTMP,MULTMP,T0,T1,T2,T3
C
C---  CALL CPU_TIME(T0)
      ONE_EIGHT = 1.0D+00/8.0D+00
      N = 0
      L2 = L1*(L1+1)/2
      CALL DCOPY(L2,FAO,1,FAOTMP,1)
      CALL VCLR(MUL,1,L1)
      DO I = 1, NAT
        DO J = 1,MAXANG(ISPE(I))**2
          N = N + 1
          IIND(N) = I
          MUL(I) = MUL(I) + MULAO(N)
        END DO
      END DO
C---  CALL CPU_TIME(T1)
C
      DO I = 1, NAT
        DO J = 1, I
          NSEQ = I*(I-1)/2 + J
          G3 = GAMMA(NSEQ)
          DO K = 1, MAXANG(ISPE(I))**2
            M = IND(I)+K !! mu
            DO L = 1, MAXANG(ISPE(J))**2
              N = IND(J)+L !! nu
              SHIFT = 0.0D+00
              DO II = 1, NAT
                MULTMP = QREF(ISPE(II))/MUL(II)
                CALL DFTB_CNVSQ(II,J,NSEQ)
                G4 = GAMMA(NSEQ)
                DO JJ = 1, NAT
                  CALL DFTB_CNVSQ(I,JJ,NSEQ)
                  G1 = GAMMA(NSEQ)
                  CALL DFTB_CNVSQ(II,JJ,NSEQ)
                  G2 = GAMMA(NSEQ)
                  GTMP = (G1+G2+G3+G4)*G3
                  DO KK = 1, MAXANG(ISPE(II))**2
                    MM = IND(II)+KK !! a
                    CALL DFTB_CNVSQ(M,MM,NSEQ)
                    ST1 = S(NSEQ)
                    DO LL = 1, MAXANG(ISPE(JJ))**2
                      NN = IND(JJ)+LL !! b
                      CALL DFTB_CNVSQ(NN,N,NSEQ)
                      ST2 = S(NSEQ)
                      CALL DFTB_CNVSQ(MM,NN,NSEQ)
                      IF (MM.EQ.NN) THEN
                        IF (QREF(ISPE(II)).EQ.1.0D+00) THEN
                          DP = P(NSEQ) - QREF(ISPE(II))
                        ELSE
                          TMP = MULAO(MM)*MULTMP
                          DP = P(NSEQ) - TMP
                        END IF
                      ELSE
                        DP = P(NSEQ)
                      END IF
                      SHIFT = SHIFT + ST1*ST2*DP*GTMP
                    END DO
                  END DO
                END DO
              END DO
              CALL DFTB_CNVSQ(M,N,NSEQ)
              FAO(NSEQ) = FAO(NSEQ)-ONE_EIGHT*SHIFT
            END DO
          END DO
        END DO
      END DO
C---  CALL CPU_TIME(T2)
C
      DO I = 1, L2
        FAOTMP(I) = FAO(I) - FAOTMP(I)
      END DO
      SHIFT = 0.0D+00
      DO II = 1, L1
        MULTMP = QREF(ISPE(II))/MUL(II)
        DO JJ = 1, L1
          CALL DFTB_CNVSQ(II,JJ,NSEQ)
          IF (II.EQ.JJ) THEN
            IF (QREF(ISPE(IIND(II))).EQ.1.0D+00) THEN
              TMP = 1.0D+00
              DP = P(NSEQ) - QREF(ISPE(IIND(II)))
            ELSE
              TMP = MULTMP
              DP = P(NSEQ) - TMP
            END IF
          ELSE
            DP = P(NSEQ)
          END IF
          SHIFT = SHIFT + FAOTMP(NSEQ)*DP
        END DO
      END DO
      ELR = 0.5D+00*SHIFT
C---  CALL CPU_TIME(T3)
C---  WRITE (*,'(" CPU TIME IN DFTB_LRSHIFT, PREP        = ",F8.4)')
C--- + T1-T0
C---  WRITE (*,'(" CPU TIME IN DFTB_LRSHIFT, HAMILTONIAN = ",F8.4)')
C--- + T2-T1
C---  WRITE (*,'(" CPU TIME IN DFTB_LRSHIFT, ENERGY      = ",F8.4)')
C--- + T3-T2
C     WRITE (*,*) "ELR = ", ELR
C     CALL PRTRIL(FAOTMP,L1)
C     call abrt
C
      END SUBROUTINE DFTB_LRSHIFT
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_EPOTEN
C>
C>    @brief DFTB/PCM
C>
C>    @details This is a bypass of EPOTEN subroutine to compute the
C>             the electrostatic potential of each tessera.
C>             Since DFTB cannot calculate ordinary integrals, ESP
C>             calculated here is a simple classical ESP, that is
C>             qu*qv/r_{12} where qu and qv are charges of a solvent
C>             atom and a solute (tessera).  Error function can be used?
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- (Preliminary) subroutine written
C>    @data Feb, 2016- Yoshio Nishimoto
C>    - Subroutine written
C>
C>           --- INPUT ---
C>    @param ACONST USUALLY 1.0D+00?
C>    @param XCOORD,YCOORD,ZCOORD [X,Y,Z] coordinates of tesserae
C>    @param C Coordinates of solute
C>    @param NP Number of tesserae
C>           --- OUTPUT ---
C>    @param VALUE ESP of tesserae from solute atoms
C>
C
      SUBROUTINE DFTB_EPOTEN(ACONST,XCOORD,YCOORD,ZCOORD,VALUE,DA,C,NP,
     *                       NAT,L1,L2,NSHELL)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (ONE=1.0D+00)
C
      DIMENSION XCOORD(NP),YCOORD(NP),ZCOORD(NP),VALUE(NP),C(3,NAT),
     *          DA(L2)
      LOGICAL GOPARR,DSKWRK,MASWRK,
     *        TRIPLET,SG1T,TAMMD,TPA,ALPHKWD,BETAKWD
C
      COMMON /FMCOM / X(1)
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /INFOTD/ CNVTOL,PFREQ(2),
     *                JANST,NRADT,NTHET,NPHIT,NLEBT,
     *                NSTAT,NTRIAL,MAXVEC,NTHST,IRECTD,ITDFG,ITDPRP,
     *                TRIPLET,SG1T,NONEQR,TAMMD,TPA,ALPHKWD,BETAKWD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RNONE/8HNONE    /
      DIMENSION CC(3)
C
      IF (TDDFTYP.NE.RNONE.AND.ITDFG.EQ.1.OR.IFMOSTP.EQ.4) THEN
        CALL VALFM(LOADFM)
        LMUL  = LOADFM + 1
        LMULS = LMUL   + L1
        LMULA = LMULS  + NSHELL
        LS    = LMULA  + NAT
        LAST  = LS     + L2
        NEED  = LAST - LOADFM - 1
        CALL GETFM(NEED)
        IF (IFMOSTP.EQ.4) THEN !! FOR SCZV
          CALL VCLR(X(LS),1,L2)
          CALL DFTB_HAM_OVER(1,NAT,X(LS),X(LS),.FALSE.,.TRUE.)
        ELSE
          CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
        END IF
        CALL DFTB_MULLIKEN(L1,L2,DA,X(LS),X(LMUL))
        CALL DFTB_MULSA(X(LMUL),X(LMULS),X(LMULA),L1,NSHELL,NAT)
      ELSE
        CALL VALFM(LOADFM)
        LMULA = LOADFM + 1
        LAST  = LMULA  + NAT
        NEED  = LAST - LOADFM - 1
        CALL GETFM(NEED)
        CALL DAREAD(IDAF,IODA,X(LMULA),NAT,556,0)
      END IF
      IF (ACONST.NE.ONE) CALL DSCAL(NAT,ACONST,X(LMULA),1)
C
C     USE POPULATION
C     NUCLEAR INTERACTION IS CALCULATED ELSEWHERE
C
      IPCOUNT = ME - 1
      DO NI = 1, NAT
        IF(GOPARR) THEN
          IPCOUNT = IPCOUNT + 1
          IF(MOD(IPCOUNT,NPROC).NE.0) CYCLE
        END IF
        CX = C(1,NI)
        CY = C(2,NI)
        CZ = C(3,NI)
        CHAMUL = X(LMULA+NI-1)
        DO NTS = 1, NP
          CC(1) = CX-XCOORD(NTS)
          CC(2) = CY-YCOORD(NTS)
          CC(3) = CZ-ZCOORD(NTS)
          VALUE(NTS) = VALUE(NTS)
     *      + CHAMUL/SQRT(CC(1)*CC(1)+CC(2)*CC(2)+CC(3)*CC(3))
        END DO
      END DO
C     IF (ACONST.NE.ONE) CALL DSCAL(NP,ACONST,VALUE,1)
C
      CALL RETFM(NEED)
C
      RETURN
C
      END SUBROUTINE DFTB_EPOTEN
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_INTMEP
C>
C>    @brief DFTB/PCM
C>
C>    @details This is a bypass of INTMEP subroutine.  This subroutine
C>             is called to calculate a PCM contribution to Fock.
C>             Overlap matrix in AO basis has to be stored as X(LS)
C>             before this subroutine is called.  It is usually done
C>             before PCMFLD is called, but for non-PCM calculations,
C>             some additional lines may be required.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- (Preliminary) subroutine written
C>    @data Feb, 2016- Yoshio Nishimoto
C>    - Subroutine written
C>
C>           --- INPUT ---
C>    @param XPP,YPP,ZPP Coordinates of tesserae
C>    @param C Coordinates of solute
C>    @param NAT Number of atoms (solute)
C>    @param L1 Number of basis functions
C>           --- OUTPUT ---
C>    @param VALUE Non-charge scaled potential from tessera to solute AO
C>
C
      SUBROUTINE DFTB_INTMEP(VALUE,XPP,YPP,ZPP,C,NAT,L1)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION VALUE(*),C(3,NAT)
C
      DOUBLE PRECISION, PARAMETER :: ONE=1.0D+00
      INTEGER, PARAMETER :: MXATM=2000,MXSPE=10
C     LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBS / LS
      COMMON /FMCOM / X(1)
C     COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION SHIF(NAT)
C
      L2 = L1*(L1+1)/2
C
C     CALL VALFM(LOADFM)
C     LS    = LOADFM + 1
C     LAST  = LS     + L2
C     NEED  = LAST - LOADFM - 1
C     CALL GETFM(NEED)
C
C     SAVGOP = GOPARR
C     GOPARR = .FALSE.
C     CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
C     GOPARR = SAVGOP
C
      CALL VCLR(VALUE,1,L2)
C
      DO IAT = 1, NAT
        CX = XPP-C(1,IAT)
        CY = YPP-C(2,IAT)
        CZ = ZPP-C(3,IAT)
        SHIF(IAT) = ONE/SQRT(CX*CX+CY*CY+CZ*CZ)
      END DO
C
      CALL DFTB_SHIFT_FOCK(SHIF,VALUE,X(LS),NAT,L2,NSPE,ISPE,IND,MAXANG)
C
C     CALL RETFM(NEED)
C
      RETURN
C
      END SUBROUTINE DFTB_INTMEP
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_INTMEP2
C>
C>    @brief DFTB/PCM
C>
C>    @details This is similar to DFTB_INTMEP subroutine, but the loop
C>             of tesserae is done internally in this subroutine.
C>             This achieves significant time saving.
C>
C>    @author Yoshio Nishimoto
C>    - Oct, 2015- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms (solute)
C>    @param L2  L1*(L1+1)/2
C>    @param C   Coordinates of solute
C>    @param NTS Number of tesserae
C>    @param XPP,YPP,ZPP Coordinates of tesserae
C>    @param QSE Apparent surface charges
C>    @param WRK Working array
C>           --- OUTPUT ---
C>    @param FAO PCM contribution to AO-Fock matrix
C>
C
      SUBROUTINE DFTB_INTMEP2(NAT,L2,C,NTS,XCTS,YCTS,ZCTS,FAO,QSE,
     *                        WRK)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION C(3,NAT),XCTS(*),YCTS(*),ZCTS(*),FAO(*),QSE(*),WRK(*)
C
      INTEGER, PARAMETER :: MXATM=2000,MXSPE=10
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBS / LS
      COMMON /FMCOM / X(1)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION CC(7)
C
      CALL VCLR(WRK,1,NAT)
      IPCOUNT = ME - 1
      DO IAT = 1, NAT
        IF (GOPARR) THEN
          IPCOUNT = IPCOUNT + 1
          IF (MOD(IPCOUNT,NPROC).NE.0) CYCLE
        END IF
        CC(7) = 0.0D+00
        CC(1) = C(1,IAT)
        CC(2) = C(2,IAT)
        CC(3) = C(3,IAT)
        DO ITS = 1, NTS
          CC(4) = CC(1) - XCTS(ITS)
          CC(4) = CC(4)*CC(4)
          CC(5) = CC(2) - YCTS(ITS)
          CC(5) = CC(5)*CC(5)
          CC(6) = CC(3) - ZCTS(ITS)
          CC(6) = CC(6)*CC(6)
          CC(7) = CC(7) - QSE(ITS)/SQRT(CC(4)+CC(5)+CC(6))
        END DO
        WRK(IAT) = CC(7)
      END DO
C
      CALL DFTB_SHIFT_FOCK(WRK,FAO,X(LS),NAT,L2,NSPE,ISPE,IND,MAXANG)
C
      RETURN
C
      END SUBROUTINE DFTB_INTMEP2
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_2ND_SHIFT
C>
C>    @brief Calculate shift contribution
C>
C>    @details Calculate the shift contribution of Coulomb potential.
C>             This is for DFTB2 only.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param CHAMUL Mulliken charges of each atom
C>    @param GAMMA DFTB2 gamma array
C>    @param NDIM Number of dimension to be considered.  If SRSCC=.T.,
C>           NDIM will be NSHELL, and otherwise, NDIM will be NAT.
C>           --- OUTPUT ---
C>    @param SHIFT Shift contribution
C>
C
      SUBROUTINE DFTB_2ND_SHIFT(SHIFT,CHAMUL,GAMMA,NDIM)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NDIM
      DOUBLE PRECISION, INTENT(IN) :: CHAMUL(NDIM),
     *  GAMMA((NDIM*NDIM+NDIM)/2)
      DOUBLE PRECISION, INTENT(INOUT) :: SHIFT(NDIM)
C
      INTEGER :: I,J,NSEQ
C
      DO I = 1, NDIM
        DO J = 1, NDIM
          CALL DFTB_CNVSQ(I,J,NSEQ)
          SHIFT(I) = SHIFT(I) + CHAMUL(J)*GAMMA(NSEQ)
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_2ND_SHIFT
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_3RD_SHIFT
C>
C>    @brief Calculate shift contribution
C>
C>    @details Calculate the shift contribution of Coulomb potential.
C>             This is for DFTB3 only.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param CHAMUL Mulliken charges of each atom
C>    @param GAMMA DFTB3 gamma array
C>    @param NDIM Number of dimension to be considered.  If SRSCC=.T.,
C>           NDIM will be NSHELL, and otherwise, NDIM will be NAT.
C>           --- OUTPUT ---
C>    @param SHIFT Shift contribution
C>
C
      SUBROUTINE DFTB_3RD_SHIFT(SHIFT,CHAMUL,GAMMA,NDIM)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NDIM
      DOUBLE PRECISION, INTENT(IN) :: CHAMUL(NDIM),GAMMA(NDIM,NDIM)
      DOUBLE PRECISION, INTENT(INOUT) :: SHIFT(NDIM)
C
      INTEGER :: I,J
      DOUBLE PRECISION :: GAMI,GAMJ
      !! MULTIPLICITD BY TWO BECAUSE 1/2 IS MULTIPLIED LATER
      DOUBLE PRECISION, PARAMETER :: TWO=2.0D+00,THREE=3.0D+00,
     *  TWO_THIRD=TWO/THREE,TWO_SIX=TWO_THIRD*0.5D+00
C
      DO I = 1, NDIM !! a
        DO J = 1, NDIM !! c
          GAMI = GAMMA(I,J) !! G_ac
C         GAMI = GAMMA(I-1+(J-1)*NDIM) !! G_ac
          GAMJ = GAMMA(J,I) !! G_ca
C         GAMJ = GAMMA(J-1+(I-1)*NDIM) !! G_ca
          SHIFT(I) = SHIFT(I)
     *      + TWO_THIRD * CHAMUL(J) * CHAMUL(I) * GAMI
     *      + TWO_SIX   * CHAMUL(J) * CHAMUL(J) * GAMJ
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_3RD_SHIFT
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_3RD_SHIFT_SRSCC
C>
C>    @brief Calculate shift contribution
C>
C>    @details Calculate the shift contribution of Coulomb potential
C>             with SRSCC option.
C>
C>    @author Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param CHAMUL   Shell-resolved Mulliken charges
C>    @param GAMMA    DFTB3 gamma array
C>    @param NSHELL   Number of shells
C>    @param NAT      Number of atoms
C>    @param MAXANG   Array of maximum angular momenta
C>    @param ISPE     Array of species
C>    @param CHAMULAT Atom-resolved Mulliken charges
C>           --- OUTPUT ---
C>    @param SHIFT    Shift contribution
C>
C
      SUBROUTINE DFTB_3RD_SHIFT_SRSCC(SHIFT,CHAMUL,GAMMA,NSHELL,NAT,
     *                                MAXANG,ISPE,CHAMULAT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER, INTENT(IN) :: NSHELL,NAT,MAXANG(*),ISPE(*)
      DOUBLE PRECISION,INTENT(IN):: CHAMUL(NSHELL),GAMMA(NSHELL,NSHELL),
     *                              CHAMULAT(NAT)
      DOUBLE PRECISION, INTENT(INOUT) :: SHIFT(NSHELL)
C
      INTEGER :: I,J
      DOUBLE PRECISION, PARAMETER :: ONE_THIRD=1.0D+00/3.0D+00
C
      ISH0 = 0
      DO I = 1, NAT !! atom A
        JSH0 = 0
        DO J = 1, NAT !! atom C
          DO II = 1, MAXANG(ISPE(I)) !! shell l (A)
            ISH = ISH0 + II
            DO JJ = 1, MAXANG(ISPE(J)) !! shell ll (C)
              JSH = JSH0 + JJ
              DQJ = CHAMUL(JSH)*ONE_THIRD
              SHIFT(ISH) = SHIFT(ISH) + GAMMA(ISH,JSH)*CHAMULAT(I)*DQJ
     *                                + GAMMA(JSH,ISH)*CHAMULAT(J)*DQJ
              DO KK = 1, MAXANG(ISPE(I)) !! shell lll (inner A)
                KSH = ISH0 + KK
                SHIFT(ISH) = SHIFT(ISH)
     *                     + GAMMA(KSH,JSH)*CHAMUL(KSH)*DQJ
              END DO
            END DO
          END DO
          JSH0 = JSH0 + MAXANG(ISPE(J))
        END DO
        ISH0 = ISH0 + MAXANG(ISPE(I))
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_3RD_SHIFT_SRSCC
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_3RD_SHIFT_FMO
C>
C>    @brief Calculate shift contribution
C>
C>    @details Calculate the shift contribution of Coulomb potential.
C>             This is for FMO-DFTB3 only.  In FMO-DFTB2, this shift
C>             contribution is calculated in DFTB_ESP subroutine,
C>             however in FMO-DFTB3, this contribution depends on the
C>             charges currently considered, therefore the contribution
C>             has to be updated in each cycle.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param CHAMUL Mulliken charges of each atom
C>    @param SHIFTFMO This contains coefficients of external atoms.
C>           This is taken from No.908 dictionary
C>    @param NAT Number of atoms
C>           --- OUTPUT ---
C>    @param SHIFT Shift contribution
C>
C
      SUBROUTINE DFTB_3RD_SHIFT_FMO(SHIFT,CHAMUL,SHIFTFMO,NAT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT
      DOUBLE PRECISION, INTENT(INOUT) :: SHIFT(NAT)
      DOUBLE PRECISION, INTENT(IN) :: CHAMUL(NAT),SHIFTFMO(2*NAT)
C
      INTEGER :: I
      DOUBLE PRECISION, PARAMETER :: TWO=2.0D+00
C
      DO I = 1, NAT
        SHIFT(I) = SHIFT(I) + CHAMUL(I)*SHIFTFMO(I)*TWO+SHIFTFMO(NAT+I)
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_3RD_SHIFT_FMO
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_SPIN_SHIFT
C>
C>    @brief Calculate shift contribution
C>
C>    @details Calculate the shift contribution of spin-spin interaction
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param CHAMUL Mulliken spin population of each atom
C>    @param SPNCST Spin constants
C>    @param NAT Number of atoms
C>    @param NSHELL Number of shells
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param SHIFT Shift contribution
C>
C
      SUBROUTINE DFTB_SPIN_SHIFT(SHIFT,CHAMUL,SPNCST,NAT,NSHELL,NSPE,
     *  ISPE,MAXANG)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NSHELL,NSPE
      DOUBLE PRECISION, INTENT(IN) :: CHAMUL(NSHELL),SPNCST(6,NSPE)
      DOUBLE PRECISION, INTENT(INOUT) :: SHIFT(NSHELL)
      INTEGER, INTENT(IN) :: NAT,ISPE(NAT),MAXANG(NSPE)
C
      INTEGER :: I,J,K,ISH,JSH,NN,NSEQ
      DOUBLE PRECISION :: SHCH,SPC,TMP
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00
C
      NN = 0
      ISH = 0
      DO I = 1, NAT
        DO J = 1, MAXANG(ISPE(I))
          ISH = NN + J
          TMP = ZERO
          DO K = 1, MAXANG(ISPE(I))
            JSH = NN + K
            SHCH = CHAMUL(JSH)
            CALL DFTB_CNVSQ(J,K,NSEQ)
            SPC = SPNCST(NSEQ,ISPE(I))
            TMP = TMP + SPC*SHCH
          END DO
          SHIFT(ISH) = SHIFT(ISH) + TMP
        END DO
        NN = NN + MAXANG(ISPE(I))
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_SPIN_SHIFT
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_EFIELD_SHIFT
C>
C>    @brief Calculate shift contribution
C>
C>    @details Calculate the shift contribution of electric field
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param EVEC Vector of electric field
C>    @param C Coordinates
C>    @param NAT NUmber of atoms
C>           --- OUTPUT ---
C>    @param SHIFT Shift contribution
C>
C
      SUBROUTINE DFTB_EFIELD_SHIFT(SHIFT,EVEC,C,NAT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT
      DOUBLE PRECISION, INTENT(IN) :: EVEC(3),C(3,NAT)
      DOUBLE PRECISION, INTENT(INOUT) :: SHIFT(NAT)
C
      INTEGER :: I
C
C     THE SIGN IS SET TO BE CONSISTENT WITH DFTB+ RESULTS
      DO I = 1, NAT
C       SHIFT(I) = SHIFT(I) - C(1,I)*EVEC(1)
C    *    - C(2,I)*EVEC(2) - C(3,I)*EVEC(3)
        SHIFT(I) = SHIFT(I) + C(1,I)*EVEC(1)
     *    + C(2,I)*EVEC(2) + C(3,I)*EVEC(3)
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_EFIELD_SHIFT
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_SHIFT_FOCK
C>
C>    @brief Calculate shift contribution
C>
C>    @details Add shift contribution to Fock (Hamilton) matrix
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param SHIFT Shift contribution
C>    @param S Overlap matrix in AO
C>    @param NAT Number of atoms
C>    @param L2 L1*(L1+1)/2
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param IND Index of atomic orbitals
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param FAO Fork (Hamilton) matrix in AO basis
C>
C
      SUBROUTINE DFTB_SHIFT_FOCK(SHIFT,FAO,S,NAT,L2,NSPE,ISPE,IND,
     *  MAXANG)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L2,NSPE
      DOUBLE PRECISION, INTENT(IN) :: SHIFT(NAT),S(L2)
      DOUBLE PRECISION, INTENT(INOUT) :: FAO(L2)
      INTEGER, INTENT(IN) :: ISPE(NAT),IND(NSPE),MAXANG(NSPE)
C
      INTEGER :: I,J,K,L,M,N,NSEQ
      DOUBLE PRECISION :: SHIFTI,SHIFTJ,SHIFTIJ
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
C
      DO I = 1, NAT
        SHIFTI = SHIFT(I)
        DO K = 1, MAXANG(ISPE(I))**2
          M = IND(I)+K
          DO J = 1, I
            SHIFTJ = SHIFT(J)
            SHIFTIJ = SHIFTI + SHIFTJ
            SHIFTIJ = SHIFTIJ * HALF
            DO L = 1, MAXANG(ISPE(J))**2
              N = IND(J)+L
              CALL DFTB_CNVSQ(M,N,NSEQ)
              FAO(NSEQ) = FAO(NSEQ) + S(NSEQ)*SHIFTIJ
            END DO
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_SHIFT_FOCK
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_SHIFT_FOCK_SRSCC
C>
C>    @brief Calculate shift contribution
C>
C>    @details Add shift contribution to Fock (Hamilton) matrix for
C>             shell-resolved SCC calculations
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param SHIFTSH Shell-resolved shift contribution
C>    @param S Overlap matrix in AO
C>    @param NAT Number of atoms
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param NSHELL Number of shells
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param FA Fork (Hamilton) matrix in AO basis
C>
C
      SUBROUTINE DFTB_SHIFT_FOCK_SRSCC(FA,SHIFTSH,S,NAT,L1,L2,
     *  NSHELL,NSPE,ISPE,MAXANG)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L1,L2,NSHELL,NSPE
      DOUBLE PRECISION, INTENT(IN) :: SHIFTSH(NSHELL),S(L2)
      DOUBLE PRECISION, INTENT(INOUT) :: FA(L2)
      INTEGER, INTENT(IN) :: ISPE(NAT),MAXANG(NSPE)
C
      INTEGER :: I,II,III,J,JJ,JJJ,M,N,MU,NU,ISH,JSH,NSEQ
      DOUBLE PRECISION :: SHIFTI,SHIFTJ,SHIFTIJ
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
C
      ISH = 0
      MU = 0
      NSEQ = 0
      DO I = 1, NAT
        DO II = 1, MAXANG(ISPE(I))
          ISH = ISH + 1
          SHIFTI = SHIFTSH(ISH)
          IF (II.EQ.1) III = 1
          IF (II.EQ.2) III = 3
          IF (II.EQ.3) III = 5
          DO M = 1, III
            MU = MU + 1
            JSH = 0
            NU = 0
            DO J = 1, I
              DO JJ = 1, MAXANG(ISPE(J))
                JSH = JSH + 1
                SHIFTJ = SHIFTSH(JSH)
                SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
                IF (JJ.EQ.1) JJJ = 1
                IF (JJ.EQ.2) JJJ = 3
                IF (JJ.EQ.3) JJJ = 5
                DO N = 1, JJJ
                  NU = NU + 1
                  CALL DFTB_CNVSQ(MU,NU,NSEQ)
                  FA(NSEQ) = FA(NSEQ) + S(NSEQ)*SHIFTIJ
                END DO
              END DO
            END DO
C           write (*,*) ish,mu,nseq
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_SHIFT_FOCK_SRSCC
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_SHIFT_FOCK_UHF
C>
C>    @brief Calculate shift contribution
C>
C>    @details Add shift contribution to Fock (Hamilton) matrix for
C>             unrestricted DFTB.  This anyway uses SRSCC approach,
C>             because spin-spin interaction is already shell-resolved.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param SHIFTS Shell-resolved spin shift contribution
C>    @param SHIFTSH Shell-resolved non-spin shift contribution
C>    @param S Overlap matrix in AO
C>    @param NAT Number of atoms
C>    @param L2 L1*(L1+1)/2
C>    @param NSHELL Number of shells
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param FA Alpha Fork (Hamilton) matrix in AO basis
C>    @param FB Beta Fork (Hamilton) matrix in AO basis
C>
C
      SUBROUTINE DFTB_SHIFT_FOCK_UHF(FA,FB,SHIFTS,SHIFTSH,S,NAT,L2,
     *  NSHELL,NSPE,ISPE,MAXANG)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L2,NSHELL,NSPE
      DOUBLE PRECISION, INTENT(IN) :: SHIFTS(NSHELL),SHIFTSH(NSHELL),
     *  S(L2)
      DOUBLE PRECISION, INTENT(INOUT) :: FA(L2),FB(L2)
      INTEGER, INTENT(IN) :: ISPE(NAT),MAXANG(NSPE)
C
      INTEGER :: I,II,III,J,JJ,JJJ,M,N,MU,NU,ISH,JSH,NSEQ
      DOUBLE PRECISION :: SHIFTIA,SHIFTIB,SHIFTJA,SHIFTJB,SHIFTIJA,
     *  SHIFTIJB
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
C
      ISH = 0
      MU = 0
      NSEQ = 0
      DO I = 1, NAT
        DO II = 1, MAXANG(ISPE(I))
          ISH = ISH + 1
          SHIFTIA = SHIFTSH(ISH)+SHIFTS(ISH)
          SHIFTIB = SHIFTSH(ISH)-SHIFTS(ISH)
          IF (II.EQ.1) III = 1
          IF (II.EQ.2) III = 3
          IF (II.EQ.3) III = 5
          DO M = 1, III
            MU = MU + 1
            JSH = 0
            NU = 0
            DO J = 1, I
              DO JJ = 1, MAXANG(ISPE(J))
                JSH = JSH + 1
                SHIFTJA = SHIFTSH(JSH)+SHIFTS(JSH)
                SHIFTJB = SHIFTSH(JSH)-SHIFTS(JSH)
                SHIFTIJA = HALF*(SHIFTIA+SHIFTJA)
                SHIFTIJB = HALF*(SHIFTIB+SHIFTJB)
                IF (JJ.EQ.1) JJJ = 1
                IF (JJ.EQ.2) JJJ = 3
                IF (JJ.EQ.3) JJJ = 5
                DO N = 1, JJJ
                  NU = NU + 1
                  CALL DFTB_CNVSQ(MU,NU,NSEQ)
                  FA(NSEQ) = FA(NSEQ) + S(NSEQ)*SHIFTIJA
                  FB(NSEQ) = FB(NSEQ) + S(NSEQ)*SHIFTIJB
                END DO
              END DO
            END DO
C           write (*,*) ish,mu,nseq
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_SHIFT_FOCK_UHF
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_CALC_ENCC_SOSCF
C>
C>    @brief Calculate DFTB energy
C>
C>    @details Calculate NCC-DFTB energy when SOSCF is used.
C>             It is more efficient that energy is calculated with
C>             eigenvalues, however they are not updated in SOSCF, so
C>             this subroutine follows such an equation:
C>               E_NCC = \sum_i n_i \sum_{\mu \nu}
C>                       c_{\mu i} c_{\nu i} H_{\mu \nu}^0
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param DA Density matrix of alpha
C>    @param DB Density matrix of beta
C>    @param H0 Non-perturbed Hamiltonian in AO
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param SCFTYP scf type
C>    @param ROHFGAMESS
C>           --- OUTPUT ---
C>    @param ENCC NCC energy
C>
C
      SUBROUTINE DFTB_CALC_ENCC_SOSCF(ENCC,DA,DB,H0,L1,L2,SCFTYP,
     *  ROHFGAMESS)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,L2
      DOUBLE PRECISION, INTENT(INOUT) :: ENCC
      DOUBLE PRECISION, INTENT(IN) :: DA(L2),DB(L2),H0(L2),SCFTYP
      LOGICAL, INTENT(IN) :: ROHFGAMESS
C
      INTEGER :: IO,NSEQ
      DOUBLE PRECISION :: DDOT
      DOUBLE PRECISION :: XDOT
      DOUBLE PRECISION, PARAMETER :: TWO=2.0D+00
      DOUBLE PRECISION UHF/8HUHF     /
C
      IF (SCFTYP.EQ.UHF.OR.ROHFGAMESS) THEN
        ENCC = ENCC + DDOT(L2,DA,1,H0,1)
        ENCC = ENCC + DDOT(L2,DB,1,H0,1)
        ENCC = ENCC * TWO
        NSEQ = 0
        DO IO = 1, L1
          NSEQ = NSEQ + IO
          ENCC = ENCC - (DA(NSEQ)+DB(NSEQ))*H0(NSEQ)
        END DO
      ELSE
        ENCC = ENCC + DDOT(L2,DA,1,H0,1)*TWO
        NSEQ = 0
        DO IO = 1, L1
          NSEQ = NSEQ + IO
          ENCC = ENCC - DA(NSEQ)*H0(NSEQ)
        END DO
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_ENCC_SOSCF
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_CALC_ENCC
C>
C>    @brief Calculate DFTB energy
C>
C>    @details Calculate NCC-DFTB energy with eigenvalues.  This is much
C>             more efficient than above.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param AOC,BOC Occupation numbers of alpha and beta
C>    @param EA,EB Eigenvalues of alpha and beta
C>    @param CHAMUL Mulliken population of each atom
C>    @param SHIFT Shift contribution
C>    @param L1 Number of basis functions
C>    @param NDIM Number of dimension to be considered.  If SRSCC=.T.,
C>           NDIM will be NSHELL, and otherwise, NDIM will be NAT.
C>    @param SCC SCC or NCC
C>    @param ROHF ROHF?
C>    @param SCFTYP scf type
C>           --- OUTPUT ---
C>    @param ENCC NCC energy
C>
C
      SUBROUTINE DFTB_CALC_ENCC(ENCC,AOC,EA,BOC,EB,CHAMUL,SHIFT,L1,
     *  NDIM,SCC,ROHF,SCFTYP)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,NDIM
      DOUBLE PRECISION, INTENT(INOUT) :: ENCC
      DOUBLE PRECISION, INTENT(IN) :: AOC(L1),EA(L1),BOC(L1),EB(L1),
     *  CHAMUL(NDIM),SHIFT(NDIM),SCFTYP
      LOGICAL, INTENT(IN) :: SCC,ROHF
C
      DOUBLE PRECISION :: DDOT,XDOT,UHF
      DATA UHF/8HUHF     /
C
      ENCC = ENCC + DDOT(L1,AOC,1,EA,1)
      IF (SCFTYP.EQ.UHF.OR.ROHF) ENCC = ENCC + DDOT(L1,BOC,1,EB,1)
C
      IF (SCC) ENCC = ENCC - DDOT(NDIM,CHAMUL,1,SHIFT,1)
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_ENCC
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_CALC_ESCC
C>
C>    @brief Calculate DFTB energy
C>
C>    @details Calculate SCC energy for both DFTB2 and DFTB3.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Added DFTB3 with SRSCC
C>
C>           --- INPUT ---
C>    @param GAMMA2 DFTB2 gamma matrix
C>    @param GAMMA3 DFTB3 gamma matrix
C>    @param CHAMUL Mulliken population of each atom
C>    @param NDIM   Number of dimension to be considered.  If SRSCC=.T.,
C>                  NDIM will be NSHELL, and otherwise, NDIM will be NAT.
C>    @param DFTB3  DFTB3 or not
C>    @param SRSCC  SRSCC is used or not
C>    @param NAT    Number of atoms
C>    @param MAXANG Array of maximum angular momenta
C>    @param ISPE   Array of species
C>           --- OUTPUT ---
C>    @param ESCC   SCC energy of DFTB2
C>    @param ESCC3  SCC energy of DFTB3
C>
C
      SUBROUTINE DFTB_CALC_ESCC(ESCC,ESCC3,GAMMA2,GAMMA3,CHAMUL,
     *  NDIM,DFTB3,SRSCC,NAT,MAXANG,ISPE)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION, INTENT(INOUT) :: ESCC,ESCC3
      INTEGER, INTENT(IN) :: NDIM,NAT,MAXANG(*),ISPE(*)
      DOUBLE PRECISION, INTENT(IN) :: GAMMA2((NDIM*NDIM+NDIM)/2),
     *  GAMMA3(NDIM,NDIM),CHAMUL(NDIM)
      LOGICAL, INTENT(IN) :: DFTB3,SRSCC
C
      INTEGER :: I,J,NSEQ,II,ISH,ISH0
      DOUBLE PRECISION:: TMP,TMPCHA
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,HALF=0.5D+00
C
      DO I = 1, NDIM
        DO J = 1, NDIM
          CALL DFTB_CNVSQ(I,J,NSEQ)
          ESCC = ESCC + GAMMA2(NSEQ)*CHAMUL(I)*CHAMUL(J)
        END DO
      END DO
      ESCC = HALF * ESCC
C
      IF (DFTB3) THEN
        ESCC3 = ZERO
        IF (SRSCC) THEN
          ISH0 = 0
          DO I = 1, NAT
            TMPCHA = ZERO
            TMP = ZERO
            DO II = 1, MAXANG(ISPE(I))
              ISH = ISH0 + II
              DO J = 1, NDIM
                TMP = TMP + CHAMUL(ISH)*CHAMUL(J)*GAMMA3(ISH,J)
              END DO
              TMPCHA = TMPCHA + CHAMUL(ISH)
            END DO
            ESCC3 = ESCC3 + TMP*TMPCHA
            ISH0 = ISH0 + MAXANG(ISPE(I))
          END DO
        ELSE
          DO I = 1, NDIM
            DO J = 1, NDIM
              ESCC3 = ESCC3 + CHAMUL(I)*CHAMUL(I)*CHAMUL(J)*GAMMA3(I,J)
            END DO
          END DO
        END IF
        ESCC3 = ESCC3/3.0D+00
        ESCC = ESCC + ESCC3
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_ESCC
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_CALC_ESPIN
C>
C>    @brief Calculate DFTB energy
C>
C>    @details Calculate spin-spin interaction energy
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param SHIFT Shift contribution
C>    @param CHAMULS Shell-resolved spin Mulliken populations
C>    @param SPNCST Spin constants
C>    @param NAT Number of atoms
C>    @param NSHELL Number of shells
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>    @param SCC SCC or not
C>    @param SOSCF SOSCF is used or not
C>           --- OUTPUT ---
C>    @param ENCC NCC energy
C>    @param ESPIN spin-spin interaction energy
C>
C
      SUBROUTINE DFTB_CALC_ESPIN(ENCC,ESPIN,SHIFT,CHAMULS,
     *  SPNCST,NAT,NSHELL,NSPE,ISPE,MAXANG,SCC,SOSCF)
C
      IMPLICIT NONE
C
      !! CHAMULS :: SHELL-RESOLVED SPIN POPULATION
      INTEGER, INTENT(IN) :: NAT,NSHELL,NSPE
      DOUBLE PRECISION, INTENT(INOUT) :: ENCC,ESPIN
      DOUBLE PRECISION, INTENT(IN) :: SHIFT(NSHELL),CHAMULS(NSHELL),
     *  SPNCST(6,NSPE)
      INTEGER, INTENT(IN) :: ISPE(NAT),MAXANG(NSPE)
      LOGICAL, INTENT(IN) :: SCC,SOSCF
C
      INTEGER :: I,J,K,ISH,JSH,NN,NSEQ
      DOUBLE PRECISION :: DDOT,SPOPI,SPOPJ,SPC
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
      DOUBLE PRECISION :: XDOT
C
      !! ENCC CORRECTION ONLY IF SOSCF IS NOT USED
      !! \DELTA ENCC = (SPIN-RESOLVED POPULATION) * SHIFT
      IF (SCC.AND..NOT.SOSCF)
     *  ENCC = ENCC - DDOT(NSHELL,CHAMULS,1,SHIFT,1)
C
      ISH = 0
      JSH = 0
      NN = 0
      DO I = 1, NAT
        DO J = 1, MAXANG(ISPE(I))
          ISH = NN + J
          SPOPI = CHAMULS(ISH)
          DO K = 1, MAXANG(ISPE(I))
            JSH = NN + K
            SPOPJ = CHAMULS(JSH)
            CALL DFTB_CNVSQ(J,K,NSEQ)
            SPC = SPNCST(NSEQ,ISPE(I))
            ESPIN = ESPIN + SPC*SPOPI*SPOPJ
          END DO
        END DO
        NN = NN + MAXANG(ISPE(I))
      END DO
      ESPIN = ESPIN * HALF
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_ESPIN
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_FMONBOND
C>
C>    @brief   Dispersion in FMO-DFTB-D(SKHP)
C>
C>    @details Coun the number of bonds
C>
C>    @author Yoshio Nishimoto
C>    - Jan, 2015- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT    Number of atoms
C>    @param IAGLOB Index of atoms
C>    @param IWRK   Integer working array
C>           --- OUTPUT ---
C>    @param NBOND  Number of bonds
C>
C
      SUBROUTINE DFTB_FMONBOND(NAT,IAGLOB,NBOND,IWRK)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,IAGLOB(NAT),NBOND(*)
      INTEGER, INTENT(OUT) :: IWRK(NAT)
C
      INTEGER :: I,IAG
C
      DO I = 1, NAT
        IAG = IAGLOB(I)
        IWRK(I) = NBOND(IAG)
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_FMONBOND
C
C-----------------------------------------------------------------------
C*MODULE DFTBX     *DECK DFTB_COSADD
C>
C>    @brief   COSMO solvation model
C>
C>    @details Calculate ESP on each atom, as COSADD does
C>             DFTB/COSMO energy may be available?
C>
C>    @author Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- OUTPUT ---
C>    @param SHIFT Shift contributions
C>
C
      SUBROUTINE DFTB_COSADD(SHIFT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION SHIFT(*)
C
      PARAMETER (MXATM=2000,MAXDEN=25*MXATM,MXABC=6000)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      LOGICAL COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
      COMMON /COSDAT/ SE2,SECORR,QVCOSMO,ELAST,EMP2COS,EMP2LAST,
     *                COSVOL,COSSAR,EDIEL,EOC1,DEOC_RS,SUMQSC,
     *                SUMQSCOLD,ZSUM,ZSUM2,ZSUM3,FEPSI,RDS,DISEX2,
     *                EPSI,COSRAD,DISEX,OUTCHG,EDIEL_SAVE,
     *                MAXNPS,ICORR,ITRIP,NQS,MP2TRIP,MP2ITER,
     *                ICFREQ,NSPA,NSPH,NPSD,NPS,NPS2,NDEN,NPSPHER,
     *                COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
      COMMON /COSVCE/ QSCNET(MXABC),CORZAN(3,MXABC),
     *                QDEN(MAXDEN),QSCNET_SAVE(MXABC),IATSP(MXABC+1)
C
      DO ITS = 1, NPS
        XPP = CORZAN(1,ITS)
        YPP = CORZAN(2,ITS)
        ZPP = CORZAN(3,ITS)
        DO NM = 1, NAT
          DIST = SQRT((C(1,NM)-XPP)*(C(1,NM)-XPP)
     *              + (C(2,NM)-YPP)*(C(2,NM)-YPP)
     *              + (C(3,NM)-ZPP)*(C(3,NM)-ZPP))
          SHIFT(NM) = SHIFT(NM) - QSCNET(ITS)/DIST
        END DO
      END DO
C
      RETURN
C
      END
