C  1 Apr 16 - TN,HN,DGF - changes for FMO 5.2
C 22 Oct 22 - FZ,KRB,HN  - implement SCZV for DFT, add LC 
C 30 Sep 14 - HN  - enable ROHF for FMO
C 21 May 13 - TN,HN,DGF - changes for FMO 5.0
C 19 Oct 12 - MWS - synchronize FRGINF common
C 24 JUL 12 - HN  - enable UHF for FMO 
C 23 MAR 12 - DGF - pad common blocks
C 27 DEC 11 - TN  - changes for FMO 4.2
C 15 Apr 11 - TN  - misc changes for FMO 4.1
C 11 Aug 10 - TN  - new module for CPHF in FMO
C
C*MODULE FMOCP   *DECK ESDCPHFX
C>
C>     @brief CPHF for ES dimers 
C>
C>     @details Do CPHF for ES dimers. 
C>
C>     @author Takeshi Nagata 
C>    @date Feb, 2016- Yoshio Nishimoto
C>    - Added FMO-DFTB SCZV
C>    @date Jan, 2017-C.Bertoni
C>    - Changes for EFMO gradient
C>
      SUBROUTINE ESDCPHFX(ILAY,LOADHF,LOADM,DA,TRI1,TRI2,ZVLAG,FMODE,
     *                    NUMFRG,IODFMO,IDMREC0,LAYFRG,SCFFRG,
     *                    IREC0,NGRFMO,MANNOD,MASTID,NQMTFG,IPTLG,
     *                    HOPGRD,NEVSAV,XYZCTS,mulfg,DOPBCMD,PEL,
     *                    lfmasc,needasc,needmul,mappcm,irmdfmo,mdout)
cpbc  needr0,rwrk,mfg2,vdwrad,nprfrg,units)
cpbc  dimension RWRK(*),vdwrad(*),nprfrg(*)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,MAXPST=10)
      INTEGER DDI_WORLD,DDI_GROUP
      PARAMETER (DDI_WORLD=0,DDI_GROUP=1)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,HALF=0.5D+00,FOUR=4.0D+00)
      PARAMETER (THRSH=1.0D-06)
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (MXSPE=10)
C
      DIMENSION ZVLAG(1),DA(1)
      DIMENSION LOADM(*),NUMFRG(*)
      DIMENSION IODFMO(*),IDMREC0(*),LAYFRG(*),SCFFRG(*)
      DIMENSION NGRFMO(MAXPST,*),MANNOD(*),MASTID(*),NQMTFG(*)
      DIMENSION IPTLG(*)
      DIMENSION FMODE(3,*),XYZCTS(MXTS,*)
      DIMENSION TRI1(1), TRI2(1)
      DIMENSION mulfg(*),PEL(*),mappcm(*)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,out0,out1
      LOGICAL MYJOB
      LOGICAL LCONV,HOPGRD,DODISTR,LFIRST,DOSCZV,doesppc1
      LOGICAL DIRSAV, DIRSCF, FDIFF
      LOGICAL UHFCAL,ISGDDI,PAROUT,INITGDDI,wasgddi,urohf,DOPBCMD,MLGDDI
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB,mdout

C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
      COMMON /EFFMOP/ LEFLDF,LEFADDF,LDINDFMO,LDINDDFMO,
     *                LDEFEF,LDEFTF,LTORQF
cz    COMMON /EFPFM2/ TOTEFPC,POLTOT,LABFLDT,LDINDF2,LDINDDF2,LDELABFLD,
cz   *                LDELDIND,LDELDINDD,LALCNT2F
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP,iefmo_agrad
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /FMCOM / X(1)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2,maxrij
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
c     COMMON /FMOPMD/ FMOBOX(3),MDWPBC,NIMGCELL,IMGLVL,
c    *                LTRVEC,LFMOGCTR,LFMOCTMP,LINDATMD,LWRKDSAV,LINDXIU
c    *               ,IPBCFST
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MLTFMO/ Q_MUL,IMLTFMO,ISWPFD,ISWNEW1
      COMMON /MLTPNT/ LDELEPOT,LDELQSE,LQSETMP,LFZVEC,LMAPCMFD,LQBL2FD
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,NFMOPCM,IHET
      common /ppcpnt/ lddijpot,lzppcpot,lvipot,lgrdtest
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
C     FOR DFT
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA   UHF/8HUHF     /
      DATA   RHF/8HRHF     /
      DATA  ROHF/8HROHF    /
      DATA RNONE/8HNONE    /
C     PARAMETERS
C
c     OUT = MASWRK.AND.IAND(NPRFMO,3).NE.3
      OUT0= MASWRK.AND.IAND(NPRFMO,3).eq.0
      OUT1= MASWRK.AND.IAND(NPRFMO,3).ge.1
c     IF (DFTBFL) OUT = OUT.AND.MDOUT
      MAXL2   = (MAXL1*MAXL1+MAXL1)/2
      MAXL3   =  MAXL1*MAXL1
      JCURFG  = 0
      KCURFG  = 0
      ICURLAY = ILAY
      IF(DFTYPE.NE.RNONE)  CALL TDDINP
      modep=0
      if(iand(nprfmo,3).eq.3) modep=1
C
CZ
CZ    SPACE FOR ZVEC
      uhfcal=.false.
CZ
      DODISTR = IAND(MODPAR,512+1024).NE.0
      NOVTOT = 0
      NOVMAX = 0
C
      NLAYFRG=0
      DO IFG = 1, NFG
        IF (LAYFRG(IFG).GE.ILAY) THEN
          NLAYFRG=NLAYFRG+1
          NQI = IAND(NQMTFG(IFG),65535)
          NAI = ISHFT(NUMFRG(IFG),-16)
          NTMP = (NQI-NAI)*NAI
          if(scffrg(ifg).eq.uhf.or.scffrg(ifg).eq.rohf) then
            NBI = NAI  + 1 - mulfg(ifg)
            NTMP= NTMP + NBI * (NQI-NBI)
            UHFCAL=.true.
          end if
          NOVTOT = NOVTOT + NTMP
          NOVMAX = MAX(NOVMAX,NTMP)
        END IF
      END DO
C
CZ
CZ    SUM UP ZVLAG
CZ
c     write(6,*) 'Lagrangian frg2 in CPHF',ZVLAG(41),ZVLAG(42)
      IF (.NOT.DODISTR) THEN
        IF (ISGDDI) THEN
          CALL GDDI_SCOPE(DDI_WORLD)
          CALL DDI_GSUMF(3000,ZVLAG,IPTLG(NFG+1))
          CALL GDDI_SCOPE(DDI_GROUP)
        ELSE
           if( iefmorun .gt. 0 .and. iefmo_agrad .gt. 0) then
              CALL DDI_GSUMF(3000,ZVLAG,IPTLG(NFG+1))
           else
              CALL DDI_BCAST(3000,'F',ZVLAG,IPTLG(NFG+1),0)
           endif
        END IF
      END IF
c     write(6,*) 'summed Lagrangian frg2 in CPHF',ZVLAG(41),ZVLAG(42)
C
CZ
CZ    ALLOCATION OF THE WORK SPACE
CZ
      CALL VALFM(LOADFM)
      NDASC = 0
      LFPNT = LOADFM
      IF (ISWNEW1.EQ.1.and.modfd.eq.0) THEN
        if(isgddi) then
          NTSPAR=(NTS-1)/npglob+1
        else
          NTSPAR=(NTS-1)/NPROC+1
        endif
        CALL INDQPROD(0,NTSPAR,LFPNT,NDASC,DUM,DUM,DUM,modep)
      END IF
      LWRT1 = LFPNT + NDASC + 1
      if(uhfcal) then
        LWRK1 = LWRT1 + MAXL2*2 + MAXL3*2
        LWRK2 = LWRK1 + MAXL3*2 + MAXL3*2
        IF(DFTYPE.NE.RNONE) LWRK2 = LWRK1 + MAXL3*6
        LWRK3 = LWRK2 + MAXL3*2 + MAXL3*2
        LAST  = LWRK3 + MAXL3*2 + MAXL3*2
      else
        LWRK1 = LWRT1 + MAXL2
        LWRK2 = LWRK1 + MAXL3
        IF(DFTYPE.NE.RNONE) LWRK2 = LWRK1 + MAXL3*2
        LWRK3 = LWRK2 + MAXL3
        LAST  = LWRK3 + MAXL3
      end if
C

      IF (DODISTR) THEN
        ! LZVEC0 HAS TEMPORARY SPACE OF NOVMAX
        ! WHICH IS USED IN OFFORBHSS
        LZVEC0 = LAST
        LZVEC1 = LZVEC0 + NOVMAX*2
        LAST   = LZVEC1 + NOVMAX
        LIPTZC = LAST
      ELSE
        LZVEC0 = LAST
        LZVEC1 = LZVEC0 + NOVTOT
        LIPTZC = LZVEC1 + NOVTOT
        LAST   = LIPTZC + NFG
      END IF
CZ
      IF (IEFPFMO.EQ.2) THEN
        LZVECFLD = LAST
        LAST     = LZVECFLD + NPTTPT*3
      END IF
cz
      doesppc1  = iand(modgrd,8).ne.0.and.resppc(1).ne.zero.or.dftbfl
      maxnatnfg = maxnat*nfg
      lqindz    = last
      if (doesppc1) last = lqindz + maxnatnfg*2
C
      IF (DFTBFL) THEN
        LDIST = LAST
        LGAM2 = LDIST + MAXNAT*(MAXNAT+1)/2
        LAST  = LGAM2 + MAXNAT*(MAXNAT+1)/2
        IF (DFTB3) THEN
          LGAM3 = LAST
          LAST  = LGAM3 + MAXNAT*MAXNAT 
        END IF
        !! SHIFTCT MATRIX WILL GATHER SHIFT CONTRIBUTIONS OF KFG
        CALL VCLR(X(LSHIFTCT),1,NATFMO+NBDFG)
      END IF
C
      NEEDWK = LAST - LOADFM -1
      CALL GETFM(NEEDWK)
C
      IF (.NOT.DODISTR) THEN
        IPT = 1
        DO IFG = 1, NFG
          CALL IXSTOR(X(LIPTZC),IFG,IPT)
          IF (LAYFRG(IFG).GE.ILAY) THEN
            NQI = IAND(NQMTFG(IFG),65535)
            NAI = ISHFT(NUMFRG(IFG),-16)
            if(scffrg(ifg).eq.uhf)  NBI = NAI + 1 - mulfg(IFG)
            if(scffrg(ifg).eq.rohf) NBI = NAI + 1 - mulfg(IFG)
            IPT = IPT + (NQI-NAI)*NAI
            if(scffrg(ifg).eq.uhf)  IPT = IPT + (NQI - NBI) * NBI
            if(scffrg(ifg).eq.rohf) IPT = IPT + (NQI - NBI) * NBI
          END IF
        END DO
      END IF
      IF (doesppc1) then
        CALL VCLR(X(lqindz),1,maxnatnfg*2)
        if(.not.dftbfl) CALL VCLR(X(Lzppcpot),1,maxnatnfg)
      end if
C
C
C     SWITCH GDDI GROUPS TO MONOMERS (USING MONOMER GROUP DIVISION).
C
      IF (ISGDDI.AND.NGRFMO(1,ILAY).NE.0)
     *  CALL FMOPRE(ILAY,1,NGRFMO,MANNOD,MASTID,irmdfmo)
C
      IF (DODISTR) THEN
        CALL VCLR(X(LZVEC0),1,NOVMAX*2)
        CALL VCLR(X(LZVEC1),1,NOVMAX)
      ELSE
        CALL VCLR(X(LZVEC0),1,NOVTOT)
        CALL VCLR(X(LZVEC1),1,NOVTOT)
      END IF
      IF (IEFPFMO.EQ.2) THEN
        CALL VCLR(X(LDINDFMO) ,1,NPTTPT*3)
        CALL VCLR(X(LDINDDFMO),1,NPTTPT*3)
      END IF
CZ
C     SAVE FMOC
C---  IF(DOPBCMD) CALL GENFRGMIC(0,-1)
      IF(DOPBCMD) CALL GENIMAGEFG(0,0)
CZ
CZ    OUTERMOST LOOP
CZ
      IF (maswrk.and.mdout) WRITE(IW,9005)
      NTER  = 50
      if( iefmorun .gt. 0 .and. iefmo_agrad .gt. 0 ) nter = 2
      LCONV = .FALSE.
      DO ITER = 0, NTER
C
        ! IF NEVSAV.EQ.0, RESULT WOULD CORRUPT?
        LFIRST  = DODISTR.AND.ITER.EQ.0.AND.NEVSAV.LT.1
        DOSCZV  = (.NOT.DODISTR.AND.ITER.GT.0).OR.(.NOT.LFIRST)
        IF (IEFPFMO.EQ.2) CALL VCLR(X(LZVECFLD),1,NPTTPT*3)
        IF (ISWNEW1.EQ.1.and.modfd.eq.0) CALL VCLR(X(LDELEPOT),1,NTS)
        IF (ISWNEW1.EQ.1.and.modfd.ne.0) CALL VCLR(PEL,1,NTS)
        IF (doesppc1) CALL VCLR(X(lqindz+maxnatnfg),1,maxnatnfg)
CZ      IF (MASWRK) WRITE(6,*) 'LFIRST',LFIRST
        IF (OUT0) WRITE(IW,9000) ITER
C
CZ
CZ      MONOMER SCZV LOOP
CZ
        NCURSH = 0
        NCONV  = 0
        IF (ISGDDI) CALL GDDICOUNT(-1,LGROUP,MYJOB)
        DO 230 IIFG = 1,NFG
          IFG = IIFG
          IF (LOADHF.EQ.1) IFG = LOADM(IIFG)
C
C
          IF (LAYFRG(IFG).LT.ILAY) GOTO 230
          ICURFG = IFG
          IF (ISGDDI) THEN
            CALL GDDICOUNT(0,LGROUP,MYJOB)
            IF (.NOT.MYJOB) GOTO 230
          END IF
cpbc
C         GENERATE FRAGMENTS AROUND THE FRAGMENT IFG ACCOORDING TO
C         THE MINIMUM IMAGE CONVENTION. FMOC, CFRG, AND UNTXYZ ARE
C         DESTROYED (FMOC IS STORED IN FMOCTMP), AND SO THEY MUST
C         BE RESTORED LATER USING FMOCTMP.
C---      IF(DOPBCMD) CALL GENFRGMIC(IFG,0)
          IF(DOPBCMD) CALL GENIMAGEFG(2,IFG)
          IF(DOPBCMD) then
c          call makeindexiu(ilay,loadhf,loadm,x(lindat),x(lfmozan),
c     *                   x(lfmoc),x(liabdfg),x(ljabdfg),x(lscffrg),
c     *                   needr0,x(lrij),rwrk,mfg2,vdwrad,
c     *                   nprfrg,isgddi,nimgcell,natfmo+nbdfg,
c     *                   x(luntxyz),units,x(lindxiu),.false.)
          ENDIF
C
          IF (OUT0) WRITE(IW,9010) IFG
          CALL CLOSDA('DELETE')
          CALL OPENDA(0)
          NEVALS = 0
          CALL MAKEMOL(IFG,0,0,ILAY,0,0,0,0,0,0,0,.TRUE.)
          L1  = NUM
          L2  = (L1*L1+L1)/2
          L3  =  L1*L1
          NQI = IAND(NQMTFG(IFG),65535)
          NQMT = NQI
CZ        IF (MASWRK) WRITE(6,*) 'NUM NQMT',NUM,NQMT,NQI
c   for dft
          IF(DFTYPE.NE.RNONE) THEN
            CALL SYMOFF
            CALL MEMGRD
            CALL SYMON
          END IF
C
          !! CALCULATE GAMMA VALUES FOR I-TH FRAGMENT
          IF (DFTBFL) THEN
            NSEQ = 0
            DO I = 1, NAT
              DO J = 1, I-1
                NSEQ = NSEQ + 1
                X(LDIST+NSEQ-1) = SQRT((C(1,I)-C(1,J))**2
     *            + (C(2,I)-C(2,J))**2 + (C(3,I)-C(3,J))**2)
              END DO
              NSEQ = NSEQ + 1
              X(LDIST+NSEQ-1) = ZERO
            END DO
            CALL DFTB_GAMMA(DAMPXHE,HUBBL,X(LGAM2),X(LDIST),NAT,NSPE,
     *        ISPE,MAXANG,SPE,DAMPXH,SRSCC)
            IF (DFTB3) THEN
              CALL VCLR(X(LGAM3),1,NAT*NAT)
              CALL DFTB_GAMMA3(NAT,HUBBL,X(LGAM3),X(LDIST))
            END IF
          END IF
CZ
CZ        OPTION: FMO/EFP
CZ
          IF (DOSCZV.AND.IEFPFMO.EQ.1) THEN
            CALL VALFM(LOADFM)
            LPEX  = LOADFM + 1
            LPEY  = LPEX   + L2
            LPEZ  = LPEY   + L2
            LAST  = LPEZ   + L2
            NDEFP = LAST - LOADFM -1
            CALL GETFM(NDEFP)
C
            ! PEX, PEY, PEZ ARE STORED IN A FILE
            CALL POLINT(X(LPEX),X(LPEY),X(LPEZ),L2)
            CALL RETFM(NDEFP)
          END IF
C
CZ
CZ        WONDER HOW TO TREAT JANDK?
CZ
CZCZ      IF (ITER.GT.0) THEN
          IF (DOSCZV) THEN
            DIRSAV = DIRSCF
            DIRSCF = .TRUE.
            IST=1
            JST=1
            KST=1
            LST=1
            IF (.NOT.DFTBFL) CALL JANDK
            DIRSCF = DIRSAV
          END IF
C
C
CZCZ      IREC0=IDMREC0(ILAY)
C         HACK IT UP TO POINT TO RHF DENSITIES FOR RUNS WITH MP2 DENSITIES.
CZCZ      IF(DODDCOR) THEN
CZCZ        IREC0RHF=1
CZCZ        IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
CZCZ        IREC0=IREC0RHF
CZCZ      ENDIF
          IDMREC0I = IFG + IREC0
C
CZCZ      NAI  = ISHFT(NUMFRG(IFG),-16)
CZCZ      MULI = MULFG(IFG)
CZCZ      NBI  = NAI-MULI+1
          NAI  = NA
CZCZ      MULI = MUL
          NBI  = NB
C
CZ        NUMBERS OF OCC. AND VIR.
          NOCC = NAI
          NVIR = NQI - NOCC
C
          NVOC = NOCC*NVIR
          LCCC = L2 + 1
          LORB = L2 + L3 + 1
          if(scffrg(ifg).eq.uhf) then
            NOCCB = NBI
            NVIRB = NQI - NOCCB
            NVOCB = NOCCB * NVIRB
            LORB = L2+L3*2+1
            LORBB= LORB+L1
            LCCCB= LCCC+L3
            LNUM = L3*2+l1*2
            NNUM = NVOC + NVOCB
            SCAL = 2.0D+00
            urohf= .true.
          else if(scffrg(ifg).eq.rohf) then
            NOCCB = NBI
            NVIRB = NQI - NOCCB
            NVOCB = NOCCB * NVIRB
            LORBB= LORB
            LCCCB= LCCC
            LNUM = L3+l1
            NNUM = NVOC + NVOCB
            SCAL = 2.0D+00
            urohf= .true.
           else
            NOCCB = NBI
            NVIRB = NQI - NOCCB
            NVOCB = NOCCB * NVIRB
            LNUM = L3+L1
            LORBB= LORB
            LCCCB= LCCC
            NNUM = NVOC
            SCAL = 4.0D+00
            urohf= .false.
           end if

CZ
CZ        IN THE FMO/CPHF CASE, MOS AND ORBITAL ENERGIES ARE
CZ        ALWAYS READ IN.
CZ
          CALL VCLR(DA,1,L2+LNUM)
          CALL RAREADS(IDAFMO,IODFMO,DA(LCCC),LNUM,IDMREC0I,0)
          IF(DFTYPE.NE.RNONE) CALL dawrit(IDAF,IODA,DA(LCCC),l3,15,0)
          IF(DFTYPE.NE.RNONE.and.urohf) 
     *      CALL dawrit(IDAF,IODA,DA(LCCCB),l3,19,0)
          ! CONSTRUCT DENSITY: BE CAREFUL ABOUT THE LAST ARG.
          CALL DMTX2(DA,DA(LCCC),NAI,L1,L1,NBI)
C
CZ
CZ        IF (MASWRK) WRITE(6,*) 'DENSITY FOR ',IFG
CZ        CALL PRTRI(DA,L1)
CZ
CZ
CZ        COPY ZVEC0 TO ZVEC1
CZ
          IF (DODISTR) THEN
            LZ0PT = LZVEC0
            LZ1PT = LZVEC1
            IF (LFIRST) THEN
              CALL VCLR(X(LZVEC0),1,NVOC)
            ELSE
              CALL ZVECPUTGET(1,0,IFG,NVOC,X(LIPTZVEC),X(LZ0PT))
              CALL DCOPY(NVOC,X(LZ0PT),1,X(LZ1PT),1)
            END IF
          ELSE
            IPT   = IXFTCH(X(LIPTZC),IFG)-1
            LZ0PT = LZVEC0+IPT
            LZ1PT = LZVEC1+IPT
            if(scffrg(ifg).eq.uhf)  LZ2PT= LZ1PT + NVOC
            if(scffrg(ifg).eq.ROHF) LZ2PT= LZ1PT + NVOC
            if(scffrg(ifg).eq.rhf)  LZ2PT= LZ1PT
            IF (ITER.EQ.0) THEN
              CALL VCLR(X(LZ0PT),1,NNUM)
            ELSE
              CALL DCOPY(NNUM,X(LZ0PT),1,X(LZ1PT),1)
            END IF
          END IF
C
CZ
CZ        GET LAGRANGIAN LAG_I=SUM_KL{D_KL*TWOEI} (+ POLARIZATION)
CZ
          IF (LCONV) THEN
            IF (DODISTR) THEN
              ! CLEAR THE SPACE FOR THE NEXT CALCULATION OF ZLAG
              CALL VCLR(X(LWRK1),1,NVOC)
              CALL ZLAGACCGET(2,IFG,IPTLG,NVOC,X(LWRK1))
            END IF
          ELSE
            IF (DODISTR) THEN
              CALL ZLAGACCGET(1,IFG,IPTLG,NVOC,X(LWRK1))
            ELSE
c             IF (MASWRK) WRITE(IW,*) 'pre Z-VECTOR IN', IFG,IPTLG(IFG)
c             CALL PRSQ(ZVLAG(IPTLG(IFG)),NOCC,NVIR,NVIR)
              CALL DCOPY(NNUM,ZVLAG(IPTLG(IFG)),1,X(LWRK1),1)
            END IF
          END IF
C
          iter0=0
          ! LWRK1 IS LAGRANGIAN HERE
          IF (DODISTR) THEN
            IF (LFIRST) THEN
              CALL PRFCTMO(0,NVIR,NOCC,NVIR,X(LWRK1),X(LWRK2),DA(LORB),
     *                     FOUR)
              CALL DCOPY(NVOC,X(LWRK1),1,X(LZVEC1),1)
            ELSE
              IF (LCONV) THEN
                CALL DCOPY(NVOC,X(LZVEC1),1,X(LWRK1),1)
                CALL PRFCTMO(2,NVIR,NOCC,NVIR,X(LWRK1),X(LWRK2),
     *                       DA(LORB),ONE)
              ELSE
                CALL DSCAL(NVOC,FOUR,X(LWRK1),1)
                CALL FMOCGCP(IFG,ILAY,NOCC,NVIR,L1,L2,DA(LCCC),
     *                       X(LZVEC0),X(LZVEC1),NOVMAX,DA(LORB),
     *                       LAYFRG,IDMREC0,NQMTFG,DODISTR,X(LWRT1),
     *                       X(LWRK1),X(LWRK2),X(LWRK3),x(lqindz),
     *                       DA(LCCCB),DA(LORBB),scffrg(ifg).eq.uhf,
     *                       NBI,X(LZ2PT),scffrg,NAT,X(LGAM2),X(LGAM3),
     *                       iter0)
              END IF
            END IF
          ELSE
c$$$ for the first iteration (iter=0), we just set up a prefactor
c$$$ for the second, we'll actually solve for the Zvector
            IF (ITER.EQ.0) THEN
              CALL PRFCTMO(0,NVIR,NOCC,NVIR,X(LWRK1),X(LWRK2),DA(LORB),
     *                     SCAL)
              if(urohf) then
                 CALL PRFCTMO(0,NVIRB,NOCCB,NVIRB,X(LWRK1+NVOC),
     *                        X(LWRK2+NVOC),DA(LORBB),SCAL)
              end if
              CALL DCOPY(NNUM,X(LWRK1),1,X(LZ1PT),1)
c             IF (MASWRK) WRITE(IW,*) 'copied Z-VECTOR IN', IFG
            ELSEIF (ITER.GT.0) THEN
              IF (LCONV) THEN
                CALL DCOPY(NNUM,X(LZ1PT),1,X(LWRK1),1)
                CALL PRFCTMO(2,NVIR,NOCC,NVIR,X(LWRK1),X(LWRK2),
     *                       DA(LORB),ONE)
                if(urohf) then
                  CALL PRFCTMO(2,NVIRB,NOCCB,NVIRB,X(LWRK1+NVOC),
     *                         X(LWRK2+NVOC),
     *                         DA(LORBB),
     *                         ONE)
                end if
              ELSE
                CALL DSCAL(NNUM,SCAL,X(LWRK1),1)
                CALL FMOCGCP(IFG,ILAY,NOCC,NVIR,L1,L2,DA(LCCC),
     *                       X(LZVEC0),X(LZ1PT),X(LIPTZC),DA(LORB),
     *                       LAYFRG,IDMREC0,NQMTFG,DODISTR,X(LWRT1),
     *                       X(LWRK1),X(LWRK2),X(LWRK3),x(lqindz),
     *                       DA(LCCCB),DA(LORBB),urohf,
     *                       NBI,X(LZ2PT),scffrg,NAT,X(LGAM2),X(LGAM3),
     *                       iter0)
              END IF
            END IF
          END IF
c         IF (MASWRK) WRITE(IW,*) 'Z-VECTOR IN', IFG
c         CALL PRSQ(X(LZ1PT),NOCC,NVIR,NVIR)
CZ
CZ        CHECK THE FRAGMENT CONVERGENCE
CZ
          CONV_F = ZERO
          DO II = 0, NVOC-1
            DIFF = X(LZ1PT+II) - X(LZ0PT+II)
            CONV_F = CONV_F + DIFF*DIFF
          END DO
          if(urohf) then
            DO II = NVOC,NVOC+NVOCB-1
              DIFF = X(LZ1PT+II) - X(LZ0PT+II)
              CONV_F = CONV_F + DIFF*DIFF
            END DO
          end if
          CONV_F = SQRT(CONV_F/NNUM)
          IF (OUT1) then
            if(IAND(NPRFMO,3).le.1) WRITE(IW,9025) IFG, CONV_F, iter0
          else IF (out0) then
            WRITE(IW,9020) IFG, CONV_F, iter0
          endif
          IF (CONV_F.LE.THRSH.AND.MASWRK) NCONV = NCONV + 1
C
CZ
CZ        IF ALL THE FRAGMENT Z-VECTORS CONVERGE,
CZ        GO TO CALCULATION OF THE GRADIENT CONTRIBUTION: Z*B^A
CZ
CZCZ      LCONV = .TRUE.
CZCZ      IF (LCONV) THEN
          IF (LCONV.AND.ITER.GT.0) THEN
            ! GET TRI1 FROM ZVEC
            CALL SWBASIS(0,L1,NOCC,NVIR,DA(LCCC),X(LZ1PT),NVIR,
     *                   X(LWRK1),L1,X(LWRK3))
            CALL SQ2TRI(L1,L1,X(LWRK1),TRI1,HALF)
            if(urohf) then
              CALL SWBASIS(0,L1,NOCCB,NVIRB,DA(LCCCB),X(LZ2PT)
     *                    ,NVIRB,X(LWRK1+l3),L1,X(LWRK3))
              CALL SQ2TRI(L1,L1,X(LWRK1+l3),TRI1(L2+1),HALF)
            end if
CZ
            IF(DFTYPE.NE.RNONE)  THEN
             if(urohf) then
              CALL DCOPY(L3*2,X(LWRK1),1,X(LWRK1+L3*2),1)
c             ldftden=lwrk1 + l3*2
             else
              CALL DCOPY(L3,X(LWRK1),1,X(LWRK1+L3),1)
c             ldftden=lwrk1 + l3
             end if
            END IF
CZ          IF (MASWRK) WRITE(IW,*) 'MOS', IFG
CZ          CALL PRSQ(DA(LCCC),L1,L1,L1)
CZ          IF (MASWRK) WRITE(6,*) 'TRI1'
CZ          CALL PRTRI(TRI1,L1)
CZ
            ! GET TRI2: FOR S^A
            CALL SWBASIS(0,L1,NOCC,NVIR,DA(LCCC),X(LWRK2),NVIR,
     *                   X(LWRK1),L1,X(LWRK3))
            CALL SQ2TRI(L1,L1,X(LWRK1),TRI2,-HALF)

            if(urohf) then
              CALL SWBASIS(0,L1,NOCCB,NVIRB,DA(LCCCB),X(LWRK2+NVOC)
     *                    ,NVIRB,X(LWRK1+NVOC),L1,X(LWRK3+NVOC))
              CALL SQ2TRI(L1,L1,X(LWRK1+NVOC),TRI2(L2+1),-HALF)
            end if

C
C
            IF (DFTBFL) THEN
             CALL DFTB_ESDCPHF(IFG,ILAY,TRI1,TRI2,L1,L2,FMODE,
     *                     SCFFRG,X(LWRT1),X(LWRK1),X(LWRK2),
     *                     HOPGRD)
            ELSE
              CALL ESDCPHF(IFG,ILAY,DA,TRI1,TRI2,L1,L2,FMODE,LAYFRG,
     *                     SCFFRG,IDMREC0,0,0,0,X(LWRT1),X(LWRK1),
     *                     X(LWRK2),X(LWRK3),HOPGRD,NAI,NBI,X(LZ1PT),
     *                     NQMTFG)
            END IF
CZ          IF (MASWRK) WRITE(IW,*) 'Z-VECTOR IN', IFG
CZ          CALL PRSQ(X(LZ1PT),NOCC,NVIR,NVIR)
          END IF
C
CZ
CZ        potential due to Z-vector (TRI1) is updated for
CZ        new FMO/EFP, FMO/PCM<1> and ESP-PC approximation
CZ
          if (iefpfmo.eq.2.or.iswnew1.eq.1.or.doesppc1) then
            CALL SWBASIS(0,L1,NOCC,NVIR,DA(LCCC),X(LZ1PT),NVIR,
     *                   X(LWRK1),L1,X(LWRK3))
            CALL SQ2TRI(L1,L1,X(LWRK1),TRI1,HALF)
            if(scffrg(ifg).eq.uhf.or.scffrg(ifg).eq.rohf) then
              CALL SWBASIS(0,L1,NOCCB,NVIRB,DA(LCCCB),X(LZ2PT)
     *                    ,NVIRB,X(LWRK1+NVOC),L1,X(LWRK3+NVOC))
              CALL SQ2TRI(L1,L1,X(LWRK1+NVOC),TRI1(L2+1),HALF)
            end if
          end if
CZ
          if(scffrg(ifg).eq.uhf.or.scffrg(ifg).eq.rohf)
     *    call daxpy(l2,ONE,TRI1(l2+1),1,TRI1,1)
          if (doesppc1) then
            call calcqindz(ifg,l1,l2,tri1,x(lwrk1),x(lqindz+maxnatnfg),
     *                     x(lwrk2))
            if (lconv.and..not.dftbfl) 
     *      call getddijpot(1,0,TRI1,L2,X(LZPPCPOT))
          end if
CZ
          IF (IEFPFMO.EQ.2) THEN
            ! GET ELECTROSTATIC FIELD DUE TO ZVEC 
            CALL VALFM(LOADFM)
            LPEX     = LOADFM  + 1
            LPEY     = LPEX    + L2
            LPEZ     = LPEY    + L2
            LTMPFLD  = LPEZ    + L2
            LAST     = LTMPFLD + NPTTPT*3 
            NDEFP = LAST - LOADFM -1
            CALL GETFM(NDEFP)
            CALL VCLR(X(LTMPFLD),1,NPTTPT*3)
            CALL DRCTPOL(1,NPTTPT,L1,L2,.FALSE.,.TRUE.,DUM,X(LTMPFLD),
     *                   TRI1,DUM,DUM,DUM,X(LPEX),X(LPEY),X(LPEZ))
            IF (MASWRK) 
     *      CALL DAXPY(NPTTPT*3,ONE,X(LTMPFLD),1,X(LZVECFLD),1)
            CALL RETFM(NDEFP)
          END IF
CZ
CZ        FMO/PCM<1>
CZ
          IF (ISWNEW1.EQ.1) THEN
            ! ONE CAN USE LDELEPOT AS A WORKING SPACE HERE
            if(modfd.eq.0) then
             CALL EPOTEN(-ONE,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),
     *                   X(LDELEPOT),TRI1,NTS,L2)
            else
             call EPOTEN3(-ONE,XYZCTS(1,1),XYZCTS(1,2),XYZCTS(1,3),
     *            PEL,TRI1,NTS,L2,mappcm)
            end if
          END IF
CZ
          IF (DODISTR) THEN
            ! PUT NEW ZVEC
            CALL ZVECPUTGET(0,NFG,IFG,NVOC,X(LIPTZVEC),X(LZ1PT))
          ELSE
            IF (GOPARR) CALL DSCAL(NNUM,ONE/NPROC,X(LZ1PT),1)
          END IF
  230   CONTINUE
        IF (OUT0) CALL TIMIT(1)
Cpbc
C       RESTORE THE ORIGINAL ATOMIC COORDINATES
C---    IF(DOPBCMD) CALL GENFRGMIC(0,1)
        IF(DOPBCMD) CALL GENIMAGEFG(1,0)
        IF(DOPBCMD) then
c          call makeindexiu(ilay,loadhf,loadm,x(lindat),x(lfmozan),
c     *                   x(lfmoc),x(liabdfg),x(ljabdfg),x(lscffrg),
c     *                   needr0,x(lrij),rwrk,mfg2,vdwrad,
c     *                   nprfrg,isgddi,nimgcell,natfmo+nbdfg,
c     *                   x(luntxyz),units,x(lindxiu),.false.)
C
       ENDIF
C
        IF (ISGDDI) CALL GDDICOUNT( 1,LGROUP,MYJOB)
        IF (DODISTR) THEN
          IF (ISGDDI) THEN
            CALL GDDI_SCOPE(DDI_WORLD)
            CALL DDI_GSUMI(3004,NCONV,1)
            CALL GDDI_SCOPE(DDI_GROUP)
          ELSE
            CALL DDI_BCAST(3004,'I',NCONV,1,0)
          END IF
        ELSE
          IF (ISGDDI) THEN
            CALL GDDI_SCOPE(DDI_WORLD)
            CALL DDI_GSUMF(3003,X(LZVEC1),NOVTOT)
            CALL DDI_GSUMI(3004,NCONV,1)
            CALL GDDI_SCOPE(DDI_GROUP)
          ELSE
            CALL DDI_GSUMF(3003,X(LZVEC1),NOVTOT)
            CALL DDI_BCAST(3004,'I',NCONV,1,0)
          END IF
        END IF
C
        IF (LCONV.AND.ITER.GT.0) THEN
          IF (maswrk.and.IAND(NPRFMO,3).le.1) WRITE(IW,9040) ITER
          GOTO 555
        END IF
CZCZ    IF ((NCONV.EQ.NFG.AND.ITER.GT.0).OR.ITER.EQ.NTER-1)
CZCZ *     LCONV = .TRUE.
CZCZ    IF (OUT) WRITE(IW,9030) NCONV, ITER
C
        IF (DODISTR) THEN
          IF (ISGDDI) CALL GDDICOUNT(-1,LGROUP,MYJOB)
          DO 444 IFG = 1, NFG
            IF (LAYFRG(IFG).LT.ILAY) GOTO 444
            IF (ISGDDI) THEN
              CALL GDDICOUNT(0,LGROUP,MYJOB)
              IF (.NOT.MYJOB) GOTO 444
            END IF
            NQI  = IAND(NQMTFG(IFG),65535)
            NAI  = ISHFT(NUMFRG(IFG),-16)
            NVOC = (NQI-NAI)*NAI
            CALL ZVECPUTGET(1,NFG,IFG,NVOC,X(LIPTZVEC),X(LZVEC0))
            CALL ZVECPUTGET(0,  0,IFG,NVOC,X(LIPTZVEC),X(LZVEC0))
  444     CONTINUE
          IF (ISGDDI) CALL GDDICOUNT( 1,LGROUP,MYJOB)
        ELSE
          CALL DCOPY(NOVTOT,X(LZVEC1),1,X(LZVEC0),1)
          CALL VCLR(X(LZVEC1),1,NOVTOT)
        END IF
CZ
CZ      WORLD SCOPE
CZ
        if (iefpfmo.eq.2.or.iswnew1.eq.1.or.doesppc1) then
          IF (ISGDDI) THEN
            CALL GDDI_SCOPE(DDI_WORLD)
            if (iefpfmo.eq.2) CALL EFPPARL
          END IF
        end if
CZ
CZ      GENERATE THE INDUCED DIPOLE DUE TO Z-VECTORS
CZ
        IF (IEFPFMO.EQ.2) THEN
          CALL DDI_GSUMF(3004,X(LZVECFLD),NPTTPT*3)
          CALL DINDPROD(X(LZVECFLD),X(LDINDFMO),X(LDINDDFMO))
        END IF
CZ
CZ      INDUCED CHARGE DUE TO MONOMER Z-VECTORS IN FMO/PCM<1>
CZ
        IF (ISWNEW1.EQ.1) THEN
          if(modfd.eq.0) then
           CALL DDI_GSUMF(3005,X(LDELEPOT),NTS)
           LPNT = LQSETMP
           IF(IHET.EQ.1) LPNT= LQSETMP + NTS
           ITER0 = ITER + 1
           CALL INDQPROD(ITER0,NTSPAR,LFPNT,NDASC,X(LDELEPOT),
     *                  X(LQSETMP),X(LPNT),modep)
          else
           ITER0 = ITER + 1
           imode = 4
           IF(ITER.GE.1) imode=5
           CALL DDI_GSUMF(3005,PEL,NTS)
           call mltfmopcm(imode,lfmasc,needasc,needmul,mappcm,idum)
          end if
        END IF
cz
cz      mulliken charge due to z-vectors in the ESP-PC approximation
cz
        if (doesppc1) then
          CALL DDI_GSUMF(3007, X(lqindz+maxnatnfg),maxnatnfg)
          CALL DCOPY(maxnatnfg,X(LQINDZ+MAXNATNFG),1,X(LQINDZ),1)
cz        write(6,'(8F12.8)') (X(lqindz+jfk),jfk=0,maxnatnfg-1)
        end if
C
        if (iefpfmo.eq.2.or.iswnew1.eq.1.or.doesppc1) then
          IF (ISGDDI) THEN
            CALL GDDI_SCOPE(DDI_GROUP)
            if (iefpfmo.eq.2) CALL EFPPARL
          END IF
        end if

        IF ((NCONV.EQ.NLAYFRG.AND.ITER.GT.0).OR.ITER.EQ.NTER-1)
     *     LCONV = .TRUE.
        IF (OUT1) then
           if(mdout.or.NCONV.eq.nfg)
     *     WRITE(IW,9035) NCONV, ITER
        else IF (OUT0) then
           WRITE(IW,9030) NCONV, ITER
        endif
      END DO
C
  555 CONTINUE
CZ
CZ    NEW FMO/EFP
CZ
      IF (IEFPFMO.EQ.2) THEN
        CALL DNEWIND2(1,ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,
     *                X(LIPTZC),X(LZVEC0),FMODE,ORBXCH,NUMFRG,IODFMO,
     *                LAYFRG,SCFFRG,ISGDDI,IREC0,NGRFMO,MANNOD,
     *                MASTID,NQMTFG,X(LWRT1),X(LWRK1),X(LWRK2),X(LWRK3))
      END IF
      IF (ISWNEW1.EQ.1) THEN
        CALL FMOPCMREMD(1,NTS,ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,
     *                  X(LIPTZC),X(LZVEC0),FMODE,ORBXCH,NUMFRG,
     *                  IODFMO,LAYFRG,SCFFRG,IREC0,
     *                  NGRFMO,MANNOD,MASTID,NQMTFG,mulfg,
     *                  lfmasc,needasc,needmul,mappcm)
      END IF
      if (doesppc1.and..not.dftbfl) then
        CALL ESPPCDER(1,ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,
     *                X(LZPPCPOT),FMODE,ORBXCH,NUMFRG,
     *                IODFMO,LAYFRG,SCFFRG,ISGDDI,IREC0,
     *                NGRFMO,MANNOD,MASTID,NQMTFG,mulfg,irmdfmo)
      end if
C     ADD GRADIENT OF KFG LOOP
      IF (DFTBFL) THEN
        CALL DFTB_ZVEC_KGRAD(LAYFRG,X(LNATFRG),X(LIATFRG),X(LINDFRG),
     *    FMODE,IDMREC0,NUMFRG,IODFMO,X(LISPE),X(LFMOC),MODORB,
     *    out1.and.MDOUT)
      END IF
CZ
      CALL RETFM(NEEDWK)
      RETURN
 9000 FORMAT(/1X,60(1H+)/
     *        1X,60(1H-)/
     *        3X,' FMO CPHF CALCULATION AT ITERATION:',I5/
     *        1X,60(1H-)/
     *        1X,60(1H+))
 9005 FORMAT(/1X,' Self-consistent Z-vector driver (T. Nagata).',/)
 9010 FORMAT(/3X,44(1H=)/
     *        5X,' SCZV CALCULATION FOR IFG=',I5/
     *        3X,44(1H=))
 9020 FORMAT(/3X,60(1H#)/
     *        5X,'FOR FRAG.:',I7,' Z-VECTOR DEV:',F12.8,' IN',I3,
     *        ' ITERATIONS',/3X,60(1H#))
 9025 FORMAT(5X,'FOR FRAG.:',I7,' Z-VECTOR DEV:',F12.8,' IN',I3,
     *        ' ITERATIONS')
 9030 FORMAT(/1X,60(1H*)/
     *        3X,I7,' Z-VECTORS HAVE CONVERGED SO FAR AT ITER=',I4/
     *        1X,60(1H*))
 9035 FORMAT(3X,I7,' FRAGMENTS HAVE CONVERGED SO FAR ON ITER=',I4,/)
 9040 FORMAT(/1X,60(1H*)/
     *        3X,'RESPONSE CALCULATIONS ARE ALL DONE IN FMO AT ITER=',
     *        I4/
     *        1X,60(1H*))
      END
C*MODULE FMOCP   *DECK ESDCPHF
C>
C>     @brief CPHF for ES dimers
C>
C>     @details Do CPHF for ES dimers.
C>
C>     @author Takeshi Nagata
C>
C>     @date January, 2017 C.Bertoni
C>         - Changes for the EFMO gradient
C>
      SUBROUTINE ESDCPHF(IXFG,IXLAY,DX,TRI1,TRI2,L1,L2,FMODE,
     *                   LAYFRG,SCFFRG,IDMREC0,IDAM,IDAD,IDAT,
     *                   WRT1,WRK1,WRK2,WRK3,HOPGRD,NAI,NBI,ZVEC1,
     *                   NQMTFG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXSH=5000,MXGTOT=20000,MXAO=8192,MXGSH=30,
     *           MXG2=MXGSH*MXGSH,MXRT=100,MAXL=5)
      PARAMETER (HALF=0.5D+00,ZERO=0.0D+00,ONE=1.0D+00)
C
      LOGICAL DIRSCF,FDIFF,DIRSAV,SCHWRZ,PACK2E,GOPARR,DSKWRK,MASWRK,
     *        OUT,SOME,BSSEDIM,ORBXCH,SAVGOP,ESPPAR,NXT,ESPAP,DODDCOR,
     *        ESDDER,LARGEPRI,LCFLAG,LRINT,LCFLAGS,LRINTS,camflag
      LOGICAL camflags,ESDER,HOPGRD,EFLDL,urohf
C
      DIMENSION LAYFRG(*),SCFFRG(*),IDMREC0(*),KARTEN(0:MAXL-1)
      DIMENSION DX(1), TRI1(1), TRI2(1)
      DIMENSION WRT1(*),WRK1(*),WRK2(*),WRK3(*)
      DIMENSION FMODE(3,*),ZVEC1(*),NQMTFG(*)
C
      COMMON /DFTCAM/ ALPHAC,BETAC,CAMMU,CAMVWN,CAMLYP,CAMFLAG
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2,maxrij
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMOPMD/ FMOBOX(3),MDWPBC,NIMGCELL,IMGLVL,
     *                LTRVEC,LFMOGCTR,LFMOCTMP,LINDATMD,LWRKDSAV,LINDXIU
     *               ,IPBCFST
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TT(432),INVT(48),NT
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP,iefmo_agrad
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCPFMO/ IMCPFMO,LFZCOR,LIFMPTYP,LIFMPTYP2,LMCPSW,
     *                LIZCOR2,IMP0,JMP0,ICORSH0,IGTF0,IECPFMO
      COMMON /MMPDOC/ MPTYP(MXATM),IMVO,IMCORE
      COMMON /NLRC  / LCFLAG,EMU,EMU2,LRFILE
      COMMON /NLRCF / LRINT
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,NANGM,NGTH(4)
      COMMON /EFLDC / EVEC(3),EFLDL
c     COMMON /INFGRD/ RHOMIN,ILENG,MAXGRD
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
CZ
CZ    common /ppcpnt/ lddijpot,lzppcpot,lvipot,lgrdtest
cz
C
      DATA KARTEN/1,4,6,10,15/
      DATA RHF/8HRHF     /,RMC/8HMCSCF   /,UHF/8HUHF     /,
     *     DBGFMO/8HDBGFMO  /,DBGME/8HFMOESP  /,DEBUG/8HDEBUG   /
      DATA ROHF/8HROHF    /
      DATA RNONE/8HNONE    /
CZ
CZ    THIS ROUTINE COMPUTES THE RESPONSE TERMS IN FMO.
CZ
C     PARSTAT: GROUPFULL/GROUPNONE
C
C     FOR NBSSE=3 MONOMERS AND DIMERS DURING BSSE RUNS ARE IN VACCUUM
      IF(NBSSE.EQ.3.AND.IFMOSTP.EQ.5. OR. IFMOSTP.EQ.1) RETURN
      IF (IFMOSTP.EQ.6) THEN
        WRITE (IW,*) 'IFMOSTP=6 IS NOT ALLOWED IN FMOESDER'
        CALL ABRT
      END IF
      IF (IFMOSTP.NE.2.AND.IFMOSTP.NE.4.AND.IFMOSTP.NE.9) RETURN
C
      SOME=(EXETYP.EQ.DEBUG.OR.EXETYP.EQ.DBGFMO.OR.EXETYP.EQ.DBGME).AND.
     *     MASWRK
      ORBXCH=MOD(MODORB,2).NE.0
C     ENEXCH=MOD(MODORB/2,2).NE.0
      ESPPAR=MOD(MODPAR/2,2).NE.0.AND.GOPARR
C     .TRUE.  DIVIDE FRAGMENTS
C     .FALSE. DIVIDE SHELLS
CZ    LWRKDEN  = LFMOBUF(1)  ! LWRK  -> TRI1
      LWRKESP  = LFMOBUF(2)  ! LWRK2 -> DIJ
CZ    LWRKESP2 = LFMODB      ! DB    -> TRI2
      IF(NAT.LT.0) WRITE(IW,*) IDAT
C
C
C     FOR MONOMER SCF THERE IS NO NEED TO ADJUST IREC0 BELOW (AND MPPROP MAY
C     NOT HAVE BEEN READ ANYWAY).
C
      IFG      = IXFG
      ILAY     = IXLAY
      L3       = L1*L1
c     LX       = IAND(NQMTFG(IFG),65535)
C
      IF(IFG.EQ.0) RETURN
C
C
C     ESP IS NOT NEEDED. THIS HAPPENS WHEN MONOMER/DIMER SCF ITERATIONS RUN.
C     (ESP IS COMPUTED BEFORE SUCH ITERATIONS ALONG WITH 1-EL INTEGRALS)
C
      CALL DERCHK(NDER)
CZ
CZ    IESDPPC=1 AVOIDS ADDITION OF FMO/PCM REDUNDANT GRADIENTS IN SUBROUTINE FMODEG
CZ
      IESDPPC = 1   ! ALREADY SET IN FMOESDER?
CZ
      ESDER = NDER.GT.0.AND.IAND(MODGRD,32).NE.0
      IF (.NOT.ESDER) THEN
        WRITE(IW,*) 'MUST DEBUG FOR ESDCPHF'
        CALL ABRT
      END IF
CZ    ESDDER=IFMOSTP.EQ.6.AND.RESDIM.NE.0.AND.IAND(IXESP,32).EQ.0.AND.
CZ   *       NDER.GT.0
      ESDDER=.TRUE.
C
CZCZ
CZCZ  JFG AND LFG SHOULD BE CHANGED ??
CZCZ
CZCZ  JFG  = JCURFG
CZCZ  LFG  = KCURFG
      JFG  = 0
      LFG  = 0
CZCZ
      KFG0 = 1
      KFG1 = NFG
      IZ   = 1
cpbc
      IUNIT0 = 0
      IUNIT1 = 0
      IF(MDWPBC.NE.0) THEN
        IF(NBODY.GT.2) CALL ABRT
        IUNIT0 = 0
        IUNIT1 = NIMGCELL
      END IF
CZ
      RESPAPI=RESPAP(IZ)
      RESPPCI=RESPPC(IZ)
      BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5
      IF(BSSEDIM) JFG=0
      DODDCOR=IAND(IXESP,1024).NE.0
C
C     SCHWRZ = ISCHWZ.GT.0
      SCHWRZ = .TRUE.
C     DO NOT THINK THAT YOU CAN SET SCHWRZ TO .FALSE. AND GET AWAY WITH IT.
C     SCHWRZ ALSO FORCES INTEGRAL INITIALISATION THAT WILL OTHERWISE NOT BE
C     DONE.
C
      DIRSAV  =  DIRSCF
      DIRSCF  = .TRUE.
C     SCFTYP1 = SCFTYP
C     IF(SCFTYP.EQ.RMC) SCFTYP1=RHF
      SCFTYP1 = RHF
      OUT=SCHWRZ.AND.MASWRK.AND.IAND(NPRFMO,3).EQ.0
C
CZCZ  CALL VCLR(X(LFMOESPA),1,L2)
CB    CALL VCLR(X(LFMOESPB),1,L2)
C
CZ
CZ    NOTE IN 11/23/09: HOW I TREAT ICURFG?
CZ    THIS ROUTINE PROCCEDS TO ESVDER AND EXTHELFEY WHERE
CZ    ICURFG IS USED IN FMOATFRG AND ICURFG NEVER EQUALS TO IXFG
CZ    SHOULD I CHANGE THE VALUE OF ICURFG BEFORE ESVDER AND EXTHELFEY?
C
      NPRSAV=NPRFMO
      IF(NPRINT.EQ.-5.AND.IAND(NPRFMO,3).EQ.0) NPRFMO=NPRFMO+1
C     THAT IS, ENFORCE REDUCED OUTPUT IF NPRINT.EQ.-5
C     FOR ESPS THE ONLY MEANINGFUL USAGE OF LOADM IS WITH TRUE ESPPAR.
C     LOADM SHOULD ONLY BE USED IF FULL RANGE OF FRAGMENTS IS TREATED
C     (THAT IS, EXCLUDING SEPARATED DIMERS).
      LOADHF=MOD(MODPAR,2)
      LARGEPRI=LOADHF.EQ.1.AND.ESPPAR.AND.KFG0.EQ.1.AND.KFG1.EQ.NFG
C     WRITE(6,*) 'WWWLB',LARGEPRI
C
CZ
CZ    CLEAR DE FIRST FOR INTERNAL CONTRIBUTIONS
CZ
      CALL VCLR(DE,1,NAT*3)
CZ
CZ    (1). BASIS FUNCTION DERIVATIVE CONTRIBUTION OF 1E INTEGRALS
CZ         TO FOCK DERIVATIVES
CZ    THE CONTRIBUTIONS ARE DIRECTLY STORED IN FMODE().
      urohf = scffrg(ifg).eq.uhf.or.scffrg(ifg).eq.rohf
CZ
      if( iefmorun .gt. 0 .and. iefmo_agrad .gt.0) then
         CALL TVDER(TRI1,WRK1,WRK2,L2,0)
      else
         CALL ESVDER(1,0,TRI1,WRK1,WRK2,L2,0,FMODE,FMODE,.TRUE.)
      endif
      if(urohf)
     *   CALL ESVDER(1,0,TRI1(l2+1),WRK1,WRK2,L2,0,FMODE,FMODE,.TRUE.)

      IF(DFTYPE.NE.RNONE) THEN
C      for DFT| both close and open shell
       ldftden= 1 + l3
       if(urohf) ldftden= 1 + l3*2
       CALL tdder2(wrk1(ldftden),L1,DX,urohf,NAI,NBI)
       CALL SYMOFF
       CALL MEMGRD
       CALL SYMON
      END IF
C
CZ    ONE = 1.0D+00
CZCZ  IF (GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
CZ    IF (MASWRK) THEN
CZ      WRITE(6,*) 'ESVDER',NCURSH,NSHELL
CZ      DO I = 1, NAT
CZ        WRITE(6,'(3F12.8)') DE(1,I),DE(2,I),DE(3,I)
CZ      END DO
CZ    END IF
CZCZ  IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
CZ
CZ    (2). HELMANN-FEYNMAN CONTRIBUTION TO FOCK DERIVATIVES
CZ
      ! SECOND FMODE IS DUMMY IN THE PRESENT VERSION
      if( iefmorun .gt. 0 .and. iefmo_agrad .gt. 0) then
         CALL HELFEY(TRI1,WRK1,L2)
      else
         CALL EXTHELFEY(1,0,TRI1,WRK1,L2,FMODE,FMODE,.TRUE.)
      endif
      if(urohf)
     * CALL EXTHELFEY(1,0,TRI1(l2+1),WRK1,L2,FMODE,FMODE,.TRUE.)

C
C
      IF(EFLDL) THEN
        CALL EFLD2(TRI1,L2)
        if(urohf) CALL EFLD2(TRI1(L2+1),L2)
      END IF
CZCZ  IF (GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
CZ    IF (MASWRK) THEN
CZ      WRITE(6,*) 'ESVDER+HELFEY'
CZ      DO I = 1, NAT
CZ        WRITE(6,'(3F12.8)') DE(1,I),DE(2,I),DE(3,I)
CZ      END DO
CZ    END IF
CZCZ  IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
CZ
CZ    (3). OVERLAP DERIVATIVE CONTRIBUTION TO RESPONSE
CZ
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
      CALL BASCHK(LMAX)
      IF(LMAX.GE.5) THEN
         IF(MASWRK) WRITE(IW,*) 'FMO HAS NOT BEEN REVIEWED FOR H,I'
         CALL ABRT
      END IF
C     FOR SOME REASON GAMESS LIKES TO HANDLE AT LEAST L-SHELLS
      NANGM=KARTEN(MAX(LMAX,1))
      MAXG = NANGM**4
      CALL VALFM(LOADFM)
C
      LXINTS= LOADFM + 1
      LGHOND= LXINTS + NSH2
      LDSH  = LGHOND + MAXG
      LDSHB = LDSH   + NSH2
      LDDIJ = LDSHB  + NSH2
      LAST  = LDDIJ  + 49*MXG2
      NEED1 = LAST - LOADFM -1
      CALL GETFM(NEED1)

      if(scffrg(ifg).eq.rhf) then
         l2d  = l2
         l2b  =  1
      else
         l2d  = l2*2
         l2b  = L2+1
      end if

C     Extra exchange terms for rohf
      if(scffrg(ifg).eq.rohf) then
         NSO = NAI - NBI 
         CALL DMTX2(TRI1(L2*2+1),DX(L2+1+L1*NBI),NSO,l1,l1,0) 
         l2d = l2 * 3
      end if

      IF(SCHWRZ) THEN
        DUMMY = 0.0D+00
        CALL SHLDEN(scffrg(ifg),TRI1,TRI1(l2b),DUMMY,X(LDSH),IA,
     *              L1,L2,NSH2,1)
        IF(scffrg(ifg).eq.rohf) then
          CALL SHLDEN(RHF,TRI1(l2*2+1),TRI1(L2*2+1),DUMMY,X(LDSHB),
     *       IA, L1,L2,NSH2,1)
          DO ISH = 1,NSH2
            X(LDSH-1+ISH)=MAX(X(LDSH-1+ISH),X(LDSHB-1+ISH))
          END DO 
        end if 
        ! XINTS IS STORED IN DISK IN THIS CASE (NCURSH IS 0)
        CALL EXCHNG(X(LXINTS),X(LGHOND),X(LDDIJ),NSH2,MAXG,INTTYP)
      END IF
C
      NXYZ = 1 ! IF NXYZ = NAT*3, IT IS JUST FOR RESPONSE
      IF(scffrg(ifg).eq.rohf) NXYZ = 2
      NINT  =0
      NSCHWZ=0
      IST=1
      JST=1
      KST=1
      LST=1
CZCZ  CALL JANDK
CZ
CZ     IN: TRI1 SYMMETRIZED Z-VECTOR
CZ    OUT: WRK1     FOCK-LIKE MATRIX
CZ
      IDUMMY=1
      CALL VCLR(WRT1,1,L2d)
      IF(LCFLAG) THEN
        LRINT=.TRUE.
        CALL TWOEI(scffrg(ifg),DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *             INTTYP,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *             DUMMY,DUMMY,IDUMMY,1,X(LXINTS),NSH2,X(LGHOND),
     *             MAXG,X(LDDIJ),IA,TRI1,WRT1,TRI1(l2b),WRT1(l2b),
     *             X(LDSH),DUMMY,DUMMY,NXYZ)
        LRINT=.FALSE.
      END IF
      CALL TWOEI(scffrg(ifg),DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *           INTTYP,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *           DUMMY,DUMMY,IDUMMY,1,X(LXINTS),NSH2,X(LGHOND),
     *           MAXG,X(LDDIJ),IA,TRI1,WRT1,TRI1(l2b),WRT1(l2b),
     *           X(LDSH),DUMMY,DUMMY,NXYZ)
      CALL RETFM(NEED1)
      CALL DSCAL(L2d,HALF,WRT1,1)
      II = 0
      DO I=1, L1
        II = II+I
        WRT1(II) = WRT1(II) + WRT1(II)
        if(urohf) WRT1(II+L2) = WRT1(II+L2) + WRT1(II+L2)
        IF(scffrg(ifg).eq.rohf) THEN
          WRT1(II+l2*2) = WRT1(II+l2*2) + WRT1(II+l2*2)
        END IF
      ENDDO
C     DFT XC
      IF(DFTYPE.NE.RNONE) THEN
        if(urohf) CALL UDFTFCK(UHF,L1,L2,IA,tri1,tri1(l2+1),
     *                         wrt1,wrt1(l2+1),1)
        if(.not.urohf) CALL DFTFCK(RHF,L1,L2,IA,tri1,wrt1,1) 
      END IF
C
CZ
CZ    OPTION (1). EFP CONTRIBUTION
CZ
C     THIS POSITION IS THE BEST, BECAUSE THE CONTRIBUTION TO
C     S^A SHOULD BE MERGED WITH OTHER S^A TERMS.
      IF (IEFPFMO.EQ.1) CALL EFPCNT2RSP(L1,L2,DX,TRI1,WRT1)
CZ
C
      IF (GOPARR) CALL DDI_GSUMF(2418,WRT1,L2d)
CZ    IF (MASWRK) WRITE(6,*) 'TRI*TWOEI MATRIX'
CZ    CALL PRTRI(WRT1,L1)
C
      ! NOTE THAT WRK2 WORKS AS TRIANGLE MATRIX
      if(scffrg(ifg).eq.rhf) then
        CALL CPYTSQ(DX,WRK1,L1,1)
        CALL TFTRI(WRK2,WRT1,WRK1,WRK3,L1,L1,L1)
        CALL DAXPY(L2,-HALF,WRK2,1,TRI2,1)
      else if(urohf) then
        CALL DMTX2(DX,DX(l2+1),NAI,L1,L1,0)
        CALL CPYTSQ(DX,WRK1,L1,1)
        CALL TFTRI(WRK2,WRT1,WRK1,WRK3,L1,L1,L1)
        CALL DAXPY(L2,-one,WRK2,1,TRI2,1)
        l3=l1*l1
        if(scffrg(ifg).eq.uhf)  CALL DMTX2(DX,DX(l2+l3+1),NBI,L1,L1,0)
        if(scffrg(ifg).eq.rohf) CALL DMTX2(DX,DX(l2+   1),NBI,L1,L1,0)
        CALL CPYTSQ(DX,WRK1,L1,1)
        CALL TFTRI(WRK2,WRT1(l2+1),WRK1,WRK3,L1,L1,L1)
        CALL DAXPY(L2,-one,WRK2,1,TRI2(l2+1),1)
        CALL DAXPY(L2,one,TRI2(l2+1),1,TRI2,1)
        if(scffrg(ifg).eq.rohf) then
          NQI  = IAND(NQMTFG(IFG),65535)
          NOCC = NAI
          NOCCB= NBI
          NVIR = NQI-NAI
          NVIRB= NQI-NBI
          NOV  = NVIR*NOCC
          CALL EXINT2_ROHF(WRT1(L2*2+1),WRK3,WRK1,DX(l2+1),L1,L2,NQI,
     *         NOCC,NVIR,NOCCB,NVIRB,ZVEC1,ZVEC1(1+NOV),
     *         TRI2)
        end if
      end if
C
CZ    IF (MASWRK) WRITE(6,*) 'DENSITY-LIKE MAT FOR SDER'
CZ    CALL PRTRI(TRI2,L1)
C
      CALL SDER(TRI2,WRK1,L1,L2,.FALSE.)
      ! FROM NOW ON, TRI2 IS USED AS WORK SPACE
CZCZ  IF (GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
CZ    IF (MASWRK) THEN
CZ      WRITE(6,*) '+ SDERIVATIVE CONTRIBUTION'
CZ      DO I = 1, NAT
CZ        WRITE(6,'(3F12.8)') DE(1,I),DE(2,I),DE(3,I)
CZ      END DO
CZ    END IF
CZCZ  IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
C
CZ
CZ    (4) HOP DERIVATIVE CONTRIBUTION
CZ
      IF (HOPGRD) THEN
        I2D = 0
        I3D = 0
        IF (NBODY.EQ.2) I2D = 1 
        IF (NBODY.EQ.3) I3D = 1 
CZ      WRITE(6,*) 'HOPDER IN SCZV'
        CALL HOPDER(1,0,I2D,I3D,L1,L2,TRI1,WRK1,WRK2,DUM)
        if(urohf)  then
          CALL HOPDER(1,0,I2D,I3D,L1,L2,TRI1(L2+1),WRK1,WRK2,DUM)
        end if
      END IF
CZ
CZ    (5). TWO-ELECTON CONTRIBUTION TO FOCK DERIVATIVES
CZ         HERE JUST FOR INTERNAL FRAGMENT IXFG
CZ         JKDER IS NOT APPLIED AS IT IS, BECAUSE IT CALLS
CZ         DAREAD WITH THE OLD DATA FOR THE FRAGMENT IJ.
CZ         HERE, HOWEVER, A CALL TO DAREAD SHOULD BE MADE FOR IXFG.
CZ         ANOTHER PROBLEM IS THAT Z-VECTOR (TRI1) IN ADDITION TO
CZ         DA FOR K SHOULD BE READ IN.
CZ         IN THE CURRENT CODE, IT IS NOT IMPLEMENTED.
CZ         THUS I HAVE TO MODIFY JKDER OR ESD2DER.
CZ         I THINK THE LATTER IS MUCH EASIER TO MODIFY.
CZ
      ! NCURSH SHOULD BE ZERO HERE
      ! SPECIAL TREATMENT FOR THIS PURPOSE IS MADE FOR
      ! THE LAST ARGUMENT
      IF(SCHWRZ) LFMOBUF(3) = 0 ! READ IN XINTS FROM A FILE
c     if(scffrg(ifg).eq.rhf) CALL ESD2DER(DX,TRI1,-1)
      if(scffrg(ifg).eq.rhf) then
        IF(LCFLAG) THEN
          LRINT=.TRUE.
          CALL ESD2DER(DX,TRI1,-1)
          LRINT=.FALSE.
        END IF
        CALL ESD2DER(DX,TRI1,-1)
      end if

C     DABCLU is also changed
      if(urohf) then
       CALL DMTX2(DX,DX(l2+1),NAI,L1,L1,0)
       if(scffrg(ifg).eq. uhf) CALL DMTX2(WRK1,DX(l2+1+L3),NBI,L1,L1,0)
       if(scffrg(ifg).eq.rohf) CALL DMTX2(WRK1,DX(l2+1   ),NBI,L1,L1,0)
       IF(LCFLAG) THEN
        LRINT=.TRUE.
!       Only exchange is considered
!       Z*B    Alpha * Alpha
        CALL ESD2DER(DX,TRI1,-3)
!       Z*B    Beta  * Beta 
        CALL ESD2DER(WRK1,TRI1(l2+1),-3)
C
        LRINT=.FALSE.
       END IF
!      Z*B    Alpha * Alpha
       CALL ESD2DER(DX,TRI1,-3)
!      Z*B    Alpha * Beta 
       CALL ESD2DER(DX,TRI1(L2+1),-2)
!      Z*B    Beta  * Beta 
       CALL ESD2DER(WRK1,TRI1(l2+1),-3)
!      Z*B    Beta  * Alpha
       CALL ESD2DER(WRK1,TRI1,-2)
!
!      After we calculate two electron integral
!      Since Alpha and Beta are no more difference
!      they will be summed up and calculated together
       CALL DAXPY(L2,one,WRK1,1,DX,1)
       CALL DAXPY(L2,one,TRI1(L2+1),1,TRI1,1)
      end if
C
CZCZ  IF (GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
CZ    IF (MASWRK) THEN
CZ      WRITE(6,*) 'AFTER ESD2DER',NCURSH
CZ      DO I = 1, NAT
CZ        WRITE(6,'(3F12.8)') DE(1,I),DE(2,I),DE(3,I)
CZ      END DO
CZ    END IF
CZCZ  IF(GOPARR) CALL DSCAL(3*NAT,ONE/NPROC,DE,1)
C
CZ
CZ    OPTION (2). MCP CONTRIBUTION
CZ
      IF (IMCPFMO.EQ.1) THEN
        IMCPSW = 0
        IF (IXFG.NE.0)   IMCPSW = IXFTCH(X(LMCPSW),IXFG)
CZCZ    IF (JCURFG.NE.0) IMCPSW = IMCPSW + IXFTCH(X(LMCPSW),JCURFG)
CZCZ    IF (KCURFG.NE.0) IMCPSW = IMCPSW + IXFTCH(X(LMCPSW),KCURFG)
CZ      WRITE(6,*) 'IMCPSW', IMCPSW
        IF (IMCPSW.NE.0) THEN
          NATMCP = NAT
          MXVO   = IMVO
          MXCO   = IMCORE
C
          CALL VALFM(LOADFM)
          LDD  = LOADFM + 1
          LOV  = LDD + 3*NATMCP
          LDV  = LOV + MXCO*MXVO
          LAST = LDV + MXCO*MXVO*3
          NDMCP = LAST - LOADFM -1
          CALL GETFM(NDMCP)
          CALL MCPGRD(DE,TRI1,X(LDD),X(LOV),X(LDV),MXCO,MXVO)
          CALL RETFM(NDMCP)
        END IF
      END IF
      IF(IECP.GT.0.and.IECP.ne.5) then
        CALL ECPGRD(DE, TRI1, EXETYP, SOME)
      end if
C
CZ
CZ    SUM UP DE
CZ
      IF (GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
CZ
CZ    THE COLLECTED DE IS NOW COPIED TO FMODE
CZ
      IF (MASWRK) THEN
czcz    IF (IFMOSTP.EQ.2) THEN
czcz      CALL FMODEG(1,FMODE,X(LFMOPG),X(LIAGLOB))
czcz    ELSEIF (IFMOSTP.EQ.4) THEN
        IF     (IFMOSTP.EQ.4) THEN
          CALL FMODEG(1,FMODE,X(LFMOPG),X(LIAGLOB))
czcz      N11 = IDAM + IDAD
czcz      N11 = 0      ! NEED TO FIX FOR APPROXIMATE FMO3
czcz      IF (NBODY.GT.2)
czcz *      CALL FMODEG(N11,X(LFMODE+6*NATFMO),X(LFMOPG),X(LIAGLOB))
czcz      ! MUST CHANGE
        ELSEIF (IFMOSTP.EQ.9) THEN
          CALL FMODEG(1,FMODE,X(LFMOPG),X(LIAGLOB))
        ENDIF
      ENDIF
C
CZCZ  GOTO 666
C
C     SAVE THE PRISTINE MONOMER(DIMER) CONFIGURATION
C
      CALL MONBSR(NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR,
     *            NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,
     *            NCURSH,NGAU0,ENUCR0)
C
C     FIX THE NUMBER OF ELECTRONS TO AVOID DOUBLE COUNTING:
C     EXCLUDE CHARGE AS OTHERWISE THE CHARGE OF FRAGMENT I WILL BE ADDED
C     TO NE FIRST HERE AND THEN AGAIN IN MAKMOL BELOW.
C     AT PRESENT NE IS ACTUALLY NOT IMPORTANT BECAUSE NUMFRG HAS NA.
      NE0C=NE0+ICH0
C
C
      LCFLAGS =  LCFLAG
      camFLAGS= camFLAG
      LRINTS  =  LRINT
      LCFLAG  = .FALSE.
      camFLAG = .FALSE.
      LRINT   = .FALSE.
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C
      NXT = IBTYP.EQ.1
      NEXT  = -1
      KOUNT = -1
C
C     ESP WILL BE COMPUTED IN THE DIRECT FASHION
C
      if(iefmorun .lt. 0 .or. iefmo_agrad .lt. 0) then

C     DO 100 KFG=1,NFG
cpbc
      DO 111 IUNIT=IUNIT0,IUNIT1
       IF(MDWPBC.NE.0.AND.IUNIT.GT.0) THEN
         NATFMOB=NATFMO+NBDFG
         CALL DCOPY(3*NATFMOB,X(LUNTXYZ+3*NATFMOB*IUNIT),1,X(LCFRG),1)
         CALL DCOPY(3*3,X(LUNTROT+3*3*IUNIT),1,TT,1)
         CALL TRMAT
       END IF
      DO 100 KKFG=KFG0,KFG1
        IF(LARGEPRI) THEN
          KFG=IXFTCH(X(LLOADM),KKFG)
        ELSE
          KFG=KKFG
        ENDIF
c       IF(IFG.EQ.KFG.OR.JFG.EQ.KFG.OR.LFG.EQ.KFG) GOTO 100
        IF((IFG.EQ.KFG.OR.JFG.EQ.KFG.OR.LFG.EQ.KFG).AND.
     *     (MDWPBC.eq.0.or.IUNIT.EQ.0)) GOTO 100
C
CZCZ    AS OF 11/23/09
CZCZ    THE APPROXIMATION COULD BE CHANGED FOR THE RESPONSE CALCULATION?
CZCZ
        IF(RESPPCI.NE.ZERO.OR.RESPAPI.NE.ZERO.OR.RESDIM.NE.ZERO) THEN
          icurunt=iunit
          RK=FMODIST(IFG,JFG,LFG,KFG)
C         THE DISTANCE WILL BE REFINED LATER FOR SMARTR.
C         WRITE(6,*) 'DISTANCE IS',KFG,RK,RESPPCI
          IF(RK.GT.RESPPCI.AND.RESPPCI.NE.ZERO) GOTO 100
CZ
C
         IF(IFMOSTP.EQ.2.AND.IAND(IXESP,4096).NE.0.AND.RK.NE.0) GOTO 100
C
          ESPAP=RK.GT.RESPAPI.AND.RESPAPI.NE.ZERO
        ELSE
          ESPAP=.FALSE.
        ENDIF
C
        IF(ESPPAR) THEN
          KOUNT=KOUNT+1
          IF(GOPARR) THEN
            IF(NXT) THEN
              IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.KOUNT) GOTO 100
            ELSE
              IF(MOD(KOUNT,NPROC).NE.ME) GOTO 100
            ENDIF
          ENDIF
          SAVGOP=GOPARR
          GOPARR=.FALSE.
C         GOPARR IS SET TO .FALSE. TO PREVENT SHELL-BASED WORK DIVISION
C         INSIDE OF EXCHNG AND FMOESP.
C         NOTE THAT SHELL-BASED WORK DIVISION IS USED FOR ESPPAR=.FALSE.
        ENDIF
        KLAY=MIN(ILAY,LAYFRG(KFG))
C       BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5.AND.KFG.EQ.JCURFG
        BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5
        IF(SOME) WRITE(6,*) 'COMPUTING ESD DUE TO FRG',KFG,' LAYER',KLAY
C
C       ADD MONOMER KFG AND READ ITS DENSITY (NOW ONLY ALPHA)
C
        KFGX = KFG
        CALL MAKEMOL(KFGX,0,0,KLAY,0,NAT0,NCURSH,NGAU0,NE0C,ICH0,MUL0,
     *               .FALSE.)
        L1K =  NUM-NUM0
        L2K = (L1K*L1K+L1K)/2
        L3K =  L1K*L1K
C
        IREC0=IDMREC0(KLAY)
C       HACK IT UP TO POINT TO RHF DENSITIES FOR RUNS WITH MP2 DENSITIES.
        if(scffrg(kfg).ne.uhf) then
          l2kb=1
        else
          l2kb=l2k+1
        end if
        IF(DODDCOR) THEN
          IREC0RHF=1
          IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
          IREC0=IREC0RHF
        ENDIF
        IDMREC0K=KFG+IREC0
        IF(.NOT.ESPAP) THEN
          NAK  = ISHFT(IXFTCH(X(LNUMFRG),KFG),-16)
          MULK = IXFTCH(X(LMULFG),KFG)
          NBK  = NAK-MULK+1
CZ
CZ        IN THIS CASE, WRT1 IS EXPECTED TO HAVE THE LENGTH OF L2+L3
CZ        COVERING WRK1, BECAUSE READMOND FIRST READS THE MOS AND THEN
CZ        THE DENSITY IS CONSTRUCTED IN WRT1
CZ
          CALL READMOND(WRT1,ORBXCH,SCFFRG(KFG).EQ.RMC,
     *                  NAK,NBK,L1K,X(LIODFMO),IDMREC0K,
     *                  scffrg(kfg).eq.uhf)
          ! TRI2 IS EXTERNAL DENSITY
          if(scffrg(kfg).eq.uhf.or.scffrg(kfg).eq.rohf) then
            CALL DMTX2(WRT1,WRT1(l2K+1),NAK,L1K,L1K,0)
            CALL DCOPY(L2K,WRT1,1,TRI2,1)
            if(scffrg(kfg).eq.uhf)
     *         CALL DMTX2(WRT1,WRT1(l2K+1+L3K),NBK,L1K,L1K,0)
            if(scffrg(kfg).eq.rohf)
     *         CALL DMTX2(WRT1,WRT1(l2K+1    ),NBK,L1K,L1K,0)
            CALL DCOPY(L2K,WRT1,1,TRI2(L2K+1),1)
          else
            CALL DCOPY(L2K,WRT1,1,TRI2,1)
          end if

C         GOTO 100
C         WRITE(6,*) 'ORIGINAL DENSITY',KFG,L1K,NAK
C         CALL PRTRI(X(LFMODA),L1K)
C         CALL SEQOPN(38,'HESSIAN','UNKNOWN',.FALSE.,'UNFORMATTED')
C         WRITE(38) (X(LFMODA+I-1),I=1,L2K)
C         CALL SEQCLO(38,'KEEP')
C         READ BETA DENSITY
        ENDIF
C
C       ARRAY SIZES ARE DIFFERENT FOR EACH FRAGMENT.
C
        NSH2 = (NSHELL*NSHELL+NSHELL)/2
        CALL BASCHK(LMAX)
        IF(LMAX.GE.5) THEN
           IF(MASWRK) WRITE(IW,*) 'FMO HAS NOT BEEN REVIEWED FOR H,I'
           CALL ABRT
        END IF
C       FOR SOME REASON GAMESS LIKES TO HANDLE AT LEAST L-SHELLS
        NANGM=KARTEN(MAX(LMAX,1))
        MAXG = NANGM**4
        CALL VALFM(LOADFM)
C
        LXINTS= LOADFM + 1
        LGHOND= LXINTS + NSH2
        LDSH  = LGHOND + MAXG
        LDSHB = LDSH   + NSH2
        LDDIJ = LDSHB  + NSH2
        LAST  = LDDIJ  + 49*MXG2
        NEED  = LAST- LOADFM -1
        CALL GETFM(NEED)
C
        LDENP=LPOPMUL+((ICURPOP-1)*NFG+KFG-1)*MAXL1
        IF(ESPAP) THEN
          LDENA=LDENP
          LDENB=LDENA
        ELSE
CZCZ      LDENA=LWRKDEN
          LDENA=LWRKESP  ! TRI2 IS LWRKESP IN FMOESDER (TRICKY)
CZCZ      LDENB=LFMODB   ! LWRKESP2=GEN
          LDENB=LWRKESP  ! NOTHING HAPPENS, I GUESS
        ENDIF
C
C       CALL ERIPRE
C       THERE IS NO NEED TO CALL ERIPRE HERE. FMO CODE ALWAYS CALLS EXCHNG
C       (BECAUSE SCHWRZ IS FORCED TRUE), AHD THIS IS WHERE INITIALISATION
C       FOR EACH (N+1)-MER IS DONE. NOTE THAT THIS INITIALISATION IS
C       IMPORTANT NOW: IT SETS ARRAYS FOR SCREENING AND SOME OTHER THINGS.
C
C       CREATE DENSITY MATRIX FOR SHELL INDICES
C
        IF(SCHWRZ) THEN
          DUMMY = 0.0D+00
CNB       FOR GRADIENTS, WHAT SHOULD BE SCFTYP??
C         L1 AND L2K SEEM TO BE THE RIGHT CHOICE:
C         L1 IS USED TO SKIP L1 AOS TO GET TO THE EXTERNAL MONOMER SHELL
C         L2K GIVES THE SIZE OF GVB DENSITY MATRICES FOR THE EXTERNAL MONOMER
C         WRITE(6,*) 'ORIGINAL DENSITY',KFG,L1K
C         CALL PRTRI(X(LFMODA),L1K)
          IF(ESPAP) THEN
C           WRITE(6,*) 'MULLIKENS'
C           CALL PRSQ(X(LDENA),L1K,1,1)
            CALL SHLDEND(SCFTYP1,X(LDENA),X(LDENB),DUMMY,X(LDSH),L1,1)
C           WRITE(6,*) 'CONTRACTED L-DENSITY',KFG,NSHELL-NCURSH
C           CALL PRSQ(X(LDSH),NSHELL-NCURSH,1,1)
          ELSE
            CALL SHLDEN(scffrg(kfg),TRI2,TRI2(L2kb),DUMMY,X(LDSH),IA,
     *                  L1,L2K,NSH2,1)
            IF(ESDDER) THEN
C             REMOVE ALL EVIDENCE OF FRAGMENT 2 BEING INVOLVED.
C             KEEP ONLY FRAGMENT 1 INFORMATION AND OBTAIN ITS SHELL DENSITY.
C             L1 ARGUMENT IS UNUSED BELOW.
              NSHSAV=NSHELL
              NSHELL=NCURSH
              NCURSH=0
              ! TRI1 WORKS AS DENSITY-LIKE MATRIX
              CALL SHLDEN(SCFTYP1,TRI1,X(LDENB),DUMMY,X(LDSHB),IA,
     *                    L1,L2,NSH2,1)
              NCURSH=NSHELL
              NSHELL=NSHSAV
            ENDIF
C         WRITE(6,*) 'CONTRACTED DENSITY',KFG,NSHELL-NCURSH
C         CALL PRTRI(X(LDSH),NSHELL-NCURSH)
          ENDIF
        END IF
C
C       INITIALISE TWO-ELECTRON INTEGRALS
C       POPLE INTEGRALS USE A SEPARATE COORDINATE COMMON BLOCK INITIALISED
C       ABOVE, ETC. ?ST MUST BE RESET SO THAT NO PHONEY RESTART IS DONE.
C
        IST=1
        JST=1
        KST=1
        LST=1
        CALL JANDK
C
C     ----- EXCHANGE INTEGRALS FOR DIRECT SCF THRESHOLD TESTS -----
C       COMPUTED FOR THE COMBINED SYSTEM, NO NEED TO ADJUST INDICES.
C
        NINT   = 0
        NSCHWZ = 0
CNB5    EXCHNG CAN BE ADJUSTED TO TAKE ADVANTAGE OF THE REDUCED BASIS WITH BSSE.
C       GOTO 100
C       DO IOHNO=1,1000
        IF(SCHWRZ) CALL EXCHNG(X(LXINTS),X(LGHOND),X(LDDIJ),
     *                         NSH2,MAXG,INTTYP)
C       ENDDO
C       COMPUTE 2-EL INTEGRALS CORRESPONDING TO PLACING THE ORIGINAL
C       MONOMER(DIMER) INTO THE COULOMB FIELD OF MONOMER KFG.
C
C       GOTO 100
        IF(ESDDER) CALL VCLR(WRT1,1,L2K)
CZ
C       CALL TIMIT(1)
C       DO IOHNO=1,100
CZ
CZ      HERE ONLY TRI1 IS IMPORTANT AND OTHERS JUST PASS BY
CZ      OUTPUT IS WRT1: FIRST WRT1 (FA) IS DUMMY
CZ
        CALL FMO2EI(SCHWRZ,NINT,NSCHWZ,NSCHWZB,NSCHWNZB,L1,L2,X(LXINTS),
     *              NSH2,X(LGHOND),MAXG,IA,LDENA,LDENP,WRT1,
     *              TRI1,WRT1,X(LDSH),X(LDSHB),X(LIAGLOB),
     *              X(LINDAT),X(LINDATG),BSSEDIM,RESPAPI,RESPPCI,ESPAP,
     *              ESDDER,ESDER,IFG,JFG,LFG,KFG,0,.false.)
C       ENDDO
C       CALL TIMIT(1)
        IF(OUT) THEN
          IF(NSCHWZB.EQ.0) THEN
            WRITE(IW,9000) KFG,NINT,NSCHWZ
          ELSE
            WRITE(IW,9005) KFG,NINT,NSCHWZ,NSCHWZB
          ENDIF
        ENDIF
C       WRITE(IW,*) 'NON-ZERO SUPERBLOCKS',NSCHWNZB,NSH2
C
C       WRITE(6,*) 'DENSITY IN ESP IS'
C       CALL PRTRIL(X(LFMODA),NUM0)
CZ
CZ      ADDED BY NAGATA 3/27/07
CZ
CZCZCZ  IF(SCHWRZ) CALL DAWRIT(IDAF,IODA,X(LXINTS),NSH2,54,0)
        ! LXINTS IS USED IN ESD2DER
        IF(SCHWRZ) LFMOBUF(3) = LXINTS
C
        IF(ESPPAR) GOPARR=SAVGOP
        CALL DSCAL(L2K,HALF,WRT1,1)
        II=0
        DO I=1, L1K
          II = II + I
          WRT1(II) = WRT1(II) + WRT1(II)
        ENDDO
        IF(GOPARR) CALL DDI_GSUMF(2418,WRT1,L2K)
CZ      TEST
C       WRITE(6,*) 'DEN*TWOEI',L1K
C       CALL PRTRIL(WRT1,L1K)
CZ
        if(scffrg(kfg).eq.rhf) then
          CALL CPYTSQ(TRI2,WRK1,L1K,1)
          CALL TFTRI(WRK3,WRT1,WRK1,WRK2,L1K,L1K,L1K)
          CALL DSCAL(L2K,-HALF,WRK3,1)
        else if(scffrg(kfg).eq.uhf.or.scffrg(kfg).eq.rohf) then
          CALL CPYTSQ(TRI2,WRK1,L1K,1)
          CALL TFTRI(WRK3,WRT1,WRK1,WRK2,L1K,L1K,L1K)
          CALL CPYTSQ(TRI2(L2K+1),WRK1,L1K,1)
          CALL TFTRI(TRI2(L2K+1),WRT1,WRK1,WRK2,L1K,L1K,L1K)
          CALL DAXPY(L2K,one,TRI2(L2K+1),1,WRK3,1)
          CALL DSCAL(L2K,-one,WRK3,1)
          CALL READMOND(WRT1,ORBXCH,SCFFRG(KFG).EQ.RMC,
     *              NAK,NBK,L1K,X(LIODFMO),IDMREC0K,
     *              scffrg(kfg).eq.uhf)
          CALL DCOPY(L2K,WRT1,1,TRI2,1)
        end if
C
        CALL VCLR(DE,1,NAT*3)
        CALL EXTSDER(WRK3,WRK2,L1K,L2K,.FALSE.,.FALSE.,L1)
C
CZ
CZ      2E CONTRIBUTION TO FOCK DERIVATIVES
CZ
CZ      NOTE THAT DERIVATIVES ARE STORED IN DE().
CZ
        CALL ESD2DER(TRI1,TRI2,L1)
        IF(GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
CZ      IF (MASWRK) THEN
CZ        WRITE(6,*) 'TEST AFTER ESD2DER',KFG,NAT
CZ        DO IJ = 1, NAT
CZ          WRITE(6,'(3F12.8)') DE(1,IJ),DE(2,IJ),DE(3,IJ)
CZ        END DO
CZ      END IF
        CALL RETFM(NEED)
CZ
        IF (MASWRK) THEN
          IF     (IFMOSTP.EQ.2) THEN
            CALL FMODEG(1,FMODE,X(LFMOPG),X(LIAGLOB))
          ELSEIF (IFMOSTP.EQ.4) THEN
            CALL FMODEG(1,FMODE,X(LFMOPG),X(LIAGLOB))
            N11 = IDAM + IDAD
            N11 = 0      ! NEED TO FIX FOR APPROXIMATE FMO3
            IF (NBODY.GT.2) CALL FMODEG
     *         (N11,X(LFMODE+NATFMO*6),X(LFMOPG),X(LIAGLOB))
            ! MUST CHANGE
          ELSEIF (IFMOSTP.EQ.9) THEN
            CALL FMODEG(1,FMODE,X(LFMOPG),X(LIAGLOB))
          ENDIF
        ENDIF
  100 CONTINUE
  111 CONTINUE
      endif
      IF(ESPPAR.AND.GOPARR.AND.NXT) CALL DDI_DLBRESET
cpbc
      IF(MDWPBC.NE.0.AND.IUNIT1.GT.0) THEN
        CALL DCOPY(3*NATFMOB,X(LUNTXYZ),1,X(LCFRG),1)
        CALL RUNITV(3,3,TT)
        CALL TRMAT
      ENDIF
C
C     IT IS IMPORTANT TO RESET NCURSH SO THAT 2E INTEGRALS WITHIN THE MONOMER
C     (DIMER) DURING THE FOLLOWING SCF ARE COMPUTED PROPERLY.
      NCURSH = 0  ! NEED TO RESET
C
C     COMPUTE 2-EL INTEGRALS FOR THE ORIGINAL MONOMER(DIMER)
C
      IF(IFMOSTP.NE.6) THEN
        IST=1
        JST=1
        KST=1
        LST=1
        CALL JANDK
      ENDIF
      NPRFMO = NPRSAV
      DIRSCF = DIRSAV
      LCFLAG = LCFLAGS
      camFLAG=camFLAGS
      LRINT  = LRINTS
      IESDPPC = 0
      LFMOBUF(3) = 0
CZ
CZ    RESTORE THE CALCULATION (11/24/09).
CZ
      CALL MONBSR(NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,NCURSH,NGAU0,
     *           ENUCR0,NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR)
C     CALL DCOPY(NATFMO*3,X(LFMODEST),1,FMODE,1)
C
      RETURN
 9000 FORMAT(/1X,'ESD LFG=',I5,': NZ',I12,' SKIPPED',I10,' BLOCKS.')
 9005 FORMAT(/1X,'ESD LFG=',I5,': NZ',I12,' SKIPPED',I10,' BLOCKS',I8,
     *           ' SUPERBLOCKS.')
      END
C*MODULE FMOCP   *DECK FMOCGCP
C>
C>    @brief   Fully analytic FMO gradient
C>
C>    @details Conjugate gradient solver on monomer
C>
C>    @author Takeshi Nagata 
C>    @date Feb, 2016- Yoshio Nishimoto
C>    - Added FMO-DFTB SCZV
C>    @date Jan, 2017- C.Bertoni
C>    - Changes for EFMO gradient
C>
      SUBROUTINE FMOCGCP(IFG,ILAY,NOCC,NVIR,L1,L2,CX,ZVEC0,ZVEC1,IPTZC,
     *                   ORB_E,LAYFRG,IDMREC0,NQMTFG,DODISTR,
     *                   WRT1,WRK1,WRK2,WRK3,qindz,CXB,ORB_EB,urohf,NBI,
     *                   ZVEC1B,scffrg,NAT,GAMMA,GAMMA3,iter0)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (THRSH=1.0D-08)
      PARAMETER (ONE=1.0D+00)

C
      LOGICAL GOPARR,DSKWRK,MASWRK,OUT
      LOGICAL DODISTR
      LOGICAL urohf
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      DIMENSION CX(L1,*),CXB(L1,*)
      DIMENSION ZVEC0(1), ZVEC1(NVIR,*), IPTZC(1)
      DIMENSION ZVEC1B(l1-NBI,*)
      DIMENSION ORB_E(L1)
      DIMENSION ORB_EB(L1)
      DIMENSION scffrg(*)
      DIMENSION LAYFRG(1), IDMREC0(1),NQMTFG(1)
      DIMENSION WRT1(1),WRK1(1),WRK2(1),WRK3(1)
      dimension qindz(maxnat,*)
      DIMENSION GAMMA(*)
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /EFMO  / EFMOETOT,EFMOESERG,EFMOPOLERG,EFMODISERG,
     *                EFMOREPNRG,EFMOCHTNRG,EFMOEPEN,EFMOPCMG,
     *                IEFMORUN,IMODEFP,IEFMORT,IEFMOCFRG,IEFMONFRG,
     *                IEFMODIM(2),IMODEFE,NATEFMO,IMODEFD,IMODEFER,
     *                IMODEFCT,IDIMTYP,iefmo_agrad
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /FMCOM / X(1)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2,maxrij
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D,
     *                LNBOND,LCTMUL
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MLTFMO/ Q_MUL,IMLTFMO,ISWPFD,ISWNEW1
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DATA  ROHF/8HROHF    /

C
      threshold = thrsh
      if( iefmo_agrad .gt. 0 .or. iefmorun .gt. 0 )
     *     threshold=threshold/10d0
      OUT = MASWRK.AND.IAND(NPRFMO,3).eq.0
c     IF (DFTBFL) OUT = OUT.AND.MDOUT
      iter0=0
c     
      NQI = IAND(NQMTFG(IFG),65535)
      NOV = NVIR*NOCC
      NOCCB=NBI
      NVIRB= NQI-NBI
      NOVB = NVIRB*NOCCB
      if(urohf) then
        NNUM = NOV + NOVB
        SCAL = 2.0D+00
        if(SCFFRG(ifg).eq.rohf) then
          NOCD    = NOCCB
          NOCS    = NOCC - NOCCB
        end if
      else
        NNUM = NOV
        SCAL = 4.0D+00
      end if

CZ
CZ   THIS ROUTINE SOLVES THE EQUATION A*X = B
CZ   USING THE PRECONDITIONED CONJUGATE GRADIENT METHOD
CZ
      CALL VALFM(LOADFM)
C
      LR0  = LOADFM + 1
      LZ0  = LR0    + NNUM
      LP0  = LZ0    + NNUM
      LAP  = LP0    + NNUM
      LAST = LAP    + NNUM
CZCZ
CZCZ  IF (IEFPFMO.EQ.2) THEN
      IF (IEFPFMO.EQ.2.OR.ISWNEW1.EQ.1) THEN
        LCNT1 = LAST
        LAST  = LCNT1 + L2
      END IF
CZCZ
      IF (DFTBFL) THEN
        LQINDZTMP = LAST
        LS        = LQINDZTMP + MAXNAT
        LAST      = LS        + L2
        IF (DFTB3) THEN
          LCHAMUL = LAST
          LAST    = LCHAMUL   + NAT
        ELSE
          LCHAMUL = LAST
        END IF
      END IF
C
      NEED = LAST - LOADFM -1
      CALL GETFM(NEED)
C
CZ
CZ    COMPUTE INITIAL PARAMETERS
CZ    (A) CONSTRUCT RESIDUE R0
CZ
      ! FIRST COPY LAG INTO R0
      CALL DCOPY(NNUM,WRK1,1,X(LR0),1)
      ! COMPUTE A PART OF A*Z
      IF (DODISTR) THEN
        IZPT = 1
      ELSE
        IZPT = IPTZC(IFG)
      END IF
      ! CONSTRUCT INTEGRAL PART OF A*Z
      IF (DFTBFL) THEN
        !! CONSTRUCT MULLIKEN CHARGE ARRAY
        IF (DFTB3) CALL DFTB_ZVEC_MUL(NAT,LPOPMAT,MAXNAT,IFG,X(LCHAMUL),
     *                                LPOPMATI)
        CALL VCLR(X(LS),1,L2)
        CALL DFTB_HAM_OVER(1,NAT,X(LS),X(LS),.FALSE.,.TRUE.)
        CALL DFTB_DIAORBHSS(L2,WRK2,X(LS),QINDZ(1,IFG),GAMMA,GAMMA3,
     *                      WRT1,DFTB3,X(LCHAMUL),IFG,X(LIAGLOB),
     *                      X(LNATFRG),X(LINDFRG),X(LIATFRG),
     *                      X(LPOPMATI),X(LFMOC),X(LINDAT),X(LIALOC))
      ELSE
        CALL DIAORBHSS(L1,L2,NOCC,NVIR,CX,ZVEC0(IZPT),WRT1,WRK1,WRK2,
     *                 scffrg(ifg),CXB,NBI)
      END IF
CZ
      IF (IEFPFMO.EQ.2) THEN
        CALL EFPCNT2ORBH(L1,L2,X(LCNT1))
        CALL DAXPY(L2,ONE,X(LCNT1),1,WRT1,1)
      END IF
      IF (ISWNEW1.EQ.1) THEN
        CALL PCMCNT2ORBH(L2,X(LCNT1))
        CALL DAXPY(L2,ONE,X(LCNT1),1,WRT1,1)
        if(urohf) CALL DAXPY(L2,ONE,X(LCNT1),1,WRT1(L2+1),1)
      END IF
CZ
      CALL CPYTSQ(WRT1,WRK1,L1,1)
      CALL SWBASIS(1,L1,NOCC,NVIR,CX,WRK1,L1,WRK2,NVIR,WRK3)
      if(urohf) then
        CALL CPYTSQ(WRT1(l2+1),WRK1,L1,1)
        CALL SWBASIS(1,L1,NOCCB,NVIRB,CXB,WRK1,L1,WRK2(1+NOV),
     *       NVIRB,WRK3(1+NOV))
        IF(scffrg(ifg).EQ.ROHF) THEN
          CALL EXINT_ROHF(WRT1(L2*2+1),WRK3,WRK1,CX,L1,L2,NQI,
     *         NOCC,NVIR,NOCCB,NVIRB,ZVEC0(IZPT),ZVEC0(IZPT+NOV),
     *         WRK2,WRK2(1+NOV))
        END IF
      end if

      ! FACTOR FOUR IS CORRECT ?
      CALL DSCAL(NNUM,SCAL,WRK2,1)
      if(SCFFRG(ifg).eq.rohf) then
        CALL SWZVROHF(WRK2,WRK2(1+NOV),NOCD,NOCS,NVIR,NVIRB)
      end if
      ! COMPLETE  A'*Z (A' = (E_I-E_R) - A)
      CALL COMPAZ(NOCC,NVIR,ZVEC0(IZPT),WRK2,WRK1,ORB_E)
      if(urohf)  CALL COMPAZ(NOCCB,NVIRB,ZVEC0(IZPT+NOV),WRK2(1+NOV),
     *                WRK1(NOV+1),ORB_EB)

      ! R0 = X-A'*Z: THE FACTOR ONE IS CORRECT? 12/16
      CALL DAXPY(NNUM,-ONE,WRK1,1,X(LR0),1)
C
      if( iefmorun .le. 0 .or. iefmo_agrad .le. 0 ) then
      ! CONSTRUCT OFF_A*Z
      IF (DFTBFL) THEN
        IF (IAND(MODGAMMA,2).NE.0) THEN
          NN = 2
          NN2 = NATFMO+NBDFG
        ELSE
          NN = 1
          NN2 = NATFMO
        END IF
        !! WRK1 AND IS DUMMY
        CALL DFTB_OFFORBHSS(IFG,X(LIAGLOB),X(LNATFRG),X(LINDFRG),
     *       X(LIATFRG),QINDZ,X(LS),WRT1,X(LISPE),X(LFMOC),X(LGAMMA3),
     *       WRK1,X(LCHAMUL),X(LPOPMATI),.TRUE.,X(LINDAT),X(LIALOC),
     *       NN,NN2)
      ELSE
        CALL OFFORBHSS(IFG,ILAY,L1,L2,ZVEC0,IPTZC,WRT1,LAYFRG,
     *                 IDMREC0,NQMTFG,DODISTR,WRK1,WRK2,WRK3,qindz
     *                ,scffrg)
      END IF
      CALL CPYTSQ(WRT1,WRK1,L1,1)
      ! AO TO MO
      CALL SWBASIS(1,L1,NOCC,NVIR,CX,WRK1,L1,WRK2,NVIR,WRK3)
      if(urohf)
     * CALL SWBASIS(1,L1,NOCCB,NVIRB,CXB,WRK1,L1,WRK2(1+NOV),
     *      NVIRB,WRK3)

      ! R0 = B - A*Z: TWO IS CORRECT?? 12/12
      ! WHERE B = X + OFF_A*Z
      CALL DAXPY(NNUM,SCAL,WRK2,1,X(LR0),1)
      endif
C
CZCZ  DISPLAY THE RESIDUAL
CZ    CALL PRSQ(X(LR0),NOCC,NVIR,NVIR)
CZCZ
C
CZ    (B) CONSTRUCT Z0 FROM R0 AND MAKE P0=Z0
CZ
      CALL DCOPY(NNUM,X(LR0),1,X(LZ0),1)
      ! SECOND Z0 IS DUMMY IN THE CASE OF MODE=1
      CALL PRFCTMO(1,NVIR,NOCC,NVIR,X(LZ0),X(LZ0),ORB_E,ONE)
      if(urohf)  CALL PRFCTMO(1,NVIRB,NOCCB,NVIRB,
     *           X(LZ0+NOV),X(LZ0+NOV),ORB_EB,ONE)

      CALL DCOPY(NNUM,X(LZ0),1,X(LP0),1)
C
CZ
CZ    CONJUGATE GRADIENT ITERATION STARTS
CZ
      IF (DFTBFL) CALL DCOPY(MAXNAT,QINDZ(1,IFG),1,X(LQINDZTMP),1)
      NTER = 50
      DO ITER = 1, NTER
C
        ! COMPUTE AP = A*P0
        IF (DFTBFL) THEN
          CALL SWBASIS(0,L1,NOCC,NVIR,CX,X(LP0),NVIR,
     *                   WRK1,L1,WRK2)
          CALL SQ2TRI(L1,L1,WRK1,WRT1,0.5D+00)
          call vclr(qindz(1,ifg),1,maxnat)
          call calcqindz(ifg,l1,l2,WRT1,wrk1,qindz,wrk2)
          IF (GOPARR) CALL DDI_BCAST(666,'F',QINDZ(1,IFG),NAT,0)
          CALL DFTB_DIAORBHSS(L2,WRK2,X(LS),QINDZ(1,IFG),GAMMA,GAMMA3,
     *                        WRT1,DFTB3,X(LCHAMUL),IFG,X(LIAGLOB),
     *                        X(LNATFRG),X(LINDFRG),X(LIATFRG),
     *                        X(LPOPMATI),X(LFMOC),X(LINDAT),X(LIALOC))
        ELSE
          CALL DIAORBHSS(L1,L2,NOCC,NVIR,CX,X(LP0),WRT1,WRK1,WRK2,
     *         scffrg(ifg),CXB,NBI)
        END IF

        CALL CPYTSQ(WRT1,WRK2,L1,1)
        CALL SWBASIS(1,L1,NOCC,NVIR,CX,WRK2,L1,WRK1,NVIR,WRK3)
        if(urohf) then
          CALL CPYTSQ(WRT1(l2+1),WRK2,L1,1)
          CALL SWBASIS(1,L1,NOCCB,NVIRB,CXB,WRK2,L1,WRK1(1+NOV),
     *         NVIRB,WRK3(1+NOV))
          IF(scffrg(ifg).EQ.ROHF) THEN
            CALL EXINT_ROHF(WRT1(L2*2+1),WRK3,WRK2,CX,L1,L2,NQI,
     *           NOCC,NVIR,NOCCB,NVIRB,X(LP0),X(LP0+NOV),
     *           WRK1,WRK1(1+NOV))
          END IF
        end if

        IF(SCFFRG(IFG).EQ.ROHF) THEN
          CALL SWZVROHF(WRK1,WRK1(1+NOV),NOCD,NOCS,NVIR,NVIRB)
        END IF

        CALL DSCAL(NNUM,SCAL,WRK1,1)
        CALL COMPAZ(NOCC,NVIR,X(LP0),WRK1,X(LAP),ORB_E)
        if(urohf)  CALL COMPAZ(NOCCB,NVIRB,X(LP0+NOV),WRK1(1+NOV),
     *                  X(LAP+NOV),ORB_EB)

C
        DENO  = DDOT(NNUM,X(LP0),1,X(LAP),1)
        RDNO  = DDOT(NNUM,X(LR0),1,X(LZ0),1)
        IF (MASWRK) THEN
          RNORM = DDOT(NNUM,X(LR0),1,X(LR0),1)
          RNORM = SQRT(RNORM)
        END IF
        IF (GOPARR) CALL DDI_BCAST(666,'F',RNORM,1,0)
        IF (OUT) WRITE(IW,1000) ITER, RNORM
        IF (RNORM.LT.threshold) THEN
          IF (OUT) WRITE(IW,*) 'CG CONVERGES AT ',ITER
          iter0=iter
          IF (DFTBFL) CALL DCOPY(MAXNAT,X(LQINDZTMP),1,QINDZ(1,IFG),1)
          CALL RETFM(NEED)
          RETURN
        END IF
C
        ALPHA1 = RDNO/DENO
C
        ! NEW X = ZVEC1
        CALL DAXPY(NOV, ALPHA1,X(LP0),1,ZVEC1,1)
        if(urohf) CALL DAXPY(NOVB,ALPHA1,X(LP0+NOV),1,ZVEC1B,1)
        ! NEW R
        CALL DAXPY(NNUM,-ALPHA1,X(LAP),1,X(LR0),1)
        ! NEW Z
        CALL DCOPY(NNUM,X(LR0),1,X(LZ0),1)
        CALL PRFCTMO(1,NVIR,NOCC,NVIR,X(LZ0),X(LZ0),ORB_E,ONE)
        if(urohf)
     *     CALL PRFCTMO(1,NVIRB,NOCCB,NVIRB,X(LZ0+NOV),
     *          X(LZ0+NOV),ORB_EB,ONE)

C
        BETA1 = DDOT(NNUM,X(LR0),1,X(LZ0),1)/RDNO
C
        ! NEW P
        CALL DSCAL(NNUM,BETA1,X(LP0),1)
        CALL DAXPY(NNUM,ONE,X(LZ0),1,X(LP0),1)
      END DO
C
      IF (MASWRK) WRITE(IW,*) 'CG DOES NOT CONVERGE IN ',ITER
      CALL RETFM(NEED)
      RETURN
 1000 FORMAT(1X,I4,'-TH LOCAL CONJUGATE GRADIENT RMSD:',F12.8)
      END
C*MODULE FMOCP   *DECK DIAORBHSS
      SUBROUTINE DIAORBHSS(L1,L2,NOCC,NVIR,CX,ZVEC,ORBH,WRK1,WRK2,
     *           CALTYP,CXB,NBI)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL SCHWRZ
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DIRSCF,FDIFF,DIRSAV
      LOGICAL PACK2E,urohf,LCFLAG,LRINT
      PARAMETER (MXSH=5000,MXGTOT=20000,MXAO=8192,MXGSH=30,
     *           MXG2=MXGSH*MXGSH,MAXL=5)
      PARAMETER (HALF=0.5D+00)
C
      DIMENSION CX(L1,*),ZVEC(1),ORBH(1)
      DIMENSION CXB(L1,*)
      DIMENSION WRK1(1),WRK2(1)
      DIMENSION KARTEN(0:MAXL-1)
C
      COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NLRC  / LCFLAG,EMU,EMU2,LRFILE
      COMMON /NLRCF / LRINT
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA UHF/8HUHF     /
      DATA  ROHF/8HROHF    /
      DATA   RHF/8HRHF     /
      DATA RNONE/8HNONE    /
      DATA KARTEN/1,4,6,10,15/
CZ
CZ    COMPUTE THE ORBITAL HESSIAN MULTIPLIED BY DENSITY-LIKE MATRIX
CZ    TRI1: DENSITY-LIKE MATRIX
CZ    ORBH: ORBITAL HESSIAN MULTIPLIED BY TRI1
CZ
      DIRSAV  =  DIRSCF
      DIRSCF  = .TRUE.
      SCHWRZ  = .TRUE.
      SCFTYP1 =  CALTYP
      urohf   = .false.
      if(caltyp.eq.uhf.or.caltyp.eq.rohf) then
       l2d=l2*2
       urohf  = .TRUE.
      else
       l2d=l2
      end if
C
      NSH2 = (NSHELL*NSHELL+NSHELL)/2
      CALL BASCHK(LMAX)
      IF(LMAX.GE.5) THEN
         IF(MASWRK) WRITE(IW,*) 'FMO HAS NOT BEEN REVIEWED FOR H,I'
         CALL ABRT
      END IF
C
      NVOC = NOCC*NVIR
      NOCCB= NBI
      NVIRB= NVIR + NOCC - NBI
c     NVOCB= NOCCB * NVIRB
      ! ZVEC: MO --> AO
      CALL SWBASIS(0,L1,NOCC,NVIR,CX,ZVEC,NVIR,WRK1,L1,WRK2)
      ! FACTOR ONE SHOULD BE CHANGED ? 12/12
CZCZ  CALL SQ2TRI(L1,L1,WRK1,WRK2,ONE)
      CALL SQ2TRI(L1,L1,WRK1,WRK2,HALF)
      if(urohf) then
         CALL SWBASIS(0,L1,NOCCB,NVIRB,CXB,ZVEC(NVOC+1),
     *   NVIRB,WRK1,L1,WRK2(L2+1))
         CALL SQ2TRI(L1,L1,WRK1,WRK2(L2+1),HALF)
      end if
      if(scftyp1.eq.rohf) then
         NSO = NOCC - NOCCB 
         CALL DMTX2(WRK2(L2*2+1),CX(1,NOCCB+1),NSO,l1,l1,0) 
         l2d = l2 * 3
      end if
      ! WRK2 WITH L2 IS THE SYMMETRIZED DENSITY-LIKE MATRIX
C
C     FOR SOME REASON GAMESS LIKES TO HANDLE AT LEAST L-SHELLS
      NANGM=KARTEN(MAX(LMAX,1))
      MAXG = NANGM**4
      CALL VALFM(LOADFM)
C
      LXINTS= LOADFM + 1
      LGHOND= LXINTS + NSH2
      LDSH  = LGHOND + MAXG
      LDSHB = LDSH   + NSH2
      LDDIJ = LDSHB  + NSH2
      LAST  = LDDIJ  + 49*MXG2
      NEED1 = LAST - LOADFM -1
      CALL GETFM(NEED1)
      IF(SCHWRZ) THEN
        DUMMY = 0.0D+00
        CALL SHLDEN(SCFTYP1,WRK2,WRK2(L2+1),DUMMY,X(LDSH),IA,
     *              L1,L2,NSH2,1)
        IF(scftyp1.eq.rohf) then
          CALL SHLDEN(RHF,WRK2(l2*2+1),WRK2(L2*2+1),DUMMY,X(LDSHB),
     *       IA, L1,L2,NSH2,1)
          DO ISH = 1,NSH2
            X(LDSH-1+ISH)=MAX(X(LDSH-1+ISH),X(LDSHB-1+ISH))
          END DO 
        END IF 
      END IF
C
      NXYZ = 1 ! IF NXYZ = NAT*3, IT IS JUST FOR RESPONSE
      IF(SCFTYP1.eq.rohf) NXYZ= 2
      NINT  =0
      NSCHWZ=0
      IST=1
      JST=1
      KST=1
      LST=1
CZCZ  CALL JANDK
C
      ! XINTS IS STORED IN DISK IN THIS CASE (NCURSH IS 0)
      IF(SCHWRZ)
     *  CALL EXCHNG(X(LXINTS),X(LGHOND),X(LDDIJ),NSH2,MAXG,INTTYP)
CZ
CZ     IN: WRK2 DENSITY-LIKE MATRIX
CZ    OUT: ORBH    FOCK-LIKE MATRIX
CZ
      IDUMMY=1
      CALL VCLR(ORBH,1,L2d)
      IF(LCFLAG) THEN
        LRINT=.TRUE.
        CALL TWOEI(SCFTYP1,DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *             INTTYP,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *             DUMMY,DUMMY,IDUMMY,1,X(LXINTS),NSH2,X(LGHOND),
     *             MAXG,X(LDDIJ),IA,WRK2,ORBH,WRK2(l2+1),
     *             ORBH(l2+1),X(LDSH),DUMMY,DUMMY,NXYZ)
        LRINT=.FALSE.
      END IF
      CALL TWOEI(SCFTYP1,DIRSCF,.FALSE.,.FALSE.,.FALSE.,
     *           INTTYP,SCHWRZ,NINT,NSCHWZ,L1,L2,
     *           DUMMY,DUMMY,IDUMMY,1,X(LXINTS),NSH2,X(LGHOND),
     *           MAXG,X(LDDIJ),IA,WRK2,ORBH,WRK2(l2+1),
     *           ORBH(l2+1),X(LDSH),DUMMY,DUMMY,NXYZ)
      CALL RETFM(NEED1)
      CALL DSCAL(L2d,HALF,ORBH,1)
      II = 0
      DO I=1, L1
        II = II+I
        ORBH(II) = ORBH(II) + ORBH(II)
      ENDDO
CZ
      IF (IEFPFMO.EQ.1) CALL CALCINDE(1,L1,L2,WRK2,ORBH)
CZ
      if(urohf) then
!       CALL DSCAL(L2,HALF,ORBH(L2+1),1)
        II=0
        DO I=1, L1
          II = II+I
          ORBH(II+l2) = ORBH(II+l2) + ORBH(II+l2)
          IF(SCFTYP1.EQ.ROHF) THEN
            ORBH(II+l2*2) = ORBH(II+l2*2) + ORBH(II+l2*2)
          END IF
        ENDDO
      end if
CZ
      IF(DFTYPE.NE.RNONE) THEN
        if(urohf) CALL UDFTFCK(UHF,L1,L2,IA,wrk2,wrk2(l2+1),
     *                         orbh,orbh(l2+1),1)
        if(.not.urohf) CALL DFTFCK(RHF,L1,L2,IA,WRK2,ORBH,1) 
      END IF
C
      IF (GOPARR) CALL DDI_GSUMF(3020,ORBH,L2d)
CZ    TEST
CZ    WRITE(6,*) 'DIAGONAL HESSIAN',L1
CZ    CALL PRTRI(ORBH,L1)
CZ
      DIRSCF  =  DIRSAV
      IST=1
      JST=1
      KST=1
      LST=1
C
      RETURN
      END
C*MODULE FMOCP   *DECK OFFORBHSS
C>
C>     @brief off-diagonal blocks of orbital hessian in FMO 
C>
C>     @details Calculate off-diagonal blocks of orbital hessian in FMO.
C>
C>     @author Takeshi Nagata
C>
      SUBROUTINE OFFORBHSS(IXFG,IXLAY,L1,L2,ZVEC0,IPTZC,OFFH,LAYFRG,
     *                     IDMREC0,NQMTFG,DODISTR,WRK1,WRK2,WRK3,qindz,
     *                     scffrg)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXSH=5000,MXGTOT=20000,MXAO=8192,MXGSH=30,
     *           MXG2=MXGSH*MXGSH,MXRT=100,MAXL=5)
      PARAMETER (HALF=0.5D+00,ZERO=0.0D+00,ONE=1.0D+00)
C
      LOGICAL DIRSCF,FDIFF,DIRSAV,SCHWRZ,PACK2E,GOPARR,DSKWRK,MASWRK,
     *        OUT,SOME,BSSEDIM,SAVGOP,ESPPAR,NXT,ESPAP,DODDCOR,
     *        ESDDER,LARGEPRI,LCFLAG,LRINT,LCFLAGS,LRINTS,DODISTR,
     *        camflag,camflags
CZ    LOGICAL ESDER
C
      DIMENSION LAYFRG(*),IDMREC0(*),KARTEN(0:MAXL-1),NQMTFG(*)
      DIMENSION WRK1(1),WRK2(1),WRK3(1)
      DIMENSION ZVEC0(1),IPTZC(1),OFFH(1)
      dimension qindz(maxnat,*)
      DIMENSION scffrg(*)
C
      COMMON /DFTCAM/ ALPHAC,BETAC,CAMMU,CAMVWN,CAMLYP,CAMFLAG
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
C     COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NLRC  / LCFLAG,EMU,EMU2,LRFILE
      COMMON /NLRCF / LRINT
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OPTSCF/ DIRSCF,FDIFF
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,NANGM,NGTH(4)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2,maxrij
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPMD/ FMOBOX(3),MDWPBC,NIMGCELL,IMGLVL,
     *                LTRVEC,LFMOGCTR,LFMOCTMP,LINDATMD,LWRKDSAV,LINDXIU
     *               ,IPBCFST
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
C
CZ    COMMON /GRAD  / DE(3,MXATM)
C
      DATA KARTEN/1,4,6,10,15/
      DATA RHF/8HRHF     /,UHF/8HUHF     /,ROHF/8HROHF    /,
     *     DBGFMO/8HDBGFMO  /,DBGME/8HFMOESP  /,DEBUG/8HDEBUG   /
CZ
CZ    OFF-DIAGONAL BLOCKS OF ORBITAL HESSIAN IN FMO
CZ
C     PARSTAT: GROUPFULL/GROUPNONE
C
C     FOR NBSSE=3 MONOMERS AND DIMERS DURING BSSE RUNS ARE IN VACCUUM
      IF(NBSSE.EQ.3.AND.IFMOSTP.EQ.5. OR. IFMOSTP.EQ.1) RETURN
      IF (IFMOSTP.EQ.6) THEN
        WRITE (IW,*) 'IFMOSTP=6 IS NOT ALLOWED IN FMOESDER'
        CALL ABRT
      END IF
      IF (IFMOSTP.NE.2.AND.IFMOSTP.NE.4.AND.IFMOSTP.NE.9) RETURN
C
      SOME=(EXETYP.EQ.DEBUG.OR.EXETYP.EQ.DBGFMO.OR.EXETYP.EQ.DBGME).AND.
     *     MASWRK
CZ    ORBXCH=MOD(MODORB,2).NE.0
C     ENEXCH=MOD(MODORB/2,2).NE.0
      ESPPAR=MOD(MODPAR/2,2).NE.0.AND.GOPARR
C     .TRUE.  DIVIDE FRAGMENTS
C     .FALSE. DIVIDE SHELLS
      LWRKDEN  = LFMOBUF(1)  ! LWRK  -> MAXL1D+MAXL2D+MAXL3D
      LWRKESP  = LFMOBUF(2)  ! LWRK2 -> MAXL2D
CZ    LWRKESP2 = LFMODB      ! DB    -> MAXM2D
CZCZ
C
C     FOR MONOMER SCF THERE IS NO NEED TO ADJUST IREC0 BELOW (AND MPPROP MAY
C     NOT HAVE BEEN READ ANYWAY).
C
      IFG      = IXFG
      ILAY     = IXLAY
C
      IF(IFG.EQ.0) RETURN
C
      LCFLAGS =  LCFLAG
      camFLAGS=  camFLAG
      LRINTS  =  LRINT
      LCFLAG  = .FALSE.
      camFLAG = .FALSE.
      LRINT   = .FALSE.
C
C     ESP IS NOT NEEDED. THIS HAPPENS WHEN MONOMER/DIMER SCF ITERATIONS RUN.
C     (ESP IS COMPUTED BEFORE SUCH ITERATIONS ALONG WITH 1-EL INTEGRALS)
C
CZCZ  CALL DERCHK(NDER)
CZ
CZCZ  ESDER = NDER.GT.0.AND.IAND(MODGRD,32).NE.0
CZCZ  IF (.NOT.ESDER) THEN
CZCZ    WRITE(IW,*) 'MUST DEBUG FOR ESDCPHF'
CZCZ    CALL ABRT
CZCZ  END IF
      ESDDER=.FALSE.
C
      ! THEY ARE SUPPOSED TO BE ZERO; OTHERWISE MADE TO BE ZERO
      JFG  = JCURFG
      LFG  = KCURFG
CZCZ
      KFG0 = 1
      KFG1 = NFG
      IZ   = 1
cpbc
      iunit0 = 0
      iunit1 = 0
c     if(mdwpbc.ne.0) then
c       if(nbody.gt.2) call abrt
c       iunit0 = 0
c       iunit1 = nimgcell
c     end if
CZ
      RESPAPI=RESPAP(IZ)
      RESPPCI=RESPPC(IZ)
      BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5
      IF(BSSEDIM) JFG=0
      DODDCOR=IAND(IXESP,1024).NE.0
C
C     SCHWRZ = ISCHWZ.GT.0
      SCHWRZ = .TRUE.
C     DO NOT THINK THAT YOU CAN SET SCHWRZ TO .FALSE. AND GET AWAY WITH IT.
C     SCHWRZ ALSO FORCES INTEGRAL INITIALISATION THAT WILL OTHERWISE NOT BE
C     DONE.
C
      DIRSAV  =  DIRSCF
      DIRSCF  = .TRUE.
C     SCFTYP1 = SCFTYP
C     IF(SCFTYP.EQ.RMC) SCFTYP1=RHF
      SCFTYP1=RHF
      OUT=SCHWRZ.AND.MASWRK.AND.IAND(NPRFMO,3).EQ.0
C
      NPRSAV=NPRFMO
      IF(NPRINT.EQ.-5.AND.IAND(NPRFMO,3).EQ.0) NPRFMO=NPRFMO+1
C     THAT IS, ENFORCE REDUCED OUTPUT IF NPRINT.EQ.-5
C     FOR ESPS THE ONLY MEANINGFUL USAGE OF LOADM IS WITH TRUE ESPPAR.
C     LOADM SHOULD ONLY BE USED IF FULL RANGE OF FRAGMENTS IS TREATED
C     (THAT IS, EXCLUDING SEPARATED DIMERS).
      LOADHF=MOD(MODPAR,2)
      LARGEPRI=LOADHF.EQ.1.AND.ESPPAR.AND.KFG0.EQ.1.AND.KFG1.EQ.NFG
C     WRITE(6,*) 'WWWLB',LARGEPRI
C
      CALL VCLR(OFFH,1,L2)
cz
cz    ESP-PC approximation
cz
      if (iand(modgrd,8).ne.0.and.resppci.ne.zero) then
        CALL PPCVINT(qindz,WRK3,L2,.false.)
czcz  CALL DSCAL(L2,2.0D+00,wrk3,1)
cz      write(6,*) 'test ppcvint',ifg
cz      CALL PRTRI(wrk3,L1)
cz      CALL VCLR(wrk3,1,L2)
      end if
cz
C
C     SAVE THE PRISTINE MONOMER(DIMER) CONFIGURATION
C
      CALL MONBSR(NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR,
     *            NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,
     *            NCURSH,NGAU0,ENUCR0)
C
C     FIX THE NUMBER OF ELECTRONS TO AVOID DOUBLE COUNTING:
C     EXCLUDE CHARGE AS OTHERWISE THE CHARGE OF FRAGMENT I WILL BE ADDED
C     TO NE FIRST HERE AND THEN AGAIN IN MAKMOL BELOW.
C     AT PRESENT NE IS ACTUALLY NOT IMPORTANT BECAUSE NUMFRG HAS NA.
      NE0C=NE0+ICH0
C
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C
      NXT = IBTYP.EQ.1
      NEXT  = -1
      KOUNT = -1
C
C     ESP WILL BE COMPUTED IN THE DIRECT FASHION
C
C     DO 100 KFG=1,NFG
Cpbc
      DO 111 IUNIT=IUNIT0,IUNIT1
       IF(MDWPBC.NE.0.AND.IUNIT.GT.0) THEN
         NATFMOB=NATFMO+NBDFG
         CALL DCOPY(3*NATFMOB,X(LUNTXYZ+3*NATFMOB*IUNIT),1,X(LCFRG),1)
         CALL DCOPY(3*3,X(LUNTROT+3*3*IUNIT),1,TT,1)
         CALL TRMAT
       END IF
      DO 100 KKFG=KFG0,KFG1
        IF(LARGEPRI) THEN
          KFG=IXFTCH(X(LLOADM),KKFG)
        ELSE
          KFG=KKFG
        ENDIF
c       IF(IFG.EQ.KFG.OR.JFG.EQ.KFG.OR.LFG.EQ.KFG) GOTO 100
        IF((IFG.EQ.KFG.OR.JFG.EQ.KFG.OR.LFG.EQ.KFG).AND.
     *     (MDWPBC.eq.0.or.IUNIT.EQ.0)) GOTO 100
        IF (LAYFRG(KFG).LT.ILAY) GO TO 100
C
CZCZ    AS OF 11/23/09
CZCZ    THE APPROXIMATION COULD BE CHANGED FOR THE RESPONSE CALCULATION?
CZCZ
        IF(RESPPCI.NE.ZERO.OR.RESPAPI.NE.ZERO.OR.RESDIM.NE.ZERO) THEN
          RK=FMODIST(IFG,JFG,LFG,KFG)
C         THE DISTANCE WILL BE REFINED LATER FOR SMARTR.
C         WRITE(6,*) 'DISTANCE IS',KFG,RK,RESPPCI
          IF(RK.GT.RESPPCI.AND.RESPPCI.NE.ZERO) GOTO 100
CZ
C
         IF(IFMOSTP.EQ.2.AND.IAND(IXESP,4096).NE.0.AND.RK.NE.0) GOTO 100
C
          ESPAP=RK.GT.RESPAPI.AND.RESPAPI.NE.ZERO
        ELSE
          ESPAP=.FALSE.
        ENDIF
C
        IF(ESPPAR) THEN
          KOUNT=KOUNT+1
          IF(GOPARR) THEN
            IF(NXT) THEN
              IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.KOUNT) GOTO 100
            ELSE
              IF(MOD(KOUNT,NPROC).NE.ME) GOTO 100
            ENDIF
          ENDIF
          SAVGOP=GOPARR
          GOPARR=.FALSE.
C         GOPARR IS SET TO .FALSE. TO PREVENT SHELL-BASED WORK DIVISION
C         INSIDE OF EXCHNG AND FMOESP.
C         NOTE THAT SHELL-BASED WORK DIVISION IS USED FOR ESPPAR=.FALSE.
        ENDIF
        KLAY=MIN(ILAY,LAYFRG(KFG))
C       BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5.AND.KFG.EQ.JCURFG
        BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5
        IF(SOME) WRITE(6,*) 'COMPUTING ESD DUE TO FRG',KFG,' LAYER',KLAY
C
C       ADD MONOMER KFG AND READ ITS DENSITY (NOW ONLY ALPHA)
C
        KFGX = KFG
        CALL MAKEMOL(KFGX,0,0,KLAY,0,NAT0,NCURSH,NGAU0,NE0C,ICH0,MUL0,
     *               .FALSE.)
        L1K =  NUM-NUM0
        L2K = (L1K*L1K+L1K)/2
        L3K =  L1K*L1K
CZCZ    NQK = NQMT - NQMT0
C
        IREC0=IDMREC0(KLAY)
C       HACK IT UP TO POINT TO RHF DENSITIES FOR RUNS WITH MP2 DENSITIES.
        IF(DODDCOR) THEN
          IREC0RHF=1
          IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
          IREC0=IREC0RHF
        ENDIF
        IDMREC0K=KFG+IREC0
CZCZ    IF(.NOT.ESPAP) THEN
        NAK  = ISHFT(IXFTCH(X(LNUMFRG),KFG),-16)
        MULK = IXFTCH(X(LMULFG),KFG)
        NBK  = NAK-MULK+1
CZ
        if(scffrg(kfg).eq.uhf) l3kd=l3k*2
        if(scffrg(kfg).ne.uhf) l3kd=l3k

CZ        JUST GET MO COEFFICIENT MATRIX
CZ
        LCK = LWRKDEN + L2K
        CALL RAREADS(IDAFMO,X(LIODFMO),X(LCK),L3Kd,IDMREC0K,0)
CZCZ      CALL READMOND(WRT1,ORBXCH,SCFFRG(KFG).EQ.RMC,
CZCZ *                  NAK,NBK,L1K,X(LIODFMO),IDMREC0K)
CZCZ      CALL DCOPY(L2K,WRT1,1,TRI2,1)
C         GOTO 100
C         WRITE(6,*) 'ORIGINAL DENSITY',KFG,L1K,NAK
C         CALL PRTRI(X(LFMODA),L1K)
C         CALL SEQOPN(38,'HESSIAN','UNKNOWN',.FALSE.,'UNFORMATTED')
C         WRITE(38) (X(LFMODA+I-1),I=1,L2K)
C         CALL SEQCLO(38,'KEEP')
C         READ BETA DENSITY
CZCZ    ENDIF
CZ
CZ      CONSTRUCT HERE THE DENSITY-LIKE MATRIX FROM ZVLAG
CZ
        NOCK = NAK
        NVRK = IAND(NQMTFG(KFG),65535) - NAK
        NOCKB= NBK
        NVRKB= IAND(NQMTFG(KFG),65535) - NBK
        NOVK=NOCK*NVRK
        NOVKB=NOCKB*NVRKB
        if(scffrg(kfg).eq.uhf.or.scffrg(kfg).eq.rohf) then
          NNUM=NOVK + NOVKB
        else
          NNUM=NOVK
        end if

CZ      NVRK = L1K - NAK
        IF (DODISTR) THEN
          ! TRICKY PART
          ! IPTZC(1) SHOULD BE NOVMAX, WHICH AVOIDS OVERWRITE OF ZVEC0(1)
          IPTZ = IPTZC(1) + 1
          CALL ZVECPUTGET(1,0,KFG,NNUM,X(LIPTZVEC),ZVEC0(IPTZ))
        ELSE
          IPTZ = IPTZC(KFG)
        END IF
        ! TO AO BASIS
        CALL SWBASIS(0,L1K,NOCK,NVRK,X(LCK),ZVEC0(IPTZ),NVRK,WRK2,L1K,
     *               WRK1)
        if(scffrg(kfg).eq.uhf)
     *  CALL SWBASIS(0,L1K,NOCKB,NVRKB,X(LCK+l3K),ZVEC0(IPTZ+NOVK),
     *       NVRKB,WRK2(L3k+1),L1K,WRK1)
        if(scffrg(kfg).eq.rohf)
     *  CALL SWBASIS(0,L1K,NOCKB,NVRKB,X(LCK),ZVEC0(IPTZ+NOVK),
     *       NVRKB,WRK2(L3k+1),L1K,WRK1)
C
        CALL SQ2TRI(L1K,L1K,WRK2,X(LWRKDEN),HALF)
        if(scffrg(kfg).eq.uhf.or.scffrg(kfg).eq.rohf) then
          CALL SQ2TRI(L1K,L1K,WRK2(L3K+1),X(LWRKESP),HALF)
          call daxpy(l2k,one,X(LWRKESP),1,X(LWRKDEN),1)
        end if


C
C
C       ARRAY SIZES ARE DIFFERENT FOR EACH FRAGMENT.
C
        NSH2 = (NSHELL*NSHELL+NSHELL)/2
        CALL BASCHK(LMAX)
        IF(LMAX.GE.5) THEN
           IF(MASWRK) WRITE(IW,*) 'FMO HAS NOT BEEN REVIEWED FOR H,I'
           CALL ABRT
        END IF
C       FOR SOME REASON GAMESS LIKES TO HANDLE AT LEAST L-SHELLS
        NANGM=KARTEN(MAX(LMAX,1))
        MAXG = NANGM**4
        CALL VALFM(LOADFM)
C
        LXINTS= LOADFM + 1
        LGHOND= LXINTS + NSH2
        LDSH  = LGHOND + MAXG
        LDSHB = LDSH   + NSH2
        LDDIJ = LDSHB  + NSH2
        LAST  = LDDIJ  + 49*MXG2
        NEED  = LAST- LOADFM -1
        CALL GETFM(NEED)
C
        LDENP=LPOPMUL+((ICURPOP-1)*NFG+KFG-1)*MAXL1
CZCZ    IF(ESPAP) THEN
CZCZ      LDENA=LDENP
CZCZ      LDENB=LDENA
CZCZ    ELSE
          LDENA=LWRKDEN
CZCZ      LDENB=LFMODB   ! LWRKESP2=GEN
          LDENB=LWRKESP  ! NOTHING HAPPENS, I GUESS
CZCZ    ENDIF
C
C       CALL ERIPRE
C       THERE IS NO NEED TO CALL ERIPRE HERE. FMO CODE ALWAYS CALLS EXCHNG
C       (BECAUSE SCHWRZ IS FORCED TRUE), AHD THIS IS WHERE INITIALISATION
C       FOR EACH (N+1)-MER IS DONE. NOTE THAT THIS INITIALISATION IS
C       IMPORTANT NOW: IT SETS ARRAYS FOR SCREENING AND SOME OTHER THINGS.
C
C       CREATE DENSITY MATRIX FOR SHELL INDICES
C
        IF(SCHWRZ) THEN
          DUMMY = 0.0D+00
CNB       FOR GRADIENTS, WHAT SHOULD BE SCFTYP??
C         L1 AND L2K SEEM TO BE THE RIGHT CHOICE:
C         L1 IS USED TO SKIP L1 AOS TO GET TO THE EXTERNAL MONOMER SHELL
C         L2K GIVES THE SIZE OF GVB DENSITY MATRICES FOR THE EXTERNAL MONOMER
C         WRITE(6,*) 'ORIGINAL DENSITY',KFG,L1K
C         CALL PRTRI(X(LFMODA),L1K)
CZCZ      IF(ESPAP) THEN
C           WRITE(6,*) 'MULLIKENS'
C           CALL PRSQ(X(LDENA),L1K,1,1)
CZCZ        CALL SHLDEND(SCFTYP1,X(LDENA),X(LDENB),DUMMY,X(LDSH),L1,1)
C           WRITE(6,*) 'CONTRACTED L-DENSITY',KFG,NSHELL-NCURSH
C           CALL PRSQ(X(LDSH),NSHELL-NCURSH,1,1)
CZCZ      ELSE
          CALL SHLDEN(SCFTYP1,X(LDENA),X(LDENB),DUMMY,X(LDSH),IA,
     *                L1,L2K,NSH2,1)
            ! ESDDER IS ALWAYS FALSE FOR OFF-DIAGONAL HESSIAN
CZCZ        IF(ESDDER) THEN
C             REMOVE ALL EVIDENCE OF FRAGMENT 2 BEING INVOLVED.
C             KEEP ONLY FRAGMENT 1 INFORMATION AND OBTAIN ITS SHELL DENSITY.
C             L1 ARGUMENT IS UNUSED BELOW.
CZCZ          NSHSAV=NSHELL
CZCZ          NSHELL=NCURSH
CZCZ          NCURSH=0
CZCZ          ! TRI1 WORKS AS DENSITY MATRIX
CZCZ          CALL SHLDEN(SCFTYP1,TRI1,X(LDENB),DUMMY,X(LDSHB),IA,
CZCZ *                    L1,L2,NSH2,1)
CZCZ          NCURSH=NSHELL
CZCZ          NSHELL=NSHSAV
CZCZ        ENDIF
C         WRITE(6,*) 'CONTRACTED DENSITY',KFG,NSHELL-NCURSH
C         CALL PRTRI(X(LDSH),NSHELL-NCURSH)
CZCZ      ENDIF
        END IF
C
C       INITIALISE TWO-ELECTRON INTEGRALS
C       POPLE INTEGRALS USE A SEPARATE COORDINATE COMMON BLOCK INITIALISED
C       ABOVE, ETC. ?ST MUST BE RESET SO THAT NO PHONEY RESTART IS DONE.
C
        IST=1
        JST=1
        KST=1
        LST=1
        CALL JANDK
C
C     ----- EXCHANGE INTEGRALS FOR DIRECT SCF THRESHOLD TESTS -----
C       COMPUTED FOR THE COMBINED SYSTEM, NO NEED TO ADJUST INDICES.
C
        NINT   = 0
        NSCHWZ = 0
CNB5    EXCHNG CAN BE ADJUSTED TO TAKE ADVANTAGE OF THE REDUCED BASIS WITH BSSE.
C       GOTO 100
C       DO IOHNO=1,1000
        IF(SCHWRZ) CALL EXCHNG(X(LXINTS),X(LGHOND),X(LDDIJ),
     *                         NSH2,MAXG,INTTYP)
C       ENDDO
C       COMPUTE 2-EL INTEGRALS CORRESPONDING TO PLACING THE ORIGINAL
C       MONOMER(DIMER) INTO THE COULOMB FIELD OF MONOMER KFG.
C
C       GOTO 100
CZCZ    IF(ESDDER) CALL VCLR(WRT1,1,L2K)
CZ
C       CALL TIMIT(1)
C       DO IOHNO=1,100
CZ
CZ      WE JUST GIVE LDENA TO FMO2EI. THE OUTPUT IS OFFH
CZ
        CALL FMO2EI(SCHWRZ,NINT,NSCHWZ,NSCHWZB,NSCHWNZB,L1,L2,X(LXINTS),
     *              NSH2,X(LGHOND),MAXG,IA,LDENA,LDENP,OFFH,
     *              DUMMY,DUMMY,X(LDSH),X(LDSHB),X(LIAGLOB),
     *              X(LINDAT),X(LINDATG),BSSEDIM,RESPAPI,RESPPCI,ESPAP,
     *              ESDDER,.FALSE.,IFG,JFG,LFG,KFG,0,.false.)
C       ENDDO
C       CALL TIMIT(1)
        IF(OUT) THEN
          IF(NSCHWZB.EQ.0) THEN
            WRITE(IW,9000) KFG,NINT,NSCHWZ
          ELSE
            WRITE(IW,9005) KFG,NINT,NSCHWZ,NSCHWZB
          ENDIF
        ENDIF
C       WRITE(IW,*) 'NON-ZERO SUPERBLOCKS',NSCHWNZB,NSH2
C
C       WRITE(6,*) 'DENSITY IN ESP IS'
C       CALL PRTRIL(X(LFMODA),NUM0)
        IF(ESPPAR) GOPARR=SAVGOP
        CALL RETFM(NEED)
  100 CONTINUE
  111 CONTINUE
      IF(ESPPAR.AND.GOPARR.AND.NXT) CALL DDI_DLBRESET
Cpbc
      IF(MDWPBC.NE.0.AND.IUNIT1.GT.0) THEN
        CALL DCOPY(3*NATFMOB,X(LUNTXYZ),1,X(LCFRG),1)
        CALL RUNITV(3,3,TT)
        CALL TRMAT
      ENDIF
C
      CALL DSCAL(L2,HALF,OFFH,1)
      II = 0
      DO I=1, L1
        II = II + I
        OFFH(II) = OFFH(II) + OFFH(II)
      ENDDO
      IF(GOPARR) CALL DDI_GSUMF(3333,OFFH,L2)
CZ    TEST
CZ    WRITE(6,*) 'OFF-DIAGONAL HESSIAN',L1
CZ    CALL PRTRI(OFFH,L1)
CZ
C
C     IT IS IMPORTANT TO RESET NCURSH SO THAT 2E INTEGRALS WITHIN THE MONOMER
C     (DIMER) DURING THE FOLLOWING SCF ARE COMPUTED PROPERLY.
C
C     COMPUTE 2-EL INTEGRALS FOR THE ORIGINAL MONOMER(DIMER)
C
CZ
CZ    RESTORE THE CALCULATION (11/24/09).
CZ
      CALL MONBSR(NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,NCURSH,NGAU0,
     *           ENUCR0,NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR)
CZ
      NCURSH = 0  ! NEED TO RESET
C
      IF(IFMOSTP.NE.6) THEN
        IST=1
        JST=1
        KST=1
        LST=1
        CALL JANDK
      ENDIF
      NPRFMO = NPRSAV
      DIRSCF = DIRSAV
      LCFLAG = LCFLAGS
      camFLAG =camFLAGS
      LRINT  = LRINTS
cz
cz    ESP-PC approximation
cz
      if (iand(modgrd,8).ne.0.and.resppci.ne.zero) then
        CALL DAXPY(L2,ONE,WRK3,1,OFFH,1)
CZCZ    CALL PRTRI(OFFH,L1)
      end if
cz
C
      RETURN
 9000 FORMAT(/1X,'ESD LFG=',I5,': NZ',I12,' SKIPPED',I10,' BLOCKS.')
 9005 FORMAT(/1X,'ESD LFG=',I5,': NZ',I12,' SKIPPED',I10,' BLOCKS',I8,
     *           ' SUPERBLOCKS.')
      END
C*MODULE FMOCP   *DECK SQ2TRI
      SUBROUTINE SQ2TRI(LDA,L,SQ,TRI,FAC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION TRI(1), SQ(LDA,*)
C
      IC = 0
      DO I = 1, L
        DO J = 1, I
          IC = IC + 1
          TMP = SQ(I,J) + SQ(J,I)
          TRI(IC) = TMP * FAC
        END DO
      END DO
C
      RETURN
      END
C*MODULE FMOCP   *DECK PRFCTMO
      SUBROUTINE PRFCTMO(MODE,LL,NOCC,NVIR,WRK1,WRK2,ORB_E,FAC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION WRK1(LL,*), WRK2(LL,*),ORB_E(1)
CZCZ  PARAMETER (FOUR=4.0D+00)
C
CZ
CZ    MODE=0: FULL PREFACTOR AND COMPLEMENT
CZ    MODE=1: FULL PREFACTOR BUT WRK2 IS DUMMY
CZ    MODE=2: FAC FACTOR AND COMPLEMENT
CZ
      IF (MODE.EQ.0) THEN
        DO IO = 1, NOCC
          E_OCC = ORB_E(IO)
          DO JR = 1, NVIR
            E_VIR = ORB_E(NOCC+JR)
            TMP = FAC*WRK1(JR,IO)/(E_OCC-E_VIR)
            WRK1(JR,IO) = TMP
            WRK2(JR,IO) = TMP*E_OCC
          END DO
        END DO
      ELSEIF (MODE.EQ.1) THEN
        DO IO = 1, NOCC
          E_OCC = ORB_E(IO)
          DO JR = 1, NVIR
            E_VIR = ORB_E(NOCC+JR)
            TMP = FAC*WRK1(JR,IO)/(E_OCC-E_VIR)
            WRK1(JR,IO) = TMP
          END DO
        END DO
      ELSEIF (MODE.EQ.2) THEN
        DO IO = 1, NOCC
          E_OCC = ORB_E(IO)
          DO JR = 1, NVIR
            TMP = FAC*WRK1(JR,IO)
            WRK1(JR,IO) = TMP
            WRK2(JR,IO) = TMP*E_OCC
          END DO
        END DO
      ELSE
        CALL ABRT
      END IF
C
      RETURN
      END
C*MODULE FMOCP   *DECK SWBASIS
      SUBROUTINE SWBASIS(MODE,L1,NOCC,NVIR,C,TRA,LT,OUT,LO,WRK)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00)
      DIMENSION TRA(LT,*), C(L1,*), OUT(LO,*), WRK(L1,L1)
C
CZ
CZ    C MUST BE MO COEFFICIENT MATRIX.
CZ    MODE=0: TRA IS IN THE MO BASIS WITH NVIR*NOCC DIMENSION.
CZ    MODE=1: TRA IS IN THE AO BASIS WITH L1*L1.
CZ
CZ    OUT = SWBASIS + BETA * OUT
CZ
      IF     (MODE.EQ.0) THEN
        ! MO -> AO: C(1,NOCC+1)*TRA*C(1,1)^T
        CALL DGEMM('N','T',NVIR,L1,NOCC,ONE,TRA,LT,C(1,1),L1,ZERO,
     *             WRK,L1)
        CALL DGEMM('N','N',L1,L1,NVIR,ONE,C(1,NOCC+1),L1,WRK,L1,ZERO,
     *             OUT,LO)
      ELSEIF (MODE.EQ.1) THEN
        ! AO -> MO: C(1,NOCC+1)^T*TRA*C(1,1)
        CALL DGEMM('N','N',L1,NOCC,L1,ONE,TRA,LT,C(1,1),L1,ZERO,WRK,L1)
        CALL DGEMM('T','N',NVIR,NOCC,L1,ONE,C(1,NOCC+1),L1,WRK,L1,ZERO,
     *              OUT,LO)
      ELSE
        CALL ABRT
      END IF
      RETURN
      END
C*MODULE FMOCP   *DECK COMPAZ
      SUBROUTINE COMPAZ(NOCC,NVIR,Z,AZ,R,ORB_E)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION Z(NVIR,*), AZ(NVIR,*), ORB_E(1)
      DIMENSION R(NVIR,*)
CZ
CZ    COMPLETE ORBITAL HESSIAN * Z-VECTOR
CZ    R = (E_OCC-E_VIR)*Z - A*Z
CZ
      DO IOCC = 1, NOCC
        EO = ORB_E(IOCC)
        DO IVIR = 1, NVIR
          EV = ORB_E(NOCC+IVIR)
          EVO = EO - EV
          R(IVIR,IOCC) = EVO*Z(IVIR,IOCC) - AZ(IVIR,IOCC)
        END DO
      END DO
C
      RETURN
      END
C*MODULE FMOCP   *DECK ZVLGMEM1
      SUBROUTINE ZVLGMEM1(NZV,MXZVWK,NQMTFG,scffrg,mulfg,layfrg)

C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION NQMTFG(1)
C     FOR UHF 
      DIMENSION mulfg(*),scffrg(*),layfrg(*)
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
C
      DATA UHF/8HUHF     /
      DATA ROHF/8HROHF    /

      NZV = 0
      MXZVWK = 0
      DO I = 1, NFG
        IF(layfrg(I).eq.NLAYER) THEN
          NQMT = IAND(NQMTFG(I),65535)
          NAI  = ISHFT(NQMTFG(I),-16)
          NOCV = NAI * (NQMT - NAI)
          if(scffrg(I).eq.uhf.or.scffrg(I).eq.rohf) then
            NBI = NAI  - mulfg(I)+1
            NOCV= NOCV + NBI * (NQMT - NBI)
          end if
          NZV = NZV + NOCV 
          MXZVWK = MAX(MXZVWK,NOCV)
C       WRITE(6,*) 'NQMT NAI', NQMT, NAI
        END IF
      END DO
C
      RETURN
      END
C*MODULE FMOCP   *DECK ZVLGMEM2
      SUBROUTINE ZVLGMEM2(IPTLG,NQMTFG,scffrg,mulfg,layfrg,dofret,nst)

C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION IPTLG(1),NQMTFG(1)
!    For UHF fragment
      DIMENSION mulfg(nfg),scffrg(nfg),layfrg(nfg)
      LOGICAL   dofret
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
C
      DATA UHF/8HUHF     /
      DATA ROHF/8HROHF    /

C
      IPT = 1
      DO I = 1, NFG
        IPTLG(I) = IPT
        IF(layfrg(I).eq.NLAYER) THEN
          NQMT =  IAND(NQMTFG(I),65535)
          NAI  = ISHFT(NQMTFG(I),-16)
          NOCV = NAI * (NQMT - NAI)
          IPT  = IPT + NOCV
          if(dofret) IPT = IPT + NOCV * (nst + 1)
          if(scffrg(I).eq.uhf.or.scffrg(I).eq.rohf) then
            NBI =NAI - mulfg(I)+1
            NOCV=NBI * (NQMT - NBI)
            IPT =IPT + NOCV
          end if
        END IF
      END DO
      IPTLG(NFG+1) = IPT - 1
C
      RETURN
      END
C*MODULE FMOCP   *DECK SETDZVEC
      SUBROUTINE SETDZVEC(NZVSZ,IPTZVEC,IPTZLG,NUMFRG,NQMTFG,MAXL30,
     *           layfrg)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION IPTZVEC(1),IPTZLG(1),layfrg(1)
      DIMENSION NUMFRG(1),NQMTFG(1),MAXL30(1)
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
CZ
CZ    THIS ROUTINE ARE FOR PUT-GET TREATMENT
CZ
      ! (1) LAGRANGIAN
      IPT   = 1
      NZVSZ = 0
      DO IFG = 1, NFG
        IPTZLG(IFG) = IPT
        IF(layfrg(IFG).eq.NLAYER) THEN
         NQMT = IAND(NQMTFG(IFG),65535)
         NAI  = ISHFT(NUMFRG(IFG),-16)
         NTMP = (NQMT-NAI)*NAI
         NZVSZ = NZVSZ + NTMP
         IPT = IPT + NTMP
        END IF
      END DO
      IF(NFG.LT.0) WRITE(6,*) IPTZLG(1),MAXL30(1)
C
      ! (2). ZVECTORS
      DO IFG = 1, NFG
        IPTZVEC(IFG) = IPT
        IF(layfrg(IFG).eq.NLAYER) THEN
         NQMT = IAND(NQMTFG(IFG),65535)
         NAI  = ISHFT(NUMFRG(IFG),-16)
         NTMP = (NQMT-NAI)*NAI
         NZVSZ = NZVSZ + NTMP
         IPT = IPT + NTMP
        END IF
      END DO
      DO IFG = 1, NFG
        IPTZVEC(NFG+IFG) = IPT
        NTMP = IPTZVEC(IFG+1) - IPTZVEC(IFG)
        NZVSZ = NZVSZ + NTMP
        IPT = IPT + NTMP
      END DO
CZ    IPTZVEC(2*NFG+1) = NZVSZ
CZ    WRITE(6,*) 'IPTZVEC'
CZ    WRITE(6,'(6I5)') (IPTZVEC(I),I=1,2*NFG)

      RETURN
      END
C*MODULE FMOCP   *DECK ZVECPUTGET
      SUBROUTINE ZVECPUTGET(NPUTGET,NNFG,IFG,LEN,IPT,ZVEC)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER DDI_WORLD
      PARAMETER (DDI_WORLD=0)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI
      DIMENSION ZVEC(1),IPT(1)
C
CZ    COMMON /FMCOM / X(1)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
C
C     NPUTGET = 0: PUT
C               1: GET
C      NNFG =   0: ZVEC0
C           = NFG: ZVEC1
C
      IST  = IPT(IFG+NNFG)
      IEND = IST + LEN - 1
C
      IF (MASWRK) THEN
        ITMP = ISCOPE
        IF (ISGDDI.AND.ITMP.NE.DDI_WORLD) CALL GDDI_ASCOPE(DDI_WORLD)
C
        IF     (NPUTGET.EQ.0) THEN
          CALL DDI_PUT(IDFZVEC,1,1,IST,IEND,ZVEC)
        ELSEIF (NPUTGET.EQ.1) THEN
          CALL DDI_GET(IDFZVEC,1,1,IST,IEND,ZVEC)
        ELSE
          CALL ABRT
        END IF
        IF (ISGDDI.AND.ITMP.NE.DDI_WORLD) CALL GDDI_ASCOPE(ITMP)
      END IF
      IF (NPUTGET.EQ.1) CALL DDI_BCAST(3000,'F',ZVEC,LEN,MASTER)
C
      RETURN
      END
C*MODULE FMOCP   *DECK RETZVEC
      SUBROUTINE RETZVEC
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER DDI_WORLD
      PARAMETER (DDI_WORLD=0)
C
      LOGICAL ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
C
      IF (IDFZVEC.GE.0) THEN
        IF (ISGDDI) CALL GDDI_SCOPE(DDI_WORLD)
        CALL DDI_DESTROY(IDFZVEC)
        IDFZVEC = -1
      END IF
C
      RETURN
      END
C*MODULE FMOCP   *DECK ZLAGACCGET
      SUBROUTINE ZLAGACCGET(NACCGET,IFG,IPTLG,LEN,ZLAG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER DDI_WORLD
      PARAMETER (DDI_WORLD=0)

      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI
      DIMENSION ZLAG(1), IPTLG(1)

CZ    COMMON /FMCOM / X(1)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
C
C     NACCGET = 0: ACC
C               1: GET
C               2: PUT (USE FOR ZEROING OUT)
C
      IST  = IPTLG(IFG)
      IEND = IST + LEN - 1

      IF (MASWRK) THEN
        ITMP = ISCOPE
        IF (ISGDDI.AND.ITMP.NE.DDI_WORLD) CALL GDDI_ASCOPE(DDI_WORLD)

        IF     (NACCGET.EQ.0) THEN
          CALL DDI_ACC(IDFZVEC,1,1,IST,IEND,ZLAG)
        ELSEIF (NACCGET.EQ.1) THEN
          CALL DDI_GET(IDFZVEC,1,1,IST,IEND,ZLAG)
        ELSEIF (NACCGET.EQ.2) THEN
          CALL DDI_PUT(IDFZVEC,1,1,IST,IEND,ZLAG)
        END IF

        IF (ISGDDI.AND.ITMP.NE.DDI_WORLD) CALL GDDI_ASCOPE(ITMP)
      END IF
      IF (NACCGET.EQ.1) CALL DDI_BCAST(3000,'F',ZLAG,LEN,MASTER)

      RETURN
      END
C*MODULE FMOCP   *DECK GETMP2MLAG
      SUBROUTINE GETMP2MLAG(IDA,NOCC,NVIR,ZVWRK,ZVLAG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (PT5=0.5D+00)
      DIMENSION ZVWRK(NOCC,*),ZVLAG(NVIR,*)
CZ
CZ    (1). THIS ROUTINE ARRANGES THE ARRAY OF MONOMER MP2 LAG FOR FMO LAG. 
CZ    (2). CALCULATES -(N-2)*XLAI: XLAI IS ALREADY MULTIPLIED BY 4
CZ         IN THE MP2 GRADIENT CODE (MP2GR2.SRC) WHILE FMO LAG IN FMOESD 
CZ         IS NOT MULTIPLIED BY 4 UNTIL SCZV, SO HERE -(N-2)*XLAI SHOULD BE 
CZ         DIVIDED BY 4.
CZ    (3). ON THE OTHER HAND, THE Z-VECTOR EQUATION YEILDS  PAI, 
CZ         WHICH IS NOT YET MULTIPLIED BY 2 FOR THE CLOSED SHELL MP2. 
CZ         THIS MEANS THAT XLAI IS NOT MULTIPLIED BY 2 AS WELL. 
CZ         AS A RESULT, LAGRANGIAN HERE SHOULD BE DIVIDED BY 4/2=2.
CZ
      IF (IDA.EQ.0) RETURN
      DA = IDA
      DA = DA*PT5
      DO IOCC=1, NOCC
        DO IVIR=1, NVIR
          ZVLAG(IVIR,IOCC) = -DA*ZVWRK(IOCC,IVIR)
        END DO
      END DO

      RETURN
      END
C
C
C*MODULE FMOCP   *DECK SWZVROHF
C>
C>    @brief Construct complete Fock like matrix for ROHF
C>
C>    @details Gather Alpha Fock like matrix and Beta Fock like
C>    matrix together to construct the total matrix product (A*Z)
C>
C>    @author Hiroya Nakata
C>    - Aug, 2013- Subroutine written
C>
C>           --- IN/OUTPUT ---
C>    @param ZVECA Alpha Fock like matrix (Z*A)
C>    @param ZVECB Beta  Fock like matrix (Z*B)
C>           --- INPUT ---
C>    @param NOCD  number of doubly occupied molecular orbital
C>    @param NOCS  number of singly occupied molecular orbital
C>    @param NVIRA number of virtual orbital for alpha
C>    @param NVIRB number of virtual orbital for beta
      subroutine SWZVROHF(ZVECA,ZVECB,NOCD,NOCS,NVIRA,NVIRB)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION ZVECA(NVIRA,*),ZVECB(NVIRB,*)
C      
C     MODE 0  convert A B  -->  TOT
      do ivir=1,nvira 
        do iocc = 1,NOCD
c         write(*,'(2f11.8)')ZVECA(ivir,iocc),ZVECB(ivir+NOCS,iocc)
          ZVECA(ivir,iocc) = ZVECB(ivir+NOCS,iocc) + ZVECA(ivir,iocc)
          ZVECA(ivir,iocc) = ZVECA(ivir,iocc)      * 0.5D+00    
          ZVECB(ivir+NOCS,iocc) = ZVECA(ivir,iocc) 
        end do
      end do
C
      RETURN
      END
c
C*MODULE FMOCP   *DECK EXINT_ROHF
C>
C>    @brief Exchange integral terms for ROHF orbital Hessian A
C>
C>    @details Calculate the contribution of ROHF orbital hessian
C>    terms of exchange integral from singly occupied molecular orbitals 
C>
C>    @author Hiroya Nakata
C>    - Aug, 2013- Subroutine written
C>
C>           --- INPUT ---
C>    @param WRT1   two electron integral terms of singly occupied orbital
C>    @param WRK3   work space and dimension is l3*2
C>    @param WRK1   work space and dimension is l3*2
C>    @param CX     molecular orbital coefficient
C>    @param l1     number of atomic orbital 
C>    @param l2     number of elements for triangular matrix of AO
C>    @param NQI    number of moleclar orbital
C>    @param NOCC   number of occupied molecular orbital for alpha
C>    @param NVIR   number of virtual  molecular orbital for alpha
C>    @param NOCCB  number of occupied molecular orbital for beta
C>    @param NVIRB  number of virtual  molecular orbital for beta
C>    @param ZVEC0A Z-vector for alpha molecular orbital
C>    @param ZVEC0B Z-vector for beta  molecular orbital
C>           --- OUTPUT ---
C>    @param ZVEC1A The product of Z-vector and orbital Hessian A for alpha
C>    @param ZVEC1B The product of Z-vector and orbital Hessian A for beta
      SUBROUTINE EXINT_ROHF(WRT1,WRK3,WRK1,CX,L1,L2,NQI,
     *         NOCC,NVIR,NOCCB,NVIRB,
     *         ZVEC0A,ZVEC0B,ZVEC1A,ZVEC1B)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (TWO=2.0D+00)
      PARAMETER (ONE=1.0D+00,ZERO=0.0D+00)
C
      DIMENSION WRT1(*),CX(l1,*)
      DIMENSION WRK3(NQI,NQI,2),WRK1(*)
      DIMENSION ZVEC0A(NVIR,NOCC),ZVEC0B(NVIRB,NOCCB)
      DIMENSION ZVEC1A(NVIR,NOCC),ZVEC1B(NVIRB,NOCCB)
C


C
C     AO -->  MO
      CALL TFTRI(WRK1,WRT1,CX,WRK3,L1,L1,L1)
c     write(*,*) "TEST00"
c     write(*,*) (WRK1(iii),III=1,L1)
C
      DO I = 1,NQI
        SCALI=ZERO
        IF(I.LE.NOCCB) SCALI = TWO 
        IF(I.LE.NOCC.AND.I.GT.NOCCB) SCALI = ONE
        DO K = 1,I
C
          WRK3(I,K,1) = ZERO
          WRK3(K,I,1) = ZERO
C
          SCALK=ZERO
          IF(K.LE.NOCCB) SCALK = TWO 
          IF(K.LE.NOCC.AND.K.GT.NOCCB) SCALK = ONE
          DUM       = abs((SCALI-SCALK)/TWO) 
          IF(DUM.NE.ZERO) THEN
            IF(SCALI.EQ.ZERO) THEN
C         ALPHA ZVEC0 IS USED
              IVIR = I - NOCC
              KOCC = K 
              WRK3(I,K,1) = DUM * ZVEC0A(IVIR,KOCC)
c             WRK3(K,I,1) = DUM * ZVEC0A(IVIR,KOCC)
            ELSE IF(SCALI.EQ.ONE) THEN
C         BETA  ZVEC0 IS USED
              IVIR = I - NOCCB
              KOCC = K 
c             WRK3(K,I,1) = DUM * ZVEC0B(IVIR,KOCC)
              WRK3(I,K,1) = DUM * ZVEC0B(IVIR,KOCC)
            END IF
          END IF
        END DO
      END DO
      CALL CPYTSQ(WRK1,WRK1(l2+1),NQI,1)
C   CONSTRUCT TERM1, TERM2, TERM4,
      CALL DGEMM('N','N',NQI,NQI,NQI,ONE,WRK3,NQI,WRK1(L2+1),NQI,ZERO,
     *             WRK3(1,1,2),NQI)
C     ALPHA (from virtual to doubly or singly occupied orbital)
      DO I=1,NVIR
         DO J=1,NOCC
           II=I+NOCC
           ZVEC1A(I,J)=ZVEC1A(I,J)+WRK3(II,J,2)
         END DO
C     TERM 4
         DO J=NOCCB+1,NOCC
           II=I+NOCC
           ZVEC1A(I,J)=ZVEC1A(I,J)+WRK3(J,II,2)
         END DO
      END DO
C     BETA  (from virtual or singly occupied to doubly occupied orbital)
      DO I=1,NVIRB
         DO J=1,NOCCB
           II=I+NOCCB
           ZVEC1B(I,J)=ZVEC1B(I,J)+WRK3(II,J,2)
         END DO
      END DO
C   CONSTRUCT TERM3, TERM5 and TERM6         
      CALL DGEMM('N','N',NQI,NQI,NQI,ONE,WRK1(l2+1),NQI,
     *     WRK3,NQI,ZERO, WRK3(1,1,2),NQI)
C     ALPHA (from virtual to doubly or singly occupied orbital)
      DO I=1,NVIR
         DO J=1,NOCC
           II=I+NOCC
           ZVEC1A(I,J)=ZVEC1A(I,J)+WRK3(II,J,2)
         END DO
      END DO
C     BETA  (from virtual or singly occupied to doubly occupied orbital)
      DO I=1,NVIRB
         DO J=1,NOCCB
           II=I+NOCCB
           ZVEC1B(I,J)=ZVEC1B(I,J)+WRK3(II,J,2)
         END DO
      END DO
C     TERM3
      DO I=1,NVIRB-NVIR
         DO J=1,NOCCB
           II=I+NOCCB
           ZVEC1B(I,J)=ZVEC1B(I,J)+WRK3(J,II,2)
         END DO
      END DO

      RETURN
      END
c
C*MODULE FMOCP   *DECK EXINT2_ROHF
C>
C>    @brief Exchange integral terms for matrix B^a for ROHF 
C>
C>    @details Calculate the contribution of ROHF gradient from matrix Z*B^a:
C>    the terms of exchange integral from singly occupied molecular orbitals 
C>    is added.
C>
C>    @author Hiroya Nakata
C>    - Aug, 2013- Subroutine written
C>
C>           --- INPUT ---
C>    @param WRT1   two electron integral terms of singly occupied orbital
C>    @param WRK3   work space and dimension is l3*2
C>    @param WRK1   work space and dimension is l3*2
C>    @param CX     molecular orbital coefficient
C>    @param l1     number of atomic orbital 
C>    @param l2     number of elements for triangular matrix of AO
C>    @param NQI    number of moleclar orbital
C>    @param NOCC   number of occupied molecular orbital for alpha
C>    @param NVIR   number of virtual  molecular orbital for alpha
C>    @param NOCCB  number of occupied molecular orbital for beta
C>    @param NVIRB  number of virtual  molecular orbital for beta
C>    @param ZVEC0A Z-vector for alpha molecular orbital
C>    @param ZVEC0B Z-vector for beta  molecular orbital
C>           --- OUTPUT ---
C>    @param TRI2   The product of Z-vector and orbital Hessian A, and
C>                  it is converted to AO basis 
      SUBROUTINE EXINT2_ROHF(WRT1,WRK3,WRK1,CX,L1,L2,NQI,
     *         NOCC,NVIR,NOCCB,NVIRB,
     *         ZVEC0A,ZVEC0B,TRI2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (TWO=2.0D+00,MXAO=8192)
      PARAMETER (ONE=1.0D+00,ZERO=0.0D+00,HALF=0.5D+00)
C
      DIMENSION WRT1(*),CX(l1,*)
      DIMENSION WRK3(NQI,NQI,2),WRK1(*)
      DIMENSION ZVEC0A(NVIR,NOCC),ZVEC0B(NVIRB,NOCCB)
      DIMENSION TRI2(*)
      COMMON /IJPAIR/ IA(MXAO)
C


C
C     AO -->  MO
      L3 = L1 * L1
      CALL TFTRI(WRK1,WRT1,CX,WRK3,L1,L1,L1)
c     write(*,*) "TEST01"
c     write(*,*) (WRK1(iii),III=1,L1)
C
      CALL VCLR(WRK3,1,L1*L1*2)
C    FOR I K block
      DO I = NOCCB+1,NQI
         SCALI=ZERO
         IF(I.LE.NOCC) SCALI=ONE
         DO K = 1,NOCC
           SCALK=ONE
           IF(K.LE.NOCCB) SCALK=TWO 
           VAL0 =abs((SCALI-SCALK)/TWO)
           IF(VAL0.NE.ZERO) THEN
             DUM=ZERO
             NOCC0=NOCC
             IF(I.LE.NOCC) NOCC0=NOCCB
             DO J= 1,NOCC0
                IF(I.GT.NOCC) VAL1 = ZVEC0A(I-NOCC ,J)
                IF(I.LE.NOCC) VAL1 = ZVEC0B(I-NOCCB,J)
                IF(K.GE.J)    VAL2 = WRK1(IA(K)+J)
                IF(K.LT.J)    VAL2 = WRK1(IA(J)+K)
                SCAL = ONE
                IF(SCALI.EQ.ZERO.AND.J.LE.NOCCB) SCAL = TWO
                DUM  = DUM + VAL0*VAL1*VAL2*SCAL
             END DO 
             WRK3(I,K,1)=DUM
           END IF
         END DO
      END DO
C    FOR J K block
      DO J = NOCCB+1,NOCC
         DO K = 1,NOCCB
            VAL0=HALF
            DUM =ZERO
            DO I=NOCC+1,NQI
              VAL1 = ZVEC0A(I-NOCC ,J)
              VAL2 = WRK1(IA(I)+K)
              DUM  = DUM + VAL0*VAL1*VAL2
            END DO
            WRK3(J,K,2)=DUM
         END DO
      END DO
C     MO  --> AO    
      CALL DGEMM('N','N',l1,NQI,NQI,ONE,CX,L1,WRK3,NQI,ZERO,WRK1,l1)
      CALL DGEMM('N','T',l1,l1,NQI,ONE,WRK1,l1,CX,l1,ZERO,WRK1(L3+1),l1)
      CALL SQ2TRI(L1,L1,WRK1(L3+1),WRK1,ONE)
      call daxpy(l2,ONE,WRK1,1,TRI2,1)
C
      CALL DGEMM('N','N',l1,NQI,NQI,ONE,CX,L1,WRK3(1,1,2),
     *            NQI,ZERO,WRK1,l1)
      CALL DGEMM('N','T',l1,l1,NQI,ONE,WRK1,l1,CX,l1,ZERO,WRK1(L3+1),l1)
      CALL SQ2TRI(L1,L1,WRK1(L3+1),WRK1,ONE)
      call daxpy(l2,ONE,WRK1,1,TRI2,1)
C
      RETURN
      END

C
C
C*MODULE FMOCP  *DECK TDDER2
C>
C>    @brief DFT contributions to orbital relaxation terms
C>
C>    @details Calculate the contribution of DFT gradient from matrix Z*B^a:
C>    the terms of DFT exchange corrlation is added.
C>
C>    @author Federico Zahariev
C>    - Aug, 2013- Subroutine written
C>
C>           --- INPUT ---
C>    @param ZVEC   Zvector  coverted from  MO to AO
C>    @param   L1   work space and dimension is l3*2
C>    @param   DX   Molecular orbitals
      SUBROUTINE TDDER2(zvec,L1,DX,urohf,NAI,NBI)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
c     PARAMETER (MXATM=2000)
      PARAMETER (ONE=1.0D+00)
C
      dimension zvec(*),DX(*)
C
c     LOGICAL TRIPLET,SG1T,TAMMD
      logical urohf
C
      COMMON /FMCOM / X(1)
      COMMON /INFGRD/RHOMIN,ILENG,MAXGRD
c     COMMON /INFOTD/ CNVTOL,TRIPLET,SG1T,JANST,NRADT,NTHET,NPHIT,NLEBT,
c    *                NSTAT,NTRIAL,MAXVEC,NTHST,IRECTD,ITDFG,NONEQR,
c    *                ITDPRP,TAMMD
c     COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
C  for debug
c     COMMON /GRAD  / DE(3,MXATM)
C
c     DATA    CHECK,DBUGME/8HCHECK   ,8HTDDER   /
C
C         COMPUTE GRID POINT CONTRIBUTIONS TO TD-DFT NUCLEAR GRADIENT
C
c     DEBUG = EXETYP.EQ.DBUGME
C
C     --- DEFINE MAXGRD
      CALL MEMGRD
C
C     --- MEMORY
C
      L2   = (L1*(L1+1))/2
      L3   = L1*L1
      lnum = 1
      if(urohf) lnum = 2
C
      CALL VALFM(LOADFM)
      I10=LOADFM+1
C     I10:V(L1*LX) OR SCRATCH
      I20=I10+L1*L1*lnum
C     I20:PA(L3)
c     I30=I20+L3
C     I30:V1A(L3)
c     J10=I30+L3
      J10=I20+L3*lnum
C     J10:XYZGRD(MAXGRD*3)
      J20=J10+MAXGRD*3
C     J20:XYZWGT(MAXGRD)
      J30=J20+MAXGRD
C     J30:XYZDDC(10,NUM,ILENG)
      J40=J30+10*L1*ILENG
C     J40:D(L2)
      J50=J40+L2*lnum
C     J50:KCP(MAXGRD)
      J60=J50+MAXGRD
C     J60:GRDFUN(MAXGRD)
      J70=J60+MAXGRD
C     J70:DRHOI_(4*MAXGRD)
      J80=J70+4*MAXGRD*lnum
C     J80:EX0(ILENG)
      J90=J80+ILENG
C     J90:EX(38*ILENG)
      J100=J90+38*ILENG
C     J100:EC0(ILENG)
      J110=J100+ILENG
C     J110:EC(119*ILENG)
      J120=J110+119*ILENG
C     J120:AOMAX(L1)
      J130=J120+L1
C     J130:IPRGRD(2,L3)
      J140=J130+2*L3*lnum
C     J140:IAO(L1)
      J150=J140+L1
C     J150:DDUM(ILENG,4)
      J160=J150+4*ILENG*lnum
C     J160:PDUM(ILENG,4)
      J170=J160+4*ILENG*lnum
C     J170:VDUM(ILENG,4)
      J180=J170+4*ILENG*lnum
C     J180:DTRAI_(5*ILENG)
      J190=J180+5*ILENG*lnum
C     J190:DTAUI_(MAXGRD)
      LAST=J190+MAXGRD*lnum
      NEED=LAST-I10
      CALL GETFM(NEED)
C
C
c     IF(EXETYP.EQ.CHECK) GO TO 800
C
C     -- GRID READ AND DENSITY SET
C
      CALL DCOPY(L3,DX(1+l2),1,X(I10),1)
      if(.not.urohf) then
       CALL TDDFTSET(RHOSET,X(J10),X(J20),X(J30),X(I10),
     *               X(J70),X(J190),X(J120),X(J130),ILENG,NPTGRD,L1)
      else 
       CALL DCOPY(L3,DX(1+l2+l3),1,X(I10+l3),1)
       CALL UTDDFTSET(X(J10),X(J20),X(J30),X(I10),X(I10+l3),
     *               X(J70),X(J190),X(J120),X(J130),ILENG,NPTGRD,L1)
      end if
C     ----- CALCULATE XC GRADIENT     BY USING PA, V1A, DA
C
c     call cantogen(zvec,x(i20),l1)
      CALL DCOPY(L3,zvec,1,X(i20),1)
      if(urohf) CALL DCOPY(L3,zvec(l3+1),1,X(i20+l3),1)
c     call vclr(x(i30),1,l1*l1)
      if(urohf) then
C      alpha
       CALL DMTX2(DX,DX(l2+1),NAI,L1,L1,0)
       CALL DCOPY(L2,DX,1,X(J40),1)
C      beta
       CALL DMTX2(DX,DX(l2+1+L3),NBI,L1,L1,0)
       CALL DCOPY(L2,DX,1,X(J40+l2),1)
C
       call daxpy(l2,ONE,X(J40+l2),1,DX,1)
      else
       CALL DCOPY(L2,DX,1,X(J40),1)
      end if
      CALL DSCAL(L3*lnum,0.5D+00,X(i20),1)
      CALL DSCAL(L2*lnum,0.5D+00,X(J40),1)
C
      CALL CANTOGEN(X(J40),X(I10),L1)
      if(urohf) CALL CANTOGEN(X(J40+l2),X(I10+l3),L1)
C
      CALL VFEXC2(X(I10),X(I20),X(J10),X(J20),X(J30),X(J70),
     *           X(J190),X(J180),X(J80),X(J90),X(J100),X(J110),X(J60),
     *           X(J50),X(J120),X(J150),X(J160),X(J140),X(J130),
     *           NPTGRD,L1,ILENG,urohf)
C
C
c     IF (GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
c     IF (MASWRK) THEN
c       WRITE(*,*) 'GRADIENT VECTOR AFTER VFEXC2'
c       DO I = 1, NAT
c         WRITE(*,'(3F12.8)') DE(1,I),DE(2,I),DE(3,I)
c       END DO
c     END IF
c     IF(GOPARR) CALL DSCAL(3*NAT,1.0D+00/NPROC,DE,1)
C     ----- WEIGHT DERIVATIVE CORRECTION
C
c 800 CONTINUE
      NEEDDER = NEED
      CALL TDWGT(X(J60),X(J70),NPTGRD,NEEDDER)
C
      CALL RETFM(NEED)
      CALL TIMIT(1)
      RETURN
      END
C
C*MODULE TDDGRD  *DECK VFEXC2
C>
C>    @brief DFT numerical integration driver for SCZV
C>
C>    @details Calculate the numerical integration over the fragments 
C>    and evaluate the contribution of DFT gradient of matrix Z*B^a:
C>    the terms of DFT exchange corrlation is added.
C>
C>    @author Federico Zahariev
C>    - Aug, 2013- Subroutine written
C>
C>           --- INPUT ---
C>   @param        D   molecular orbitals
C>   @param       PA   Z-vector
C>   @param      V1A   Dummy variable
C>   @param   XYZGRD   Cartesian coordinate for grid points
C>   @param   XYZWGT   weight for grid points
C>   @param   XYZDDC   atomic orbital and its derivative at the grid points
C>   @param  DRHOI_    Electronic density at the gridpoint.
C>   @param  DTAUI_    Density derivative terms
C>   @param  DTRAI_    Product of respons terms and rho or gamma 
C>   @param   EX0      energy of exchange function 
C>   @param   EX       derivative of exchange function with respect to the density
C>   @param   EC0      energy of correlation funciton
C>   @param   EC       derivative of correlation function with respect to the density
C>   @param   GRDFUN   contribution of XC due to the integration grid.
C>   @param      KCP   indice of atom on the grid points
C>   @param  AOMAX     maximum value for AO function.
C>   @param     DDUM   work variable for gradient
C>   @param     PDUM   work variable for gradient
C>   @param      IAO   Atomic orbital indice having large AO
C>   @param   IPRGRD   Atomic orbital pair to be calculated
C>   @param   NPTGRD   Number of total grid point
C>   @param       L1   Number of AO
C>   @param    ILENG   number of grid point to be calculated
      SUBROUTINE VFEXC2(D,PA,XYZGRD,XYZWGT,XYZDDC,DRHOI_,
     *             DTAUI_,DTRAI_,EX0,EX,EC0,EC,GRDFUN,KCP,AOMAX,
     *                 DDUM,PDUM,IAO,IPRGRD,NPTGRD,L1,ILENG,urohf)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION D(*),PA(L1,L1,*),
     *          XYZGRD(3,NPTGRD),XYZWGT(NPTGRD),XYZDDC(*),
     *          DRHOI_(*),DTAUI_(*),DTRAI_(*),EX0(*),
     *          EX(*),EC0(*),EC(*),
     *          GRDFUN(NPTGRD),KCP(NPTGRD),AOMAX(*),
     *          DDUM(*),PDUM(*),IAO(*),IPRGRD(*)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DLB,SG1,urohf
C
      PARAMETER (MXATM=2000,ONE=1.0D+00)
      PARAMETER (MXGRID=10,MXGRIDTYP=10)
C
      COMMON /DFGRID/ DFTTHR,DFTGTHR,SWOFF,SW0,BSLRD(137),NDFTFG,
     *                NRAD,NTHE,NPHI,NRAD0,NTHE0,NPHI0,
     *                NANGPT(MXGRID),NANGPT0(MXGRID),SG1,JANS
      COMMON /DFPRUN/ PRUNERADS(MXGRID,MXGRIDTYP),
     *                PRUNEATOMS(2,MXGRIDTYP),
     *                IPRUNECUTS(MXATM),NTOTGRIDPOINTS(MXATM),
     *                NGRIDS,MAXANG,NGRIDTYPS
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SCFOPT/ CONVHF,MAXIT,MCONV,NPUNCH,NPREO(4)
C
C     -- MEMORY ALLOCATION
C
C     THE VARIABLE IRU IS HARD-CODED IN SOMETIMES, BUT NOT ALWAYS.
C
      IRU = 1
      if(urohf) IRU = 2
C      IF (NOT((IRU.EQ.1).OR.(IRU.EQ.2))) THEN
C        IF(MASWRK) WRITE(IW,*) ' SOMETHING IS WRONG, IRU=',IRU
C      ENDIF
      L3   = L1*L1
      CALL VALFM(LOADFM)
      IPA  = LOADFM + 1
      LWRK = IPA    + L3 * IRU
      LAST = LWRK   + L3
c     LAST = IPB  + L3
      NEED = LAST   - IPA
      CALL GETFM(NEED)
C
C     REDUCE MATRICES FOR FAST CALL TO XCGRD
C     DO NOT INTERCHANGE I,J BELOW
      NCOUNT = 0
      DO ISP = 1,IRU
       DO J = 1, L1
        DO I = 1, L1
          X(IPA+NCOUNT)  = PA(I,J,ISP) + PA(J,I,ISP)
          NCOUNT = NCOUNT + 1
        END DO
       END DO
      END DO
C
c     DBUG   = .FALSE.
      NPT    = NRAD*MAXANG
      RCUTOFF= CONVHF/(NPT*NAT)
C
      CALL GRDRD(22,XYZGRD,XYZWGT,KCP,NPTGRD,1)
      CALL VCLR(GRDFUN,1,NPTGRD)
      RHO  =0.0D+00
      IST  =0
      IEND =0
      IAREA=0
C
C     LOAD BALANCING TERMS
      LOOP  =0
      NGRAN =20
      NLENG =(NPTGRD-1)/ILENG + 1
      MCHUNK=(NLENG-1)/(NGRAN*NPROC)+1
      NEXT  =-1
      DLB   =IBTYP.EQ.1
C
C     CHANGED GOTO INTO DO LOOP FOR PARALLELIZATION
C
      DO 10 ILG=1,NLENG
C
C     DYNAMIC AND STATIC LOAD BALANCING
C
      IF(GOPARR) THEN
         IF(DLB) THEN
            LOOP=LOOP+1
            ICHUNK=(LOOP-1)/MCHUNK
            IF(ICHUNK.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
            IF(NEXT.NE.ICHUNK) GOTO 10
C     SLB HAS ALREADY DISTRIBUTED THE DATA, DO EVERYTHING WE HAVE STORED
         ELSE
C---        IF(MOD(ILG,NPROC).NE.ME) GOTO 10
            CONTINUE
         ENDIF
      ENDIF
C      IST=IEND+1
      IST  =(ILG-1)*ILENG+1
      IEND =IST+ILENG-1
      IAREA=IAREA+1
      IF(IEND.GT.NPTGRD) IEND=NPTGRD
C
C     ---- FUNCTIONAL ENERGY AND DERIVATIVES
C          EX(ILENG,18) & EC(ILENG,55)
C
      CALL DFXCSET(EX0,EX,EC0,EC,DRHOI_,DTAUI_,XYZWGT,1.0D-12,
     *             EXC,ECOR,ILENG,NPTGRD,IRU,2,IST,IEND)
c     HN: NDER should be changed from 3 to 2.
C
C     ---- GRADIENT DENSIY:DDUM,PDUM,VDUM
C
      CALL GRDGAO(IST,IEND,XYZGRD,XYZDDC,AOMAX,L1)
      THRE=1.0D-08
      CALL AOSERCH(THRE,AOMAX,IAO,L1,IAON)
C     PA
      THRE=1.0D-11
C
      CALL DCOPY(L3,PA,1,X(LWRK),1)
      IF(UROHF) call daxpy(l3,ONE,PA(1,1,2),1,X(LWRK),1)
C
      CALL SELECTPR(THRE,X(LWRK),AOMAX,IPRGRD,IAO,IMAX,L1,IAON)
C     for UDFT
      CALL TRADEN2_fmocp(RCUTOFF,DRHOI_,DTRAI_,PA,XYZDDC,IPRGRD,
     * IST,IEND,NPTGRD,IMAX,L1,ILENG,IRU)
C
      CALL GSVCOEF2(DDUM,PDUM,DRHOI_,DTRAI_,EX,EC 
     * ,GRDFUN,RCUTOFF,NPTGRD,ILENG,IST,IEND,1)
C     V1A
c     CALL SELECTPR(THRE,V1A,AOMAX,IPRGRD,IAO,IMAX,L1,IAON)
c     CALL TRADEN2(RCUTOFF,DRHOI_,DTRAI_,V1A,XYZDDC,IPRGRD,
c    * IST,IEND,NPTGRD,IMAX,L1,ILENG)
c     CALL FCOEF(DDUM,VDUM,DRHOI_,DTRAI_,EX,EC
c    * ,GRDFUN,RCUTOFF,NPTGRD,ILENG,IST,IEND,1)
c
C     ---- V & F GRADIENT
C
      CALL GRDGGAO(IST,IEND,XYZGRD,XYZDDC,AOMAX,L1)
      CALL XCGRD2(RHO,DRHOI_,DDUM,PDUM,D,D,X(IPA),
     * XYZWGT,XYZDDC,RCUTOFF,NPTGRD,KCP,ILENG,IST,IEND,L1,1)
C
C      IF(IEND.EQ.NPTGRD) THEN
C      GOTO 20
C      ELSE
C      GOTO 10
C      ENDIF
C   20 CONTINUE
C
 10   CONTINUE
C
C     RESET FOR DYNAMIC LOAD BALANCING
C
      IF(GOPARR.AND.DLB) CALL DDI_DLBRESET
C
C
      CALL RETFM(NEED)
      RETURN
      END
C



C*MODULE TDDGRD  *DECK XCGRD
C>
C>    @brief Calculate final product of groud state energy derivative
C>
C>    @details Calculate the product of grid, density and XC function
C>
C>    @author Federico Zahariev
C>    - Aug, 2013- Subroutine written
C>
C>           --- INPUT ---
C>   @param      RHO   product of density and grid weight for check
C>   @param  DRHOI_    Electronic density at the gridpoint.
C>   @param     DDUM   work variable for gradient
C>   @param     PDUM   work variable for gradient
C>   @param       DA   alpha density
C>   @param       DB   beta  density
C>   @param      PPA   zvector
C>   @param   XYZWGT   weight for grid points
C>   @param   XYZDDC   atomic orbital and its derivative at the grid points
C>   @param   RHOMIN   Cutoff thrushold for density
C>   @param   NPTGRD   Number of total grid point
C>   @param      KCP   indice of atom on the grid points
C>   @param    ILENG   number of grid point to be calculated
C>   @param      IST   starting point for grid integration
C>   @param     IEND   last     point for grid integration
C>   @param       L1   Number of AO
C>   @param      IRU   Indice for open shell
      SUBROUTINE XCGRD2(RHO,DRHOI_,DDUM,PDUM,DA,DB,PPA,
     *                 XYZWGT,XYZDDC,RHOMIN,NPTGRD,KCP,
     *                 ILENG,IST,IEND,L1,IRU)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXSH=5000, MXGTOT=20000,MXATM=2000,ZERO=0.0D+00)
C
      DIMENSION DA(L1,*),DB(L1,*)
      DIMENSION PPA(L1,L1,IRU)
c     DIMENSION PV1A(L1,L1,IRU)
      DIMENSION DRHOI_(NPTGRD,4,IRU)
      DIMENSION DDUM(4,ILENG,IRU)
      DIMENSION PDUM(4,ILENG,IRU)
c     DIMENSION VDUM(4,ILENG,IRU)
      DIMENSION XYZWGT(*)
      DIMENSION XYZDDC(10,L1,*)
      DIMENSION KCP(*)
      DIMENSION DUMA(4,2),DEMA(4,2)
C
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
C
C     -- GRID LOOP
      DO IPT=IST,IEND
      IIPT=IPT-IST+1
      RHOA = DRHOI_(IPT,1,1)
      RHOB = DRHOI_(IPT,1,IRU)
      RHOT=RHOA+RHOB
      IF(RHOT.GT.RHOMIN) THEN
C
C     --- GRADIENT OF THE THREE DIFFERENT DENSITIES
C     -- D DENSITY GRADIENT
      DUMA(1,1) = DDUM(1,IIPT,1)
      DUMA(2,1) = DDUM(2,IIPT,1)
      DUMA(3,1) = DDUM(3,IIPT,1)
      DUMA(4,1) = DDUM(4,IIPT,1)
      DUMA(1,2) = DDUM(1,IIPT,IRU)
      DUMA(2,2) = DDUM(2,IIPT,IRU)
      DUMA(3,2) = DDUM(3,IIPT,IRU)
      DUMA(4,2) = DDUM(4,IIPT,IRU)
C     -- P DENSITY GRADIENT
      DEMA(1,1) = PDUM(1,IIPT,1)
      DEMA(2,1) = PDUM(2,IIPT,1)
      DEMA(3,1) = PDUM(3,IIPT,1)
      DEMA(4,1) = PDUM(4,IIPT,1)
      DEMA(1,2) = PDUM(1,IIPT,IRU)
      DEMA(2,2) = PDUM(2,IIPT,IRU)
      DEMA(3,2) = PDUM(3,IIPT,IRU)
      DEMA(4,2) = PDUM(4,IIPT,IRU)
C     CALL VCLR(DUMA,1,4*2)
C     CALL VCLR(DEMA,1,4*2)
C     CALL VCLR(DOMA,1,4*2)
C
C     --- CALCULATE DENSITY GRADIENT
C
      KAT=KCP(IPT)
      DO 100 ISHELL=1,NSHELL
       IAT =KATOM(ISHELL)
       IF(IAT.EQ.KAT) GOTO 100
       MINI=KMIN (ISHELL)
       MAXI=KMAX (ISHELL)
       LOCI=KLOC (ISHELL)-MINI
       TEMPX = ZERO
       TEMPY = ZERO
       TEMPZ = ZERO
       DO IBFN=MINI,MAXI
       ICHI=LOCI+IBFN
       DO JCHI=1,L1
C      -- DENSITY TERM
       DAIJ=DA(JCHI,ICHI)+DA(JCHI,ICHI)
       DBIJ=DB(JCHI,ICHI)+DB(JCHI,ICHI)
       PAIJ=PPA(JCHI,ICHI,1)
       PBIJ=PPA(JCHI,ICHI,IRU)
C     --ALPHA
       DUMNA=DUMA(1,1)*DAIJ+DEMA(1,1)*PAIJ
       DUMXA=DUMA(2,1)*DAIJ+DEMA(2,1)*PAIJ
       DUMYA=DUMA(3,1)*DAIJ+DEMA(3,1)*PAIJ
       DUMZA=DUMA(4,1)*DAIJ+DEMA(4,1)*PAIJ
c     --BETA
       DUMNB=DUMA(1,2)*DBIJ+DEMA(1,2)*PBIJ
       DUMXB=DUMA(2,2)*DBIJ+DEMA(2,2)*PBIJ
       DUMYB=DUMA(3,2)*DBIJ+DEMA(3,2)*PBIJ
       DUMZB=DUMA(4,2)*DBIJ+DEMA(4,2)*PBIJ
C     --TOTAL
       DUM=DUMNA+DUMNB
       DUMX=DUMXA+DUMXB
       DUMY=DUMYA+DUMYB
       DUMZ=DUMZA+DUMZB
C    THIS PIECE OF CODE IS OBSOLETE NOW THAT THE LOOP
C    IS RESTRUCTURED
C
C      TEMP =DUM * XYZDDC( 1,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)
C    *      +DUMX*(XYZDDC( 2,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
C    *             XYZDDC( 1,ICHI,IIPT)*XYZDDC( 2,JCHI,IIPT))
C    *      +DUMY*(XYZDDC( 3,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
C    *             XYZDDC( 1,ICHI,IIPT)*XYZDDC( 3,JCHI,IIPT))
C    *      +DUMZ*(XYZDDC( 4,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
C    *             XYZDDC( 1,ICHI,IIPT)*XYZDDC( 4,JCHI,IIPT))
       TEMPX=TEMPX + DUM * XYZDDC( 2,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)
     *      +DUMX*(XYZDDC( 5,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
     *             XYZDDC( 2,ICHI,IIPT)*XYZDDC( 2,JCHI,IIPT))
     *      +DUMY*(XYZDDC( 8,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
     *             XYZDDC( 2,ICHI,IIPT)*XYZDDC( 3,JCHI,IIPT))
     *      +DUMZ*(XYZDDC( 9,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
     *             XYZDDC( 2,ICHI,IIPT)*XYZDDC( 4,JCHI,IIPT))
       TEMPY=TEMPY + DUM * XYZDDC( 3,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)
     *      +DUMX*(XYZDDC( 8,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
     *             XYZDDC( 3,ICHI,IIPT)*XYZDDC( 2,JCHI,IIPT))
     *      +DUMY*(XYZDDC( 6,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
     *             XYZDDC( 3,ICHI,IIPT)*XYZDDC( 3,JCHI,IIPT))
     *      +DUMZ*(XYZDDC(10,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
     *             XYZDDC( 3,ICHI,IIPT)*XYZDDC( 4,JCHI,IIPT))
       TEMPZ=TEMPZ + DUM * XYZDDC( 4,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)
     *      +DUMX*(XYZDDC( 9,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
     *             XYZDDC( 4,ICHI,IIPT)*XYZDDC( 2,JCHI,IIPT))
     *      +DUMY*(XYZDDC(10,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
     *             XYZDDC( 4,ICHI,IIPT)*XYZDDC( 3,JCHI,IIPT))
     *      +DUMZ*(XYZDDC( 7,ICHI,IIPT)*XYZDDC( 1,JCHI,IIPT)+
     *             XYZDDC( 4,ICHI,IIPT)*XYZDDC( 4,JCHI,IIPT))
       END DO
       END DO
C     --- USING TRANSLATIONAL INVARIANCE
       DE(1,IAT)=DE(1,IAT)-TEMPX*XYZWGT(IPT)
       DE(2,IAT)=DE(2,IAT)-TEMPY*XYZWGT(IPT)
       DE(3,IAT)=DE(3,IAT)-TEMPZ*XYZWGT(IPT)
       DE(1,KAT)=DE(1,KAT)+TEMPX*XYZWGT(IPT)
       DE(2,KAT)=DE(2,KAT)+TEMPY*XYZWGT(IPT)
       DE(3,KAT)=DE(3,KAT)+TEMPZ*XYZWGT(IPT)
  100 CONTINUE
C     -- DEBUG DENSITY
      RHO =RHO +RHOT *XYZWGT(IPT)
      ENDIF
      END DO
C     -- END GRID LOOP
C
      RETURN
      END
C
C*MODULE FMOCP *DECK GSVCOEF2
C>
C>    @brief Calculate product of XC and dnsity for gradient 
C>
C>    @details Calculate the product of density and XC function
C>
C>    @author Federico Zahariev
C>    - Aug, 2013- Subroutine written
C>
C>           --- INPUT ---
C>   @param     DDUM   work variable for gradient
C>   @param     PDUM   work variable for gradient
C>   @param  DRHOI_    Electronic density at the gridpoint.
C>   @param  DTRAI_    Product of respons terms and rho or gamma 
C>   @param   EX       derivative of exchange function with respect to the density
C>   @param   EC       derivative of correlation function with respect to the density
C>   @param   GRDFUN   contribution of XC due to the integration grid.
C>   @param   RHOMIN   Cutoff thrushold for density
C>   @param   NPTGRD   Number of total grid point
C>   @param    ILENG   number of grid point to be calculated
C>   @param      IST   starting point for grid integration
C>   @param     IEND   last     point for grid integration
C>   @param      IRU   Indice for open shell
      SUBROUTINE GSVCOEF2(DDUM,PDUM,DRHOI_,DTRAI_,EX,EC,
     *                   GRDFUN,RHOMIN,NPTGRD,ILENG,IST,IEND,IRU)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON /XDERIX/ NXDIM(3),KRA,KRB,KGA,KGB,KTA,KTB,KRARA,KRAGA,
     *                KRATA,KGAGA,KGATA,KTATA,KRBRB,KRBGB,KRBTB,KGBGB,
     *                KGBTB,KTBTB,KRARARA,KRARAGA,KRARATA,KRAGAGA,
     *                KRAGATA,KRATATA,KGAGAGA,KGAGATA,KGATATA,KTATATA,
     *                KRBRBRB,KRBRBGB,KRBRBTB,KRBGBGB,KRBGBTB,KRBTBTB,
     *                KGBGBGB,KGBGBTB,KGBTBTB,KTBTBTB
      COMMON /CDERIX/ NCDIM(3),IRA,IRB,IGA,IGB,IGC,ITA,ITB,IRARA,IRARB,
     *                IRAGA,IRAGB,IRAGC,IRATA,IRATB,IRBRB,IRBGA,IRBGB,
     *                IRBGC,IRBTA,IRBTB,IGAGA,IGAGB,IGAGC,IGATA,IGATB,
     *                IGBGB,IGBGC,IGBTA,IGBTB,IGCGC,IGCTA,IGCTB,ITATA,
     *                ITATB,ITBTB,IRARARA,IRARARB,IRARAGA,IRARAGB,
     *                IRARAGC,IRARATA,IRARATB,IRARBRB,IRARBGA,IRARBGB,
     *                IRARBGC,IRARBTA,IRARBTB,IRAGAGA,IRAGAGB,IRAGAGC,
     *                IRAGATA,IRAGATB,IRAGBGB,IRAGBGC,IRAGBTA,IRAGBTB,
     *                IRAGCGC,IRAGCTA,IRAGCTB,IRATATA,IRATATB,IRATBTB,
     *                IRBRBRB,IRBRBGA,IRBRBGB,IRBRBGC,IRBRBTA,IRBRBTB,
     *                IRBGAGA,IRBGAGB,IRBGAGC,IRBGATA,IRBGATB,IRBGBGB,
     *                IRBGBGC,IRBGBTA,IRBGBTB,IRBGCGC,IRBGCTA,IRBGCTB,
     *                IRBTATA,IRBTATB,IRBTBTB,IGAGAGA,IGAGAGB,IGAGAGC,
     *                IGAGATA,IGAGATB,IGAGBGB,IGAGBGC,IGAGBTA,IGAGBTB,
     *                IGAGCGC,IGAGCTA,IGAGCTB,IGATATA,IGATATB,IGATBTB,
     *                IGBGBGB,IGBGBGC,IGBGBTA,IGBGBTB,IGBGCGC,IGBGCTA,
     *                IGBGCTB,IGBTATA,IGBTATB,IGBTBTB,IGCGCGC,IGCGCTA,
     *                IGCGCTB,IGCTATA,IGCTATB,IGCTBTB,ITATATA,ITATATB,
     *                ITATBTB,ITBTBTB
C
      DIMENSION DRHOI_(NPTGRD,4,*),DTRAI_(5,ILENG,*)
      DIMENSION DDUM(4,ILENG,*),PDUM(4,ILENG,*)
      DIMENSION EX(ILENG,*)
      DIMENSION EC(ILENG,*)
c     DIMENSION EX0(*)
c     DIMENSION EC0(*)
      DIMENSION GRDFUN(*)
      DIMENSION DUMGRV(4),DUMXX(4),DUMNV(2)
      DIMENSION DXV(2),DYV(2),DZV(2)
C
      DATA ZERO  /0.0D+00/
      DATA TWO   /2.0D+00/
C
C     INITIALIZE
C
      CALL VCLR(DDUM,1,4*IRU*ILENG)
      CALL VCLR(PDUM,1,4*IRU*ILENG)
C
      DO IPT=IST,IEND
         IIPT=IPT-IST+1
         RHOA = DRHOI_(IPT,1,1)
         RHOB = DRHOI_(IPT,1,IRU)
         RHOT=RHOA+RHOB
         IF(RHOT.GT.RHOMIN) THEN
            DRHOAX=DRHOI_(IPT,2,1)
            DRHOAY=DRHOI_(IPT,3,1)
            DRHOAZ=DRHOI_(IPT,4,1)
            DRHOBX=DRHOI_(IPT,2,IRU)
            DRHOBY=DRHOI_(IPT,3,IRU)
            DRHOBZ=DRHOI_(IPT,4,IRU)
C
C     ---- DIFFERENCE DENSITY
C
            DUMNV(1)=DTRAI_(1,IIPT,1)
            DXV(1)=DTRAI_(2,IIPT,1)
            DYV(1)=DTRAI_(3,IIPT,1)
            DZV(1)=DTRAI_(4,IIPT,1)
            DUMNV(2)=DTRAI_(1,IIPT,IRU)
            DXV(2)=DTRAI_(2,IIPT,IRU)
            DYV(2)=DTRAI_(3,IIPT,IRU)
            DZV(2)=DTRAI_(4,IIPT,IRU)
C     -- DUMGRV
C     1:A*A 2:B*B 3:A*B 4:B*A
            DUMGRV(1)=DXV(1)*DRHOAX+DYV(1)*DRHOAY+DZV(1)*DRHOAZ
            DUMGRV(2)=DXV(2)*DRHOBX+DYV(2)*DRHOBY+DZV(2)*DRHOBZ
            DUMGRV(3)=DXV(1)*DRHOBX+DYV(1)*DRHOBY+DZV(1)*DRHOBZ
            DUMGRV(4)=DXV(2)*DRHOAX+DYV(2)*DRHOAY+DZV(2)*DRHOAZ
            DUMXX(1)=DXV(1)*DXV(1)+DYV(1)*DYV(1)+DZV(1)*DZV(1)
            DUMXX(2)=DXV(2)*DXV(2)+DYV(2)*DYV(2)+DZV(2)*DZV(2)
            DUMXX(3)=DXV(1)*DXV(2)+DYV(1)*DYV(2)+DZV(1)*DZV(2)
            DUMXX(4)=DUMXX(3)
C
C
C     ---- VNC CONTRIBUTION
C     **************V NON CORE***************************
C     ALPHA
C     VNC_A=EXC(IRA)*DUMNV(1)+TWO*EXC(IGA)*DUMGRV(1)+EXC(IGC)*DUMGRV(3)
C     --DUMNV(1) GRADIENT
            DUMNV1=EX(IIPT,KRA)+EC(IIPT,IRA)
C     --DUMGRV(1) GRADIENT
            DUMGRV1=TWO*(EX(IIPT,KGA)+EC(IIPT,IGA))
C     --DUMGRV(3) GRADIENT
            DUMGRV3=EC(IIPT,IGC)
C     BETA
C     VNC_B=EXC(IRB)*DUMNV(2)+TWO*EXC(IGB)*DUMGRV(2)+EXC(IGC)*DUMGRV(4)
C     --DUMNV(2) GRADIENT
            DUMNV2=EX(IIPT,KRB)+EC(IIPT,IRB)
C     --DUMGRV(2) GRADIENT
            DUMGRV2=TWO*(EX(IIPT,KGB)+EC(IIPT,IGB))
C     --DUMGRV(4) GRADIENT
            DUMGRV4=EC(IIPT,IGC)
C
C     CONTRACTION
C
C     -- TOTAL
C     --ALPHA
            VNCDOMA=DUMNV1
            VNCDOMAX=DUMGRV1*DRHOAX+DUMGRV3*DRHOBX
            VNCDOMAY=DUMGRV1*DRHOAY+DUMGRV3*DRHOBY
            VNCDOMAZ=DUMGRV1*DRHOAZ+DUMGRV3*DRHOBZ
            VNCDUMAX=DUMGRV1*DXV(1)+DUMGRV4*DXV(2)
            VNCDUMAY=DUMGRV1*DYV(1)+DUMGRV4*DYV(2)
            VNCDUMAZ=DUMGRV1*DZV(1)+DUMGRV4*DZV(2)
C     --BETA
            VNCDOMB=DUMNV2
            VNCDOMBX=DUMGRV2*DRHOBX+DUMGRV4*DRHOAX
            VNCDOMBY=DUMGRV2*DRHOBY+DUMGRV4*DRHOAY
            VNCDOMBZ=DUMGRV2*DRHOBZ+DUMGRV4*DRHOAZ
            VNCDUMBX=DUMGRV2*DXV(2)+DUMGRV3*DXV(1)
            VNCDUMBY=DUMGRV2*DYV(2)+DUMGRV3*DYV(1)
            VNCDUMBZ=DUMGRV2*DZV(2)+DUMGRV3*DZV(1)
C     **************V NON CORE END***********************
C
C     --- VC CONTRIBUTION
C     ******************V CORE***************************
C     --ALPHA GRADIENT
            C1=DUMNV(1)
            C2=TWO*DUMGRV(1)
            C3=DUMGRV(3)
            C4=DUMNV(2)
            C5=TWO*DUMGRV(2)
            C6=DUMGRV(4)
            DUMA=ZERO
            DUMAG1=ZERO
            DUMAG2=ZERO
C     IRA C1
            DUMA=DUMA+C1*(EX(IIPT,KRARA)+EC(IIPT,IRARA))
            DUMAG1=DUMAG1+C1*TWO*(EX(IIPT,KRAGA)+EC(IIPT,IRAGA))
            DUMAG2=DUMAG2+C1*EC(IIPT,IRAGC)
C     IGA C2
            DUMA=DUMA+C2*(EX(IIPT,KRAGA)+EC(IIPT,IRAGA))
            DUMAG1=DUMAG1+C2*TWO*(EX(IIPT,KGAGA)+EC(IIPT,IGAGA))
            DUMAG2=DUMAG2+C2*EC(IIPT,IGAGC)
C     IGC C3
            DUMA=DUMA+C3*EC(IIPT,IRAGC)
            DUMAG1=DUMAG1+C3*TWO*EC(IIPT,IGAGC)
            DUMAG2=DUMAG2+C3*EC(IIPT,IGCGC)
C     IRB C4
            DUMA=DUMA+C4*EC(IIPT,IRARB)
            DUMAG1=DUMAG1+C4*TWO*EC(IIPT,IRBGA)
            DUMAG2=DUMAG2+C4*EC(IIPT,IRBGC)
C     IGB C5
            DUMA=DUMA+C5*EC(IIPT,IRAGB)
            DUMAG1=DUMAG1+C5*TWO*EC(IIPT,IGAGB)
            DUMAG2=DUMAG2+C5*EC(IIPT,IGBGC)
C     IGC C6
            DUMA=DUMA+C6*EC(IIPT,IRAGC)
            DUMAG1=DUMAG1+C6*TWO*EC(IIPT,IGAGC)
            DUMAG2=DUMAG2+C6*EC(IIPT,IGCGC)
C     --BETA GRADIENT
            C1=DUMNV(1)
            C2=TWO*DUMGRV(1)
            C3=DUMGRV(3)
            C4=DUMNV(2)
            C5=TWO*DUMGRV(2)
            C6=DUMGRV(4)
            DUMB=ZERO
            DUMBG1=ZERO
            DUMBG2=ZERO
C     IRA C1
            DUMB=DUMB+C1*EC(IIPT,IRARB)
            DUMBG1=DUMBG1+C1*TWO*EC(IIPT,IRAGB)
            DUMBG2=DUMBG2+C1*EC(IIPT,IRAGC)
C     IGA C2
            DUMB=DUMB+C2*EC(IIPT,IRBGA)
            DUMBG1=DUMBG1+C2*TWO*EC(IIPT,IGAGB)
            DUMBG2=DUMBG2+C2*EC(IIPT,IGAGC)
C     IGC C3
            DUMB=DUMB+C3*EC(IIPT,IRBGC)
            DUMBG1=DUMBG1+C3*TWO*EC(IIPT,IGBGC)
            DUMBG2=DUMBG2+C3*EC(IIPT,IGCGC)
C     IRB C4
            DUMB=DUMB+C4*(EX(IIPT,KRBRB)+EC(IIPT,IRBRB))
            DUMBG1=DUMBG1+C4*TWO*(EX(IIPT,KRBGB)+EC(IIPT,IRBGB))
            DUMBG2=DUMBG2+C4*EC(IIPT,IRBGC)
C     IGB C5
            DUMB=DUMB+C5*(EX(IIPT,KRBGB)+EC(IIPT,IRBGB))
            DUMBG1=DUMBG1+C5*TWO*(EX(IIPT,KGBGB)+EC(IIPT,IGBGB))
            DUMBG2=DUMBG2+C5*EC(IIPT,IGBGC)
C     IGC C6
            DUMB=DUMB+C6*EC(IIPT,IRBGC)
            DUMBG1=DUMBG1+C6*TWO*EC(IIPT,IGBGC)
            DUMBG2=DUMBG2+C6*EC(IIPT,IGCGC)
C
C     CONTRACTION OF VC
C
C     DUMA,DUMAG1,DUMAG2,DUMG,DUMBG1,DUMBG2
            VCDUMA=DUMA
            VCDUMAX=DUMAG1*DRHOAX+DUMAG2*DRHOBX
            VCDUMAY=DUMAG1*DRHOAY+DUMAG2*DRHOBY
            VCDUMAZ=DUMAG1*DRHOAZ+DUMAG2*DRHOBZ
            VCDUMB=DUMB
            VCDUMBX=DUMBG1*DRHOBX+DUMBG2*DRHOAX
            VCDUMBY=DUMBG1*DRHOBY+DUMBG2*DRHOAY
            VCDUMBZ=DUMBG1*DRHOBZ+DUMBG2*DRHOAZ
C     ******************V CORE END***********************
C
C     -- TOTAL
C     --D
            DDUM(1,IIPT,1)=DDUM(1,IIPT,1)+VCDUMA
            DDUM(2,IIPT,1)=DDUM(2,IIPT,1)+VNCDUMAX+VCDUMAX
            DDUM(3,IIPT,1)=DDUM(3,IIPT,1)+VNCDUMAY+VCDUMAY
            DDUM(4,IIPT,1)=DDUM(4,IIPT,1)+VNCDUMAZ+VCDUMAZ
            IF(IRU.EQ.2) THEN
               DDUM(1,IIPT,IRU)=DDUM(1,IIPT,IRU)+VCDUMB
               DDUM(2,IIPT,IRU)=DDUM(2,IIPT,IRU)+VNCDUMBX+VCDUMBX
               DDUM(3,IIPT,IRU)=DDUM(3,IIPT,IRU)+VNCDUMBY+VCDUMBY
               DDUM(4,IIPT,IRU)=DDUM(4,IIPT,IRU)+VNCDUMBZ+VCDUMBZ
            ENDIF
C     --PA
            PDUM(1,IIPT,1)=VNCDOMA
            PDUM(2,IIPT,1)=VNCDOMAX
            PDUM(3,IIPT,1)=VNCDOMAY
            PDUM(4,IIPT,1)=VNCDOMAZ
            IF(IRU.EQ.2) THEN
               PDUM(1,IIPT,IRU)=VNCDOMB
               PDUM(2,IIPT,IRU)=VNCDOMBX
               PDUM(3,IIPT,IRU)=VNCDOMBY
               PDUM(4,IIPT,IRU)=VNCDOMBZ
            ENDIF
C     FOR GRDFUN
C     GROUND STATE
c           DUMEXC=EX0(IIPT)+EC0(IIPT)
C     VXC
            DUM1=EX(IIPT,KRA)+EC(IIPT,IRA)
            DUM2=TWO*(EX(IIPT,KGA)+EC(IIPT,IGA))
            DUM3=EC(IIPT,IGC)
            DUM4=EX(IIPT,KRB)+EC(IIPT,IRB)
            DUM5=TWO*(EX(IIPT,KGB)+EC(IIPT,IGB))
            DUM6=EC(IIPT,IGC)
            DUMVA=DUM1*DUMNV(1)+DUM2*DUMGRV(1)+DUM3*DUMGRV(3)
            DUMVB=DUM4*DUMNV(2)+DUM5*DUMGRV(2)+DUM6*DUMGRV(4)
            DUMV=DUMVA+DUMVB
            GRDFUN(IPT)=GRDFUN(IPT)+DUMV
C     DUMVA=DUM1*DUMNV(1)+DUM2*DUMGRV(1)
C     DUMVB=DUM4*DUMNV(2)+DUM2*DUMGRV(1)
C     DUMV=DUMVA+DUMVB
C     GRDFUN(IPT)=GRDFUN(IPT)+DUMEXC+DUMV
C
         ENDIF
      END DO
      RETURN
      END
C
C
C
C*MODULE fmocp   *DECK TRADEN2_fmocp
C>
C>    @brief CP-KS equaution, Density contribution for each grid
C>
C>    @details Get density contribution and its derivatives  for each grid
C>
C>    @author Hiroya Nakata
C>    - Aug, 2013- Subroutine written
C>
C>           --- IN---
C>   @param  DRHOI_    Electronic density at the gridpoint.
C>   @param  D         Response terms
C>   @param  GAO       Atomic orbital terms
C>   @param  IPRGRD    Atomic orbital pair to be calculated
C>   @param  IST       start grid point
C>   @param  IEND      end   grid point
C>   @param  IMAX      Number of pair of atomic orbital that have conotribution
C>   @param  L1        Number of atomic orbital
C>   @param  ILENG     Number of grid point for this run
C>   @param  IRU       Number of spin (RHF:1, UHF:2)
C>           --- OUTPUT ---
C>   @param  DTRAI_    Product of respons terms and rho or gamma 
      SUBROUTINE TRADEN2_fmocp(RCUTOFF,DRHOI_,DTRAI_,D,GAO,IPRGRD,
     *                   IST,IEND,NPTGRD,IMAX,L1,ILENG,IRU)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION DRHOI_(NPTGRD,4,IRU)
      DIMENSION DTRAI_(5,ILENG,IRU)
      DIMENSION D(L1,l1,*)
      DIMENSION GAO(4,L1,*)
      DIMENSION IPRGRD(2,*)
C
      DATA ZERO      /0.0D+00/
C
      CALL VCLR(DTRAI_,1,5*ILENG*IRU)
C
C     -- GRID LOOP
C
      DO IPT=IST,IEND
      IIPT=IPT-IST+1
      ROA=DRHOI_(IPT,1,1)
      ROB=DRHOI_(IPT,1,IRU)
      IF(ROA+ROB.LT.RCUTOFF) THEN
        GOTO 10
      ENDIF
C
      TI  = ZERO
      DX  = ZERO
      DY  = ZERO
      DZ  = ZERO
      DD  = ZERO
      TIB = ZERO
      DXB = ZERO
      DYB = ZERO
      DZB = ZERO
      DDB = ZERO
C
      DO IPR=1,IMAX
         M=IPRGRD(1,IPR)
         N=IPRGRD(2,IPR)
         PM=GAO(1,M,IIPT)
         PMX=GAO(2,M,IIPT)
         PMY=GAO(3,M,IIPT)
         PMZ=GAO(4,M,IIPT)
         PN=GAO(1,N,IIPT)
         PNX=GAO(2,N,IIPT)
         PNY=GAO(3,N,IIPT)
         PNZ=GAO(4,N,IIPT)
         GX=PMX*PN+PNX*PM
         GY=PMY*PN+PNY*PM
         GZ=PMZ*PN+PNZ*PM
         GG=PMX*PNX+PMY*PNY+PMZ*PNZ
         DUMN=PM*PN
         DUM =D(M,N,1)*DUMN
         DUMX=D(M,N,1)*GX
         DUMY=D(M,N,1)*GY
         DUMZ=D(M,N,1)*GZ
         DUMG=D(M,N,1)*GG
         TI=TI+DUM
         DX=DX+DUMX
         DY=DY+DUMY
         DZ=DZ+DUMZ
         DD=DD+DUMG
         IF(IRU.EQ.2) THEN
          TIB = TIB + D(M,N,IRU)*DUMN
          DXB = DXB + D(M,N,IRU)*GX
          DYB = DYB + D(M,N,IRU)*GY
          DZB = DZB + D(M,N,IRU)*GZ
          DDB = DDB + D(M,N,IRU)*GG
         END IF
       ENDDO
       DTRAI_(1,IIPT,1)=TI
       DTRAI_(2,IIPT,1)=DX
       DTRAI_(3,IIPT,1)=DY
       DTRAI_(4,IIPT,1)=DZ
       DTRAI_(5,IIPT,1)=DD
C
       IF(IRU.EQ.2) THEN
         DTRAI_(1,IIPT,2)= TIB
         DTRAI_(2,IIPT,2)= DXB
         DTRAI_(3,IIPT,2)= DYB
         DTRAI_(4,IIPT,2)= DZB
         DTRAI_(5,IIPT,2)= DDB
       END IF
   10 CONTINUE
      ENDDO
C
C     -- GRID LOOP END
C
      RETURN
      END
C
C*MODULE fmocp   *DECK GETMP2MLAG2
C>
C>    @brief  MONOMER MP2 LAG FOR FMO LAG. 
C>
C>    @details integrate Lagrangian contribution for SCZV
C>
C>    @author Takeshi Nagata
C>    - Aug, 2013- Subroutine written
C>
C>           --- INPUT ---
C>    @param NOCC   number of occupied molecular orbital for alpha
C>    @param NVIR   number of virtual  molecular orbital for alpha
C>    @param RLAG   Lagrangian contribution in MP2
C>           --- OUTPUT ---
C>    @param ZVWRK  The  output lag for sczv
C>                 
      SUBROUTINE GETMP2MLAG2(NOCC,NVIR,ZVWRK,RLAG)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      Parameter (TWO=2.0D+00)
C
      DIMENSION ZVWRK(NOCC,NVIR),RLAG(NVIR,NOCC)
C
      DO IOCC=1,NOCC
        DO IVIR=1,NVIR
          ZVWRK(IOCC,IVIR)=RLAG(IVIR,IOCC)*TWO
        END DO
      END DO
C
      RETURN
      END
