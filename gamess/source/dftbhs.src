C 18 Apr 16 - YN  - updates for FMO 5.2
C 29 Sep 14 - YN  - Implement Density-Functional Tight-Binding Method
C
C*MODULE DFTBHS    *DECK DFTB_HESSIAN
C>
C>    @brief   Hessian of DFTB
C>
C>    @details Caculate Hessian of DFTB.
C>             This is totally a preliminary version.
C>
C>    @author  Yoshio Nishimoto
C>             - Sep, 2014 - Subroutine written
C>    @date    Feb, 2016 -  Hiroya Nakata
C>             - Added FMO-DFTB Hessian
C>    @date    Feb, 2016 - Yoshio Nishimoto
C>             - Performance improvement + DFTB/PCM Hessian
C>
C>    @todo - Arrange code
C>          - Performance improvement
C>          - Further check
C>
C
      SUBROUTINE DFTB_HESSIAN
C
C     CONVERT DEBYE**2/AMU-ANGSTROM**2 UNIT TO KM/MOLE WITH 42.255
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXSPE=10)
      PARAMETER (ONE=1.0D+00)
      INTEGER, PARAMETER :: DDI_WORLD=0,DDI_GROUP=1
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      LOGICAL ISGDDI,PAROUT,INITGDDI,WASGDDI,SAVGDDI,MLGDDI
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBHS/ DEGTHR1,DEGTHR2,MODHSS,MODPRJ
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBRE/ REPCUT(MXSPE,MXSPE),NUMREP(MXSPE,MXSPE),
     *                LREPINTV(MXSPE,MXSPE),LREPSHORT(MXSPE,MXSPE),
     *                LREPCOEFF(MXSPE,MXSPE)
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
      COMMON /FMCOM / X(1)
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FUNCT / ENERGY,EGRAD(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /OPTSCF/ DIRSCF,FDIFF
      LOGICAL DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL GOPARR,DSKWRK,MASWRK,SAVGOP
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM,IHET
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA CHECK/8HCHECK   /, DEBUG/8HDEBUG   /, DBUGME/8HRHFCL   /
      DATA ROHFC/8HROHF    /
      DATA UHFC/8HUHF     /
C
      CHARACTER(11) :: CHARA
      LOGICAL :: DC,DISK,FON(3),REDUCE,ROHF,UHF,DIRECT,ISGDDI0,
     *  SOME,MASSAV,BUNDLE,DDIHSD
      INTEGER :: IORA(3*NAT*5),INDSH(NAT),INDSAO(NUM+1),NDOCC(2),
     *  NPART(2),NVIRT(2),NOCC(2)
C     DOUBLE PRECISION :: HESTMP(3*NAT*3*NAT)
C
      IF (IPCM.NE.0) THEN
        IF (MASWRK) WRITE (IW,*)
        IF (MASWRK) WRITE (IW,*) "ANALYTIC HESSIAN WITH PCM HAS NOT",
     *  " BEEN IMPLEMENTED."
        IF (MASWRK) WRITE (IW,*) "PLEASE USE $FORCE METHOD=SEMINUM"
        IF (MASWRK) WRITE (IW,*)
C       CALL ABRT
      END IF
C
C     CALL CPU_TIME(T0)
      IF(MASWRK) THEN
        SOME   = NPRINT.NE.-5 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
      END IF
      MASSAV = MASWRK
C
      FON(1) = .FALSE.
      FON(2) = .FALSE.
      FON(3) = .FALSE.
      ROHF   = .FALSE.
      UHF    = .FALSE.
      DIRECT = DIRSCF
C
      SAVGDDI= ISGDDI
      if(nfg.ne.0) ISGDDI=.false.
C
      ISGDDI0= ISGDDI
      IF (EXETYP.EQ.CHECK) ISGDDI0 = .FALSE.
C
      IF (SCFTYP.EQ.UHFC) THEN
        UHF = .TRUE.
        IF (.NOT.SCC) THEN
          IF (MASWRK)
     *      WRITE (IW,*) "UNRESTRICTED NCC-DFTB IS NOT SUPPORTED"
          CALL ABRT
        END IF
      END IF
      IF (GOPARR) THEN
c       IF (MASWRK) THEN
c         WRITE (IW,*) "THIS PARALLEL RUN IS NOT ALLOWED NOW"
c       END IF
c       CALL ABRT
      END IF
C
      NSPIN = 1
      IF (UHF) NSPIN = 2
      NSHELL = 0
      DO I = 1, NAT
        NSHELL = NSHELL + MAXANG(ISPE(I))
      END DO
      IF (UHF.OR.SRSCC) THEN
        INDSH(1) = 0
        DO I = 1, NAT-1
          INDSH(I+1) = INDSH(I) + MAXANG(ISPE(I))
        END DO
        ISH = 0
        INDSAO(1) = 0
        DO I = 1, NAT
          DO J = 1, MAXANG(ISPE(I))
            ISH = ISH + 1
            IF (J.EQ.1) INDSAO(ISH+1) = INDSAO(ISH) + 1
            IF (J.EQ.2) INDSAO(ISH+1) = INDSAO(ISH) + 3
            IF (J.EQ.3) INDSAO(ISH+1) = INDSAO(ISH) + 5
          END DO
        END DO
      END IF
C
      IF (MASWRK.AND.SOME) THEN
        WRITE (IW,*)
        WRITE (IW,'(5X,"--------------------------",5X)')
        WRITE (IW,'(5X,"SECOND DERIVATIVE FOR DFTB",5X)')
        WRITE (IW,'(5X,"--------------------------",5X)')
        WRITE (IW,*)
C       WRITE (IW,'(5X,"AVAILABLE FUNCTIONS")')
C       WRITE (IW,'(5X," |- R-DFTB1, R-DFTB2, R-DFTB3")')
C       WRITE (IW,'(5X," |- RO-DFTB1, RO-DFTB2, RO-DFTB3")')
C       WRITE (IW,'(5X," |- U-DFTB2, U-DFTB3")')
C       WRITE (IW,'(5X," |- H-X DAMPING FOR DFTB2 AND DFTB3")')
C       WRITE (IW,'(5X," |- FRACTIONAL OCCUPATION FOR DFTB1, DFTB2, ",
C    *                 "AND DFTB3")')
C       WRITE (IW,'(5X," |- UFF-TYPE (AND SK-TYPE) DISPERSION")')
C       WRITE (IW,'(5X," |- ANALYTIC DIFFERENTIATION UP TO D SHELLS")')
C       WRITE (IW,*)
        WRITE (IW,'(5X," NOTE: PLEASE CHECK WHETHER ATOMIC WEIGHTS ARE",
     *                 " CORRECT.")')
        WRITE (IW,'(5X,"       DFTB MAY NOT CONSISTENT SOMETIMES.")')
        IF (.NOT.SCC) THEN
        WRITE (IW,'(5X," NOTE: DIPOLE DERIVATIVE OF NCC-DFTB IS NOT
     * RELIABLE.")')
        WRITE (IW,'(5X,"       IR INTENSITY MAY BE MEANINGLESS.")')
        END IF
      END IF
C     CALL CPU_TIME(T0)
C
      L0 = NQMT
      L1 = NUM
      L2 = NUM*(NUM+1)/2
      L3 = NUM*NUM
C
      IF (L0.NE.L1) THEN
        IF (MASWRK) WRITE (IW,*) "CANNOT CALCULATE HESSIAN IF LINEARLY",
     *    "DEPENDENT ORBITALS HAVE BEEN REMOVED..."
        CALL ABRT
      END IF
C
C     CHECK THE NUMBERS OF DOUBLY AND PARTLY (PARTIALLY?) OCCUPIED AND
C     UNOCCUPIED ORBITALS
C
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LOCC = LOADFM + 1
      LEIG = LOCC   + L1*NSPIN
      LAST = LEIG   + L1*NSPIN
      IF (SCFTYP.EQ.ROHFC) THEN
        LWRK = LAST
        LAST = LWRK + L1
      END IF
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      IF (EXETYP.NE.CHECK) THEN
        CALL DAREAD(IDAF,IODA,X(LOCC),L1,562,0)
        CALL DAREAD(IDAF,IODA,X(LEIG),L1,17,0)
        IF (UHF) THEN
          CALL DAREAD(IDAF,IODA,X(LOCC+L1),L1,563,0)
          CALL DAREAD(IDAF,IODA,X(LEIG+L1),L1,21,0)
        END IF
        NOCC(1) = 0
        NOCC(2) = 0
        CALL DFTB_HESS_CHKOCC(X(LOCC),X(LEIG),NDOCC,NPART,
     *    NVIRT,NSPIN,L1,IW,FON,ROHF,MASWRK,SOME,SCFTYP)
        IF (FON(1).OR.FON(2)) FON(3) = .TRUE.
        NOCC(1) = NDOCC(1) + NPART(1)
        IF (NSPIN.EQ.2) NOCC(2) = NDOCC(2) + NPART(2)
C
        IF (MASWRK.AND.SOME) THEN
          WRITE (IW,*)
          DO ISPIN = 1, NSPIN
            IF (NSPIN.EQ.2) THEN
              IF (ISPIN.EQ.1) WRITE (IW,'(" *** ALPHA ***")')
              IF (ISPIN.EQ.2) WRITE (IW,'(/" *** BETA  ***")')
            END IF
            WRITE (IW,'(" NUMBER OF        OCCUPIED ORBITALS = ", I5)')
     *        NDOCC(ISPIN)
            IF (FON(ISPIN))
     *       WRITE (IW,'(" NUMBER OF PARTLY OCCUPIED ORBITALS = ", I5)')
     *          NPART(ISPIN)
            WRITE (IW,'(" NUMBER OF        VIRTUAL  ORBITALS = ", I5)')
     *        NVIRT(ISPIN)
          END DO
          WRITE (IW,'(" ------------------------------------------")')
         WRITE (IW,'(" NUMBER OF TOTAL BASIS FUNCTIONS    = ", I5)') NUM
          IF (FON(3).AND.ROHF) THEN
            WRITE
     *      (IW,'(" ... FRACTIONAL OCCUPATION NUMBERS (FON) ARE USED")')
          WRITE (IW,'(" BUT ZERO ELECTRONIC TEMPERATURE. ASSUME ROHF")')
          END IF
          WRITE (IW,*)
        END IF
      ELSE
        !! THESE VARIABLES ARE ONLY GUESS, BECAUSE WE DON'T KNOW THESE
        !! VALUES UNLESS SCF IS DONE
        NDOCC(1) = NA
        NPART(1) = 0
        NVIRT(1) = NUM - NA
        IF (UHF) THEN
          NDOCC(2) = NB
          NPART(2) = 0
          NVIRT(2) = NUM - NB
        END IF
      END IF
      CALL RETFM(NEED)
C
C     CHOOSE HOW TO STORE AO AND MO DERIVATIVES.
C
C     FULLY INCORE
C       STORE EVERYTHING IN MEMORY, INCLUDING AO/MO DERIVATIVES
C     DISK-BASED ALGORITHM
C       AO/MO DERIVATIVES ARE STORED ON DISK
C     DDI
C       AO/MO DERIVATIVES ARE STORED ON SHARED MEMORY
C
      NDIM = NAT
      IF (SRSCC) NDIM = NSHELL
C
      MEMNCC = NAT*NAT*9 + NAT*9 + L1*2 + L2*4 + L3*4 +
     *  NAT*(NAT+1)/2 + NDIM*(NDIM+1)/2*2
      MEMNCC = MEMNCC + NAT !! LMULA ... is it needed for NCC?
C
      IF (DIRECT.OR.ISGDDI0) THEN
        MEMMAT = 0
      ELSE
        MEMMAT = L2*NAT*3*2 !! (H-V), S IN MO
      END IF
C
      IF (SCC) THEN
        MEMSCC = NDIM + NDIM*(NDIM+1)/2*2
        IF (NSPIN.EQ.2) MEMSCC = MEMSCC + L1*2 + L2*2 + L3*3
        IF (UHF) MEMSCC = MEMSCC + 5*NSHELL
        IF (SRSCC.AND..NOT.UHF) MEMSCC = MEMSCC + NSHELL
        IF (.NOT.DIRECT.AND..NOT.ISGDDI0) THEN
          MEMMAT = MEMMAT + L2*NAT*3 !! S IN AO
          IF (UHF) MEMMAT = MEMMAT + L2*NAT*3*2 !! BETA (H-V), S IN MO
        END IF
        !! ESTIMATED MEMORY USED FOR BROYDEN MIXING
        LL = NAT*100 !! MXITER = 50
        LMX1 = 100
        LMX2 = (LMX1*LMX1+LMX1)/2
        LMX3 = LMX1*LMX1
        MEMBR = 7*NAT+2*LL+2*LMX1+2*LMX2+2*LMX3
      ELSE
        MEMSCC = 0
        MEMBR  = 0
      END IF
C
      !! MEMORY FOR CP-DFTB
      IF (SRSCC.OR.UHF) THEN
        NDIMSH = NSHELL
      ELSE
        NDIMSH = NAT
      END IF
      MEMCP = (L1+L2*6+NDIMSH*2)*NSPIN + L2*3 + L3*3
     *  + (NDOCC(1)+NPART(1))*L1*NSPIN
      IF (.NOT.SCC) THEN
        MEMCP = MEMCP + L1*L1
      ELSE
        MEMCP = MEMCP + L1*L1*NDIMSH*NSPIN
      END IF
      IF (SCC) MEMCP = MEMCP + NDIMSH*(2+NSPIN) + L2!*2
      IF (FON(3)) MEMCP = MEMCP + L1*2
      IF (UHF) MEMCP = MEMCP + NDIMSH
      IF (DFTB3.AND.NFG.NE.0) MEMCP = MEMCP + NAT*2
C
      IF (DFTB3) THEN
        MEMDFTB3 = NDIM*NDIM*2
      ELSE
        MEMDFTB3 = 0
      END IF
C
      IF (IPCM.NE.0) THEN
        NDASC = 0
        if (isgddi) then
          NTSPAR=(NTS-1)/npglob+1
        else
          NTSPAR=(NTS-1)/nproc+1
        end if
        LFPNT = LAST
        CALL INDQPROD(0,NTSPAR,LFPNT,NDASC,DUM,DUM,DUM,0)
        MEMPCM  = NDASC + NTS*6
        IF (IPCDER.EQ.3) MEMPCM = MEMPCM + 60*MXTS + 21*MXTS/NWDVAR+1
        MEMPCM = MAX(MEMPCM,3*NAT+9*(NAT*NAT+NAT)/2)
      ELSE
        MEMPCM = 0
      END IF
C
      MEMCORE = MEMNCC + MEMBR + MEMCP + MEMSCC + MEMDFTB3 + MEMMAT
     *        + MEMPCM
      MEMDISK = MEMNCC + MEMBR + MEMCP + MEMSCC + MEMDFTB3
     *        + MEMPCM
      MEMDISK = MEMDISK + L2*3*NSPIN !! FOR STORAGE IN HSDERIJ
      MEMCP_REDUCE = MEMCP - L1*L1*(NDIM-1)*NSPIN
C
      IF (MASWRK.AND.SOME) THEN
        WRITE(IW,'(" ESTIMATED MEMORY REQUIREMENT (UNIT IN WORDS)")')
        WRITE(IW,'("   FOR DFTB1                  = ",I12)') MEMNCC
        IF (SCC) THEN
        WRITE(IW,'("   FOR DFTB2                  = ",I12)') MEMSCC
        IF (DFTB3)
     *  WRITE(IW,'("   FOR DFTB3                  = ",I12)') MEMDFTB3
        END IF
        IF (.NOT.DIRECT.AND..NOT.ISGDDI0)
     *  WRITE(IW,'("   FOR AO/MO DERIVATIVES      = ",I12)') MEMMAT
        WRITE(IW,'("   FOR COUPLED PERTURBED DFTB = ",I12)') MEMCP
        WRITE(IW,'("   FOR BROYDEN MIXING         = ",I12)') MEMBR
        IF (IPCM.NE.0)
     *  WRITE(IW,'("   FOR PCM                    = ",I12)') MEMPCM
        WRITE(IW,'(" -------------------------------------------")')
        WRITE(IW,'("   FOR FULLY INCORE ALGORITHM = ",I12)') MEMCORE
        IF (.NOT.DIRECT.AND..NOT.ISGDDI0)
     *    WRITE(IW,'("   FOR DISK-BASED   ALGORITHM = ",I12)') MEMDISK
        WRITE(IW,'("   AVAILABLE CURRENT MEMORY   = ",I12,
     *             " WORDS")') NGOTMX
      END IF
C
      IF (MODHSS.NE.-1) THEN
        !! BIT 1 : AVOID STOREING INTEGRALS ON DISK
        !! BIT 2 : AVOID USE FASTER CP-DFTB ROUTINE (WITH MUCH MEMORY)
        !! BIT 4 : SYNCHRONIZE INTEGRALS IN HSDERIJ
        !! BIT 8 : AVOID BUNDLING CP-DFTB SOLUTIONS FOR DFTB_DEDB
        DISK   = IAND(MODHSS, 1).EQ.0
        REDUCE = IAND(MODHSS, 2).EQ.0
        DDIHSD = IAND(MODHSS, 4).NE.0
        BUNDLE = IAND(MODHSS, 8).EQ.0
        IF (MASWRK.AND.SOME) THEN
          WRITE (IW,*)
          WRITE (IW,'("     DFTBHS OPTIONS (DEFAULT= 0, CURRENT=",I2,
     *      ")")') MODHSS
          WRITE (IW,'("     ---------------------------------------")')
          WRITE (IW,'(" ISGDDI=",L8,4X,   " DISK  =",L8,4X,
     *                " REDUCE=",L8      )') ISGDDI,DISK,REDUCE
          WRITE (IW,'(" DDIHSD=",L8,4X,   " BUNDLE=",L8,4X,
     *                " XXXXXX=",L8      )') DDIHSD,BUNDLE
          WRITE (IW,*)
        END IF
C
        IF (MASWRK.AND.SOME) THEN
          IF (DISK) THEN
            WRITE (IW,*) "- STORE INTEGRALS ON DISK"
            IF (DDIHSD.AND.ISGDDI) THEN
              WRITE (IW,*) "- SYNCHRONIZE INTEGRALS WITH GDDI"
            ELSE IF (DDIHSD.AND..NOT.ISGDDI0) THEN
              WRITE (IW,*) "- IGNORE DDIHSD BECAUSE NOT ISGDDI"
            ELSE
              WRITE (IW,*) "- NOT SYNCHRONIZE INTEGRALS WITH GDDI"
            END IF
          ELSE
            IF (ISGDDI) THEN
              WRITE (IW,*) "- STORE INTEGRALS ON DDI MEMORY"
            ELSE
              WRITE (IW,*) "- STORE INTEGRALS ON REPLICATED MEMORY"
            END IF
C           WRITE (IW,*) "- NOT SYNCHRONIZE INTEGRALS WITH GDDI"
          END IF
        END IF
C
        MEM = MEMNCC + MEMBR
        IF (SCC) MEM = MEM + MEMSCC
        IF (DFTB3) MEM = MEM + MEMDFTB3
        IF (.NOT.DISK) MEM = MEM + MEMMAT
C
        IF (REDUCE) THEN
          IF (MASWRK.AND.SOME)
     *      WRITE (IW,*) "- CP-DFTB WITH REDUCED MEMORY RUN"
          MEM = MEM + MEMCP_REDUCE
        ELSE
          IF (MASWRK.AND.SOME) WRITE (IW,*) "- CP-DFTB WITH MUCH MEMORY"
          MEM = MEM + MEMCP
        END IF
C
        IF (MASWRK.AND.SOME) THEN
          IF (BUNDLE) THEN
            WRITE (IW,*) "- BUNDLE CP-DFTB SOLUTIONS"
          ELSE
            WRITE (IW,*) "- DO NOT BUNDLE CP-DFTB SOLUTIONS"
          END IF
        END IF
C
        IF (MEM.GT.NGOTMX) THEN
          IF (MASWRK) THEN
            WRITE (IW,'(" NOT ENOUGH MEMORY (WITH MODHSS)")')
            WRITE (IW,'(" INCREASE MWORDS BY APPROXIMATELY ",I6/)')
     *         INT((MEM-NGOTMX)/DBLE(1.0D+06))+1
          END IF
          CALL ABRT
        END IF
      ELSE
        DISK   = .FALSE.
        REDUCE = .FALSE.
        BUNDLE = .TRUE.
        DIRECT = .FALSE.
C       IF (MEMCORE.GE.NGOTMX.AND.MEMDISK.LT.NGOTMX) DISK = .TRUE.
        IF (ISGDDI0) THEN
          DISK = .FALSE.
          DIRECT = .FALSE.
          IF (MASWRK.AND.SOME) WRITE (IW,*)
          IF (MASWRK.AND.SOME) WRITE (IW,'(" STORE AO/MO DERIVATIVES ON
     * DDI MEMORY POOL")')
          MEMMAT = L2*NAT*3*2
          IF (SCC) MEMMAT = MEMMAT + L2*NAT*3
          IF (UHF) MEMMAT = MEMMAT + L2*NAT*3*2
          IF (MASWRK.AND.SOME)
     *      WRITE (IW,'(" MEMORY FOR DDI = ",I12," WORDS")') MEMMAT
C         MEMCORE = MEMCORE - MEMMAT
          IF (MEMCORE.GT.NGOTMX) THEN
            REDUCE = .TRUE.
            IF (MASWRK.AND.SOME) THEN
          WRITE (IW,'("   CP-DFTB TRIES TO SAVE MEMORY OF",I10,
     *       " WORDS")') L1*L1*(NDIM-1)*NSPIN
            WRITE(IW,'("   MEMORY FOR REDUCED CP-DFTB = ",I12)')
     *        MEMCP_REDUCE
            END IF
            IF (MEMCORE-MEMCP+MEMCP_REDUCE.LT.NGOTMX) THEN
              IF (MASWRK.AND.SOME) WRITE(IW,*) "REDUCED MEMORY RUN"
            ELSE
              IF (MASWRK) WRITE(IW,*) "NOT ENOUGH MEMORY"
              CALL ABRT
            END IF
          END IF
        ELSE IF (DIRECT) THEN
          DISK = .FALSE.
          IF (MASWRK.AND.SOME)  WRITE(IW,*)
          IF (MASWRK)  WRITE (IW,'(" SUPPRESS ALL I/O STORAGE,
     * BECAUSE $SCF DIRSCF=.TRUE. $END EXISTS.")')
          IF (MASWRK)  WRITE (IW,'(" (DIRSCF=.TRUE. IS NOT RECOMMENDED
     * FOR DFTB HESSIAN)")')
          IF (MEMCORE.GT.NGOTMX) THEN
            REDUCE = .TRUE.
            IF (MASWRK.AND.SOME) THEN
          WRITE (IW,'("   CP-DFTB TRIES TO SAVE MEMORY OF ",I9,
     *       " WORDS")') L1*L1*(NDIM-1)*NSPIN
            WRITE(IW,'("   MEMORY FOR REDUCED CP-DFTB = ",I12)')
     *        MEMCP_REDUCE
            END IF
            IF (MEMCORE-MEMCP+MEMCP_REDUCE.LT.NGOTMX) THEN
              IF (MASWRK.AND.SOME) WRITE(IW,*) "DIRECT ALGORITHM WITH
     * REDUCED MEMORY RUN"
            ELSE
              IF (MASWRK) WRITE(IW,*) "NOT ENOUGH MEMORY"
              CALL ABRT
            END IF
          END IF
        ELSE
          IF (MASWRK.AND.SOME)  WRITE(IW,*)
          IF (MEMCORE.LT.NGOTMX) THEN
            DISK = .FALSE.
            REDUCE = .FALSE.
            IF (MASWRK.AND.SOME ) WRITE(IW,'(" FULLY INCORE ALGORITHM",
     *                             " IS PROBABLY THE BEST CHOICE")')
          ELSE IF (MEMDISK.LT.NGOTMX) THEN
            DISK = .TRUE.
            REDUCE = .FALSE.
            IF (MASWRK.AND.SOME) WRITE(IW,'(" DISK-BASED ALGORITHM",
     *                             " IS PROBABLY THE BEST CHOICE")')
          ELSE
            DISK = .TRUE.
            REDUCE = .TRUE.
            IF (MASWRK.AND.SOME) THEN
              WRITE (IW,'("   CP-DFTB TRIES TO SAVE MEMORY OF ",I9,
     *         " WORDS")') L1*L1*(NDIM-1)*NSPIN
              WRITE(IW,'("   MEMORY FOR REDUCED CP-DFTB = ",I12)')
     *          MEMCP_REDUCE
            END IF
            IF (MEMDISK-MEMCP+MEMCP_REDUCE.LT.NGOTMX) THEN
              IF (MASWRK.AND.SOME)
     *        WRITE(IW,*) "DISK-BASED ALGORITHM WITH REDUCED MEMORY RUN"
            ELSE IF (MEMDISK.GT.NGOTMX) THEN
              IF (MASWRK) WRITE(IW,*) "NOT ENOUGH MEMORY"
              CALL ABRT
            END IF
          END IF
        END IF
      END IF
C
      CALL VALFM(LOADFM)
      NDIM = NAT
      IF (SRSCC) NDIM = NSHELL
      LHESSIAN     = LOADFM   + 1
      LDIPDER      = LHESSIAN + NAT*NAT*9
      LOCC         = LDIPDER  + NAT*9
      LEIG         = LOCC     + L1*NSPIN
      LD           = LEIG     + L1*NSPIN
      LD2          = LD       + L2*NSPIN
      LS           = LD2      + L2*NSPIN
      LVEC         = LS       + L2
      LWRK         = LVEC     + L3*NSPIN
      LWRK1        = LWRK     + L3*NSPIN !! U MATRIX
      LWRK2        = LWRK1    + L3*NSPIN !! UINIT
      LWRK3        = LWRK2    + L3
      LDIST        = LWRK3    + L2
      LGRAD        = LDIST    + NAT*(NAT+1)/2
      LHESS        = LGRAD    + NDIM*(NDIM+1)/2
      LAST         = LHESS    + NDIM*(NDIM+1)/2
      IF (UHF) THEN
        LSHIFTS    = LAST
        LSHIFTSH   = LSHIFTS  + NSHELL
        LSHIFTSA   = LSHIFTSH + NSHELL
        LSHIFTSB   = LSHIFTSA + NSHELL
        LMULS      = LSHIFTSB + NSHELL
        LAST       = LMULS    + NSHELL
      END IF
      IF (DIRECT) THEN
        LPS        = LAST
        LHDERIJ    = LAST
        LSDERIJ    = LAST
      ELSE IF (DISK.OR.ISGDDI0) THEN
        LHDERIJ    = LAST
        LSDERIJ    = LHDERIJ  + L2*3*NSPIN
        LAST       = LSDERIJ  + L2*3*NSPIN
        IF (SCC) THEN
          LPS      = LAST
          LAST     = LPS      + L2*3
        ELSE
          LPS      = LAST
        END IF
      ELSE
        LHDERIJ    = LAST
        LSDERIJ    = LHDERIJ  + L2*NAT*3*NSPIN
        LAST       = LSDERIJ  + L2*NAT*3*NSPIN
        IF (SCC) THEN
          LPS      = LAST
          LAST     = LPS      + L2*NAT*3
        ELSE
          LPS      = LAST
        END IF
      END IF
      LMULA        = LAST
      LAST         = LMULA    + NAT
C
      IF (SCC) THEN
        LGAMMA     = LAST
        LGAMDER    = LGAMMA   + NDIM*(NDIM+1)/2
        LSHIFT     = LGAMDER  + NDIM*(NDIM+1)/2
        LAST       = LSHIFT   + NAT
        IF (SRSCC.AND..NOT.UHF) THEN
          LSHIFTSH = LAST
          LSHIFTSA = LSHIFTSH + NSHELL
          LSHIFTSB = LSHIFTSA + NSHELL
          LMULS    = LSHIFTSB + NSHELL
          LAST     = LMULS    + NSHELL
          LSHIFTS  = LAST
        END IF
        IF (DFTB3) THEN
          LGAMMA3  = LAST
          LGAMDER3 = LGAMMA3  + NDIM*NDIM
          LAST     = LGAMDER3 + NDIM*NDIM
        ELSE
          LGAMMA3  = LAST
          LGAMDER3 = LAST
        END IF
      ELSE
        LGAMMA     = LAST
        LGAMDER    = LAST
        LSHIFT     = LAST
        LGAMMA3    = LAST
        LGAMDER3   = LAST
      END IF
      NEED         = LAST - LOADFM - 1
C
C     ----- GET MEMORY -----
C
      CALL GETFM(NEED)
      IF (MASWRK.AND.SOME) THEN
        WRITE (IW,'(" ...... ALLOCATED MEMORY = ",I10," WORDS")') NEED
        WRITE (IW,*)
      END IF
C
      IF (EXETYP.EQ.CHECK) THEN
        IF (MASWRK) THEN
          WRITE (IW,'(" W/O DDI MEMORY POOL")')
          WRITE (IW,'(" SUGGESTED MWORDS FOR FULLY INCORE = ",I5)')
     *      INT(MEMCORE/DBLE(1.0D+06))+1
          WRITE (IW,'(" SUGGESTED MWORDS WITH AO/MO STORE = ",I5)')
     *      INT(MEMDISK/DBLE(1.0D+06))+1
          WRITE (IW,'(" SUGGESTED MWORDS WITH MIN. MEMORY = ",I5)')
     *      INT((MEMDISK-MEMCP+MEMCP_REDUCE)/DBLE(1.0D+06))+1
          WRITE (IW,'(" -----------------------------------------")')
          WRITE (IW,'(" W/  DDI MEMORY POOL")')
          WRITE (IW,'(" SUGGESTED MEMDDI                  = ",I5)')
     *      INT(MEMMAT/DBLE(1.0D+06))+1
          WRITE (IW,'(" SUGGESTED MWORDS FOR FULLY INCORE = ",I5)')
     *      INT((MEMCORE-MEMMAT)/DBLE(1.0D+06))+1
          WRITE (IW,'(" SUGGESTED MWORDS WITH MIN. MEMORY = ",I5)')
     *      INT((MEMDISK-MEMCP+MEMCP_REDUCE)/DBLE(1.0D+06))+1
        END IF
        GO TO 10
      END IF
C
C     ----- RESTORE VECTORS AND ARRAYS OBTAINED IN SCF -----
C
      !! EIGENVECTORS
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,15,0)
      !! DENSITY MATRIX
      CALL DAREAD(IDAF,IODA,X(LD),L2,16,0)
      IF (ROHF.OR.SCFTYP.EQ.ROHFC) THEN
        CALL DAREAD(IDAF,IODA,X(LWRK1),L2,20,0)
        CALL VADD(X(LD),1,X(LWRK1),1,X(LD),1,L2)
      END IF
      !! EIGENVALUES
      CALL DAREAD(IDAF,IODA,X(LEIG),L1,17,0)
      !! OCCUPATION NUMBER
      CALL DAREAD(IDAF,IODA,X(LOCC),L1,562,0)
      !! CALCULATE EIGENVALUE WEIGHTED DENSIT YMATRIX
      CALL VCLR(X(LD2),1,L2)
      CALL DFTB_DMTEIG(X(LD2),X(LVEC),X(LOCC),X(LEIG),NA,L1,L1)
      !! OVERLAP
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      !! ATOMIC MULLIKEN POPULATION
      CALL DAREAD(IDAF,IODA,X(LMULA),NAT,556,0)
      !! SHIFT MATRIX
      IF (SCC) THEN
        CALL DAREAD(IDAF,IODA,X(LSHIFT),NAT,559,0)
        IF (SRSCC) CALL DAREAD(IDAF,IODA,X(LSHIFTSH),NSHELL,560,0)
      END IF
      IF (UHF.OR.SRSCC) THEN
        CALL DAREAD(IDAF,IODA,X(LMULS),NSHELL,557,0)
        ISH = 0
        DO I = 1, NAT
          DO J = 1, MAXANG(ISPE(I))
            ISH = ISH + 1
            X(LMULS+ISH-1) = X(LMULS+ISH-1) - QREFL(J,ISPE(I))
          END DO
        END DO
      END IF
      IF (UHF) THEN
        CALL DAREAD(IDAF,IODA,X(LVEC+L3),L3,19,0)
        CALL DAREAD(IDAF,IODA,X(LD+L2),L2,20,0)
        CALL DAREAD(IDAF,IODA,X(LEIG+L1),L1,21,0)
        CALL DAREAD(IDAF,IODA,X(LOCC+L1),L1,563,0)
        CALL VCLR(X(LD2+L2),1,L2)
        CALL DFTB_DMTEIG(X(LD2+L2),X(LVEC+L3),X(LOCC+L1),X(LEIG+L1),
     *    NB,L1,L1)
        CALL DAREAD(IDAF,IODA,X(LSHIFTS),NSHELL,561,0)
      END IF
C
      DC = .FALSE.
      IF (IDFTBD.EQ.1.OR.IDFTBD.EQ.2.OR.IDFTBD.EQ.4) DC = .TRUE.
C
      CALL VCLR(X(LDIST),1,NAT*(NAT+1)/2)
      CALL VCLR(X(LGRAD),1,NAT*(NAT+1)/2)
      CALL VCLR(X(LHESS),1,NAT*(NAT+1)/2)
      CALL VCLR(X(LHESSIAN),1,3*NAT*3*NAT)
      CALL VCLR(X(LDIPDER),1,9*NAT)
C
C     ----- RESTORE PCM GRADIENT AND HESSIAN -----
C
      IF (IPCM.NE.0) THEN
        CALL GOTFM(NGOTMX)
        CALL VALFM(LOADFM)
        NEGH = 3*NAT + 9*(NAT*NAT+NAT)/2
        LEGH = LOADFM + 1
        LEG  = LEGH
        LEH  = LEG   + 3*NAT
        LAST = LEH   + 9*(NAT*NAT+NAT)/2
        NEED2= LAST - LOADFM - 1
        CALL GETFM(NEED2)
        !! gradient
        CALL DAREAD(IDAF,IODA,X(LEGH),NEGH,67,0)
        CALL DAXPY(3*NAT,1.0D+00,X(LEGH),1,EGRAD,1)
C       CALL DFTB_PRJGRD(EGRAD,C,RUNTYP,NAT)
        CALL DAWRIT(IDAF,IODA,EGRAD,3*NAT,3,0)
        !! hessian
        CALL CPWAB0(X(LHESSIAN),X(LEH),NAT)
C       CALL CPFCM(X(LHESSIAN),NAT)
        IF (GOPARR) CALL DSCAL(9*NAT*NAT,ONE/DBLE(NPROC),X(LHESSIAN),1)
        CALL RETFM(NEED2)
      END IF
C
C     ----- CALCULATE INTER-ATOMIC DISTANCES -----
C
      NSEQ = 0
      DO I = 1, NAT
        DO J = 1, I
          NSEQ = NSEQ + 1
          DIST = SQRT( (C(1,I)-C(1,J))**2
     &               + (C(2,I)-C(2,J))**2
     &               + (C(3,I)-C(3,J))**2 )
          X(LDIST+NSEQ-1) = DIST
        END DO
      END DO
CD    CALL CPU_TIME(T1)
C
      SAVGOP=GOPARR
      IF(GOPARR.AND.NFG.NE.0) GOPARR=.false.
      IF (NFG.NE.0.AND.DISK) THEN
        IF (MASWRK) WRITE (IW,*) "NOT ENOUGH MEMORY(NFG.NE.0.AND.DISK)"
        CALL ABRT
      END IF
C
C     ----- CALCULATE GAMMA AND ITS DERIVATIVE OF DFTB2 AND DFTB3 -----
C
      IF (SCC) THEN
        CALL DFTB_GAMMA(DAMPXHE,HUBBL,X(LGAMMA),X(LDIST),NAT,NSPE,
     *    ISPE,MAXANG,SPE,DAMPXH,SRSCC)
        !! CALCULATE GAMMA DERIVATIVES
        IF (SRSCC) THEN
          NN = 0
          DO I = 1, NSPE
            NN = NN + MAXANG(I)
          END DO
          NNN = NSHELL
        ELSE
          NN = NSPE
          NNN = NAT
        END IF
        CALL DFTB_GAMDER(NAT,NSPE,HUBBL,ISPE,X(LGAMDER),DAMPXH,
     *    DAMPXHE,SPE,X(LDIST),DFTB3,X(LGAMDER3),HUBDER,SRSCC,MAXANG,
     *    NNN,NN)
        IF (DFTB3) THEN
          !! DFTB_GAMDER GIVES GAMDER3 VALUES SCALED BY 1/3
          CALL DSCAL(NNN*NNN,3.0D+00,X(LGAMDER3),1)
          !! NOW, GAMMA3 VALUES ARE NOT SCALED>
          CALL DFTB_GAMMA3(NAT,HUBBL,X(LGAMMA3),X(LDIST))
        END IF
      END IF
C
C     ----- OPEN RANDOM ACCESS FILE (.F20) -----
C     FOR THE DISK-BASED ALGORITHM, H_{IJ}^a, S_{IJ}^a, V_{IJ}^a
C     (=\OMEGA*dS/da), and dS/da WILL BE STORED.  H_{IJ}^a, S_{IJ}^a,
C     V_{IJ}^a ARE DERIVATIVES OF NCC-HAMILTONIAN, OVERLAP, AND OVERLAP
C     WITH GAMMA MATRICES IN MO EXPRESSION.  The dS/da MATRIX IS JUST A
C     DERIVATIVE OF OVERLAP MATRIX IN AO EXPRESSION.  THE POSITIONS OF
C     FOUR MATRICES WILL BE FOLLOWING:
C
C               1 ~ 1*(NAT*3) :: H_{IJ}^a + V_{IJ}^a
C     1*(NAT*3)+1 ~ 2*(NAT*3) :: S_{IJ}^a
C     2*(NAT*3)+1 ~ 3*(NAT*3) :: dS/da   (NOT NEEDED FOR DFTB1)
C     3*(NAT*3)+1 ~ 4*(NAT*3) :: H_{IJ}^a + V_{IJ}^a (BETA)
C     4*(NAT*3)+1 ~ 5*(NAT*3) :: S_{IJ}^a (BETA)
C
C     IN DFTB_EXHSDER SUBROUTINE, dH/da AND dS/da MATRICES ARE PUT AS
C     H_{IJ}^a AND S_{IJ}^a, AND LATER THEY WILL BE OVERWRITTEN BY
C     H_{IJ}^a AND S_{IJ}^a IN DFTB_HSDERIJ SUBROUTINE.
C     NOTE THAT V_{IJ}^a IS ONLY FOR DFTB2 AND DFTB3.
C
C     FOR PARALLEL RUNS, REPLICATE .F20 FILE ON EACH PROCESSORS.  IS IT
C     POSSIBLE TO DISTRIBUTE AFTER THE CALCULATION OF HAMILTONIAN AND
C     OVERLAP DERIVATIVES?
C
   10 IF (DISK) THEN
        IF (ISGDDI) CALL GDDI_SCOPE(DDI_GROUP)
        IRAF = 20
        IF (SCC) THEN
          NN = 3*3*NAT
          IF (UHF) NN = NN + 3*2*NAT
        ELSE
          NN = 3*2*NAT
        END IF
        IF (GOPARR) THEN
C         DSKWRK = .TRUE.
C         IF (MODHSS.NE.0) DSKWRK = DSKREP
        END IF
        CALL RAOPEN(IRAF,IORA,0,NN,L2,0)
        IF (ISGDDI) CALL GDDI_SCOPE(DDI_WORLD)
      ELSE IF (ISGDDI0) THEN
        CALL GDDI_SCOPE(DDI_WORLD)
        CALL DDI_CREATE(L2*3*NSPIN,NAT,ID_HDERMO)
        IF (ID_HDERMO.EQ.-1) CALL ABRT
        CALL DDI_CREATE(L2*3*NSPIN,NAT,ID_SDERMO)
        IF (ID_SDERMO.EQ.-1) CALL ABRT
        IF (SCC) THEN
          CALL DDI_CREATE(L2*3      ,NAT,ID_SDERAO)
          IF (ID_SDERAO.EQ.-1) CALL ABRT
        END IF
        WRITE (IW,*)
      END IF
      IF (EXETYP.EQ.CHECK) GO TO 20
CD    CALL CPU_TIME(T2)
C
      DO I = 1, NAT
        X(LMULA+I-1) = X(LMULA+I-1) - ZREF(I)
      END DO
C
C     ----- CONVERT ATOM-RESOLVED SHIFT TO SHELL-RESOLVED SHIFT -----
C
C     IF (SRSCC.OR.UHF) THEN
      IF (.NOT.SRSCC.AND.UHF) THEN
        CALL DFTB_SHIFT_ATOSH(X(LSHIFT),X(LSHIFTSH),NAT,NSHELL,NSPE,
     *    ISPE,MAXANG)
      END IF
C
C     ----- MAKE SHIFT MATRICES INCLUDING SPIN CONTRIBUTION -----
C     SHIFTSA = (SHELL-RESOLVED SHIFT) + (SPIN SHIFT)
C     SHIFTSB = (SHELL-RESOLVED SHIFT) - (SPIN SHIFT)
C
      IF (UHF) THEN
        CALL DCOPY(NSHELL,X(LSHIFTSH),1,X(LSHIFTSA),1)
        CALL DCOPY(NSHELL,X(LSHIFTSH),1,X(LSHIFTSB),1)
        CALL DAXPY(NSHELL, ONE,X(LSHIFTS),1,X(LSHIFTSA),1)
        CALL DAXPY(NSHELL,-ONE,X(LSHIFTS),1,X(LSHIFTSB),1)
      ELSE IF (SRSCC) THEN
        CALL DCOPY(NSHELL,X(LSHIFTSH),1,X(LSHIFTSA),1)
        CALL VCLR(X(LSHIFTSB),1,NSHELL)
      END IF
C
C     ----- CALCULATE HAMILTONIAN AND OVELAP DERIVATIVES IN AO -----
C     ----- CALCULATE HAMILTONIAN AND OVELAP DERIVATIVES IN MO -----
C
      IF (DIRECT) THEN
        IF (MASWRK.AND.SOME) WRITE (IW,'(" SKIP AO AND MO DERIVATIVES
     * PREPARATION"/)')
      ELSE
        IF (MASWRK.AND.SOME)
     `    WRITE (IW,'(" PREPARE AO AND MO DERIVATIVES ...")')
CD      CALL CPU_TIME(T3)
CD      CALL SYSTEM_CLOCK(ICLOCK_COUNTS_3,ICLOCK_RATE)
        NN = NAT
        IF (SRSCC.OR.UHF) NN = NSHELL
        CALL DFTB_HSDERIJ(NAT,L0,L1,L2,IND,IRAF,IORA,NN,C,X(LHDERIJ),
     *    X(LSDERIJ),X(LPS),X(LSHIFT),X(LSHIFTSA),X(LSHIFTSB),X(LVEC),
     *    X(LWRK),X(LWRK1),X(LWRK2),X(LWRK3),SCC,DISK,UHF,SRSCC,NSPIN,
     *    INDSH,INDSAO,MAXANG,NSPE,ISPE,ID_HDERMO,ID_SDERMO,ID_SDERAO,
     *    NOCC,DDIHSD)
C
        IF(NFG.ne.0.and.NBDFG.ne.0) then
c        IF(MASWRK)  write(*,*) "Entering HOP DER in CPHF"
         GOPARR = SAVGOP
         CALL HOPDER(2,0,0,0,L1,L2,
     *               x(lfmoda),X(LHDERIJ),DUM,X(LPS))
         IF(GOPARR) GOPARR=.false.
        end if
CD      CALL CPU_TIME(T4)
CD      CALL SYSTEM_CLOCK(ICLOCK_COUNTS_4,ICLOCK_RATE)
CD      IF (MASWRK) WRITE (IW,'(3X,"FINISHED IN ",F8.2," SECONDS IN
CD   * CPU TIME" )')
CD   *    T4-T3
CD      IF (MASWRK) WRITE (IW,'(3X,"FINISHED IN ",F8.2," SECONDS IN
CD   * WALL-CLOCK TIME"/)')
CD   *    (ICLOCK_COUNTS_4-ICLOCK_COUNTS_3)/DBLE(ICLOCK_RATE)
      END IF
C
C     ----- SOLVE COUPLED PERTURBED DFTB EQUATIONS -----
C
   20 CONTINUE
      NGAM = NAT
      IF (SRSCC) NGAM = NSHELL
      NDIM = NAT
      IF (SRSCC.OR.UHF) NDIM = NSHELL
C     CALL DCOPY(3*NAT*3*NAT,X(LHESSIAN),1,HESTMP,1)
      CALL DFTB_CP(L0,L1,L2,IRAF,IORA,NDOCC,NVIRT,NPART,NOCC,
     *  X(LWRK),X(LVEC),X(LPS),X(LEIG),X(LOCC),X(LSHIFT),
     *  X(LGAMMA),X(LGAMDER),X(LS),X(LMULA),X(LDIST),X(LWRK1),
     *  X(LHESSIAN),X(LD),X(LHDERIJ),X(LSDERIJ),X(LGAMMA3),
     *  X(LGAMDER3),X(LDIPDER),DISK,FON,REDUCE,ROHF,UHF,NGAM,
     *  X(LSHIFTSA),X(LSHIFTSB),INDSH,
     *  INDSAO,NSPIN,X(LMULS),NDIM,DIRECT,ID_HDERMO,
     *  ID_SDERMO,ID_SDERAO,SAVGOP,SOME,BUNDLE)
      IF (EXETYP.EQ.CHECK) GO TO 100
C
      IF (ISGDDI0) CALL GDDI_SCOPE(DDI_WORLD)
      IF (ISGDDI0.AND..NOT.DISK) THEN
        CALL DDI_DESTROY(ID_SDERAO)
        CALL DDI_DESTROY(ID_SDERMO)
        CALL DDI_DESTROY(ID_HDERMO)
      END IF
C
C     WRITE (*,*) "AFTER DFTB_CP"
C     DO I = 1, 3*3*NAT*NAT
C       WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)
C     END DO
C     WRITE (*,*) "DFTB_CP CONTRIBUTION"
C     DO I = 1, 3*3*NAT*NAT
C       WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)-hestmp(i)
C     END DO
CD    CALL CPU_TIME(T5)
CD    CALL SYSTEM_CLOCK(ICLOCK_COUNTS_5,ICLOCK_RATE)
CD    IF (MASWRK) WRITE (IW,'(3X,"FINISHED IN ",F8.2," SECONDS IN
CD   * CPU TIME" )') T5-T4
CD    IF (MASWRK) WRITE (IW,'(3X,"FINISHED IN ",F8.2," SECONDS IN
CD   * WALL-CLOCK TIME"/)')
CD   *  (ICLOCK_COUNTS_5-ICLOCK_COUNTS_4)/DBLE(ICLOCK_RATE)
C
C     CALL DCOPY(3*NAT*3*NAT,X(LHESSIAN),1,HESTMP,1)
      IF (MASWRK.AND.SOME)
     *  WRITE (IW,*) "CALCULATE DERIVATIVES OF H AND S ..."
      CALL DFTB_D2HS(X(LWRK),X(LWRK1),X(LD),X(LD2),
     *  X(LSHIFT),X(LSHIFTSA),X(LSHIFTSB),
     *  C,X(LHESSIAN),NAT,L2,NSPIN,IND,NSHELL,NSPE,ISPE,MAXANG,
     *  INDSAO,SCC,SRSCC,UHF)
C     WRITE (*,*) "AFTER D2HS"
C     DO I = 1, 3*3*NAT*NAT
C       WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)
C     END DO
C     WRITE (*,*) "D2HS CONTRIBUTION"
C     DO I = 1, 3*3*NAT*NAT
C     WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)-hestmp(i)
C     END DO
C---  CALL CPU_TIME(T6)
C
C     CALL DCOPY(3*NAT*3*NAT,X(LHESSIAN),1,HESTMP,1)
      IF (SCC) THEN
        IF (MASWRK.AND.SOME)
     *    WRITE (IW,*) "CALCULATE GAMMA DERIVATIVE TERM ..."
        IF (SRSCC) THEN
          NN = 0
          DO I = 1, NSPE
            NN = NN + MAXANG(I)
          END DO
          CALL DFTB_GAM_DER2(NAT,NSPE,HUBBL,C,X(LDIST),X(LGRAD),
     *      X(LHESS),X(LWRK),X(LWRK1),X(LMULS),X(LHESSIAN),DFTB3,
     *      HUBDER,DAMPXHE,ISPE,MAXANG,NSHELL,NSHELL,NN,SPE,SRSCC,
     *      DAMPXH,X(LMULA))
        ELSE
          NN = NSPE
          CALL DFTB_GAM_DER2(NAT,NSPE,HUBBL,C,X(LDIST),X(LGRAD),
     *      X(LHESS),X(LWRK),X(LWRK1),X(LMULA),X(LHESSIAN),DFTB3,
     *      HUBDER,DAMPXHE,ISPE,MAXANG,NSHELL,NAT,NN,SPE,SRSCC,
     *      DAMPXH,X(LMULA))
        END IF
      END IF
C     END IF
C     WRITE (*,*) "AFTER GAM_DER2"
C     DO I = 1, 3*3*NAT*NAT
C       WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)
C     END DO
C     WRITE (*,*) "GAM_DER2 CONTRIBUTION"
C     DO I = 1, 3*3*NAT*NAT
C       WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)-hestmp(i)
C     END DO
C
C     ----- ADD EREP CONTRIBUTION -----
C
C---  CALL CPU_TIME(T2)
C     CALL DCOPY(3*NAT*3*NAT,X(LHESSIAN),1,HESTMP,1)
      IF (MASWRK.AND.SOME)
     *  WRITE (IW,*) "CALCULATE DERIVATIVES OF EREP ..."
      CALL DFTB_EREP_HESSIAN(X(LDIST),X(LGRAD),X(LHESS),X(LHESSIAN),
     *     X(LREPINTV(1,1)),X(LREPSHORT(1,1)),X(LREPCOEFF(1,1)))
C     goto 100
C     WRITE (*,*) "AFTER EREP"
C     DO I = 1, 3*3*NAT*NAT
C       WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)
C     END DO
C     WRITE (*,*) "EREP CONTRIBUTION"
C     DO I = 1, 3*3*NAT*NAT
C       WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)-hestmp(i)
C     END DO
C
C     ----- ADD DISPERSION CONTRIBUTION -----
C
      IF (DC) THEN
        IF (MASWRK.AND.SOME)
     *    WRITE (IW,*) "CALCULATE DERIVATIVES OF DISPERSION ..."
        IF (IDFTBD.NE.3) THEN
          CALL DFTB_DISP_HESS(NAT,NSPE,ISPE,DFTBDP,ZREF,QREF,C,X(LDIST),
     *    X(LGRAD),X(LHESS),X(LHESSIAN),IDFTBD,X(LWRK))
        END IF
      END IF
C
CD    IF (MASWRK) THEN
CD    WRITE (*,'(A,F10.5)') "TIME FOR PREPARATION       ",T0-T1
CD    WRITE (*,'(A,F10.5)') "TIME FOR DFTB_EREP_HESSIAN ",T2-T1
CD    WRITE (*,'(A,F10.5)') "TIME FOR DFTB_GAM_DER2     ",T3-T2
CD    WRITE (*,'(A,F10.5)') "TIME FOR EXTHSDER_DFTB     ",T4-T3
CD    WRITE (*,'(A,F10.5)') "TIME FOR CP-DFTB           ",T5-T4
CD    WRITE (*,'(A,F10.5)') "TIME FOR DFTB_D2HS         ",T6-T5
CD    END IF
C
  100 CONTINUE
C
      ISGDDI=SAVGDDI
C
      IF (EXETYP.EQ.CHECK) THEN
        CALL VCLR(X(LHESSIAN),1,3*NAT*3*NAT)
        CALL VCLR(X(LDIPDER),1,9*NAT)
      END IF
      IF (IPCM.NE.0) THEN
        IMODE=MODPRJ
        IF (MODPRJ.EQ.1.OR.MODPRJ.EQ.2)
     *  CALL DFTB_PRJGRD_HESS(IMODE,EGRAD,X(LHESSIAN),C,RUNTYP,NAT,
     *                        X(LWRK),X(LWRK2))
      END IF
      CALL DAWRIT(IDAF,IODA,X(LHESSIAN),3*NAT*3*NAT,4,0)
      CALL DAWRIT(IDAF,IODA,X(LDIPDER),9*NAT,34,0)
      IF (IDFTBD.EQ.3) CALL DFTD3(3,DUMMY,DUMMY)
C
C     ---- CLOSE RANDOM ACCESS FILE (.F20) -----
C
      IF (DISK) THEN
        IF (ISGDDI0) CALL GDDI_SCOPE(DDI_GROUP)
        CALL RACLOS(IRAF,'DELETE')
        IF (ISGDDI0) CALL GDDI_SCOPE(DDI_WORLD)
      END IF
      MASWRK = MASSAV
C
      CALL RETFM(NEED)
C
      IF(MASWRK.AND.SOME) THEN
        CHARA(1:11) = '           '
        CHARA(1:4)  = 'DFTB'
        NST = 5
        IF (.NOT.SCC)           CHARA(NST:NST) = '1'
        IF (SCC.AND..NOT.DFTB3) CHARA(NST:NST) = '2'
        IF (SCC.AND.DFTB3)      CHARA(NST:NST) = '3'
        NST = NST+1
        IF (DC) THEN
          IF (IDFTBD.EQ.3) THEN
            CHARA(NST:NST+1) = '-D3'
            NST = NST+2
          ELSE
            CHARA(NST:NST+1) = '-D'
            NST = NST+2
          END IF
        END IF
        IF (IPCM.NE.0) THEN
          CHARA(NST:NST+3) = '/PCM'
          NST = NST+4
        END IF
        WRITE(IW,'(" ...... END OF ",A," SECOND DERIVATIVE ",
     * "......")') CHARA(1:NST-1)
      END IF
C
      GOPARR=SAVGOP
C
      CALL TIMIT(1)
C
      END SUBROUTINE DFTB_HESSIAN
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Caculate Hessian contribution of \Delta q terms
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Changes due to PCM and SRSCC
C>
C>           --- INPUT ---
C>    @param NJ Index of atom to be displaced
C>    @param KJ Index of axis to be displaced
C>    @param NAT Number of atoms
C>    @param C Coordinates
C>    @param QDER Delta Q
C>    @param GAMDER Derivative of DFTB2 gamma
C>    @param GAMDER3 Derivative of DFTB3 gamma
C>    @param CHAMUL Mulliken charges
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param DFTB3 Whether DFTB3 or not
C>    @parma SRSCC Whether Shell-resolved SCC or not
C>    @param NDIMSH If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param HESSIAN Hessian matrix
C>
C
      SUBROUTINE DFTB_QDER(NJ,KJ,NAT,C,QDER,GAMDER,GAMDER3,CHAMUL,
     * DISTMAT,HESSIAN,DFTB3,SRSCC,NDIMSH,NSPE,ISPE,MAXANG,LPCM,QDERAT,
     * CHAMULAT,NGAMMA)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION :: QDER(NAT),GAMDER(*),CHAMUL(NDIMSH),DISTMAT(*),
     *  HESSIAN(3*NAT,3*NAT),C(3,*),GAMDER3(NGAMMA,NGAMMA),QDERAT(*),
     *  CHAMULAT(*)
      INTEGER :: NSPE,ISPE(NAT),MAXANG(NSPE)
      LOGICAL :: DFTB3,SRSCC,LPCM
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL GOPARR,DSKWRK,MASWRK,PARALL2
C
      DOUBLE PRECISION,PARAMETER :: ONE=1.0D+00,ONE_THIRD=ONE/3.0D+00
      DOUBLE PRECISION :: V(3)
C
      JR = 3*(NJ-1)+KJ
      PARALL2 = GOPARR !.AND.  M.GT.MXSQN2()
      IF (PARALL2.AND..NOT.LPCM) CALL VCLR(HESSIAN(1,JR),1,3*NAT)
      IPCOUNT = ME - 1
C
      IF (SRSCC) THEN
        ISH0 = 0
        DO NI = 1, NAT
          IF(PARALL2) THEN
            IPCOUNT = IPCOUNT + 1
            IF (MOD(IPCOUNT,NPROC).NE.0) THEN
              ISH0 = ISH0 + MAXANG(ISPE(NI))
              CYCLE
            END IF
          END IF
          CHAMULI = CHAMULAT(NI)
          DO I = 1, MAXANG(ISPE(NI))
            ISH = ISH0 + I
            CHAMUL1 = CHAMUL(ISH)
            KSH0 = 0
            DO NK = 1, NAT
              IF (NI.EQ.NK) THEN
                KSH0 = KSH0 + MAXANG(ISPE(NK))
                CYCLE
              END IF
              CHAMULK = CHAMULAT(NK)
              CALL DFTB_CNVSQ(NI,NK,NSEQ)
              DIST = DISTMAT(NSEQ)
              DISTI = ONE/DIST
              DO K = 1, MAXANG(ISPE(NK))
                KSH = KSH0 + K
                CHAMUL2 = CHAMUL(KSH)
                CALL DFTB_CNVSQ(ISH,KSH,NSEQ)
                GAMMAV = GAMDER(NSEQ)
                IF (DFTB3) THEN
                  GAMMAV3A = GAMDER3(ISH,KSH)
                  GAMMAV3B = GAMDER3(KSH,ISH)
                END IF
                DO KI = 1, 3
                  V(KI) = C(KI,NI) - C(KI,NK)
                  V(KI) = V(KI)*DISTI
                  IR = 3*(NI-1)+KI
                  GAMTMP = GAMMAV*V(KI)
                  HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *              + GAMTMP*(QDER(ISH)*CHAMUL2 + CHAMUL1*QDER(KSH))
                  IF (DFTB3) THEN
                    GAMTMP3A = GAMMAV3A*V(KI)
                    GAMTMP3B = GAMMAV3B*V(KI)
                    HESSIAN(IR,JR) = HESSIAN(IR,JR) + ONE_THIRD*
     *          (CHAMULI*GAMTMP3A*(QDER(ISH)*CHAMUL2+CHAMUL1*QDER(KSH))
     *         + CHAMULK*GAMTMP3B*(QDER(ISH)*CHAMUL2+CHAMUL1*QDER(KSH))
     *       +(QDERAT(NI)*GAMTMP3A+QDERAT(NK)*GAMTMP3B)*CHAMUL1*CHAMUL2)
                  END IF
                END DO
              END DO
              KSH0 = KSH0 + MAXANG(ISPE(NK))
            END DO
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(NI))
        END DO
      ELSE
        DO NI = 1, NAT !! A
          IF(PARALL2) THEN
            IPCOUNT = IPCOUNT + 1
C           IF (MOD(IPCOUNT,NPROC).NE.0) CYCLE
            IF (MOD(NI,NPROC).NE.ME) CYCLE
          END IF
          CHAMUL1 = CHAMUL(NI)
          DO NK = 1, NAT !! C
            IF (NI.EQ.NK) CYCLE
            CHAMUL2 = CHAMUL(NK)
            CALL DFTB_CNVSQ(NI,NK,NSEQ)
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            GAMMAV = GAMDER(NSEQ)
            IF (DFTB3) THEN
              GAMMAV3A = GAMDER3(NI,NK)
              GAMMAV3B = GAMDER3(NK,NI)
            END IF
            DO KI = 1, 3
              V(KI) = C(KI,NI) - C(KI,NK)
              V(KI) = V(KI)*DISTI
              IR = 3*(NI-1)+KI
              GAMTMP = GAMMAV*V(KI)
              HESSIAN(IR,JR) = HESSIAN(IR,JR) + GAMTMP*(QDER(NI)*CHAMUL2
     +          + CHAMUL1*QDER(NK))
C             write (*,*) "val = ", GAMTMP*(QDER(NI)*CHAMUL2+
C    *        CHAMUL1*QDER(NK))
              IF (DFTB3) THEN
                GAMTMP3A = GAMMAV3A*V(KI)
                GAMTMP3B = GAMMAV3B*V(KI)
                HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *            + ONE_THIRD
     *              *(CHAMUL2*CHAMUL2*QDER(NI)*GAMTMP3B
     *              + CHAMUL1*CHAMUL1*QDER(NK)*GAMTMP3A
     *              + 2.0D+00*CHAMUL1*CHAMUL2*(QDER(NK)*GAMTMP3B
     *                                       + QDER(NI)*GAMTMP3A))
              END IF
            END DO
          END DO
        END DO
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_QDER
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CALC_DERSHIFT
C>
C>    @brief Hessian of DFTB
C>
C>    @details Caculate non-response terms in d(Omega)/dR
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Changes due to FMO-DFTB Raman
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NI Index of atom to be displaced
C>    @param KI Index of axis to be displaced
C>    @param C Coordinates
C>    @param GAMDER Derivative of DFTB2 gamma
C>    @param GAMDER3 Derivative of DFTB3 gamma
C>    @param CHAMUL Mulliken charges
C>    @param DFTB3 Whether DFTB3 or not
C>           --- OUTPUT ---
C>    @param DERSHIFT Shift contribution
C
      SUBROUTINE DFTB_CALC_DERSHIFT(NAT,NI,KI,C,DISTMAT,GAMDER,GAMDER3,
     *  CHAMUL,DERSHIFT,DFTB3)
C
      IMPLICIT NONE
C
      COMMON /EFLDC / EVEC(3),EFLDL
      LOGICAL EFLDL
      DOUBLE PRECISION EVEC
C
      INTEGER, INTENT(IN) :: NAT,NI,KI
      DOUBLE PRECISION, INTENT(IN) :: C(3,*),DISTMAT(*),GAMDER(*),
     *  GAMDER3(NAT,NAT),CHAMUL(NAT)
      DOUBLE PRECISION, INTENT(OUT) :: DERSHIFT(NAT)
      LOGICAL, INTENT(IN) :: DFTB3
C
      INTEGER :: NC,ND,NSEQ
      DOUBLE PRECISION :: V(3),CHAMULI,CHAMULJ,VAL,GAMMAV,GAMMAV3,VAL1,
     *  VAL2,DIST
      DOUBLE PRECISION, PARAMETER :: ONE_THIRD=1.0D+00/3.0D+00,
     *  ONE_SIX=1.0D+00/6.0D+00,TWO=2.0D+00
C
      CALL VCLR(DERSHIFT,1,NAT)
C
C     CALCULATE NON-RESPONSE TERMS IN d(OMEGA)/dR.
C     -NI- CORRESPONDS TO da IN EQUATIONS.
C     -NC- CORRESPONDS TO C IN EQUATIONS.
C     -ND- CORRESPONDS TO C IN EQUATIONS WHEN NI.EQ.NC
C
      DO NC = 1, NAT
        CHAMULI = CHAMUL(NC) !! \Delta q_A
        IF (NI.EQ.NC) THEN
          DO ND = 1, NAT
C           ND = C, NI = NC = a (A)
            IF (NC.EQ.ND) CYCLE
            CHAMULJ = CHAMUL(ND) !! \Delta q_C
            CALL DFTB_CNVSQ(NC,ND,NSEQ)
            V(1) = C(1,NC) - C(1,ND) !! A-C
            V(2) = C(2,NC) - C(2,ND)
            V(3) = C(3,NC) - C(3,ND)
            DIST = DISTMAT(NSEQ)
            GAMMAV = GAMDER(NSEQ)
            VAL = GAMMAV / DIST
            DERSHIFT(NC) = DERSHIFT(NC) + V(KI)*VAL*CHAMULJ
            IF (DFTB3) THEN
              GAMMAV3 = GAMDER3(NC,ND)
              VAL1 = GAMMAV3 / DIST
              GAMMAV3 = GAMDER3(ND,NC)
              VAL2 = GAMMAV3 / DIST
              DERSHIFT(NC) = DERSHIFT(NC)
     *          + ONE_THIRD*VAL1*CHAMULI*CHAMULJ*V(KI)*TWO
     *          + ONE_SIX*VAL2*CHAMULJ*CHAMULJ*V(KI)*TWO
            END IF
          END DO
        ELSE
C         d(gamma)/dR is not zero only when ni=a
C         NC = a (A), NI = C
          CHAMULJ = CHAMUL(NI) !! \Delta q_C
          CALL DFTB_CNVSQ(NC,NI,NSEQ)
          V(1) = C(1,NI) - C(1,NC) !! C-A
          V(2) = C(2,NI) - C(2,NC)
          V(3) = C(3,NI) - C(3,NC)
          DIST = DISTMAT(NSEQ)
          GAMMAV = GAMDER(NSEQ)
          VAL = GAMMAV / DIST
          DERSHIFT(NC) = DERSHIFT(NC) + V(KI)*VAL*CHAMULJ
          IF (DFTB3) THEN
            GAMMAV3 = GAMDER3(NC,NI)
C           GAMMAV3 = GAMDER3(NI,NC)
            VAL1 = GAMMAV3 / DIST
            GAMMAV3 = GAMDER3(NI,NC)
C           GAMMAV3 = GAMDER3(NC,NI)
            VAL2 = GAMMAV3 / DIST
            DERSHIFT(NC) = DERSHIFT(NC)
     *        + ONE_THIRD*VAL1*CHAMULI*CHAMULJ*V(KI)*TWO
     *        + ONE_SIX*VAL2*CHAMULJ*CHAMULJ*V(KI)*TWO
          END IF
        END IF
      END DO
C
      IF (EFLDL) THEN
        DERSHIFT(NI) = DERSHIFT(NI) + EVEC(KI)
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_DERSHIFT
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CALC_DERSHIFT_SHELL
C>
C>    @brief Hessian of DFTB
C>
C>    @details Caculate non-response terms in d(Omega)/dR for SRSCC
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Changes due to SRSCC
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NI Index of atom to be displaced
C>    @param KI Index of axis to be displaced
C>    @param C Coordinates
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param GAMDER Derivative of DFTB2 gamma
C>    @param GAMDER3 Derivative of DFTB3 gamma
C>    @param CHAMUL Mulliken charges
C>    @param DFTB3 Whether DFTB3 or not
C>    @param NSHELL Number of shells
C>    @param INDSH Index of shell for each atom
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param DERSHIFT Shift contribution
C>
C>    @todo merged into DFTB_CALC_DERSHIFT
C
      SUBROUTINE DFTB_CALC_DERSHIFT_SHELL(NAT,NI,KI,C,DISTMAT,GAMDER,
     *  GAMDER3,CHAMUL,DERSHIFT,DFTB3,NSHELL,INDSH,NSPE,ISPE,MAXANG,
     *  CHAMULAT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,KI,NSHELL,INDSH(NAT),NSPE,ISPE(NAT),
     *  MAXANG(NSPE)
      DOUBLE PRECISION, INTENT(IN) :: C(3,*),DISTMAT(*),GAMDER(*),
     *  GAMDER3(NSHELL,NSHELL),CHAMUL(NSHELL),CHAMULAT(NAT)
      DOUBLE PRECISION, INTENT(OUT) :: DERSHIFT(NSHELL)
      LOGICAL, INTENT(IN) :: DFTB3
C
      INTEGER:: ISH0,ISH,JSH0,JSH,KSH0,KSH,I,J,NC,ND,NSEQ,LL,KK,LSH
      DOUBLE PRECISION :: V(3),DIST,DISTI,GAMMAV,CHAMULJ,VAL,
     *  VAL1,VAL2
      DOUBLE PRECISION, PARAMETER :: ONE_THIRD=1.0D+00/3.0D+00,
     *  ONE=1.0D+00
C
      CALL VCLR(DERSHIFT,1,NSHELL)
C
C     CALCULATE SHELL-RESOLVED NON-RESPONSE TERMS IN d(OMEGA)/dR.
C
      ISH0 = INDSH(NI)
      DO I = 1, MAXANG(ISPE(NI)) !! SHELL OF NI
        ISH = ISH0 + I
        JSH0 = 0
        DO NC = 1, NAT
          IF (NI.EQ.NC) THEN
            KSH0 = 0
            DO ND = 1, NAT
C             ND = C, NI = NC = a (A)
              IF (NC.EQ.ND) THEN
                KSH0 = KSH0 + MAXANG(ISPE(ND))
                CYCLE
              END IF
              V(1) = C(1,NC) - C(1,ND) !! A-C
              V(2) = C(2,NC) - C(2,ND)
              V(3) = C(3,NC) - C(3,ND)
              CALL DFTB_CNVSQ(NC,ND,NSEQ)
              DIST = DISTMAT(NSEQ)
              DISTI = ONE/DIST
              DO J = 1, MAXANG(ISPE(ND)) !! SHELL OF ND
                KSH = KSH0 + J
                CALL DFTB_CNVSQ(ISH,KSH,NSEQ)
                GAMMAV = GAMDER(NSEQ)
                CHAMULJ = CHAMUL(KSH) !! \Delta q_C
                VAL = GAMMAV*DISTI
                DERSHIFT(ISH) = DERSHIFT(ISH) + V(KI)*VAL*CHAMULJ
                IF (DFTB3) THEN
                  VAL1 = GAMDER3(ISH,KSH)*DISTI
                  VAL2 = GAMDER3(KSH,ISH)*DISTI
                  DERSHIFT(ISH) = DERSHIFT(ISH) + ONE_THIRD*(
     *                VAL1*CHAMULAT(NC)*CHAMULJ
     *              + VAL2*CHAMULAT(ND)*CHAMULJ)*V(KI)
                  DO LL = 1, MAXANG(ISPE(NI))
                    LSH = ISH0 + LL
                    DERSHIFT(ISH) = DERSHIFT(ISH)
     *                + ONE_THIRD*GAMDER3(LSH,KSH)*DISTI
     *                 *CHAMUL(LSH)*CHAMULJ*V(KI)
                  END DO
                END IF
              END DO
              KSH0 = KSH0 + MAXANG(ISPE(ND))
            END DO
          ELSE
            CHAMULJ = CHAMUL(ISH) !! \Delta q_A
            V(1) = C(1,NI) - C(1,NC) !! C-A
            V(2) = C(2,NI) - C(2,NC)
            V(3) = C(3,NI) - C(3,NC)
            CALL DFTB_CNVSQ(NI,NC,NSEQ)
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DO J = 1, MAXANG(ISPE(NC)) !! SHELL OF NC
              JSH = JSH0 + J
              CALL DFTB_CNVSQ(ISH,JSH,NSEQ)
              GAMMAV = GAMDER(NSEQ)
              VAL = GAMMAV*DISTI
              DERSHIFT(JSH) = DERSHIFT(JSH) + V(KI)*VAL*CHAMULJ
              IF (DFTB3) THEN
                VAL1 = GAMDER3(JSH,ISH)*DISTI
                VAL2 = GAMDER3(ISH,JSH)*DISTI
                DERSHIFT(JSH) = DERSHIFT(JSH) + ONE_THIRD*(
     *              VAL1*CHAMULAT(NC)*CHAMULJ
     *            + VAL2*CHAMULAT(NI)*CHAMULJ)*V(KI)
                DO KK = 1, MAXANG(ISPE(NC))
                  KSH = JSH0 + KK
                  DERSHIFT(JSH) = DERSHIFT(JSH)
     *            + ONE_THIRD*GAMDER3(KSH,ISH)*DISTI
     *             *CHAMUL(KSH)*CHAMULJ*V(KI)
                END DO
              END IF
            END DO
          END IF
          JSH0 = JSH0 + MAXANG(ISPE(NC))
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_DERSHIFT_SHELL
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CP_NR
C>
C>    @brief Hessian of DFTB
C>
C>    @details Caculate non-response terms in CP-DFTB equation
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Performance improvement?
C>
C>           --- INPUT ---
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param EIG Eigenvalues of each orbital
C>    @param OCC Occupation number of each orbital
C>    @param HDERIJ H_{ij}^a + V_{ij}^a
C>    @param SDERIJ S_{ij}^a
C>           --- OUTPUT ---
C>    @param U U matrix (geometrical derivative of MO coefficients)
C>
C
      SUBROUTINE DFTB_CP_NR(L1,L2,NDOCC,NPART,EIG,OCC,U,HDERIJ,SDERIJ,
     *                      BETA,EFERMI,DEGTHR1,DEGTHR2)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,L2,NDOCC,NPART
      DOUBLE PRECISION, INTENT(IN) :: EIG(L1),OCC(L1),HDERIJ(L2),
     *  SDERIJ(L2),BETA,EFERMI,DEGTHR1,DEGTHR2
      DOUBLE PRECISION, INTENT(OUT) :: U(L1,L1)
C
      INTEGER :: IO,JO,NSEQ
      DOUBLE PRECISION :: EI,EJ,EIJ,OCCI,OCCJ,VAL,VALI,VALJ
      LOGICAL :: PARTI, PART
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00,
     *  HALF=0.5D+00
C
      NSEQ = 0
      DO IO = 1, L1
        EI = EIG(IO)
        OCCI = OCC(IO)
        PARTI = IO.GT.NDOCC .AND. IO.LE.NDOCC+NPART
        DO JO = 1, IO !! L1
          NSEQ = NSEQ + 1
          EJ = EIG(JO)
          OCCJ = OCC(JO)
C         IF (OCCI.EQ.OCCJ) CYCLE !! FOR FON
          PART = JO.GT.NDOCC .AND. JO.LE.NDOCC+NPART .AND. PARTI
          IF (IO.EQ.JO) THEN
            U(IO,JO) = -HALF*SDERIJ(NSEQ)
          ELSE
            VAL = HDERIJ(NSEQ)
            VALI = VAL - EJ*SDERIJ(NSEQ)
            VALJ = VAL - EI*SDERIJ(NSEQ)
            IF (ABS(EJ-EI).LE.DEGTHR1.AND.PART) THEN
              IF (ABS(EJ-EI).GE.DEGTHR2) THEN
                !! AVOID NEARLY DEGENERATED P.O-P.O COUPLING ELEMENTS
                EIJ = (OCCJ-OCCI)/((EJ-EI)*OCCJ)
                U(IO,JO) = -OCCI*SDERIJ(NSEQ)/OCCJ + VALI*EIJ
                U(JO,IO) = ZERO
              ELSE
                !! USE LIMIT OR MACLAURIN EXPANSION
                EIJ = -OCCI*BETA*EXP((EI-EFERMI)*BETA)*HALF
                U(IO,JO) = -OCCI*SDERIJ(NSEQ)/OCCJ + VALI*EIJ
                U(JO,IO) = ZERO
              END IF
            ELSE
              EIJ = ONE/(EJ-EI)
              U(IO,JO) = VALI*EIJ
              U(JO,IO) = -VALJ*EIJ
            END IF
          END IF
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_CP_NR
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK SHIFT_TRIANGLE_DER_CLEAR
C>
C>    @brief Hessian of DFTB
C>
C>    @details VCLR only for values NI-th atom concerns
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of aotms
C>    @param NI Atom to differentiated
C>    @param L2 L1*(L1+1)/2
C>    @param IND Index of AO
C>           --- IN/OUTPUT ---
C>    @param OUTPUT Output (all zero matrix)
C>
C
      SUBROUTINE SHIFT_TRIANGLE_DER_CLEAR(NAT,NI,L2,IND,OUTPUT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,L2,IND(*)
      DOUBLE PRECISION, INTENT(OUT) :: OUTPUT(L2)
C
      INTEGER :: NJ,M,L,MU,NU,NSEQ
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00
C
      IF (NI.EQ.1) GO TO 100
C
      NSEQ = IND(NI)*(IND(NI)+1)/2
      DO M = 1, IND(NI+1)-IND(NI)
        DO NJ = 1, NI-1
          DO L = 1, IND(NJ+1) - IND(NJ)
            NSEQ = NSEQ + 1
            OUTPUT(NSEQ) = ZERO
          END DO
        END DO
        NSEQ = NSEQ + M
      END DO
C
100   IF (NI.EQ.NAT) RETURN

      NSEQ = IND(NI+1)*(IND(NI+1)+1)/2 + IND(NI)
      DO NJ = NI+1, NAT
        DO L = 1, IND(NJ+1) - IND(NJ)
          NU = IND(NJ)+L
          DO M = 1, IND(NI+1)-IND(NI)
            MU = IND(NI)+M
            NSEQ = NSEQ + 1
            OUTPUT(NSEQ) = ZERO
          END DO
C         MU = IND(NI+1)+1
          NSEQ = NSEQ + IND(NI) + NU - MU
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE SHIFT_TRIANGLE_DER_CLEAR
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK SHIFT_TRIANGLE_DER_SHELL
C>
C>    @brief Hessian of DFTB
C>
C>    @details Multiply shift contribution with a derivative matrix
C>             in AO basis.  Because derivative matrix is sparse
C>             (only columns of NI is non-trivial), this is faster
C>             than simple multiplication.  SHIFT should be
C>             shell-resolved.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NI Index of atom to be displaced
C>    @param L2 Size of upper triangular AO matrix
C>    @param IND AO index of each atom
C>    @param INDSH Index of shell for each atom
C>    @param INDSAO AO index of each shell
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>    @param SHIFT Shift contribution (NSHELL size)
C>    @param INPUT Input matrix, should be AO derivative matrix
C>           --- OUTPUT ---
C>    @param OUTPUT Output
C>
C
      SUBROUTINE SHIFT_TRIANGLE_DER_SHELL(NAT,NI,L2,IND,INDSH,INDSAO,
     *  NSPE,ISPE,MAXANG,SHIFT,INPUT,OUTPUT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,L2,IND(*),INDSH(*),INDSAO(*),NSPE,
     *  ISPE(NAT),MAXANG(NSPE)
      DOUBLE PRECISION, INTENT(IN) :: SHIFT(*),INPUT(L2)
      DOUBLE PRECISION, INTENT(OUT) :: OUTPUT(L2)
C
      INTEGER :: NSEQ,I,J,ISH,JSH,L,M,MU,NU,NJ
      DOUBLE PRECISION :: SHIFTI,SHIFTJ,SHIFTIJ
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
C
      IF (NI.EQ.1) GO TO 200
C
      NSEQ = IND(NI)*(IND(NI)+1)/2
      DO I = 1, MAXANG(ISPE(NI))
        ISH = INDSH(NI)+I
        SHIFTI = SHIFT(ISH)
        DO M = 1, INDSAO(ISH+1)-INDSAO(ISH)
          MU = INDSAO(ISH)+M
          DO NJ = 1, NI-1
            DO J = 1, MAXANG(ISPE(NJ))
              JSH = INDSH(NJ)+J
              SHIFTJ = SHIFT(JSH)
              SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
              DO L = 1, INDSAO(JSH+1) - INDSAO(JSH)
                NU = INDSAO(JSH)+L
                NSEQ = NSEQ + 1
                OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
              END DO
            END DO
          END DO
          NSEQ = NSEQ + MU - NU
        END DO
      END DO
C
200   IF (NI.EQ.NAT) RETURN
C
      NSEQ = IND(NI+1)*(IND(NI+1)+1)/2 + IND(NI)
      DO NJ = NI+1, NAT
        DO J = 1, MAXANG(ISPE(NJ))
          JSH = INDSH(NJ)+J
          SHIFTJ = SHIFT(JSH)
          DO L = 1, INDSAO(JSH+1)-INDSAO(JSH)
            NU = INDSAO(JSH)+L
            DO I = 1, MAXANG(ISPE(NI))
              ISH = INDSH(NI)+I
              SHIFTI = SHIFT(ISH)
              SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
              DO M = 1, INDSAO(ISH+1)-INDSAO(ISH)
                MU = INDSAO(ISH)+M
                NSEQ = NSEQ + 1
                OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
              END DO
            END DO
            NSEQ = NSEQ + IND(NI) + NU - MU
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE SHIFT_TRIANGLE_DER_SHELL
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK SHIFT_TRIANGLE_DER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Multiply shift contribution with a derivative matrix
C>             in AO basis.  Because derivative matrix is sparse
C>             (only columns of NI is non-trivial), this is faster
C>             than simple multiplication.  SHIFT should be
C>             atom-resolved.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NI Index of atom to be displaced
C>    @param L2 Size of upper triangular AO matrix
C>    @param IND AO index of each atom
C>    @param SHIFT Shift contribution (NAT size)
C>    @param INPUT Input matrix, should be AO derivative matrix
C>           --- OUTPUT ---
C>    @param OUTPUT Output
C
      SUBROUTINE SHIFT_TRIANGLE_DER(NAT,NI,L2,IND,SHIFT,INPUT,OUTPUT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,L2,IND(*)
      DOUBLE PRECISION, INTENT(IN) :: SHIFT(*),INPUT(L2)
      DOUBLE PRECISION, INTENT(OUT) :: OUTPUT(L2)
C
      INTEGER :: NSEQ,NJ,L,M,MU,NU
      DOUBLE PRECISION :: SHIFTI,SHIFTJ,SHIFTIJ
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
C
      SHIFTI = SHIFT(NI)
C
      IF (NI.EQ.1) GO TO 200
C
      NSEQ = IND(NI)*(IND(NI)+1)/2
      DO M = 1, IND(NI+1)-IND(NI)
        DO NJ = 1, NI-1
          SHIFTJ = SHIFT(NJ)
          SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
          DO L = 1, IND(NJ+1) - IND(NJ)
            NSEQ = NSEQ + 1
            OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
          END DO
        END DO
        NSEQ = NSEQ + M
      END DO
C
200   IF (NI.EQ.NAT) RETURN

      NSEQ = IND(NI+1)*(IND(NI+1)+1)/2 + IND(NI)
      DO NJ = NI+1, NAT
        SHIFTJ = SHIFT(NJ)
        SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
        DO L = 1, IND(NJ+1) - IND(NJ)
          NU = IND(NJ)+L
          DO M = 1, IND(NI+1)-IND(NI)
            MU = IND(NI)+M
            NSEQ = NSEQ + 1
            OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
          END DO
          NSEQ = NSEQ + IND(NI) + NU - MU
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE SHIFT_TRIANGLE_DER
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK SHIFT_TRIANGLE_SHELL
C>
C>    @brief Hessian of DFTB
C>
C>    @details Multiply shift contribution with a matrix in AO basis.
C>             SHIFT should be shell-resolved.
C>
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param SHIFT Shift contribution (NSHELL size)
C>    @param INPUT Input matrix, should be AO matrix
C>    @param NAT Number of atoms
C>    @param NSPE Number of species
C>    @param NSHELL Number of shells
C>    @param L2 Size of upper triangular AO matrix
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param OUTPUT Output
C
      SUBROUTINE SHIFT_TRIANGLE_SHELL(SHIFT,INPUT,OUTPUT,
     *  NAT,NSPE,NSHELL,L2,ISPE,MAXANG)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L2,NSHELL
      DOUBLE PRECISION, INTENT(IN) :: INPUT(L2),SHIFT(NSHELL)
      DOUBLE PRECISION, INTENT(OUT) :: OUTPUT(L2)
      INTEGER, INTENT(IN) :: NAT,NSPE,ISPE(NAT),MAXANG(NSPE)
C
      DOUBLE PRECISION :: SHIFTI,SHIFTJ,SHIFTIJ
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
      INTEGER :: NSEQ,MU,NU,I,II,III,J,JJ,JJJ,M,N,ISH,JSH
C
      NSEQ = 0
      MU = 0
      ISH = 0
      DO I = 1, NAT
        DO II = 1, MAXANG(ISPE(I))
          ISH = ISH + 1
          SHIFTI = SHIFT(ISH)
          IF (II.EQ.1) III = 1
          IF (II.EQ.2) III = 3
          IF (II.EQ.3) III = 5
          DO M = 1, III
            MU = MU + 1
            JSH = 0
            NU = 0
            DO J = 1, I
              DO JJ = 1, MAXANG(ISPE(J))
                JSH = JSH + 1
                SHIFTJ = SHIFT(JSH)
                SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
                IF (JJ.EQ.1) JJJ = 1
                IF (JJ.EQ.2) JJJ = 3
                IF (JJ.EQ.3) JJJ = 5
                DO N = 1, JJJ
                  NU = NU + 1
                  IF (NU.GT.MU) EXIT
                  CALL DFTB_CNVSQ(MU,NU,NSEQ)
C                 write (*,*) mu, nu
C                 write (*,*) shifti,shiftj,shiftij
                  OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
C                 write (*,*) input(nseq),"->", output(nseq)
                END DO
              END DO
            END DO
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE SHIFT_TRIANGLE_SHELL
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK SHIFT_TRIANGLE
C>
C>    @brief Hessian of DFTB
C>
C>    @details Multiply shift contribution with a matrix in AO basis.
C>             SHIFT should be atom-resolved.
C>
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L2 Size of upper triangular AO matrix
C>    @param IND Index of AOs
C>    @param SHIFT Shift contribution (NSHELL size)
C>    @param INPUT Input matrix, should be AO matrix
C>           --- OUTPUT ---
C>    @param OUTPUT Output
C
      SUBROUTINE SHIFT_TRIANGLE(NAT,L2,IND,SHIFT,INPUT,OUTPUT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L2,IND(*)
      DOUBLE PRECISION, INTENT(IN) :: SHIFT(*),INPUT(L2)
      DOUBLE PRECISION, INTENT(OUT) :: OUTPUT(L2)
C
      INTEGER :: NSEQ,MU,NU,L,M,NM,NN
      DOUBLE PRECISION :: SHIFTI,SHIFTJ,SHIFTIJ
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
C
      NSEQ = 0
      NU = 0
      DO NM = 1, NAT
        SHIFTI = SHIFT(NM)
        DO L = 1, IND(NM+1) - IND(NM)
          NU = NU + 1
          MU = 0
          DO NN = 1, NM
            SHIFTJ = SHIFT(NN)
            SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
            DO M = 1, IND(NN+1) - IND(NN)
              MU = MU + 1
              IF (MU.GT.NU) EXIT
              NSEQ = NSEQ + 1
              OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
            END DO
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE SHIFT_TRIANGLE
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_RESPONSE_REDUCE
C>
C>    @brief Hessian of DFTB
C>
C>    @details Prepare response terms in CP-DFTB iterations.  This will
C>             reduce computation.  This subroutine is used in reduced
C>             memory run and store only L1*L1*NSPIN values.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @data Oct, 2014 - Yoshio Nishimoto
C>    - Rewrittten with DGEMM
C>
C>           --- INPUT ---
C>    @param L1 Number of basis functions
C>    @param L2 Size of upper triangular AO matrix
C>    @param VEC MO coefficients
C>    @param S Overlap matrix
C>    @param SSQ Working array for square overlap matrix
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>           --- OUTPUT ---
C>    @param RESP Response terms
C
      SUBROUTINE DFTB_PREP_RESPONSE_REDUCE(L1,L2,VEC,S,RESP,SSQ,NSPIN)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,L2,NSPIN
      DOUBLE PRECISION, INTENT(IN) :: VEC(L1,L1,NSPIN),S(L2)
      DOUBLE PRECISION, INTENT(OUT) :: RESP(L1,L1,NSPIN),SSQ(L1,L1)
C
      INTEGER :: ISPIN
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00
C
C     RESP(MU,MO) = \SUM_{\MU} S_{\MU \NU} C_{\NU MO}
C
      CALL CPYTSQ(S,SSQ,L1,1)
      DO ISPIN = 1, NSPIN
        CALL DGEMM('T','N',L1,L1,L1,ONE,VEC,L1,SSQ,L1,ZERO,
     *             RESP(1,1,ISPIN),L1)
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_PREP_RESPONSE_REDUCE
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_RESPONSE
C>
C>    @brief Hessian of DFTB
C>
C>    @details Prepare response terms in CP-DFTB iterations.  This will
C>             reduce computation.  This subroutine requires much
C>             memory and store only L1*L1*NSPIN*(NAT or NSHELL) values.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L1 Number of basis functios
C>    @param L2 Size of upper triangular AO matrix
C>    @param IND Index of AO
C>    @param VEC MO coefficients
C>    @param S Overlap matrix
C>    @param SRSCC Shell-resolved SCC or not
C>    @param UHF U-DFTB or not
C>    @param INDSAO AO index of each shell
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param NDIMSH If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param NSHELL Number of shells
C>    @param SSQ Working array for square overlap matrix
C>    @param WRK Working array for MRARBR
C>           --- OUTPUT ---
C>    @param RESP Response terms
C
      SUBROUTINE DFTB_PREP_RESPONSE(NAT,L1,L2,IND,
     *  VEC,S,RESP,SRSCC,UHF,INDSAO,NSPIN,NDIMSH,NSHELL,SSQ,WRK)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L1,L2,IND(*),INDSAO(*),NSPIN,NDIMSH,
     *  NSHELL
      DOUBLE PRECISION, INTENT(IN) :: VEC(L1,L1,NSPIN),S(L2)
      DOUBLE PRECISION, INTENT(OUT) :: RESP(L1,L1,NDIMSH,NSPIN),
     *  SSQ(L1,L1),WRK(L1,L1)
      LOGICAL, INTENT(IN) :: SRSCC,UHF
C
      INTEGER :: ISPIN,NN,II,I,J
      DOUBLE PRECISION :: TMP
C
C     RESP(IO,JO,A)
C       = \sum_{\mu \in A} \sum_{\nu} c_{\mu i} c_{\nu j} S_{\mu \nu}
C
      CALL CPYTSQ(S,SSQ,L1,1)
      DO ISPIN = 1, NSPIN
        CALL MRARBR(SSQ,L1,L1,L1,VEC(1,1,ISPIN),L1,L1,WRK,L1)
        IF (SRSCC.OR.UHF) THEN
          DO NN = 1, NSHELL
            II = INDSAO(NN+1)-INDSAO(NN)
            CALL MRTRBR(VEC(INDSAO(NN)+1,1,ISPIN),L1,II,L1,
     *      WRK(INDSAO(NN)+1,1),L1,L1,RESP(1,1,NN,ISPIN),L1)
C
C           ----- SYMMETRIZE RESP MATRIX -----
C
            DO I = 1, L1
              DO J = I, L1
                TMP = RESP(J,I,NN,ISPIN) + RESP(I,J,NN,ISPIN)
                RESP(J,I,NN,ISPIN) = TMP
                RESP(I,J,NN,ISPIN) = TMP
              END DO
            END DO
          END DO
        ELSE
          DO NN = 1, NAT
            II = IND(NN+1)-IND(NN)
            CALL MRTRBR(VEC(IND(NN)+1,1,ISPIN),L1,II,L1,
     *        WRK(IND(NN)+1,1),L1,L1,RESP(1,1,NN,ISPIN),L1)
C
C           ----- SYMMETRIZE RESP MATRIX -----
C
            DO I = 1, L1
              DO J = I, L1
                TMP = RESP(J,I,NN,ISPIN) + RESP(I,J,NN,ISPIN)
                RESP(J,I,NN,ISPIN) = TMP
                RESP(I,J,NN,ISPIN) = TMP
              END DO
            END DO
          END DO
        END IF
      END DO
C
C       write (*,*) "response"
C       do i = 1, l1
C         do j = 1, l1
C           do nn = 1, nshell
C             write (*,'(3i3,3(x,f20.10))') i,j,nn,
C    *  resp(i,j,nn,1),resp(i,j,nn,2), resp(i,j,nn,1)-resp(i,j,nn,2)
C           end do
C         end do
C       end do
C     else
C       write (*,*) "response"
C       do i = 1, l1
C         do j = 1, l1
C           do nn = 1, nshell
C             write (*,'(3i3,1(x,f20.10))') i,j,nn,
C    *  resp(i,j,nn,1)
C           end do
C         end do
C       end do
C
      RETURN
C
      END SUBROUTINE DFTB_PREP_RESPONSE
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HESS_INDEX
C>
C>    @brief Hessian of DFTB
C>
C>    @details Prepare index used in DFTB_DEDB.  This will be helpful in
C>             reducing the call of DFTB_CNVSQ
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param OCC Occupation number of each orbital
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param L1 Number of basis functios
C>    @param NDIMSH L1*(NDOCC(1)+NPART(1))
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>           --- OUTPUT ---
C>    @param INDP Index of AOs for independent pairs
C
      SUBROUTINE DFTB_HESS_INDEX(OCC,INDP,NDOCC,NPART,L1,NDIM,NSPIN)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,NDIM,NSPIN
      DOUBLE PRECISION, INTENT(IN) :: OCC(L1,NSPIN)
      INTEGER, INTENT(INOUT) :: INDP(NDIM,NSPIN)
      INTEGER, INTENT(IN) :: NDOCC(2),NPART(2)
C
      DOUBLE PRECISION :: OCCI
      INTEGER :: ISPIN,N2,IO,MO,NSEQ
C
C     PREPARE INDEXING ... I'M NOT SURE THIS IS MEANINGFUL.
C
      DO ISPIN = 1, NSPIN
        N2 = 1
        DO IO = 1, NDOCC(ISPIN)+NPART(ISPIN)
          OCCI = OCC(IO,ISPIN)
          IF (OCCI.LT.1.0D-10) CYCLE
          IF (IO.LE.NDOCC(ISPIN)) THEN
            DO MO = NDOCC(ISPIN)+1, L1
              CALL DFTB_CNVSQ(MO,IO,NSEQ)
              INDP(N2,ISPIN) = NSEQ
              N2 = N2 + 1
            END DO
          ELSE
            DO MO = 1, L1
              CALL DFTB_CNVSQ(MO,IO,NSEQ)
              INDP(N2,ISPIN) = NSEQ
              N2 = N2 + 1
            END DO
          END IF
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_HESS_INDEX
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CP
C>
C>    @brief Hessian of DFTB
C>
C>    @details Solve CP-DFTB equation for each vector.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Hiroya Nakata
C>    - Added FMO-DFTB Hessian
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Performance improvement + DFTB/PCM
C>
C>           --- INPUT ---
C>    @param L0 LQMT
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param IRAF 20
C>    @param IORA Status of .F20
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NVIRT Number of virtual orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param U U matrix (derivative of MO coefficients)
C>    @parma VEC MO coefficients
C>    @param SDER Overlap derivative matrix
C>    @param EIG Eigenvalue of each MO
C>    @param OCC Occupation number of each MO
C>    @param SHIFT Shift contribution of each atom
C>    @param GAMMA Matrix of DFTB2 gamma
C>    @param GAMDER Derivative matrix of DFTB2 gamma
C>    @param S Overlap matrix
C>    @param CHAMUL Mulliken charges of each atom
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param UINIT Initial U matrix (only with non-response terms)
C>    @param D Density matrix
C>    @param HDERIJ H_{ij}^a + V_{ij}^a
C>    @param SDERIJ S_{ij}^a
C>    @param GAMMA3 Matrix of DFTB3 gamma
C>    @param GAMDER3 Derivative matrix of DFTB3 gamma
C>    @param DISK Whether disk-based algorithm or not
C>    @param FON Whether fractional occupation is used or not
C>    @param REDUCE Whether reduced memory CP-DFTB or not
C>    @param ROHF Whether (same-electron) RO-DFTB or not
C>           RO-DFTB with canonicalization has not been implemented
C>    @param UHF Whether U-DFTB or not
C>    @param NGAMMA Dimension of gamma matrices (NAT or NSHELL)
C>    @param SHIFTSA Shift contribution for alpha orbitals (shell-res.)
C>    @param SHIFTSB Shift contribution for beta  orbitals (shell-res.)
C>    @param INDSH Shell index of each atom
C>    @param INDSAO AO index of each shell
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param CHAMULS shell-resolved Mulliken charges
C>    @param NDIMSH If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param SPNCST Spin constants
C>    @param DIRECT Integral direct ... meaningless option now
C>    @param ID_HDERMO,ID_SDERMO,ID_SDERAO IDs of HDERIJ,SDERIJ,SDER
C>           stored on DDI memory pool.
C>    @param BUNDLE Bundle or not
C>           --- OUTPUT ---
C>    @param HESSIAN Hessian
C>    @param DIPDER Dipole derivative
C>
C
      SUBROUTINE DFTB_CP(L0,L1,L2,IRAF,IORA,NDOCC,NVIRT,NPART,NOCC,U,
     *  VEC,SDER,EIG,OCC,SHIFT,GAMMA,GAMDER,S,CHAMUL,DISTMAT,UINIT,
     *  HESSIAN,D,HDERIJ,SDERIJ,GAMMA3,GAMDER3,DIPDER,DISK,FON,REDUCE,
     *  ROHF,UHF,NGAMMA,SHIFTSA,SHIFTSB,INDSH,INDSAO,
     *  NSPIN,CHAMULS,NDIMSH,DIRECT,ID_HDERMO,ID_SDERMO,
     *  ID_SDERAO,SAVGOP,SOME,BUNDLE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000,MXSPE=10)
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      LOGICAL SAVGOP
C
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      DOUBLE PRECISION :: U(L1,L1,NSPIN),VEC(L1,L1,NSPIN),
     *  SDER(L2,3,NAT),EIG(L1,NSPIN),OCC(L1,NSPIN),SHIFT(NAT),
     *  UINIT(L1,L1,NSPIN),GAMMA(*),GAMDER(*),S(L2),CHAMUL(NAT),
     *  DISTMAT(*),HESSIAN(3*NAT,3*NAT),HDERIJ(L2,3,NAT,NSPIN),
     *  SDERIJ(L2,3,NAT,NSPIN),DIPDER(3,3,NAT),D(L2,NSPIN),
     *  GAMMA3(NGAMMA,NGAMMA),GAMDER3(NGAMMA,NGAMMA),
     *  SHIFTSA(NDIMSH),SHIFTSB(NDIMSH),CHAMULS(NDIMSH)
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBHS/ DEGTHR1,DEGTHR2,MODHSS,MODPRJ
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL GOPARR,DSKWRK,MASWRK,PARALL3
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM,IHET
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED,LEPSPCM
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
C     for FMO-DFTB Hessian
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
C
      LOGICAL MYJOB,ISGDDI,PAROUT,INITGDDI,WASGDDI,MLGDDI
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      DATA  CHECK/8HCHECK   /
C
      INTEGER :: IRAF,IORA(3*NAT*5),O,INDSH(*),INDSAO(*),NDOCC(2),
     *  NPART(2),NVIRT(2),NOCC(2)
      INTEGER, PARAMETER :: DDI_WORLD=0,DDI_GROUP=1
      DOUBLE PRECISION,PARAMETER ::
     *  ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00,
     *  DEBYE_ANGSTROM=2.541746675D+00*1.889725989D+00,
     *  BOLTZ=3.1668114D-06,ONE_THIRD=1.0D+00/3.0D+00
      DOUBLE PRECISION :: V(3),AUP(9,9),BUP(9,9)
C
      LOGICAL :: DISK,FON(3),REDUCE,ROHF,UHF,DIRECT,SKP,SOME,
     *  BUNDLE,BUNDLE0,SAVDCQ
C
      IF (MASWRK.AND.SOME) THEN
        WRITE (IW,*)
        WRITE (IW,*) "         *** START COUPLED-PERTURBED DFTB ***"
        WRITE (IW,*)
      END IF
C     IF (ISGDDI) CALL GDDI_SCOPE(DDI_GROUP)
      IF (ISGDDI) CALL GDDI_SCOPE(DDI_WORLD)
      L3 = L1*L1
      CALL VALFM(LOADFM)
      CALL GOTFM(NGOTMX)
C
      LDEDB        = LOADFM     + 1
      LSDER        = LDEDB      + L1*NSPIN
      LHDERIJ      = LSDER      + L2
      LSDERIJ      = LHDERIJ    + L2*NSPIN
      LFDERIJ      = LSDERIJ    + L2*NSPIN
      LSOMGDIJ     = LFDERIJ    + L2*NSPIN
      LQDER_INIT   = LSOMGDIJ   + L2*NSPIN
      LDOMEGA      = LQDER_INIT + NDIMSH*NSPIN
      LWRK         = LDOMEGA    + L2*NSPIN
       !! DFTB_DEDB will split L3*2 (LWRK2+LWRK3) into L2*3
      LWRK1        = LWRK       + L3 !! REQ
      LWRK2        = LWRK1      + L3 !! L3 IF NOT REDUCE
      LWRK3        = LWRK2      + L3 !! L2?
      LQDER        = LWRK3      + L2
      LSDSHIJ      = LQDER      + NDIMSH*NSPIN
      LINDEX       = LSDSHIJ    + L2
      LDTMP        = LINDEX     + (NDOCC(1)+NPART(1))*L1*NSPIN
      LRESPONSE    = LDTMP      + L2*NSPIN
      IF (.NOT.SCC) THEN
        LAST       = LRESPONSE  + L1*L1
      ELSE IF (REDUCE) THEN
        IF (MASWRK.AND.SOME) WRITE (IW,*) "THIS IS A REDUCED MEMORY RUN"
        LAST       = LRESPONSE  + L1*L1*NSPIN
      ELSE
        LAST       = LRESPONSE  + L1*L1*NDIMSH*NSPIN
      END IF
C
      IF (SCC) THEN
        LDERSHIFT  = LAST
        LDSH       = LDERSHIFT  + NDIMSH
        LQDER_PREV = LDSH       + NDIMSH
C       LDERSH     = LQDER_PREV + NDIMSH*NSPIN
        LSDEROMG   = LQDER_PREV + NDIMSH*NSPIN
C       LSDEROMG   = LDERSH     + L2
        LAST       = LSDEROMG   + L2
      END IF
C
      IF (FON(3)) THEN
        LDEDB_INIT = LAST
        LDNDR      = LDEDB_INIT + L1
        LAST       = LDNDR      + L1
      ELSE
        LDEDB_INIT = LAST
        LDNDR      = LAST
      END IF
C
      IF (UHF) THEN
        LSHIFTSP   = LAST
        LAST       = LSHIFTSP   + NDIMSH
      ELSE
        LSHIFTSP   = LAST
      END IF
C
      IF (DFTB3.AND.NFG.NE.0) THEN
        LSHIFT3    = LAST
        LAST       = LSHIFT3    + NAT*2
      END IF
C
      MEMPCM = 0
      IF (IPCM.NE.0.OR.NFMOPCM.GT.0) THEN
        IF (ISGDDI) CALL GDDI_SCOPE(DDI_GROUP)
        NDASC = 0
        LFPNT = LAST
        if (isgddi) then
          !! Silly strategy for ASCDII
          !! If Broyden is used, no need to do such
          NTSPAR0=(NTS-1)/npglob+1
          NTSPAR =(NTS-1)/nproc+1
        else
          NTSPAR0=(NTS-1)/nproc+1
          NTSPAR =(NTS-1)/nproc+1
        end if
        CALL INDQPROD(0,NTSPAR,LFPNT,NDASC,DUM,DUM,DUM,0)
        LAST    = LFPNT   + NDASC  + 1
C
        LEPOT   = LAST
        LPCMTMP = LEPOT      + NTS
        LQSEDER = LPCMTMP    + NTS
        LQTMP   = LQSEDER    + NTS
        LAST    = LQTMP      + NTS
C
C       MUST BE CHECKED FOR FMO
        LFIXPV = 0
        IF(IPCDER.EQ.3) LFIXPV = 3*20*MXTS
        LFIXPV2 = 0
        IF(IPCDER.EQ.3) LFIXPV2= 21*MXTS/NWDVAR + 1
        LDAI    = LAST
        LIDDAI  = LDAI        + LFIXPV
        LAST    = LIDDAI      + LFIXPV2
        IF (ISGDDI) CALL GDDI_SCOPE(DDI_WORLD)
C
        MEMPCM  = NDASC+NTS*6+LFIXPV+LFIXPV2
      END IF
      NEED         = LAST - LOADFM - 1
C
C     ----- GET MEMORY -----
C
      CALL GETFM(NEED)
      IF (EXETYP.EQ.CHECK) GO TO 1000
      IF (UHF.OR.SRSCC) NSHELL = NDIMSH
      IF (MASWRK.AND.SOME) THEN
        WRITE (IW,'(" ...... ALLOCATED MEMORY IN DFTB_CP",
     * " = ",I10," WORDS")') NEED - MEMPCM
      END IF
C
      CALL GOTFM(NGOTMX)
      MEM = 0
      IF (DIRECT) THEN
        MEM = L2*2 + L1*L1*2
      ELSE IF (ISGDDI) THEN
        MEM = L2*3*(NSPIN*2+1)
      END IF
      IF (MEM.GT.NGOTMX) THEN
        IF (MASWRK) THEN
          WRITE (IW,'(" NOT ENOUGH MEMORY IS AVAILABLE FOR DFTB_DEDB")')
          WRITE (IW,'(" NGOTMX          = ",I10," WORDS")') NGOTMX
          WRITE (IW,'(" REQUIRED MEMORY = ",I10," WORDS")') MEM
          WRITE (IW,'(" INCREASE MWORDS AT LEAST ",I10)')
     *      INT(DBLE(NGOTMX-MEM)*1.0D-06)+1
        END IF
        CALL ABRT
      END IF
C
C     CALL DFTB_DEDB ONCE FOR EACH VECTOR IS NOT EFFICIENT.
C     THEREFORE, CALL DFTB_DEDB AFTER SOLVING SEVERAL (NVEC) CP-DFTB
C     EQUATIONS, IF MEMORY IS AVAILABLE.
C     EVEN IF INTEGRALS ARE NOT STORED ON DISK, THIS APPROACH WILL
C     BE BENEFIT.
C
C     NGOTMX0 = NGOTMX
      NGOTMX = NGOTMX - MEM !! L2*3*(NSPIN*2+1)
      NOCCMAX = MAX(NOCC(1),NOCC(2))
      !! RESERVE FOR DFTB_DEDB
      IF (DIRECT) THEN
        NEEDDEDB = L2*L2*2 + L1*L1*2
      ELSE IF (ISGDDI) THEN
        NEEDDEDB = L2*3*(NSPIN*2+1)
      ELSE
        NEEDDEDB = 0
      END IF
      IF (BUNDLE) THEN
        DO NVEC = 1, 3*NAT
          MEM = NVEC*(L2+L2+L1+L1*NOCCMAX+NDIMSH)*NSPIN
          IF (FON(3)) MEM = MEM + NVEC*L1 !! LDNDR
          !! THE FOLLOWING MEMORY WILL BE ALLOCATED IN DFTB_DEDB
          IF (ISGDDI.OR.GOPARR) MEM = MEM + NVEC
          MEM = MEM + NEEDDEDB
          IF (MEM.GT.NGOTMX) EXIT
        END DO
        IF (NVEC.NE.1) NVEC = NVEC - 1
        IF (MASWRK.AND.SOME) THEN
C         WRITE (IW,'(" AVAILABLE CURRENT MEMORY =",I12)') NGOTMX0
          WRITE (IW,'(" BUNDLE ",I3," VECTORS IN CP-DFTB")') NVEC
        END IF
      ELSE
        NVEC = 1
      END IF
      BUNDLE0  = BUNDLE
      BUNDLE   = .FALSE.
      IF (NVEC.GT.1) THEN
        BUNDLE = .TRUE.
      ELSE
        BUNDLE = .FALSE.
      END IF
C
      IF (BUNDLE) THEN
        CALL VALFM(LOADFM)
        LFDERIJTMP   = LOADFM     + 1
        LSDERIJTMP   = LFDERIJTMP + L2*NSPIN*NVEC
        LDEDBTMP     = LSDERIJTMP + L2*NSPIN*NVEC
        LUTMP        = LDEDBTMP   + L1*NSPIN*NVEC
        LDOMEGATMP   = LUTMP      + L1*NOCCMAX*NSPIN*NVEC
        LAST         = LDOMEGATMP + NDIMSH*NSPIN*NVEC
        IF (FON(3)) THEN
          LDNDRTMP   = LAST
          LAST       = LDNDRTMP   + L1*NVEC
        ELSE
          LDNDRTMP   = LAST
        END IF
        LINDVEC      = LAST
        LAST         = LINDVEC    + NVEC
        NEED2        = LAST - LOADFM - 1
C
C       ----- GET MEMORY AGAIN -----
C
        CALL GETFM(NEED2)
        IF (MASWRK.AND.SOME) THEN
          WRITE (IW,'(" ...... ALLOCATED MEMORY FOR CP-DFTB SOLUTION",
     *   " = ",I10," WORDS")') NEED2
        END IF
      ELSE
        LFDERIJTMP   = LFDERIJ
        LSDERIJTMP   = LSDERIJ
        LDEDBTMP     = LDEDB
        LDOMEGATMP   = LDOMEGA
        LDNDRTMP     = LDNDR
      END IF
      IF (EXETYP.EQ.CHECK) GO TO 1000
C
C     PREPARE FOR RESPONSE TERMS
C
      IF (REDUCE) THEN
        CALL DFTB_PREP_RESPONSE_REDUCE(L1,L2,VEC,S,X(LRESPONSE),
     *    X(LWRK),NSPIN)
      ELSE
        CALL DFTB_PREP_RESPONSE(NAT,L1,L2,IND,VEC,
     *    S,X(LRESPONSE),SRSCC,UHF,INDSAO,NSPIN,NDIMSH,NDIMSH,X(LWRK),
     *    X(LWRK1))
C       do i = 1, l1*l1*ndimsh*nspin
C         write (*,*) i,x(lresponse+i-1)
C       end do
      END IF
      CALL VCLR(X(LDEDB),1,L1*NSPIN)
      IF (FON(3)) THEN
        CALL VCLR(X(LDEDB_INIT),1,L1)
        CALL VCLR(X(LDNDR),1,L1)
      END IF
C
      IF (FON(3)) THEN
        !! CALCULATE PARTIAL DENSITY MATRIX
        !! D'_{\mu \nu} = \sum_i^{NDOCC} n_i c_{\mu i} c_{\nu i}
        DO ISPIN = 1, NSPIN
          CALL DFTB_DPART(L1,L2,NDOCC(ISPIN),OCC(1,ISPIN),
     *      X(LDTMP+L2*(ISPIN-1)),VEC(1,1,ISPIN))
        END DO
      ELSE
        CALL DCOPY(L2*NSPIN,D,1,X(LDTMP),1)
      END IF
C
C     ----- RESTORE ESP CONTRIBUTION, ONLY WHEN DFTB3 -----
C
      IF (DFTB3.AND.NFG.NE.0) THEN
        GOPARR = SAVGOP
        CALL DAREAD(IDAF,IODA,X(LSHIFT3),NAT*2,567,0)
        IF (GOPARR) GOPARR = .FALSE.
      END IF
C
CD    tt0 = zero
CD    tt1 = zero
CD    tt2 = zero
CD    tt3 = zero
CD    tt4 = zero
CD    tt5 = zero
CD    tti = zero
CD    ttq = zero
CD    ttnr = zero
CD    ttqder = zero
CD    ttbr = zero
CD    ttittftri = zero
CD    ttdedb=zero
CD    ttpdedb=zero
CD    tttftri=zero
CD    tfon = zero
C
      MXITER = 100
      ALPHA = 1.0D+00
      THRES = 1.0D-06
C     IF (SRSCC.OR.UHF) THRES = 1.0D-08
      NITER = 0
      IF (FON(3)) THEN
        CALL DFTB_ETEMP(L0,NE,EIG,OCC,ETEMP,EMERMIN,EFERMI)
        BETA=ONE/(ETEMP*BOLTZ)
      END IF
C     WRITE (*,'(" DEGTHR1, DEGTHR2 =",2E9.1)') DEGTHR1,DEGTHR2
      IF (FON(3).AND.SOME.AND.MASWRK)
     *  CALL DFTB_HESS_CHKDEG(NSPIN,L1,EIG,OCC,DEGTHR1,DEGTHR2,NDOCC,
     *                        NPART,IW,NDEG,SOME.AND.MASWRK)
C
C     PREPARE INDEX FOR DFTB_DEDB
C
      NDIM = (NDOCC(1)+NPART(1))*L1
      CALL DFTB_HESS_INDEX(OCC,X(LINDEX),NDOCC,NPART,L1,NDIM,NSPIN)
C
C     PREPARE PCM INFORMATION (IN WORLD SCOPE)
C
      SAVDCQ = .FALSE.
      IF (IPCM.NE.0.OR.NFMOPCM.GT.0) THEN
        CALL DFTB_QPOTEN(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *                   X(LAXYZCT+MXTS*2),CHAMUL,X(LEPOT))
C       CALL INDQPROD(1,NTSPAR,LFPNT,NDASC,X(LEPOT),X(LQSE),X(LQSE),1)
        CALL INDQPROD(1,NTSPAR0,LFPNT,NDASC,X(LEPOT),X(LQSE),X(LQSE),1)
C       call dscal(nts,-one,x(lepot),1)
C
        IF(IPCDER.EQ.3) THEN
          CALL DAREAD(IDAF,IODA,X(LDAI),LFIXPV,334,0)
          CALL DAREAD(IDAF,IODA,X(LIDDAI),LFIXPV2,335,1)
        ENDIF
C
        !! Store dC/da*q matrix, if memory is available
        CALL GOTFM(NGOTMX)
        CALL VALFM(LOADFM)
        LDCDAQ = LOADFM + 1
        LAST   = LDCDAQ + NTS*NAT*3
        NEED3  = LAST - LOADFM - 1
        !! RESERVED FOR DFTB_DEDB
        NEED3  = NEED3 + NEEDDEDB
        IF (NEED3.LE.NGOTMX) THEN
          NEED3 = NEED3 - NEEDDEDB
          CALL GETFM(NEED3)
          SAVDCQ = .TRUE.
          CALL VCLR(X(LDCDAQ),1,NTS*NAT*3)
          IPCOUNT = ME - 1
          DO NI = 1, NAT
            IF(GOPARR) THEN
              IPCOUNT = IPCOUNT + 1
              IF (MOD(IPCOUNT,NPROC).NE.0) CYCLE
            END IF
            DO KI = 1, 3
              CALL DFTB_CALC_DCDA(NTS,NI,KI,X(LAXYZCT),
     *             X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),
     *             X(LAXYZCT+MXTS*3),X(LISPHE),
     *             X(LEPSPCM),X(LIDDAI),X(LDAI),X(LQSE),
     *             X(LDCDAQ+3*NTS*(NI-1)+NTS*(KI-1)))
            END DO
          END DO
          IF(GOPARR) CALL DDI_GSUMF(2418,X(LDCDAQ),NTS*NAT*3)
        ELSE
          NEED3 = 0
        END IF
        IF (MASWRK.AND.SOME) THEN
          IF (SAVDCQ)
     *    WRITE (IW,'(" ENOUGH MEMORY TO STORE DC/DA*Q FOR PCM",
     *     " ( ",I10," WORDS)")') NEED3
          WRITE (IW,'(" ...... ALLOCATED MEMORY FOR PCM = ",I10,
     *      " WORDS")') MEMPCM + NEED3
        END IF
      END IF
C
      IF (ISGDDI) CALL GDDI_SCOPE(DDI_GROUP)
      PARALL3 = GOPARR
C     IPCOUNT = ME - 1
      IF (PARALL3) THEN !! .AND..NOT.ISGDDI) THEN
C       GOPARR = .FALSE. !! AVOID PARALLEL CALCULATION IN TFTRI0
        IF (MASWRK.AND.SOME) THEN
          WRITE (IW,'(" PARALLEL CALCULATION WITH ",I3," CORES")')NPROC
        ELSE
C         DSKWRK = .FALSE.
        END IF
      END IF
C
      IF (ISGDDI) THEN
        IF (MASWRK.AND.SOME) THEN
          WRITE (IW,'(" PARALLEL (GDDI) CALCULATION WITH ",
     *      I3," GROUPS")') NGROUPS
        END IF
        CALL GDDI_SCOPE(DDI_GROUP)
        CALL DDI_COMMID(DDI_WORLD,IDWORLD)
        IDW = IDWORLD
        CALL GDDICOUNT(-1,LGROUP,MYJOB)
      END IF
C
      IRA1 = 0            !! HDERIJ
      IRA2 = IRA1 + 3*NAT !! SDERIJ
      IRA3 = IRA2 + 3*NAT !! SDER
      IRA4 = IRA3 + 3*NAT !! HDERIJ (BETA)
      IRA5 = IRA4 + 3*NAT !! SDERIJ (BETA)
C     write (*,*) "disk = ", disk
CD    CALL CPU_TIME(TIT0)
CD    CALL SYSTEM_CLOCK(ICLOCK_COUNTS_1,ICLOCK_RATE)
C     FIRST = .TRUE.
      FONCON = ZERO
      NVECTMP = 0
      NVCP = 0
      NITMP = 1
      KITMP = 1
      DO NI = 1, NAT
        IF (ISGDDI) THEN
          call GDDICOUNT(0,LGROUP,MYJOB)
          IF (.NOT.MYJOB) THEN
            IF (BUNDLE.AND.NI.EQ.NAT.AND.NVECTMP.GT.0) THEN
C             if (maswrk) then
C               do i = 1, nvectmp
C                 write (iw,*) i,x(lindvec+i-1)
C               end do
C               write (iw,*) "nitmp,kitmp = ", nitmp,kitmp
C             end if
              IF (PARALL3) NVECTMP = NVCP
              CALL DFTB_DEDB(HESSIAN(1,3*(NITMP-1)+KITMP),X(LWRK1),
     *          X(LWRK1+L2+1),X(LWRK1+L2*2+1),X(LWRK3),X(LWRK),
     *          X(LFDERIJTMP),X(LDEDBTMP),
     *          HDERIJ,SDERIJ,SDER,X(LUTMP),VEC,D,EIG,OCC,
     *          X(LDNDRTMP),X(LDOMEGATMP),
     *          X(LSDERIJTMP),SHIFT,SHIFTSA,
     *          SHIFTSB,C,FONCON,BETA,EFERMI,DEGTHR1,DEGTHR2,
     *          NAT,L0,L1,L2,NSPIN,NDIMSH,NDOCC,NPART,
     *          NSPE,ISPE,MAXANG,IND,INDSH,INDSAO,IRAF,IORA,
     *          ID_HDERMO,ID_SDERMO,ID_SDERAO,IDW,X(LINDEX),
     *          NVECTMP,NOCCMAX,X(LINDVEC),
     *          SCC,DISK,FON,ROHF,SRSCC,UHF,DIRECT,ISGDDI,MASWRK,SOME,
     *          PARALL3)
            END IF
            IF (DISK) THEN
              IRA1 = IRA1 + 3
              IRA2 = IRA2 + 3
              IRA3 = IRA3 + 3
              IRA4 = IRA4 + 3
              IRA5 = IRA5 + 3
            END IF
            CYCLE
          END IF
          IF (.NOT.DISK) THEN
            CALL DDI_GET_COMM(ID_HDERMO,1,L2*3*NSPIN,NI,NI,HDERIJ,IDW)
            CALL DDI_GET_COMM(ID_SDERMO,1,L2*3*NSPIN,NI,NI,SDERIJ,IDW)
            IF (SCC) CALL DDI_GET_COMM(ID_SDERAO,1,L2*3,NI,NI,SDER,IDW)
          END IF
        END IF
        DO KI = 1, 3
          IF (BUNDLE) THEN
            NVECTMP = NVECTMP + 1
            IF (PARALL3.AND.MOD(NVECTMP,NPROC).EQ.ME) NVCP = NVCP + 1
          END IF
C---      call cpu_time(t0)
C        write (*,*) "ki = ", ki
C        write (*,*) "disk = ", disk
          IF (DIRECT) THEN
            CALL DFTB_HESS_DIRECT(X(LHDERIJ),X(LSDERIJ),X(LSDER),C,
     *        VEC,SHIFT,SHIFTSA,SHIFTSB,X(LWRK),X(LWRK1),X(LWRK2),
     *        X(LWRK3),NI,KI,NAT,L0,L1,L2,IND,NSHELL,NSPE,NSPIN,INDSH,
     *        INDSAO,ISPE,MAXANG,SCC,SRSCC,UHF)
          ELSE IF (DISK) THEN
            IF (BUNDLE) THEN
              IF (PARALL3.AND.MOD(NVECTMP,NPROC).EQ.ME) THEN
                CALL IXSTOR(X(LINDVEC+NVCP-1),1,
     *            3*(NI-1)+KI-(3*(NITMP-1)+KITMP)+1)
              ELSE IF (ISGDDI.AND..NOT.PARALL3) THEN
                CALL IXSTOR(X(LINDVEC+NVECTMP-1),1,
     *            3*(NI-1)+KI-(3*(NITMP-1)+KITMP)-NVECTMP+1)
              END IF
            END IF
            IRA1 = IRA1 + 1
            IRA2 = IRA2 + 1
            IRA3 = IRA3 + 1
            IRA4 = IRA4 + 1
            IRA5 = IRA5 + 1
            CALL RAREAD(IRAF,IORA,X(LHDERIJ),L2,IRA1,0)
            CALL RAREAD(IRAF,IORA,X(LSDERIJ),L2,IRA2,0)
            IF (SCC) THEN
              CALL RAREAD(IRAF,IORA,X(LSDER),L2,IRA3,0)
              IF (UHF) THEN
                CALL RAREAD(IRAF,IORA,X(LHDERIJ+L2),L2,IRA4,0)
                CALL RAREAD(IRAF,IORA,X(LSDERIJ+L2),L2,IRA5,0)
              END IF
            END IF
C               write (iw,'(2i10,A)') me,ixftch(x(lindvec+nvcp-1),1),"a"
          ELSE IF (ISGDDI) THEN
            IF (BUNDLE) THEN
              IF (PARALL3.AND.MOD(NVECTMP,NPROC).EQ.ME) THEN
                CALL IXSTOR(X(LINDVEC+NVCP-1),1,
     *               3*(NI-1)+KI-(3*(NITMP-1)+KITMP)+1)
C               CALL IXSTOR(X(LINDVEC+NVCP-1),1,
C    *               3*(NI-1)+KI-(3*(NITMP-1)+KITMP)-NVECTMP+1)
              ELSE IF (.NOT.PARALL3) THEN
                CALL IXSTOR(X(LINDVEC+NVECTMP-1),1,
     *               3*(NI-1)+KI-(3*(NITMP-1)+KITMP)-NVECTMP+1)
              END IF
            END IF
            CALL DCOPY(L2,HDERIJ(1,KI,1,1),1,X(LHDERIJ),1)
            CALL DCOPY(L2,SDERIJ(1,KI,1,1),1,X(LSDERIJ),1)
            IF (SCC) THEN
              CALL DCOPY(L2,SDER(1,KI,1),1,X(LSDER),1)
              IF (UHF) THEN
                CALL DCOPY(L2,HDERIJ(1,KI,2,1),1,X(LHDERIJ+L2),1)
                CALL DCOPY(L2,SDERIJ(1,KI,2,1),1,X(LSDERIJ+L2),1)
              END IF
            END IF
          ELSE
            IF (BUNDLE) THEN
              IF (PARALL3.AND.MOD(NVECTMP,NPROC).EQ.ME) THEN
                CALL IXSTOR(X(LINDVEC+NVCP-1),1,
     *               3*(NI-1)+KI-(3*(NITMP-1)+KITMP)+1)
              ELSE IF (.NOT.PARALL3) THEN
                CALL IXSTOR(X(LINDVEC+NVECTMP-1),1,
     *               3*(NI-1)+KI-(3*(NITMP-1)+KITMP)-NVECTMP+1)
              END IF
            END IF
            CALL DCOPY(L2,HDERIJ(1,KI,NI,1),1,X(LHDERIJ),1)
            CALL DCOPY(L2,SDERIJ(1,KI,NI,1),1,X(LSDERIJ),1)
            IF (SCC) THEN
              CALL DCOPY(L2,SDER(1,KI,NI),1,X(LSDER),1)
              IF (UHF) THEN
                CALL DCOPY(L2,HDERIJ(1,KI,NI,2),1,X(LHDERIJ+L2),1)
                CALL DCOPY(L2,SDERIJ(1,KI,NI,2),1,X(LSDERIJ+L2),1)
              END IF
            END IF
          END IF
C           call prtril (x(lhderij),l1)
C           call prtril (x(lsderij),l1)
C           call prtril (x(lsder),l1)
C         write (*,*) "ni,ki = ", ni,ki
C         write (*,*) "hderij"
C         call prtril(x(lhderij),l1)
C         write (*,*) "sderij"
C         call prtril(x(lsderij),l1)
C         write (*,*) "sder"
C         call prtril(x(lsder),l1)
CD        call cpu_time(ti)
C
C         CALCULATE GAMDER_SHIFT FIRST
C
          IF (SCC) THEN
            IF (SRSCC) THEN
              CALL DFTB_CALC_DERSHIFT_SHELL(NAT,NI,KI,C,DISTMAT,GAMDER,
     *          GAMDER3,CHAMULS,X(LDSH),DFTB3,NSHELL,INDSH,NSPE,ISPE,
     *          MAXANG,CHAMUL)
              !! LWRK = LDERSH (OLD)
            ELSE
              CALL DFTB_CALC_DERSHIFT(NAT,NI,KI,C,DISTMAT,GAMDER,
     *          GAMDER3,CHAMUL,X(LDSH),DFTB3)
            END IF
C
            IF (IPCM.NE.0.OR.NFMOPCM.GT.0) THEN
              CALL VCLR(X(LPCMTMP),1,NTS)
              CALL VCLR(X(LWRK),1,NAT)
              !! explicit term 2
              !! also prepare implicit term 2-a
              CALL DFTB_HESS_PCM1(NAT,NI,KI,NTS,C,X(LAXYZCT),
     *             X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),X(LQSE),X(LWRK),
     *             CHAMUL,X(LPCMTMP),X(LISPHE))
              !! implicit term 1 
              IF (SAVDCQ) THEN
                CALL DAXPY(NTS,ONE,X(LDCDAQ+3*NTS*(NI-1)+NTS*(KI-1)),
     *                     1,X(LPCMTMP),1)
              ELSE
                CALL DFTB_CALC_DCDA(NTS,NI,KI,X(LAXYZCT),
     *               X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),
     *               X(LAXYZCT+MXTS*3),X(LISPHE),
     *               X(LEPSPCM),X(LIDDAI),X(LDAI),X(LQSE),X(LPCMTMP))
              END IF
              CALL INDQPROD(1,NTSPAR,LFPNT,NDASC,X(LPCMTMP),
     *                      X(LQTMP),X(LQTMP),1)
              CALL DCOPY(NTS,X(LQTMP),1,X(LQSEDER),1)
              IF (SRSCC) THEN
                CALL DFTB_QSHIFT(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *               X(LAXYZCT+MXTS*2),X(LQTMP),X(LWRK))
                CALL DFTB_SHIFT_ATOSH(X(LWRK),X(LWRK1),NAT,
     *               NSHELL,NSPE,ISPE,MAXANG)
                CALL DAXPY(NSHELL,ONE,X(LWRK1),1,X(LDSH),1)
              ELSE
                CALL DFTB_QSHIFT(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *               X(LAXYZCT+MXTS*2),X(LQTMP),X(LWRK))
                CALL DAXPY(NAT,ONE,X(LWRK),1,X(LDSH),1)
              END IF
            END IF
C
            IF (SRSCC) THEN
              CALL SHIFT_TRIANGLE_SHELL(X(LDSH),S,X(LWRK),NAT,NSPE,
     *          NSHELL,L2,ISPE,MAXANG)
            ELSE
              CALL SHIFT_TRIANGLE(NAT,L2,IND,X(LDSH),S,X(LWRK))
            END IF
CD          call cpu_time(ttftri0)
            DO ISPIN = 1, NSPIN
              CALL DFTB_TFTRI0(NDOCC(ISPIN),NPART(ISPIN),
     *          X(LSOMGDIJ+L2*(ISPIN-1)),X(LWRK),VEC(1,1,ISPIN),
     *          X(LWRK1),L0,L1,L1)
            END DO
            !! X(LSOMGDIJ) = H_{IJ}^a + non-response d(Omega)/da*S_{IJ}
            CALL VADD(X(LSOMGDIJ),1,X(LHDERIJ),1,X(LSOMGDIJ),1,L2*NSPIN)
CD          call cpu_time(ttftri1)
CD          tttftri = tttftri + ttftri1-ttftri0
C
C         CALCULATE NON-RESEPONT TERMS FOR QDER
C
            IF (SRSCC.OR.UHF) THEN
              DO ISPIN = 1, NSPIN
                CALL DFTB_PREP_QDER(NDIMSH,L0,L1,L2,
     *            INDSAO,X(LQDER_INIT+NDIMSH*(ISPIN-1)),
     *            D(1,ISPIN),X(LDTMP+L2*(ISPIN-1)),S,X(LSDER),X(LWRK),
     *            X(LWRK1),X(LWRK2),X(LWRK3),UHF,FON(3),REDUCE)
              END DO
C             CALL DCOPY(NDIMSH,X(LQDER_INIT),1,X(LWRK),1)
C             CALL DFTB_SHIFT_SHTOA(X(LWRK),X(LWRK2),NAT,NSHELL,NSPE,
C    *          ISPE,MAXANG)
C             CALL DFTB_SHIFT_SHTOA(X(Lqder_init+ndimsh),X(LWRK3),NAT,
C    *          NSHELL,NSPE,ISPE,MAXANG)
C             call
C    *        vadd(x(lwrk),1,x(lqder_init+ndimsh),1,x(lwrk),1,ndimsh)
C             CALL DFTB_SHIFT_SHTOA(X(LWRK),X(LWRK1),NAT,NSHELL,NSPE,
C    *          ISPE,MAXANG)
C           write (*,*) "QDER_INIT"
C           do i = 1, ndimsh
C             tmp = x(lqder_init+i-1)
C             if (uhf) tmp = tmp + x(lqder_init+i-1+ndimsh)
C             write (*,'(i3,x,f20.10)') i,tmp
C           end do
C           do i = 1, nat
C             tmp = x(lwrk1+i-1)
C             tmp2 = x(lwrk2+i-1)
C             tmp3 = x(lwrk3+i-1)
C             write (*,'(i3,3(x,f20.10))') i,tmp,tmp2,tmp3
C           end do
            ELSE
              CALL DFTB_PREP_QDER(NAT,L0,L1,L2,IND,
     *          X(LQDER_INIT),D,X(LDTMP),S,X(LSDER),X(LWRK),X(LWRK1),
     *          X(LWRK2),X(LWRK3),UHF,FON(3),REDUCE)
C           write (iw,*) "QDER_INIT"
C           do i = 1, ndimsh
C             tmp = x(lqder_init+i-1)
C             if (uhf) tmp = tmp + x(lqder_init+i-1+ndimsh)
C             write (iw,'(i3,x,f20.10)') i,tmp
C           end do
            END IF
          ELSE
C           CALL VCLR(X(LSOMGDIJ),1,L2)
            CALL DCOPY(L2,X(LHDERIJ),1,X(LSOMGDIJ),1)
          END IF
CD        call cpu_time(tq)
C
C         CALCULATE NON-RESEPONT TERMS
C
          DO ISPIN = 1, NSPIN
C           WRITE (*,*) "UINIT OF ISPIN = ", ispin
            CALL DFTB_CP_NR(L1,L2,NDOCC(ISPIN),NPART(ISPIN),
     *        EIG(1,ISPIN),OCC(1,ISPIN),UINIT(1,1,ISPIN),
     *        X(LSOMGDIJ+L2*(ISPIN-1)),X(LSDERIJ+L2*(ISPIN-1)),
     *        BETA,EFERMI,DEGTHR1,DEGTHR2)
            IF(NFG.NE.0) THEN
              IFG = icurfg
              JFG = jcurfg
              KFG = kcurfg
c             write(6,'("ICHK=",I3)') NDOCC(1)
              CALL FMOESP_CP_DFTB(NI,KI,UINIT,L1,L2,IFG,JFG,KFG,
     *             X(LSDER), S,VEC,EIG,CHAMUL,SAVGOP)
            END IF
C           write (*,*) "hderij"
C           call prtril(x(lhderij),l1)
C           write (*,*) "sderij"
C           call prtril(x(lsderij),l1)
C           write (*,*) "lsomgdij"
C           call prtril(x(lsomgdij),l1)
C      write (iw,*) "Ki, ni = ", ki, ni
C      call prsq(uinit(1,1,ispin),l1,l1,l1)
          END DO
          CALL DCOPY(L1*L1*NSPIN,UINIT,1,U,1)
CD        call cpu_time(tnr)
C
C         PREPARE FOR DE/DR CALCULATION
C
CD        call cpu_time(fon0)
          IF (FON(3).AND..NOT.ROHF) THEN
          !! X(LHDERIJ) IS DUMMY
            CALL DFTB_CALC_DNDR(0,L1,L2,NDOCC(1),NPART(1),ETEMP,
     *        X(LDEDB_INIT),X(LDEDB),X(LDNDR),OCC,EIG,X(LSOMGDIJ),
     *        X(LSDERIJ),X(LHDERIJ),FEDER,SCC)
          END IF
CD        call cpu_time(fon1)
          IF (.NOT.SCC)  then
CD          t1 = zero
CD          t3 = zero
CD          t4 = zero
CD          t5 = zero
CD          t45 = zero
            IF (FON(3).AND..NOT.ROHF) THEN
                CALL DFTB_CALC_DNDR(1,L1,L2,NDOCC(1),NPART(1),ETEMP,
     *            X(LDEDB_INIT),X(LDEDB),X(LDNDR),OCC,EIG,X(LHDERIJ),
     *            X(LSDERIJ),X(LSDSHIJ),FEDER,SCC)
            END IF
            GO TO 100
          END IF
C
C         START CP-DFTB ITERATION
C
          MEMMIX = 0
CD        call cpu_time(t1)
          CALL DCOPY(NDIMSH*NSPIN,X(LQDER_INIT),1,X(LQDER_PREV),1)
          DO ITER = 1, MXITER
            VMAX = ZERO
CD          VMXT = ZERO
CD          call cpu_time(qder0)
            IF (REDUCE) THEN
              DO ISPIN = 1, NSPIN
                CALL DFTB_CALC_QDER_REDUCE(NAT,L1,IND,NDOCC(ISPIN),
     *          NPART(ISPIN),X(LQDER+NDIMSH*(ISPIN-1)),
     *          U(1,1,ISPIN),OCC(1,ISPIN),
     *          X(LQDER_INIT+NDIMSH*(ISPIN-1)),
     *          X(LRESPONSE+L1*L1*(ISPIN-1)),X(LDNDR+L1*(ISPIN-1)),
     *          VEC(1,1,ISPIN),FON(ISPIN),SRSCC,NSPE,
     *          ISPE,MAXANG,NSHELL,X(LWRK),X(LWRK1))
              END DO
            ELSE
              DO ISPIN = 1, NSPIN
                CALL DFTB_CALC_QDER(NAT,L1,NDOCC(ISPIN),NPART(ISPIN),
     *            NVIRT(ISPIN),X(LQDER+NDIMSH*(ISPIN-1)),U(1,1,ISPIN),
     *            OCC(1,ISPIN),X(LQDER_INIT+NDIMSH*(ISPIN-1)),
     *            X(LRESPONSE),X(LDNDR+L1*(ISPIN-1)),FON(ISPIN),NSPIN,
     *            SRSCC,UHF,NDIMSH,NSPE,ISPE,MAXANG,ISPIN,X(LWRK))
              END DO
            END IF
C           if (iter.eq.1) then
CD          call cpu_time(qder1)
CD          ttqder = ttqder + qder1-qder0
C
C           CALCULATE CHANGE OF QDER FROM PREVIOUS ITERATION
C
CD          call cpu_time(br0)
            N = 0
            DO ISPIN = 1, NSPIN
              DO I = 1, NDIMSH
                N = N + 1
                TMP = ABS(X(LQDER+N-1)-X(LQDER_PREV+N-1))
                VMAX = MAX(VMAX,TMP)
              END DO
            END DO
C
C           BROYDEN MIXING FOR QDER
C
            CALL DFTB_MIX_BROYDEN(ITER,NDIMSH*NSPIN,MXITER,MEMMIX,
     *        ALPHA,X(LQDER_PREV),X(LQDER),ERDIIS)
            CALL DCOPY(NDIMSH*NSPIN,X(LQDER),1,X(LQDER_PREV),1)
CD          call cpu_time(br1)
CD          ttbr = ttbr + br1-br0
C
            CALL DCOPY(NDIMSH,X(LQDER),1,X(LWRK),1)
            IF (UHF) THEN
              CALL VADD(X(LWRK),1,X(LQDER+NDIMSH),1,X(LWRK),1,NDIMSH)
              IF (.NOT.SRSCC) THEN
                CALL DFTB_SHIFT_SHTOA(X(LWRK),X(LWRK1),NAT,NSHELL,NSPE,
     *            ISPE,MAXANG)
                CALL DCOPY(NAT,X(LWRK1),1,X(LWRK),1)
              END IF
            END IF
C
            CALL VCLR(X(LDERSHIFT),1,NGAMMA)
            DO NN = 1, NGAMMA
              DO NC = 1, NGAMMA
                CALL DFTB_CNVSQ(NN,NC,NSEQ)
                X(LDERSHIFT+NN-1)
     *            = X(LDERSHIFT+NN-1) + GAMMA(NSEQ)*X(LWRK+NC-1)
              END DO
            END DO
C
            IF (DFTB3) THEN
              IF (SRSCC) THEN
                !! GENERATE ATOM-RESOLVED MULLIKEN DER.
                CALL DCOPY(NDIMSH,X(LQDER),1,X(LWRK1),1)
                IF (UHF) THEN
                  CALL DAXPY(NDIMSH,ONE,X(LQDER+NDIMSH),1,X(LWRK1),1)
                END IF
                CALL DFTB_SHIFT_SHTOA(X(LWRK1),X(LWRK+NSHELL+1),NAT,
     *            NSHELL,NSPE,ISPE,MAXANG)
C
                ISH0 = 0
                DO I = 1, NAT
                  JSH0 = 0
                  DERMULI = X(LWRK+NSHELL+ I)
                  DO J = 1, NAT
                    DERMULJ = X(LWRK+NSHELL+ J)
                    DO II = 1, MAXANG(ISPE(I))
                      ISH = ISH0 + II
C                     DERSHLI = X(LWRK+ISH-1)
                      DO JJ = 1, MAXANG(ISPE(J))
                        JSH = JSH0 + JJ
                        DERSHLJ = X(LWRK+JSH-1)
                        X(LDERSHIFT+ISH-1) = X(LDERSHIFT+ISH-1)
     *                    + ONE_THIRD*
     *                     (DERMULI*CHAMULS(JSH)*GAMMA3(ISH,JSH)
     *                    + DERSHLJ*CHAMUL(I)   *GAMMA3(ISH,JSH)
     *                    + DERMULJ*CHAMULS(JSH)*GAMMA3(JSH,ISH)
     *                    + DERSHLJ*CHAMUL(J)   *GAMMA3(JSH,ISH))
                        DO KK = 1, MAXANG(ISPE(I))
                          KSH = ISH0 + KK
                          DERSHLK = X(LWRK+KSH-1)
                          X(LDERSHIFT+ISH-1) = X(LDERSHIFT+ISH-1)
     *                      + ONE_THIRD*
     *                       (DERSHLK*CHAMULS(JSH)*GAMMA3(KSH,JSH)
     *                      + DERSHLJ*CHAMULS(KSH)*GAMMA3(KSH,JSH))
                        END DO
                      END DO
                    END DO
                    JSH0 = JSH0 + MAXANG(ISPE(J))
                  END DO
                  ISH0 = ISH0 + MAXANG(ISPE(I))
                END DO
              ELSE
                DO NN = 1, NGAMMA
                  DO NC = 1, NGAMMA
                    X(LDERSHIFT+NN-1) = X(LDERSHIFT+NN-1) + TWO*(
     *               + ONE_THIRD*GAMMA3(NN,NC)*CHAMUL(NN)*X(LWRK+NC-1)
     *               + ONE_THIRD*GAMMA3(NC,NN)*CHAMUL(NC)*X(LWRK+NC-1)
     *               + ONE_THIRD*GAMMA3(NN,NC)*CHAMUL(NC)*X(LWRK+NN-1))
                  END DO
                END DO
              END IF
              IF (NFG.NE.0) THEN
                DO NN = 1, NGAMMA !! NAT
                  X(LDERSHIFT+NN-1) = X(LDERSHIFT+NN-1)
     *             + TWO*X(LSHIFT3+NN-1)*X(LWRK+NN-1)
                END DO
              END IF
            END IF
C
C           ----- CALCULATE CHARGES INDUCED BY MULLIKEN DER. -----
C           START INDQPROD WITH ITER+1, BECAUSE WE ALREADY HAVE
C           AN INITIAL GUESS WITHOUT ASCS INDUCED BY MULLIKEN
C           DERIVATIVES
C
            IF (IPCM.NE.0.OR.NFMOPCM.GT.0) THEN
              !! implicit term 2-b
              !! use dq/da (X(LWRK))
              IF (SRSCC.OR.UHF) THEN
                !! Convert shell-resolved X(LWRK) to atom-resolved
                CALL DCOPY(NDIMSH,X(LQDER),1,X(LWRK1),1)
                IF (UHF) THEN
                  CALL DAXPY(NDIMSH,ONE,X(LQDER+NDIMSH),1,X(LWRK1),1)
                END IF
                CALL DFTB_SHIFT_SHTOA(X(LWRK1),X(LWRK),NAT,NSHELL,NSPE,
     *            ISPE,MAXANG)
              END IF
              CALL DFTB_QPOTEN(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *                         X(LAXYZCT+MXTS*2),X(LWRK),X(LEPOT))
              CALL INDQPROD(ITER+1,NTSPAR,LFPNT,NDASC,X(LEPOT),
     *                      X(LQSEDER),X(LQSEDER),1)
C             CALL DFTB_QSHIFT(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
C    *             X(LAXYZCT+MXTS*2),X(LQSEDER),X(LDERSHIFT))
              IF (SRSCC) THEN
                CALL VCLR(X(LWRK1),1,NAT)
                CALL DFTB_QSHIFT(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *               X(LAXYZCT+MXTS*2),X(LQSEDER),X(LWRK1))
                CALL DFTB_SHIFT_ATOSH(X(LWRK1),X(LWRK2),NAT,NSHELL,
     *               NSPE,ISPE,MAXANG)
                CALL DAXPY(NGAMMA,ONE,X(LWRK2),1,X(LDERSHIFT),1)
              ELSE
                CALL DFTB_QSHIFT(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *               X(LAXYZCT+MXTS*2),X(LQSEDER),X(LDERSHIFT))
              END IF
            END IF
C
C           CONVERT ATOM-RESOLVED SHIFT TO SHELL-RESOLVED SHIFT,
C           AND CALCULATE SPIN CONTRIBUTION
C
            IF (UHF) THEN
              IF (.NOT.SRSCC) THEN
                CALL DCOPY(NAT,X(LDERSHIFT),1,X(LWRK),1)
                CALL DFTB_SHIFT_ATOSH(X(LWRK),X(LDERSHIFT),NAT,NSHELL,
     *            NSPE,ISPE,MAXANG)
              END IF
C             FORM d(q^a-q^b)/dR (DERIVATIVE OF SPIN DENSITY) AS X(LWRK)
              CALL DCOPY(NSHELL,X(LQDER),1,X(LWRK),1)
              CALL VSUB(X(LQDER+NDIMSH),1,X(LWRK),1,
     *          X(LWRK),1,NSHELL)
C
              CALL VCLR(X(LSHIFTSP),1,NDIMSH)
              CALL DFTB_SPIN_SHIFT(X(LSHIFTSP),X(LWRK),SPNCST,NAT,
     *          NSHELL,NSPE,ISPE,MAXANG)
              CALL DCOPY(NDIMSH,X(LDERSHIFT),1,X(LWRK1),1)
            END IF
C
C           CALCULATE RESPONSE PART OF S*d(OMEGA)/dR AS SDSHIJ
C
            IF (KI.EQ.1) CALL VCLR(X(LSDEROMG),1,L2)
            DO ISPIN = 1, NSPIN
              IF (SRSCC.OR.UHF) THEN
                IF (UHF) THEN
                  IF (ISPIN.EQ.1) THEN
                   CALL VADD(X(LSHIFTSP),1,X(LDERSHIFT),1,X(LDERSHIFT),
     *               1,NDIMSH)
                  ELSE
                    CALL DCOPY(NDIMSH,X(LWRK1),1,X(LDERSHIFT),1)
                    CALL VSUB(X(LSHIFTSP),1,X(LDERSHIFT),1,X(LDERSHIFT),
     *                1,NDIMSH)
                  END IF
                END IF
                CALL SHIFT_TRIANGLE_SHELL(X(LDERSHIFT),S,X(LSDEROMG),
     *            NAT,NSPE,NSHELL,L2,ISPE,MAXANG)
              ELSE
               CALL SHIFT_TRIANGLE(NAT,L2,IND,X(LDERSHIFT),S,
     *           X(LSDEROMG))
              END IF
CD            call cpu_time(ttftri0)
              CALL DFTB_TFTRI0(NDOCC(ISPIN),NPART(ISPIN),X(LSDSHIJ),
     *          X(LSDEROMG),VEC(1,1,ISPIN),X(LWRK),L0,L1,L1)
CD            call cpu_time(ttftri1)
CD            tttftri = tttftri + ttftri1-ttftri0
CD            ttittftri = ttittftri + ttftri1-ttftri0
C
C             UPDATE de/dR, de_F/dR, and dn/dR VECTORS
C
CD            call cpu_time(fon2)
              IF (FON(3).AND..NOT.ROHF) THEN
                  CALL DFTB_CALC_DNDR(1,L1,L2,NDOCC(1),NPART(1),ETEMP,
     *              X(LDEDB_INIT),X(LDEDB),X(LDNDR),OCC,EIG,
     *              X(LHDERIJ),X(LSDERIJ),X(LSDSHIJ),FEDER,SCC)
              END IF
C             CALL VCLR(X(LDNDR),1,L1)
C             IF (NI.EQ.1.AND.KI.EQ.1.AND.ITER.EQ.1) THEN
C               WRITE (IW,'(//"ZERO OUT DNDR MATRIX !!"//)')
C             END IF
CD            call cpu_time(fon3)
C
C             CONSTRUCT NEW U MATRIX
C
CD            call cpu_time(u0)
              CALL DFTB_HESS_UUPDATE(0,U(1,1,ISPIN),UINIT(1,1,ISPIN),
     *          X(LSDSHIJ),EIG(1,ISPIN),OCC(1,ISPIN),L1,L2,NDOCC(ISPIN),
     *          NPART(ISPIN),BETA,EFERMI,DEGTHR1,DEGTHR2)
CD            call cpu_time(u1)
CD            ttu = ttu + u1-u0
            END DO !! END OF SPIN LOOP
C           WRITE (*,'(I3,x,F20.10)') iter,vmax
            IF (ITER.GE.2.AND.VMAX.LE.THRES) THEN
             NITER = NITER + ITER
C             WRITE (*,'(" ROOT",I3," - ",I1," CONVERGED IN", I3,
C    *          " CYCLES: DELTA Q_DER = ",E10.3)') NI,KI,ITER,VMAX
              EXIT
            END IF
          END DO !! END OF CP ITERATION
C         WRITE (*,*) "U MATRIX"
C         CALL PRSQ(U,L1,L1,L1)
C         WRITE (*,*)
C         WRITE (*,*) "SDER MATRIX"
C         CALL PRTRIL(X(LSDERIJ),L1)
C         WRITE (*,*)
C         WRITE (*,*) "DEGENERATED ORBITALS"
C         DO IO = 1, L1
C           DO JO = IO+1, L1
C             IF (ABS(EIG(IO)-EIG(JO)).LE.1.0D-06) THEN
C               CALL DFTB_CNVSQ(IO,JO,NSEQ)
C               WRITE (*,'(I3,X,I3,4(X,F20.10))')
C    *            IO,JO,U(IO,JO),U(JO,IO),U(IO,JO)+U(JO,IO),
C    *            X(LSDERIJ+NSEQ-1)
C             END IF
C           END DO
C         END DO
          CALL RETFM(MEMMIX)
C
C         FOR UHF CALCULATION:
C         QDER(1,1) :: TOTAL CHARGE DERIVATIVE
C         QDER(1,2) :: SPIN DERIVATIVE
C
          IF (UHF) THEN
            CALL DCOPY(NDIMSH,X(LQDER),1,X(LWRK),1)
            CALL VADD(X(LQDER+NDIMSH),1,X(LQDER),1,X(LQDER),1,NDIMSH)
            CALL DSCAL(NDIMSH,-ONE,X(LQDER+NDIMSH),1)
            CALL VADD(X(LWRK),1,X(LQDER+NDIMSH),1,
     *        X(LQDER+NDIMSH),1,NDIMSH)
          END IF
C
C         CALCULATE d(OMEGA)/dR
C         d(OMEGA)/dR IS SYMMETRIC
C
          IF (UHF.AND..NOT.SRSCC) THEN
            CALL DCOPY(NDIMSH,X(LQDER),1,X(LWRK),1)
            CALL DFTB_SHIFT_SHTOA(X(LWRK),
     *        X(LQDER),NAT,NSHELL,NSPE,ISPE,MAXANG)
          END IF
CD        call cpu_time(t2)
          DO NM = 1, NGAMMA
            TMP1 = X(LDSH+NM-1)
            TMP2 = ZERO
            DO NC = 1, NGAMMA
              CALL DFTB_CNVSQ(NM,NC,NSEQ)
              TMP2 = TMP2 + GAMMA(NSEQ)*X(LQDER+NC-1)
            END DO
            X(LDOMEGA+NM-1) = TMP1 + TMP2
          END DO
C
          IF (DFTB3) THEN
            IF (SRSCC) THEN
              CALL DCOPY(NDIMSH,X(LQDER),1,X(LWRK1),1)
              CALL DFTB_SHIFT_SHTOA(X(LWRK1),X(LWRK+NSHELL+1),NAT,
     *          NSHELL,NSPE,ISPE,MAXANG)
C
              ISH0 = 0
              DO I = 1, NAT
                JSH0 = 0
                DERMULI = X(LWRK+NSHELL+ I)
                DO J = 1, NAT
                  DERMULJ = X(LWRK+NSHELL+ J)
                  DO II = 1, MAXANG(ISPE(I))
                    ISH = ISH0 + II
C                   DERSHLI = X(LQDER+ISH-1)
                    DO JJ = 1, MAXANG(ISPE(J))
                      JSH = JSH0 + JJ
                      DERSHLJ = X(LQDER+JSH-1)
                      X(LDOMEGA+ISH-1) = X(LDOMEGA+ISH-1)
     *                  + ONE_THIRD*
     *                   (DERMULI*CHAMULS(JSH)*GAMMA3(ISH,JSH)
     *                  + DERSHLJ*CHAMUL(I)   *GAMMA3(ISH,JSH)
     *                  + DERMULJ*CHAMULS(JSH)*GAMMA3(JSH,ISH)
     *                  + DERSHLJ*CHAMUL(J)   *GAMMA3(JSH,ISH))
                      DO KK = 1, MAXANG(ISPE(I))
                        KSH = ISH0 + KK
                        DERSHLK = X(LQDER+KSH-1)
                        X(LDOMEGA+ISH-1) = X(LDOMEGA+ISH-1)
     *                    + ONE_THIRD*
     *                     (DERSHLK*CHAMULS(JSH)*GAMMA3(KSH,JSH)
     *                    + DERSHLJ*CHAMULS(KSH)*GAMMA3(KSH,JSH))
                      END DO
                    END DO
                  END DO
                  JSH0 = JSH0 + MAXANG(ISPE(J))
                END DO
                ISH0 = ISH0 + MAXANG(ISPE(I))
              END DO
            ELSE
              DO NN = 1, NAT
                DO NC = 1, NAT
                  X(LDOMEGA+NN-1) = X(LDOMEGA+NN-1) + TWO*(
     *             + ONE_THIRD*GAMMA3(NN,NC)*CHAMUL(NN)*X(LQDER+NC-1)
     *             + ONE_THIRD*GAMMA3(NC,NN)*CHAMUL(NC)*X(LQDER+NC-1)
     *             + ONE_THIRD*GAMMA3(NN,NC)*CHAMUL(NC)*X(LQDER+NN-1))
                END DO
              END DO
            END IF
          END IF
C         WRITE (*,*) "x(ldomega)"
C         DO IO = 1, NDIMSH
C           WRITE (*,'(I3,1(X,F20.10))') IO,X(LDOMEGA+IO-1)
C         END DO
C
C         ----- PCM CONTRIBUTIONS -----
C         QSEDER HAS ASC INDUCED BY MULLIKEN DERIVATIVE.
C         SHIFT CONTRIBUTIONS OTHER THAN QSEDER HAVE BEEN ADDED AS
C         X(LDSH) ABOVE, SO SHIFT HERE IS DONE BEFORE FORMING TRUE
C         QSEDER (\bar{q}^a)
C
          IF (IPCM.NE.0.OR.NFMOPCM.GT.0) THEN
            IF (SRSCC) THEN
              CALL VCLR(X(LWRK),1,NAT)
              CALL DFTB_QSHIFT(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *             X(LAXYZCT+MXTS*2),X(LQSEDER),X(LWRK))
              CALL DFTB_SHIFT_ATOSH(X(LWRK),X(LWRK1),NAT,NSHELL,NSPE,
     *             ISPE,MAXANG)
              CALL DAXPY(NSHELL,ONE,X(LWRK1),1,X(LDOMEGA),1)
            ELSE
              CALL DFTB_QSHIFT(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *             X(LAXYZCT+MXTS*2),X(LQSEDER),X(LDOMEGA))
            END IF
            CALL DAXPY(NTS,ONE,X(LQTMP),1,X(LQSEDER),1)
            !! THIS X(LQSEDER) IS TRUE \bar{q}^a
          END IF
C
          IF (UHF) THEN
            IF (.NOT.SRSCC) THEN
              CALL DCOPY(NAT,X(LDOMEGA),1,X(LWRK),1)
              CALL DFTB_SHIFT_ATOSH(X(LWRK),X(LDOMEGA),NAT,NSHELL,NSPE,
     *          ISPE,MAXANG)
            END IF
            CALL VCLR(X(LSHIFTSP),1,NDIMSH)
            CALL DFTB_SPIN_SHIFT(X(LSHIFTSP),X(LQDER+NDIMSH),SPNCST,NAT,
     *        NSHELL,NSPE,ISPE,MAXANG)
            CALL DCOPY(NSHELL,X(LDOMEGA),1,X(LDOMEGA+NSHELL),1)
            CALL VADD(X(LSHIFTSP),1,X(LDOMEGA),1,X(LDOMEGA),1,NSHELL)
            CALL VSUB(X(LSHIFTSP),1,X(LDOMEGA+NSHELL),1,
     *        X(LDOMEGA+NSHELL),1,NSHELL)
          END IF
C
C         WE HAVE OBTAINED U MATRIX AND QDER NOW.
C
C         ADD QDER HESSIAN TERMS
C
CD        call cpu_time(t3)
          IF (SRSCC) THEN
            !! CONVERT FROM SHELL-RESOLVED TO ATOM-RESOLVED QDER
            CALL DFTB_SHIFT_SHTOA(X(LQDER),X(LWRK),NAT,NSHELL,NSPE,
     *        ISPE,MAXANG)
            CALL DFTB_QDER(NI,KI,NAT,C,X(LQDER),GAMDER,GAMDER3,
     *        CHAMULS,DISTMAT,HESSIAN,DFTB3,SRSCC,NDIMSH,NSPE,ISPE,
     *        MAXANG,IPCM.NE.0.OR.NFMOPCM.GT.0,X(LWRK),CHAMUL,NGAMMA)
            CALL DCOPY(NAT,X(LWRK),1,X(LQDER),1)
          ELSE
            CALL DFTB_QDER(NI,KI,NAT,C,X(LQDER),GAMDER,GAMDER3,
     *        CHAMUL,DISTMAT,HESSIAN,DFTB3,SRSCC,NDIMSH,NSPE,ISPE,
     *        MAXANG,IPCM.NE.0.OR.NFMOPCM.GT.0,X(LQDER),CHAMUL,NGAMMA)
          END IF
CD        call cpu_time(t4)
C
C         d(OMEGA)/dR + d(EIG(IO))/dR TERMS
C
          !! X(LDOMEGA) d(OMEGA)/dR ON ATOM BASIS
          DO ISPIN = 1, NSPIN
            IF (SRSCC.OR.UHF) THEN
              CALL SHIFT_TRIANGLE_SHELL(X(LDOMEGA+NDIMSH*(ISPIN-1)),
     *          S,X(LWRK2),NAT,NSPE,NSHELL,L2,ISPE,MAXANG)
            ELSE
              CALL SHIFT_TRIANGLE(NAT,L2,IND,X(LDOMEGA),S,X(LWRK2))
            END IF
CD          call cpu_time(ttftri0)
            CALL DFTB_TFTRI0(0,NOCC(ISPIN),X(LSOMGDIJ+L2*(ISPIN-1)),
     *        X(LWRK2),VEC(1,1,ISPIN),X(LWRK),L0,L1,L1)
CD          call cpu_time(ttftri1)
CD          tttftri = tttftri + ttftri1-ttftri0
          END DO
          CALL VADD(X(LSOMGDIJ),1,X(LHDERIJ),1,X(LHDERIJ),1,L2*NSPIN)
C
C         ----- ADD PCM CONTRIBUTIONS TO HESSIAN -----
C         LQSE   : ASC INDUCED BY D
C         LQSEDER: dq/da
C
          IF (IPCM.NE.0.OR.NFMOPCM.GT.0) THEN
            CALL DFTB_HESS_PCM2(NAT,NTS,C,X(LAXYZCT),X(LAXYZCT+MXTS),
     *                          X(LAXYZCT+MXTS*2),X(LQSE),X(LQSEDER),
     *                          X(LQDER),CHAMUL,X(LAXYZCT+MXTS*3),
     *                          X(LISPHE),X(LEPSPCM),X(LIDDAI),X(LDAI),
     *                          X(LPCMTMP),HESSIAN(1,3*(NI-1)+KI),
     *                          X(LDCDAQ),SAVDCQ)
          END IF
C
C         ADD U-DEPENDENT TERM AND DE/DB DEPENDENT TERMS
C
  100     CONTINUE
          CALL DFTB_CALC_FDER_DEDB(L1,L2,NSPIN,X(LFDERIJ),X(LDEDB),
     *      X(LHDERIJ),X(LSDERIJ),EIG)
          IF (BUNDLE) THEN
            IF (PARALL3) THEN
              IF (MOD(NVECTMP,NPROC).EQ.ME) THEN
              CALL DFTB_COPY_CPVEC(NVCP,L1,L2,NSPIN,NDIMSH,
     *          NOCCMAX,X(LFDERIJTMP),X(LSDERIJTMP),
     *          X(LUTMP),X(LDOMEGATMP),X(LDNDRTMP),X(LDEDBTMP),
     *          X(LFDERIJ),X(LSDERIJ),U,X(LDOMEGA),X(LDNDR),X(LDEDB),
     *          FON(3),SCC)
              END IF
            ELSE
              CALL DFTB_COPY_CPVEC(NVECTMP,L1,L2,NSPIN,NDIMSH,
     *          NOCCMAX,X(LFDERIJTMP),X(LSDERIJTMP),
     *          X(LUTMP),X(LDOMEGATMP),X(LDNDRTMP),X(LDEDBTMP),
     *          X(LFDERIJ),X(LSDERIJ),U,X(LDOMEGA),X(LDNDR),X(LDEDB),
     *          FON(3),SCC)
            END IF
            IF ((NVECTMP.EQ.NVEC
     *          .OR.(NVCP.EQ.NVEC.AND.MOD(NVECTMP,NPROC).EQ.0))
     *                          .OR.(NI.EQ.NAT.AND.KI.EQ.3)) THEN
              IF (PARALL3) NVECTMP = NVCP
              CALL DFTB_DEDB(HESSIAN(1,3*(NITMP-1)+KITMP),X(LWRK1),
     *          X(LWRK1+L2+1),X(LWRK1+L2*2+1),X(LWRK3),X(LWRK),
     *          X(LFDERIJTMP),X(LDEDBTMP),
     *          HDERIJ,SDERIJ,SDER,X(LUTMP),VEC,D,EIG,OCC,
     *          X(LDNDRTMP),X(LDOMEGATMP),
     *          X(LSDERIJTMP),SHIFT,SHIFTSA,
     *          SHIFTSB,C,FONCON,BETA,EFERMI,DEGTHR1,DEGTHR2,
     *          NAT,L0,L1,L2,NSPIN,NDIMSH,NDOCC,NPART,
     *          NSPE,ISPE,MAXANG,IND,INDSH,INDSAO,IRAF,IORA,
     *          ID_HDERMO,ID_SDERMO,ID_SDERAO,IDW,X(LINDEX),
     *          NVECTMP,NOCCMAX,X(LINDVEC),
     *          SCC,DISK,FON,ROHF,SRSCC,UHF,DIRECT,ISGDDI,MASWRK,SOME,
     *          PARALL3)
              NITMP = NI
              KITMP = KI+1
              IF (KITMP.EQ.4) THEN
                NITMP = NITMP + 1
                KITMP = 1
              END IF
              NVECTMP = 0
              IF (PARALL3) NVCP = 0
            END IF
          ELSE
            IF (PARALL3) THEN
              INDVEC = 1
            ELSE IF (ISGDDI) THEN
              INDVEC = 0
            END IF
            CALL DFTB_DEDB(HESSIAN(1,3*(NI-1)+KI),X(LWRK1),
     *        X(LWRK1+L2+1),X(LWRK1+L2*2+1),X(LWRK3),X(LWRK),
     *        X(LFDERIJ),X(LDEDB),
     *        HDERIJ,SDERIJ,SDER,U(1:L1,1:NOCCMAX,1:NSPIN),VEC,D,EIG,
     *        OCC,X(LDNDR),X(LDOMEGA),
     *        X(LSDERIJ),SHIFT,SHIFTSA,
     *        SHIFTSB,C,FONCON,BETA,EFERMI,DEGTHR1,DEGTHR2,
     *        NAT,L0,L1,L2,NSPIN,NDIMSH,NDOCC,NPART,
     *        NSPE,ISPE,MAXANG,IND,INDSH,INDSAO,IRAF,IORA,
     *        ID_HDERMO,ID_SDERMO,ID_SDERAO,IDW,X(LINDEX),
     *        1,NOCCMAX,INDVEC,
     *        SCC,DISK,FON,ROHF,SRSCC,UHF,DIRECT,ISGDDI,MASWRK,SOME,
     *        PARALL3)
          END IF
C
C         GET U^a (Vir-Occ)
          IF(NFG.NE.0) THEN
            NVOC = NDOCC(1)*(L1-NDOCC(1))
c           WRITE (6,'("CHECK=",I3)') NVOC
            IXYZ = (NI-1)*3 + KI
            LPNT = LYAWRK   + NVOC*(ixyz-1)
            DO ivir=1,L1-NDOCC(1)
              DO jocc=1,NDOCC(1)
                X(LPNT) = U(ivir+NDOCC(1),jocc,1)
                LPNT    = LPNT  + 1
              END DO
            END DO
            LPNT = LYAWRK   + NVOC*NAT*3 + NAT*(ixyz-1)
            CALL DCOPY(NAT,X(LQDER),1,X(LPNT),1)
          END IF
C         WRITE (IW,*) "QDER (ALPHA)"
C         DO IO = 1, NAT
C           WRITE (IW,'(I3,1(X,F20.10))') IO,X(LQDER+IO-1)
C         END DO
C         WRITE (*,*)
C         call abrt
C         WRITE (*,*) "QDER,DEDB,DNDR"
C         DO IO = 1, NAT
C           WRITE (*,'(I3,3(X,F20.10))')
C    *      IO,X(LDEDB+IO-1),X(LDNDR+IO-1),X(LQDER+IO-1)
C         END DO
C         DO IO = NAT+1, L1
C           WRITE (*,'(I3,3(X,F20.10))')
C    *      IO,X(LDEDB+IO-1),X(LDNDR+IO-1),ZERO
C         END DO
C         WRITE (*,'(" CONVERGED DE_F/DR = ",F20.10)') FEDER
CD        call cpu_time(t5)
C
C         CALCULATE QDER IF NCC TO CALCULATE DIPOLE DERIVATIVE
C
          IF (.NOT.SCC) THEN
            IF (FON(3)) THEN
              CALL DFTB_DPART(L1,L2,NDOCC,OCC,X(LDTMP),VEC)
            ELSE
              CALL DCOPY(L2,D,1,X(LDTMP),1)
            END IF
            CALL VCLR(X(LSDER),1,L2)
            !! CALCULATE OVERLAP DERIVATIVE IN AO
            DO NJ = 1, NAT
              IF (NI.EQ.NJ) CYCLE
              CALL DFTB_DISPLACEMENT(NI,NJ,KI,0,V,C,0)
              CALL DFTB_SKODE_HELPA(1,NI,NJ,KI,0,V,AUP,BUP,.FALSE.,
     *          .TRUE.,SKP)
              IF (SKP) CYCLE
              DO L = 1, IND(NJ+1) - IND(NJ)
                O = IND(NJ)+L
                DO M = 1, IND(NI+1) - IND(NI)
                  N = IND(NI)+M
                  CALL DFTB_CNVSQ(N,O,NSEQ)
                  X(LSDER+NSEQ-1) = BUP(M,L)
                END DO
              END DO
            END DO
            CALL DFTB_PREP_QDER(NAT,L0,L1,L2,IND,
     *        X(LQDER),D,X(LDTMP),S,X(LSDER),X(LWRK),X(LWRK1),
     *        X(LWRK2),X(LWRK3),UHF,FON,REDUCE)
            CALL DFTB_CALC_QDER_NCC(X(LQDER),U,OCC,X(LDNDR),S,X(LWRK),
     *        X(LRESPONSE),VEC,UINIT,NAT,L1,L2,NDOCC,NPART,NVIRT,IND,
     *        FON)
            CALL DSCAL(NAT,2.0D-01,X(LQDER),1) !! WHY?
          END IF
C
C         CALCULATE DIPOLE DERIVATIVE (TENSOR)
C
          DO I = 1, NAT
            DO J = 1, 3
              DIPDER(J,KI,NI) = DIPDER(J,KI,NI) - X(LQDER+I-1)*C(J,I)
            END DO
          END DO
          DIPDER(KI,KI,NI) = DIPDER(KI,KI,NI) - CHAMUL(NI)
          DO I = 1, 3
            DIPDER(I,KI,NI) = DIPDER(I,KI,NI) * DEBYE_ANGSTROM
          END DO
C
CD        call cpu_time(t6)
CD        tt0 = tt0 + t1-t0
CD        tti = tti + ti-t0
CD        ttq = ttq + tq-ti
CD        ttnr = ttnr + tnr-tq
CD        tt1 = tt1 + t2-t1
CD        tt2 = tt2 + t3-t2
CD        tt3 = tt3 + t4-t3
CD        tt4 = tt4 + t5-t4
CD        ttpdedb=ttpdedb+t45-t4
CD        ttdedb=ttdedb+t5-t45
CD        tt5 = tt5 + t6-t5
CD        tfon = tfon + fon3-fon2 + fon1-fon0
CD        IF (FIRST) THEN
CD          CALL CPU_TIME(TIT1)
CD          CALL SYSTEM_CLOCK(ICLOCK_COUNTS_2,ICLOCK_RATE)
CD          FIRST = .FALSE.
CD          TT = TIT1-TIT0
CD          TTW = (ICLOCK_COUNTS_2-ICLOCK_COUNTS_1)/DBLE(ICLOCK_RATE)
CD          IF (MASWRK.AND.SOME) THEN
CD            IF (ISGDDI) THEN
CD              NP = NGROUPS
CD            ELSE
CD              NP = NPROC
CD            END IF
CD            WRITE (IW,'(/"   CALCULATION OF THE FIRST VECTOR TOOK
CD   * ",F8.2," CPU TIME (SECONDS)")') TT
CD            WRITE (IW,'("   ESTIMATED TIME FOR ",I4," VECTORS IS ",
CD   *          F10.2," SECONDS (",F7.2," HOURS)")')
CD   *          3*NAT,3*NAT*TT/DBLE(NP),3*NAT*TT/(3.6D+03*DBLE(NP))
CD            WRITE (IW,'( "   CALCULATION OF THE FIRST VECTOR TOOK
CD   * ",F7.2," WALL TIME (SECONDS)")') TTW
CD            WRITE (IW,'("   ESTIMATED TIME FOR ",I4," VECTORS IS ",
CD   *          F10.2," SECONDS (",F7.2," HOURS)")')
CD   *          3*NAT,3*NAT*TTW/DBLE(NP),3*NAT*TTW/(3.6D+03*DBLE(NP))
CD          END IF
CD        END IF
        END DO
      END DO
C
      IF (ISGDDI) CALL GDDICOUNT( 1,LGROUP,MYJOB)
C
      IF (.NOT.MASWRK) THEN
        NITER = 0
        IF (NFG.EQ.0) CALL VCLR(DIPDER,1,9*NAT)
      END IF
C
      IF (ISGDDI) CALL GDDI_SCOPE(DDI_WORLD)
C
      IF (PARALL3.OR.ISGDDI) THEN
        CALL DDI_GSUMI(1,NITER,1)
        IF (FON(3)) CALL DDI_GSUMF(1,FONCON,1)
      END IF
C
      IF (MASWRK.AND.SOME) THEN
        WRITE (IW,*)
        WRITE (IW,'(X,I4," ROOTS CONVERGED AFTER ",F5.1," CYCLES ON ",
     *   "AVERAGE")')
     *   3*NAT,DBLE(NITER)/DBLE(3*NAT)
        WRITE (IW,*)
      END IF
      IF (MASWRK) THEN
        IF (FON(3)) THEN
          FONCON = SQRT(FONCON/DBLE(NAT*NAT*9))
          WRITE (IW,'(" RMS OF FON CONTRIBUTION = ",F20.10/)') FONCON
        END IF
      END IF
C
CD    WRITE (*,'(A)') "CPU TIMES IN DFTB_CP SUBROUTINE"
CD    write (*,'(A,F10.5)') "TIME FOR ALL TFTRI0        ",tttftri
CD    write (*,'(A,F10.5)') "TIME FOR PREPARATION       ",tt0
CD    write (*,'(A,F10.5)') "TIME FOR   INTEGRAL        ",tti
CD    write (*,'(A,F10.5)') "TIME FOR   PREP QDER       ",ttq
CD    write (*,'(A,F10.5)') "TIME FOR   PREP NR         ",ttnr
CD    write (*,'(A,F10.5)') "TIME FOR CP-DFTB ITERATION ",tt1
CD    write (*,'(A,F10.5)') "TIME FOR   QDER            ",ttqder
CD    write (*,'(A,F10.5)') "TIME FOR   TFTRI0          ",ttittftri
CD    write (*,'(A,F10.5)') "TIME FOR   BROYDEN         ",ttbr
CD    write (*,'(A,F10.5)') "TIME FOR   U FORMATION     ",ttu
CD    write (*,'(A,F10.5)') "TIME FOR d(OMEGA)/dR       ",tt2
CD    write (*,'(A,F10.5)') "TIME FOR DFTB_QDER         ",tt3
CD    write (*,'(A,F10.5)') "TIME FOR DFTB_DEDB         ",tt4
CD    write (*,'(A,F10.5)') "TIME FOR   PRE  DEDB       ",ttpdedb
CD    write (*,'(A,F10.5)') "TIME FOR        DEDB       ",ttdedb
CD    write (*,'(A,F10.5)') "TIME FOR DFTB_TEST         ",tt5
CD    write (*,'(A,F10.5)') "TIME FOR FON ITERATION     ",tfon
CD    write (*,*)
C
C     ----- RELEASE ALLOCATED MEMORY -----
C
1000  CONTINUE
      IF (SAVDCQ) CALL RETFM(NEED3)
      IF (NVEC.GT.1) CALL RETFM(NEED2)
      BUNDLE = BUNDLE0
      CALL RETFM(NEED)
C
      IF (PARALL3.OR.ISGDDI) THEN
C       GOPARR = .TRUE.
C       CALL DDI_GSUMF(1,HESSIAN,9*NAT*NAT)
        CALL DDI_GSUMF(1,DIPDER,9*NAT)
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_CP
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_COPY_CPVEC
C>
C>    @brief   DFTB Hessian
C>
C>    @details Store some vectors needed to calculate contributions to
C>             Hessian
C>
C>    @author Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NVEC      Index of current vector
C>    @param L1        Number of AOs
C>    @param L2        (L1*L1+L1)/2
C>    @param NSPIN     Number of spins (1: RHF, 2:UHF)
C>    @param NDIMSH    If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param NDIM      Number of occupied orbitals?
C>    @param FDERIJ    F_{ij}^a
C>    @param SDERIJ    S_{ij}^a
C>    @param U         U_{ij}^a
C>    @param DOMEGA    dOmega_{ij}/da
C>    @param FONDER    dn_i/da
C>    @param DEDB      de_i/da
C>    @param FON       FON is used or not
C>    @param SCC       SCC or not
C>           --- OUTPUT ---
C>    @param FDERIJTMP F_{ij}^a
C>    @param SDERIJTMP S_{ij}^a
C>    @param UTMP      U_{ij}^a
C>    @param DOMEGATMP dOmega_{ij}/da
C>    @param FONDERTMP dn_i/da
C>    @param DEDBTMP   de_i/da
C>
C
      SUBROUTINE DFTB_COPY_CPVEC(NVEC,L1,L2,NSPIN,NDIMSH,NDIM,
     *  FDERIJTMP,SDERIJTMP,UTMP,DOMEGATMP,FONDERTMP,DEDBTMP,FDERIJ,
     *  SDERIJ,U,DOMEGA,FONDER,DEDB,FON,SCC)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NVEC,L1,L2,NSPIN,NDIMSH,NDIM
      DOUBLE PRECISION, INTENT(IN) :: FDERIJ(L2*NSPIN),SDERIJ(L2*NSPIN),
     *  U(L1*L1,NSPIN),DOMEGA(NDIMSH*NSPIN),FONDER(L1),DEDB(L1*NSPIN)
      DOUBLE PRECISION, INTENT(INOUT) :: FDERIJTMP(L2*NSPIN,*),
     *  SDERIJTMP(L2*NSPIN,*),UTMP(L1*NDIM,NSPIN,*),
     *  DOMEGATMP(NDIMSH*NSPIN,*),FONDERTMP(L1,*),DEDBTMP(L1*NSPIN,*)
      LOGICAL, INTENT(IN) :: FON,SCC
C
      CALL DCOPY(L2*NSPIN,FDERIJ,1,FDERIJTMP(1,NVEC),1)
      CALL DCOPY(L2*NSPIN,SDERIJ,1,SDERIJTMP(1,NVEC),1)
      CALL DCOPY(L1*NDIM,U,1,UTMP(1,1,NVEC),1)
      IF (NSPIN.EQ.2) CALL DCOPY(L1*NDIM,U(1,2),1,UTMP(1,2,NVEC),1)
      IF (SCC) CALL DCOPY(NDIMSH*NSPIN,DOMEGA,1,DOMEGATMP(1,NVEC),1)
      IF (FON) CALL DCOPY(L1,FONDER,1,FONDERTMP(1,NVEC),1)
      CALL DCOPY(L1*NSPIN,DEDB,1,DEDBTMP(1,NVEC),1)
C
      RETURN
C     
      END SUBROUTINE DFTB_COPY_CPVEC
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CALC_FDER_DEDB
C>
C>    @brief   DFTB Hessian
C>
C>    @details Calculate F_{ij}^a and de_i/da
C>             Hessian
C>
C>    @author Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param L1        Number of AOs
C>    @param L2        (L1*L1+L1)/2
C>    @param NSPIN     Number of spins (1: RHF, 2:UHF)
C>    @param NDIMSH    If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param NDIM      Number of occupied orbitals?
C>    @param HDERMO    H_{ij}^{0,a}
C>    @param SDERMO    S_{ij}^a
C>    @param EIG       e_i
C>           --- OUTPUT ---
C>    @param FDERMO    F_{ij}^a
C>    @param DEDB      de_i/da
C>
C
      SUBROUTINE DFTB_CALC_FDER_DEDB(L1,L2,NSPIN,FDERMO,DEDB,HDERMO,
     *  SDERMO,EIG)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,L2,NSPIN
      DOUBLE PRECISION, INTENT(IN) :: HDERMO(L2,NSPIN),SDERMO(L2,NSPIN),
     *  EIG(L1,NSPIN)
      DOUBLE PRECISION, INTENT(OUT) :: FDERMO(L2,NSPIN),DEDB(L1,NSPIN)
C
      INTEGER :: ISPIN,NSEQ,IO,JO
      DOUBLE PRECISION :: EI,EJ
C
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      INTEGER :: nfg,nlayer,natfmo,nbdfg,naotyp,nbody
C
      DOUBLE PRECISION, PARAMETER :: TWO=2.0D+00
C      
C     CALCULATE DEDB (DERIVATIVE OF EIGENVALUES) AND FDERIJ TERMS, WHERE
C     FDERIJ_{IJ} = \SUM_{\MU \NU} C_{\MU I} C_{\NU J} dF_{\MU \NU}/dB
C     HERE WRITES FDERMO.
C     "F" IS A KIND OF FOCK MATRIX (SIMPLY HAMILTONIAN IN DFTB)
C
      DO ISPIN = 1, NSPIN
        NSEQ = 0
        IF (NFG.EQ.0) THEN
          DO IO = 1, L1
            EI = EIG(IO,ISPIN)
            DO JO = 1, IO-1
              EJ = EIG(JO,ISPIN)
              NSEQ = NSEQ + 1
              FDERMO(NSEQ,ISPIN)
     *          = HDERMO(NSEQ,ISPIN) - (EI+EJ)*SDERMO(NSEQ,ISPIN)
            END DO
            NSEQ = NSEQ + 1
            FDERMO(NSEQ,ISPIN) = -EI*SDERMO(NSEQ,ISPIN)
            DEDB(IO,ISPIN)
     *        = HDERMO(NSEQ,ISPIN)-EI*SDERMO(NSEQ,ISPIN)
          END DO
        ELSE
          DO IO = 1, L1
            EI = EIG(IO,ISPIN)
            DO JO = 1, IO-1
              EJ = EIG(JO,ISPIN)
              NSEQ = NSEQ + 1
              FDERMO(NSEQ,ISPIN)
     *          = TWO*HDERMO(NSEQ,ISPIN)-(EI+EJ)*SDERMO(NSEQ,ISPIN)
            END DO
            NSEQ = NSEQ + 1
            FDERMO(NSEQ,ISPIN)
     *        = HDERMO(NSEQ,ISPIN)-EI*SDERMO(NSEQ,ISPIN)
          END DO
        END IF
      END DO
C
      RETURN
C 
      END SUBROUTINE DFTB_CALC_FDER_DEDB
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HESS_UUPDATE
C>
C>    @brief Hessian of DFTB
C>
C>    @details Update U matrix, by calculating response terms
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Avoid degenerate problem
C>
C>           --- INPUT ---
C>    @param UINIT Initial U matrix (only with non-response terms)
C>    @param SDSHIJ Response contribution in MO basis
C>    @param EIG Eigenvalue of each MO
C>    @param OCC Occupation number of each MO
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>           --- OUTPUT ---
C>    @param U U matrix (derivatives of MO coefficient)
C>
C
      SUBROUTINE DFTB_HESS_UUPDATE(MODE,U,UINIT,SDSHIJ,EIG,OCC,L1,L2,
     *  NDOCC,NPART,BETA,EFERMI,DEGTHR1,DEGTHR2)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: MODE,L1,L2
      DOUBLE PRECISION, INTENT(INOUT) :: U(L1,L1)
      DOUBLE PRECISION, INTENT(IN) :: UINIT(L1,L1),SDSHIJ(L2),EIG(L1),
     *  OCC(L1),BETA,EFERMI,DEGTHR1,DEGTHR2
      INTEGER, INTENT(IN) :: NDOCC,NPART
C
      DOUBLE PRECISION :: EI,EJ,OCCI,OCCJ,VAL
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,HALF=0.5D+00
      INTEGER :: NN,IO,JO,NSEQ
      LOGICAL :: PARTI, PART
C
      DO IO = 1, NDOCC+NPART
        EI = EIG(IO)
        OCCI = OCC(IO)
        IF (IO.LE.NDOCC) THEN
          NN = NDOCC+1
          PARTI = .FALSE.
        ELSE
          NN = 1
          PARTI = .TRUE.
        END IF
        DO JO = NN, L1
          EJ = EIG(JO)
          OCCJ = OCC(JO)
          PART = JO.GT.NDOCC .AND. JO.LE.NDOCC+NPART .AND. PARTI
          IF (IO.EQ.JO) THEN
            U(JO,IO) = UINIT(JO,IO)
          ELSE
            CALL DFTB_CNVSQ(IO,JO,NSEQ)
            IF (ABS(EI-EJ).GT.DEGTHR1.OR..NOT.PART) THEN
              VAL = SDSHIJ(NSEQ)/(EI-EJ)
            ELSE IF (ABS(EI-EJ).GE.DEGTHR2.AND.JO.GE.IO) THEN
              VAL = SDSHIJ(NSEQ)*(OCCI-OCCJ)/((EI-EJ)*OCCI)
            ELSE IF (JO.GE.IO) THEN
              !! NOTE THAT BELOW IS ALREADY DIVIDED BY OCCI
              VAL = -SDSHIJ(NSEQ)*OCCJ*BETA*HALF*
     *              (EXP((EJ-EFERMI)*BETA))
            ELSE
              VAL = ZERO
            END IF
            U(JO,IO) = UINIT(JO,IO) + VAL
          END IF
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_HESS_UUPDATE
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CALC_QDER_NCC
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate derivatives of Mulliken charges at NCC-DFTB
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param U U matrix (derivatives of MO coefficients)
C>    @param OCC Occupation number of each MO
C>    @param DNDR Derivatives of occupation numbers
C>    @param S Overlap matrix
C>    @param SSQ Working array for square overlap matrix
C>    @param RESP Response matrix
C>    @param VEC MO coefficients
C>    @param WRK Working array
C>    @param NAT Number of atoms
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param NVIRT Number of virtual orbitals
C>    @param IND AO index of each atom
C>    @param FON Whether fractional occupation or not
C>           --- OUTPUT ---
C>    @param QDER Derivatives of Mulliken population
C>
C
      SUBROUTINE DFTB_CALC_QDER_NCC(QDER,U,OCC,DNDR,S,SSQ,RESP,VEC,WRK,
     *  NAT,L1,L2,NDOCC,NPART,NVIRT,IND,FON)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L1,L2,NDOCC,NPART,NVIRT,IND(*)
      DOUBLE PRECISION, INTENT(IN) :: U(L1,L1),OCC(L1),DNDR(L1),S(L2),
     *  VEC(L1,L1)
      DOUBLE PRECISION, INTENT(INOUT) :: QDER(NAT)
      DOUBLE PRECISION, INTENT(OUT) :: SSQ(L1,L1),RESP(L1,L1),
     *  WRK(L1,L1)
      LOGICAL, INTENT(IN) :: FON
C
      INTEGER :: NN,I,J,IO,II
      DOUBLE PRECISION :: TMP,VAL,VAL2,DDOT,XDOT
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00,HALF=0.5D+00,
     *  TWO=2.0D+00
C
      CALL CPYTSQ(S,SSQ,L1,1)
      CALL MRARBR(SSQ,L1,L1,L1,VEC,L1,L1,WRK,L1)
      DO NN = 1, NAT
        II = IND(NN+1)-IND(NN)
        CALL MRTRBR(VEC(IND(NN)+1,1),L1,II,L1,WRK(IND(NN)+1,1),L1,L1,
     *    RESP,L1)
        DO I = 1, L1
          DO J = I, L1
            TMP = RESP(J,I) + RESP(I,J)
            RESP(J,I) = TMP
            RESP(I,J) = TMP
          END DO
        END DO
C
        VAL = ZERO
        DO IO = 1, NDOCC
          VAL = VAL + DDOT(NPART+NVIRT,U(NDOCC+1,IO),1,
     *          RESP(NDOCC+1,IO),1)
        END DO
        QDER(NN) = QDER(NN) + VAL*TWO
C
        IF (FON) THEN
          VAL = ZERO
          VAL2 = ZERO
          DO IO = NDOCC+1, NDOCC+NPART
            VAL = VAL
     *       + OCC(IO)*DDOT(L1,U(1,IO),1,RESP(1,IO),1)
            VAL2 = VAL2 + DNDR(IO)*RESP(IO,IO)
          END DO
          QDER(NN) = QDER(NN) + VAL + VAL2*HALF*HALF !! WHY HALF TWICE?
        END IF
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_QDER_NCC
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DPART
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate partial density matrix.  The index of "i" runs
C>             over only doubly occupied orbitals.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param OCC Occupation number of each MO
C>    @param VEC MO coefficients
C>           --- OUTPUT ---
C>    @param D Partial density matrix
C>
C
      SUBROUTINE DFTB_DPART(L1,L2,NDOCC,OCC,D,VEC)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,L2,NDOCC
      DOUBLE PRECISION ,INTENT(IN) :: OCC(L1),VEC(L1,L1)
      DOUBLE PRECISION, INTENT(OUT) :: D(L2)
C
      INTEGER :: I,IJ,K
C
      CALL VCLR(D,1,L2)
C
      DO K = 1, NDOCC
        IJ = 1
        DO I = 1, L1
          CALL DAXPY(I,OCC(K)*VEC(I,K),VEC(1,K),1,D(IJ),1)
          IJ = IJ + I
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_DPART
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CALC_DNDR
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate derivatives of occupation numbers.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param IMODE See below
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param ETEMP Electronic temperature
C>    @param OCC Occupatio number of each MO
C>    @param EIG Eigenvalues of each MO
C>    @param HDER H_{ij}^b + V_{ij}^b
C>    @param SDER S_{ij}^b
C>    @param SOMGD Either non-response or response contribution of
C>           the derivative of shift contribution
C>    @param VEC MO coefficients
C>           --- OUTPUT ---
C>    @parma DEDB_INIT Non-response contributions of de/db (derivatives
C>           of eigenvalue)
C>    @param DEDB Derivatives of eigenvalue
C>    @param DNDR Derivatiees of occupation number
C>    @param FEDER Derivative of fermi-level
C>
C
      SUBROUTINE DFTB_CALC_DNDR(IMODE,L1,L2,NDOCC,NPART,ETEMP,
     *  DEDB_INIT,DEDB,DNDR,OCC,EIG,HDER,SDER,SOMGD,FEDER,SCC)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: IMODE,L1,L2,NDOCC,NPART
      DOUBLE PRECISION, INTENT(IN) :: ETEMP,OCC(L1),EIG(L1),HDER(L2),
     *  SDER(L2),SOMGD(L2)
      DOUBLE PRECISION, INTENT(INOUT) :: DEDB_INIT(L1),DEDB(L1),
     *  DNDR(L1),FEDER
      LOGICAL, INTENT(IN) :: SCC
C
      INTEGER :: NSEQ,IO
      DOUBLE PRECISION :: EI,OCCI,TMP,BETA
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00,HALF=0.5D+00,
     *  ONE=1.0D+00,TWO=2.0D+00,BOLTZ=3.1668114D-06
C
C     IMODE = 0
C     USED FOR FON CALCULATION.  JUST ADD NON-RESPONSE CONTRIBUTIONS TO
C     DEDB_INIT MATRIX.
C
C     IMODE = 1
C     USED FOR FON CALCULATION, AND ADD RESPONSE CONTRIBUTIONS
C
      NSEQ = 0
      IF (IMODE.EQ.0) THEN
C       WRITE (*,*) "DEDB_INIT"
        DO IO = 1, L1
          NSEQ = NSEQ + IO
          EI = EIG(IO)
C         WRITE (*,'(I3,2(X,F20.10))') NSEQ,HDER(NSEQ),SDER(NSEQ)
C         WRITE (*,'(3X,2(X,F20.10))') EI,SOMGD(NSEQ)
          TMP = HDER(NSEQ) - EI*SDER(NSEQ)
          DEDB_INIT(IO) = TMP
C         WRITE (*,'(I3,X,F20.10)') IO,DEDB_INIT(IO)
        END DO
        CALL VCLR(DNDR,1,L1)
        RETURN
      ELSE
        DO IO = 1, L1
          NSEQ = NSEQ + IO
          EI = EIG(IO)
          IF (SCC) THEN
            TMP = SOMGD(NSEQ)
          ELSE
            TMP = HDER(NSEQ) - EI*SDER(NSEQ)
          END IF
          DEDB(IO) = DEDB_INIT(IO) + TMP
        END DO
      END IF
C
C       ----- CALCULATE DERVIATIVE OF FERMI ENERGY FIRST -----
C
      CALL VCLR(DNDR,1,L1)
      FEDER = ZERO
      TMP = ZERO
      DO IO = NDOCC+1, NDOCC+NPART
        OCCI = OCC(IO)*HALF
        FEDER = FEDER + OCCI*(ONE-OCCI)*DEDB(IO)
        TMP = TMP + OCCI*(ONE-OCCI)
      END DO
      FEDER = FEDER/TMP
      BETA = ONE/(BOLTZ*ETEMP)
C
C       ----- THEN CALCULATE DERIVATIVE OF OCCUPATION NUMBESR -----
C
      DO IO = NDOCC+1, NDOCC+NPART
        OCCI = OCC(IO)*HALF
        DNDR(IO) = -OCCI*(ONE-OCCI)*(DEDB(IO)-FEDER) !! *BETA
C       DNDR(IO) = DNDR(IO)*TWO
      END DO
      CALL DSCAL(NPART,TWO*BETA,DNDR(NDOCC+1),1)
C
      END SUBROUTINE DFTB_CALC_DNDR
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate non-response contributions to the derivatives
C>             of Mulliken population
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L0 NQMT
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param IND Index of AO
C>    @param D1 Normal density matrix
C>    @param D2 Partial density matrix (for FON)
C>    @param S Overlap matrix
C>    @param SDER Matrix of overlap matrix in AO basis
C>    @param UHF Whether U-DFTB or not
C>           --- OUTPUT ---
C>    @param QDER_INIT Non-response contribution to Mulliken derivative
C>    @param WRK,WRK1,W,TMP Working array
C>
C
      SUBROUTINE DFTB_PREP_QDER(NAT,L0,L1,L2,IND,QDER_INIT,
     *  D1,D2,S,SDER,WRK,WRK1,W,TMP,UHF,FON,REDUCE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER :: IND(*)
      DOUBLE PRECISION :: QDER_INIT(NAT),D1(L2),D2(L2),S(L2),SDER(L2),
     *  WRK(*),WRK1(*),W(L2),TMP(L1)
      LOGICAL :: UHF,FON,REDUCE
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00,HALF=0.5D+00
C
C     D1 :: NORMAL DENSITY MATRIX
C     D2 :: PARTIAL DENSITY MATRIX (IF FON)
C
      CALL VCLR(QDER_INIT,1,NAT)
      !! CALCULATE LAGRANGIAN-LIKE TERM
      IF (FON.AND.REDUCE) THEN
        CALL VCLR(TMP,1,L1)
      ELSE
        CALL CPYTSQ(D2,WRK,L1,1)
        CALL TFTRI0(W,SDER,WRK,WRK1,L0,L1,L1)
        IF (.NOT.UHF) CALL DSCAL(L2,HALF,W,1)
C
C     CALCULATE S*W (BOTH MATRICES ARE SYMMETRIC)
C
        CALL DFTB_MULLIKEN(L1,L2,S,W,TMP)
      END IF
C
C     CALCULATE D*(dS/dR), BY DESTROYING W, WHICH IS NO LONGER NEEDED.
C     ONLY DIAGONAL ELEMENT IS NEEDED, AND USE THE NATURE OF
C     SYMMETRY OF D AND dS/dR.
C     
      CALL DFTB_MULLIKEN(L1,L2,D1,SDER,W)
      CALL VSUB(TMP,1,W,1,TMP,1,L1)
C
      DO NC = 1, NAT
        VAL = ZERO
        DO L = 1, IND(NC+1) - IND(NC)
          MU = IND(NC)+L
C         VAL = VAL + TMP1(MU) - TMP2(MU)
          VAL = VAL + TMP(MU)
        END DO
        QDER_INIT(NC) = QDER_INIT(NC) + VAL
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_PREP_QDER
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER_REDUCE
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate non-response contributions to the derivatives
C>             of Mulliken population.  This is used in reduced-memory
C>             run.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @data Oct, 2014 - Yoshio Nishimoto
C>    - Performance improvement
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L1 Number of basis functions
C>    @param IND Index of AO
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param U U matrix (derivative of MO coefficients)
C>    @param OCC Occupation number of each MO
C>    @param QDER_INIT Non-response contribution to Mulliken derivative
C>    @param RESP Response terms
C>    @param DNDR Derivative of occupation numbers
C>    @param VEC MO coefficients
C>    @param FON Whether fractional occupation or not
C>    @param SRSCC Whether Shell-resolved SCC or not
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>    @param NSHELL Number of shells
C>    @param WRK,WRK1 Working arrays
C>           --- OUTPUT ---
C>    @param QDER Derivative of Mulliken charges
C>
C
      SUBROUTINE DFTB_CALC_QDER_REDUCE(NAT,L1,IND,NDOCC,NPART,
     *  QDER,U,OCC,QDER_INIT,RESP,DNDR,VEC,FON,SRSCC,
     *  NSPE,ISPE,MAXANG,NSHELL,WRK,WRK1)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L1,IND(*),NDOCC,NPART,
     *  NSPE,ISPE(NAT),MAXANG(NSPE),NSHELL
      DOUBLE PRECISION, INTENT(IN)  :: U(L1,L1),OCC(L1),
     *  QDER_INIT(NAT),RESP(L1,L1),VEC(L1,L1),DNDR(L1)
      DOUBLE PRECISION, INTENT(OUT) :: QDER(NAT)
      DOUBLE PRECISION, INTENT(INOUT) :: WRK(L1,L1),WRK1(L1,L1)
      LOGICAL, INTENT(IN) :: FON,SRSCC
C
      INTEGER :: ISH0,ISH,I,IO,MM,NN,MU
      DOUBLE PRECISION :: VAL,TMP,DDOT,XDOT
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00
      INTEGER :: NOCC,JO,N1,LDIM,MXSQN2
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL GOPARR,DSKWRK,MASWRK
C
C     FIRST, ARRANGE U MATRIX.
C     FOR FON CALCULATION, U(1:L1,1:NOCC) SPACE IS AVAILABLE,
C     AND THIS IS FIRST SCALED WITH OCCUPATION NUMBERS, AND THEN
C     SYMMETRIZED.
C     IF NOT FON CALCULATION, WE ONLY NEED OCCUPIED-VIRTUAL COUPLING.
C     HOWEVER, IN ORDER TO REDUCE DGEMM ONCE, U MATRIX IS SYMMETRIZED
C     IN WRK ARRAY, AND ALSO OCCUPIED-OCCUPIED AND VIRTUAL-VIRTUAL
C     COUPLING ELEMENTS ARE REMOVED.
C
C     call cpu_time(tt0)
      NOCC = NDOCC + NPART
      CALL DCOPY(L1*L1,U,1,WRK,1)
      IF (FON) THEN
        DO IO = 1, NOCC
          CALL DSCAL(L1,OCC(IO),WRK(1,IO),1)
        END DO
        CALL VCLR(WRK(1,NOCC+1),1,L1*(L1-NOCC))
        DO IO = 1, L1
          DO JO = 1, IO
            TMP = WRK(IO,JO)+WRK(JO,IO)
            WRK(IO,JO) = TMP
            WRK(JO,IO) = TMP
          END DO
        END DO
      ELSE
        DO IO = 1, NDOCC
          CALL VCLR(WRK(1,IO),1,NDOCC)
          DO JO = NDOCC+1, L1
            WRK(IO,JO) = WRK(JO,IO)
            CALL VCLR(WRK(NDOCC+1,JO),1,L1-NDOCC)
          END DO
        END DO
      END IF
C     call cpu_time(tt1)
C
C     CALCULATE CU TERM
C
      IF (GOPARR.AND.L1.GT.MXSQN2()) THEN
        CALL VCLR(WRK1,1,L1*L1)
        NN = MOD(L1,NPROC)
        MM = (L1-NN)/NPROC
        IF (ME+1.LE.NN) THEN
          LDIM = MM+1
          N1 = LDIM*ME + 1
        ELSE
          LDIM = MM
          N1 = MM*ME + NN + 1
        END IF
        !! LDA = L1
        !!  NA = L1
        !!  MA = L1
        !! LDB = L1
        !!  MB = LDIM
        !! LDC = L1
        CALL MRARBR(VEC,L1,L1,L1,
     *              WRK(1,N1),L1,LDIM,
     *              WRK1(1,N1),L1)
        CALL DDI_GSUMF(520,WRK1,L1*L1)
        CALL DDI_BCAST(521,'F',WRK1,L1*L1,MASTER)
      ELSE
        CALL MRARBR(VEC,L1,L1,L1,WRK,L1,L1,WRK1,L1)
      END IF
C     call cpu_time(tt2)
C
C     ADD FON CONTRIBUTION
C
      IF (FON) THEN
        DO IO = NDOCC+1, NDOCC+NPART
          CALL DAXPY(L1,DNDR(IO),VEC(1,IO),1,WRK1(1,IO),1)
        END DO
      END IF
C
C     FINALLY, MULTIPLY RESP TERM, WHERE
C       RESP = S'_{i \mu} = (S'_{\mu i})^T
C            = (\sum_{\nu} S_{\mu \nu} c_{\nu i})^T
C     ONLY DIAGONAL ELEMENTS ARE NEEDED, SO DDOT IS FASTER THAN MRARBR
C
      CALL TRPOSQ(WRK1,L1)
      DO IO = 1, L1
        WRK(IO,1) = DDOT(L1,WRK1(1,IO),1,RESP(1,IO),1)
      END DO
      IF (.NOT.FON) CALL DSCAL(L1,OCC(1),WRK,1)
C     call cpu_time(tt3)
C
      IF (SRSCC) THEN
        CALL DCOPY(NSHELL,QDER_INIT,1,QDER,1)
        ISH0 = 0
        DO NN = 1, NAT
          DO I = 1, MAXANG(ISPE(NN))
            ISH = ISH0 + I
            VAL = ZERO
            DO MM = 1, IND(ISH+1)-IND(ISH)
              MU = IND(ISH)+MM
              VAL = VAL + WRK(MU,1)
            END DO
            QDER(ISH) = QDER(ISH) + VAL
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(NN))
        END DO
      ELSE
        CALL DCOPY(NAT,QDER_INIT,1,QDER,1)
        DO NN = 1, NAT
          VAL = ZERO
          DO MM = 1, IND(NN+1)-IND(NN)
            MU = IND(NN)+MM
            VAL = VAL + WRK(MU,1)
          END DO
          QDER(NN) = QDER(NN) + VAL
        END DO
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_QDER_REDUCE
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate non-response contributions to the derivatives
C>             of Mulliken population.  This is used in reduced-memory
C>             run.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L1 Number of basis functions
C>    @param IND Index of AO
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param NVIRT NUmber of virtual orbitals
C>    @param U U matrix (derivative of MO coefficients)
C>    @param OCC Occupation number of each MO
C>    @param QDER_INIT Non-response contribution to Mulliken derivative
C>    @param RESP Response terms
C>    @param DNDR Derivative of occupation numbers
C>    @param FON Whether fractional occupation or not
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param SRSCC Whether Shell-resolved SCC or not
C>    @param UHF Whether U-DFTB or not
C>    @param NDIMSH If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param ISPIN Index of spin
C>           --- OUTPUT ---
C>    @param QDER Derivative of Mulliken charges
C>
C
      SUBROUTINE DFTB_CALC_QDER(NAT,L1,NDOCC,NPART,NVIRT,QDER,U,
     *  OCC,QDER_INIT,RESP,DNDR,FON,NSPIN,SRSCC,UHF,NDIMSH,NSPE,ISPE,
     *  MAXANG,ISPIN,WRK)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L1,NDOCC,NPART,NVIRT,NSPIN,NDIMSH,
     *  NSPE,ISPE(NAT),MAXANG(NSPE),ISPIN
      DOUBLE PRECISION, INTENT(IN) :: U(L1,L1),OCC(L1),
     *  QDER_INIT(NDIMSH),RESP(L1,L1,NDIMSH,NSPIN),DNDR(L1)
      DOUBLE PRECISION, INTENT(OUT) :: QDER(NDIMSH)
      DOUBLE PRECISION, INTENT(INOUT) :: WRK(L1,L1)
      LOGICAL, INTENT(IN) :: FON,SRSCC,UHF
C
      INTEGER :: NSHELL,ISH,ISH0,I,IO,NN
      DOUBLE PRECISION :: VAL,VAL2,DDOT,XDOT
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00,HALF=0.5D+00
C
C     WHEN OCCUPATION NUMBERS ARE FRACTIONAL, ORBITAL SPACE IS DIVIDED
C     INTO THREE, DOUBLE OCCUPIED (NDOCC), PARTIAL OCCUPIED (NPART), AND
C     VIRTUAL ORBITALS (NVIRT).  ONLY DOUBLY-DOUBLY OCCUPIED COUPLINGS
C     CAN BE WRITTEN WITH S_{IJ} MATRIX.
C
      NSHELL = NDIMSH
C     write (*,*) "srscc = ", srscc
C     write (*,*) "uhf = ", uhf
      IF (SRSCC.OR.UHF) THEN
        CALL DCOPY(NSHELL,QDER_INIT,1,QDER,1)
        ISH0 = 0
        DO NN = 1, NAT
          DO I = 1, MAXANG(ISPE(NN))
            ISH = ISH0 + I
            VAL = ZERO
            DO IO = 1, NDOCC
              VAL = VAL + DDOT(NPART+NVIRT,U(NDOCC+1,IO),1,
     *              RESP(NDOCC+1,IO,ISH,ISPIN),1)
            END DO
            QDER(ISH) = QDER(ISH) + VAL*OCC(1)
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(NN))
        END DO
      ELSE
        CALL DCOPY(NAT,QDER_INIT,1,QDER,1)
        DO NN = 1, NAT
          VAL = ZERO
          DO IO = 1, NDOCC
            VAL = VAL + DDOT(NPART+NVIRT,U(NDOCC+1,IO),1,
     *            RESP(NDOCC+1,IO,NN,ISPIN),1)
          END DO
          QDER(NN) = QDER(NN) + VAL*OCC(1) !! TWO IS OCCUPATION NUMBER
        END DO
      END IF
C
      IF (FON) THEN
        DO NN = 1, NAT
          VAL = ZERO
          VAL2 = ZERO
          DO IO = NDOCC+1, NDOCC+NPART
            VAL = VAL
     *       + OCC(IO)*DDOT(L1,U(1,IO),1,RESP(1,IO,NN,ISPIN),1)
            !! RESP OF DIAGONAL PART IS MULTIPLIED BY TWO SO RE-SCALE IT
            VAL2 = VAL2 + DNDR(IO)*RESP(IO,IO,NN,ISPIN)
          END DO
          QDER(NN) = QDER(NN) + VAL + VAL2*HALF
        END DO
      END IF
C
      END SUBROUTINE DFTB_CALC_QDER
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Prepare the calculation of second-order derivative of
C>             gamma values, making TMP matrix
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param HUBA,HUBB Hubbard values of atom A and B
C>    @param DFTB3 Whether DFTB3 or not
C>    @param DAMPXH Whether DAMPXH is true or not
C>           --- OUTPUT ---
C>    @param TMP Constants
C>
C
      SUBROUTINE DFTB_PREP_GAMMA_HESS(HUBA,HUBB,TMP,DFTB3,DAMPXH)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION, INTENT(IN) :: HUBA,HUBB
      LOGICAL, INTENT(IN) :: DFTB3,DAMPXH
      DOUBLE PRECISION, INTENT(OUT) :: TMP(11)
C
      DOUBLE PRECISION :: TAUA,TAUA2,TAUA3,TAUA4,TAUA6,TAUB,TAUB2,
     *  TAUB3,TAUB4,TAUB6,TAUAB,TAUABI,TAUABI2,TAUABI3,TAUABI4
      DOUBLE PRECISION,PARAMETER :: HUBTOL=1.0D-04,
     *  HALF=0.5D+00,ONE=1.0D+00,TWO=2.0D+00,THREE=3.0D+00,
     *  TWELVE=1.2D+01,ONE_15=ONE/1.5D+01,ONE_48=ONE/4.8D+01
C
      TAUA  = 3.2D+00*HUBA
      TAUA2 = TAUA**2
      TAUA3 = TAUA*TAUA2
      TAUA4 = TAUA2**2
      TAUA6 = TAUA2*TAUA4
      TAUB = 3.2D+00*HUBB
      TAUB2 = TAUB**2
      TAUB3 = TAUB*TAUB2
      TAUB4 = TAUB2**2
      TAUB6 = TAUB2*TAUB4
      IF (ABS(HUBA-HUBB).LE.HUBTOL) THEN
        TMP(1) = 6.875D-01*TAUA  !! 11/16 a
        TMP(2) = 1.875D-01*TAUA2 !! 3/16  a^2
        TMP(3) = ONE_48*TAUA3    !! 1/48  a^3
        TMP(4) = TWO*TMP(3)  !! 1/24  a^3
        TMP(5) = 3.125D-01*TAUA3 !! 5/16  a^3
        IF (DFTB3) THEN
          TMP(5) = -6.0D-01*TAUA
          TMP(6) = 2.0D-01*TAUA2
          TMP(7) = 2.0D-01*TAUA3
          TMP(8) = TAUA4*ONE_15
          IF (DAMPXH) THEN
            TMP(9)  = -TAUA
            TMP(10) = -4.0D-01*TAUA2
            TMP(11) = -TAUA3*ONE_15
          END IF
        END IF
      ELSE
        TAUAB = TAUA2 - TAUB2
        TAUABI = ONE/TAUAB
        TAUABI2 = TAUABI**2
        TAUABI3 = TAUABI**3
        TMP(1) =  (TAUB6-THREE*TAUA2*TAUB4)*TAUABI3
        TMP(2) = HALF*TAUA*TAUB4*TAUABI2
        TMP(3) = -(TAUA6-THREE*TAUB2*TAUA4)*TAUABI3
        TMP(4) = HALF*TAUB*TAUA4*TAUABI2
        IF (DFTB3) THEN
          TAUABI4 = TAUABI**4
          TMP(5) = -HALF*(TAUB6+THREE*TAUA2*TAUB4)*TAUABI3
          TMP(6) = -TWELVE*TAUA3*TAUB4*TAUABI4
          TMP(7) = -TWO*TAUB3*TAUA3*TAUABI3
          TMP(8) =  TWELVE*TAUB4*TAUA3*TAUABI4
        END IF
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_PREP_GAMMA_HESS
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Actual function which calculates the second-order
C>             derivative of gamma values
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param HUBA,HUBB Hubbard values of atom A and B
C>    @param HUBDER Hubbard derivatives
C>    @param DIST Inter-atomic distance between atom A and B
C>    @param DAMPXHE Exponent of X-H damping function
C>    @param TMP Constants produced in DFTB_PREP_GAMMA_HESS subroutine
C>    @param DFTB3 Whether DFTB3 or not
C>    @param HDAMP Whether the pair contains H or not
C>           --- OUTPUT ---
C>    @param GRAD2 1st-order derivative of DFTB2 gamma
C>    @param HESS2 2nd-order derivative of DFTB2 gamma
C>    @param GRAD3 1st-order derivative of DFTB3 gamma
C>    @param HESS3 2nd-order derivative of DFTB3 gamma
C>
C
      SUBROUTINE DFTB_GAMHESSF(GRAD2,HESS2,GRAD3,HESS3,HUBA,HUBB,HUBDER,
     *  DIST,DAMPXHE,TMP,DFTB3,HDAMP)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION, INTENT(IN) :: HUBA,HUBB,HUBDER,DIST,DAMPXHE,
     *  TMP(11)
      DOUBLE PRECISION, INTENT(OUT) :: GRAD2,HESS2,GRAD3,HESS3
      LOGICAL, INTENT(IN) :: DFTB3,HDAMP
C
      DOUBLE PRECISION :: TAUA,TAUA2,TAUB,TAUB2,DIST2,DIST3,DISTI,
     *  DISTI2,DISTI3,EXPA,GAMTMP,GAMTMP2,GAMTMP3,GA,DGA_DR,D2GA_DR,S,
     *  DS_DR,D2S_DR,D2S_DR2,HUBMEAN,HUBMEANEXP,EXPH,DH_DR,D2H_DR2,
     *  DGA_DA,D2GA_DADR,D2GA_DR2,D3GA_DADR2,D2S_DUDR,D3S_DUDR2,
     *  HUBMEANEXP1,DS_DU,DH_DU,D2H_DUDR,D3H_DUDR2,EXPB,FAB,FBA,
     *  DFAB_DR,DFBA_DR,D2FAB_DR,D2FBA_DR,DFAB_DA,DFBA_DA,D2FAB_DR2,
     *  D2FAB_DADR,D2FBA_DADR,D3FAB_DADR2,D3FBA_DADR2
      DOUBLE PRECISION, PARAMETER :: DISTTOL=1.0D-08,HUBTOL=1.0D-04,
     *  ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00,HALF=0.5D+00
C
      IF (DIST.LT.DISTTOL) THEN
        GRAD2 = ZERO
        HESS2 = ZERO
        GRAD3 = ZERO
        HESS3 = ZERO
      ELSE
        TAUA = 3.2D+00*HUBA
        TAUA2 = TAUA**2
        TAUB = 3.2D+00*HUBB
        TAUB2 = TAUB**2
        DISTI = ONE/DIST
        DIST2 = DIST**2
        DISTI2 = DISTI**2
        DISTI3 = DISTI**3
        EXPA = EXP(-TAUA*DIST)
        GAMTMP2 = ZERO
        GAMTMP3 = ZERO
        IF (ABS(HUBA-HUBB).LE.HUBTOL) THEN
          GA = DISTI+TMP(1)+TMP(2)*DIST+TMP(3)*DIST2
          DGA_DR = -DISTI2+TMP(2)+TMP(4)*DIST
          D2GA_DR = TWO*DISTI3+TMP(4)
          S = EXPA*GA
          DS_DR = EXPA*(DGA_DR-TAUA*GA)
          D2S_DR = EXPA*(D2GA_DR-TWO*TAUA*DGA_DR+TAUA2*GA)
          GAMTMP = -DS_DR
          D2S_DR2 = D2S_DR
          IF (HDAMP) THEN
            HUBMEAN = HUBA
            HUBMEANEXP = HUBMEAN**DAMPXHE
            EXPH = EXP(-HUBMEANEXP*DIST2)
            DH_DR = -TWO*DIST*HUBMEANEXP*EXPH
            D2H_DR2 = -TWO*HUBMEANEXP
     `        *(ONE-TWO*DIST2*HUBMEANEXP)*EXPH
            GAMTMP = GAMTMP*EXPH !! -h*dSg/dR
            GAMTMP2 = -DH_DR*S
            !! D2S_DR = d2S/dR2 + 2*(dS/dR)*(dh/dR)
            D2S_DR = D2S_DR*EXPH+TWO*DS_DR*DH_DR+S*D2H_DR2
          END IF
          GRAD2 = -DISTI2+GAMTMP+GAMTMP2
          HESS2 = TWO*DISTI3-D2S_DR
C         write (*,*) disti2,gamtmp,gamtmp2
C         write (*,*) disti3,d2s_dr
          IF (DFTB3) THEN
            DIST3 = DIST2*DIST
            DGA_DA =
     *        6.875D-01+3.75D-01*TAUA*DIST+6.25D-02*TAUA2*DIST2
            D2GA_DADR = 3.75D-01*TAUA+1.25D-01*TAUA2*DIST
            D2GA_DR2 = TWO*DISTI3+TMP(4)
            D3GA_DADR2 = 1.25D-01*TAUA2
            GAMTMP = (TAUA*DIST-ONE)*GA-TAUA*DGA_DA+D2GA_DADR
     *        - DIST*DGA_DR
            D2S_DUDR = GAMTMP*EXPA*3.2D+00
            GAMTMP = -D2S_DUDR
            GAMTMP3 = -TAUA*(TAUA*DIST-TWO)*GA
     *        +TWO*(TAUA*DIST-ONE)*DGA_DR+TAUA2*DGA_DA
     *        -TWO*TAUA*D2GA_DADR+D3GA_DADR2-DIST*D2GA_DR2
            D3S_DUDR2 = GAMTMP3*EXPA*3.2D+00
            GAMTMP3 = -D3S_DUDR2
            IF (HDAMP) THEN !! damp correction with 3rd
              HUBMEANEXP1 = HUBMEAN**(DAMPXHE-ONE)
              DS_DU = EXPA*(-ONE+TMP(9)*DIST
     *          + TMP(10)*DIST2+TMP(11)*DIST3)
              DH_DU = -HALF*DIST2*DAMPXHE*HUBMEANEXP1*EXPH
              D2H_DUDR = DAMPXHE*DIST*HUBMEANEXP1
     *                   *(DIST2*HUBMEANEXP-ONE)*EXPH
              D3H_DUDR2 = DAMPXHE*HUBMEANEXP1*EXPH
     *          *(DIST2*HUBMEANEXP
     *             *(5.0D+00-TWO*DIST2*HUBMEANEXP)-ONE)
C             WRITE (*,*) GAMTMP*EXPH,-DS_DU*DH_DR,-DS_DR*DH_DU
C             WRITE (*,*) -S*D2H_DUDR
              GAMTMP = -D2S_DUDR*EXPH-DS_DU*DH_DR-DS_DR*DH_DU
     *          -S*D2H_DUDR
C             D2S_DR2 = D2S_DR
              GAMTMP3 = -D3S_DUDR2*EXPH-TWO*D2S_DUDR*DH_DR
     *          -TWO*DS_DR*D2H_DUDR-DS_DU*D2H_DR2-D2S_DR2*DH_DU
     *          -S*D3H_DUDR2
            END IF
C           GAMTMP = 3.2D+00*GAMTMP !! /3.0D+00
C           GAMTMP3 = 3.2D+00*GAMTMP3 !! /3.0D+00
            GRAD3 = GAMTMP*HUBDER
            HESS3 = GAMTMP3*HUBDER
C           WRITE (*,*) "i,j = ",i ,j
C           write (*,*) gamtmp*HUBDER(NSP1),GAMTMP3*HUBDER(NSP1)
          END IF
        ELSE
          EXPB = EXP(-TAUB*DIST)
          FAB = TMP(2)-TMP(1)*DISTI
          FBA = TMP(4)-TMP(3)*DISTI
          DFAB_DR = TMP(1)*DISTI2
          DFBA_DR = TMP(3)*DISTI2
          D2FAB_DR = -DFAB_DR*TWO*DISTI
          D2FBA_DR = -DFBA_DR*TWO*DISTI
          S = EXPA*FAB+EXPB*FBA
          DS_DR = EXPA*(DFAB_DR-TAUA*FAB)+EXPB*(DFBA_DR-TAUB*FBA)
          GAMTMP = -DS_DR
          D2S_DR = EXPA*(D2FAB_DR-TWO*TAUA*DFAB_DR+TAUA2*FAB)
     *           + EXPB*(D2FBA_DR-TWO*TAUB*DFBA_DR+TAUB2*FBA)
          D2S_DR2 = D2S_DR
          IF (HDAMP) THEN
            HUBMEAN = HALF*(HUBA+HUBB)
            HUBMEANEXP = HUBMEAN**DAMPXHE
            EXPH = EXP(-HUBMEANEXP*DIST2)
            DH_DR = -TWO*DIST*HUBMEANEXP*EXPH
            D2H_DR2 = -TWO*HUBMEANEXP
     `        *(ONE-TWO*DIST2*HUBMEANEXP)*EXPH
            GAMTMP = GAMTMP*EXPH !! -h*dSg/dR
            GAMTMP2 = -S*DH_DR
            !! D2S_DR = d2S/dR2 + 2*(dS/dR)*(dh/dR)
            D2S_DR = D2S_DR*EXPH+TWO*DS_DR*DH_DR+S*D2H_DR2
          END IF
          GRAD2 = -DISTI2+GAMTMP+GAMTMP2
C         write (*,*) disti2,gamtmp,gamtmp2
          HESS2 = TWO*DISTI3-D2S_DR
C         write (*,*) disti3,d2s_dr
          IF (DFTB3) THEN
            DFAB_DA = TMP(5) + TMP(6)*DISTI
            DFBA_DA = TMP(7) + TMP(8)*DISTI
            D2FAB_DR2 = -DFAB_DR*TWO*DISTI
            D2FAB_DADR = -TMP(6)*DISTI2
            D2FBA_DADR = -D2FAB_DADR
            D3FAB_DADR2 = -D2FAB_DADR*TWO*DISTI
            D3FBA_DADR2 = -D2FBA_DADR*TWO*DISTI
            GAMTMP = EXPA*((TAUA*DIST-ONE)*FAB-TAUA*DFAB_DA
     *        + D2FAB_DADR - DIST*DFAB_DR)
     *        + EXPB*(D2FBA_DADR - TAUB*DFBA_DA)
            D2S_DUDR = GAMTMP*3.2D+00
            GAMTMP = -D2S_DUDR
            GAMTMP3 = EXPA*(-TAUA*(TAUA*DIST-TWO)*FAB
     *        +TWO*(TAUA*DIST-ONE)*DFAB_DR+TAUA2*DFAB_DA
     *        -TWO*TAUA*D2FAB_DADR+D3FAB_DADR2
     *        -DIST*D2FAB_DR2)
     *        +EXPB*(TAUB2*DFBA_DA-TWO*TAUB*D2FBA_DADR
     *        +D3FBA_DADR2)
            D3S_DUDR2 = GAMTMP3*3.2D+00
            GAMTMP3 = -D3S_DUDR2
C           WRITE (*,*) D2S_DUDR
C           WRITE (*,*) "D3S_DUDR2 = ", D3S_DUDR2
            IF (HDAMP) THEN  !! damp correction with 3rd
              HUBMEANEXP1 = HUBMEAN**(DAMPXHE-ONE)
              DS_DU = EXPA*(DFAB_DA-DIST*FAB)+EXPB*DFBA_DA
              DS_DU = DS_DU*3.2D+00
              DH_DR = -TWO*DIST*HUBMEANEXP*EXPH
              DH_DU = -HALF*DIST2*DAMPXHE*HUBMEANEXP1*EXPH
              D2H_DUDR = DAMPXHE*DIST*HUBMEANEXP1
     *                   *(DIST2*HUBMEANEXP-ONE)*EXPH
C             WRITE (*,*) D2H_DUDR
              D3H_DUDR2 = DAMPXHE*HUBMEANEXP1*EXPH
     *          *(DIST2*HUBMEANEXP
     *             *(5.0D+00-TWO*DIST2*HUBMEANEXP)-ONE)
C             WRITE (*,*) "D3H_DUDR2 = ", D3H_DUDR2
C             WRITE (*,*) GAMTMP*EXPH,-DS_DU*DH_DR*3.2D+00,
C    *        -DS_DR*DH_DU
C             WRITE (*,*) -S*D2H_DUDR
              GAMTMP = -D2S_DUDR*EXPH-DS_DU*DH_DR
     *          -DS_DR*DH_DU-S*D2H_DUDR
C             D2S_DR2 = D2S_DR
              GAMTMP3 = -D3S_DUDR2*EXPH-TWO*D2S_DUDR*DH_DR
     *          -TWO*DS_DR*D2H_DUDR-DS_DU*D2H_DR2-D2S_DR2*DH_DU
     *          -S*D3H_DUDR2
            END IF
C           GAMTMP = 3.2D+00*GAMTMP !! /3.0D+00
C           GAMTMP3 = 3.2D+00*GAMTMP3 !! /3.0D+00
            GRAD3 = GAMTMP*HUBDER
            HESS3 = GAMTMP3*HUBDER
C           WRITE (*,*) "i,j = ",i ,j
C           write (*,*) gamtmp*HUBDER(NSP1),GAMTMP3*HUBDER(NSP1)
          END IF
        END IF
C       WRITE (*,'(I3,X,I3,X,F12.6,X,F12.6)')
C    *    1,1,GRAD2,HESS2
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_GAMHESSF
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate second-order geometrical derivative of gamma
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Bug fix
C>
C>           --- INPUT ---
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param HUBBL Shell-resolved Hubbar values
C>    @param HUBDER Hubbard derivatives
C>    @param DAMPXHE Exponent of X-H damping function
C>    @param ISPE Index of species
C>    @parma MAXANG Maximum angular momentum of each species
C>    @param NAT Number of atoms
C>    @param Number of species
C>    @param Number of shells
C>    @param NDIMGAM Dimension of gamma
C>    @param NN 
C>    @param SPE Name of species
C>    @param DFTB3 Whether DFTB3 or not
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param DAMPXH Whether H-X damping is used or not
C>           --- OUTPUT ---
C>    @param GRAD2 1st-order derivative of DFTB2 gamma
C>    @param HESS2 2nd-order derivative of DFTB2 gamma
C>    @param GRAD3 1st-order derivative of DFTB3 gamma
C>    @param HESS3 2nd-order derivative of DFTB3 gamma
C>
C
      SUBROUTINE DFTB_CALC_GAM_DER2(GRAD2,HESS2,GRAD3,HESS3,DISTMAT,
     *  HUBBL,HUBDER,DAMPXHE,ISPE,MAXANG,NAT,NSPE,NSHELL,NDIMGAM,NN,
     *  SPE,DFTB3,SRSCC,DAMPXH)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NSPE,ISPE(NAT),MAXANG(NSPE),NSHELL,
     *  NDIMGAM,NN
      DOUBLE PRECISION, INTENT(INOUT) :: GRAD2(*),HESS2(*),
     *  GRAD3(NDIMGAM,NDIMGAM),HESS3(NDIMGAM,NDIMGAM)
      DOUBLE PRECISION, INTENT(IN) :: DISTMAT(*),HUBBL(3,NSPE),DAMPXHE,
     *  HUBDER(*),SPE(*)
      LOGICAL, INTENT(IN) :: DFTB3,SRSCC,DAMPXH
C
      INTEGER :: I,II,ISH,J,JJ,JSH,NSP1,NSP2,NSEQ,ISHELL(NSHELL),
     *  IND(NSPE),ISH0,JSH0
      DOUBLE PRECISION :: HUBA,HUBB,HUBDERTMP,DIST,CHARA1,CHARA2,
     *  TMP(11,NN,NN)
      LOGICAL :: HDAMP
      DOUBLE PRECISION H/8HH       /
C
      CALL VCLR(TMP,1,11*NN*NN)

      IF (SRSCC) THEN
        IND(1) = 0
        DO I = 2, NSPE
          IND(I) = IND(I-1) + MAXANG(I-1) !MAXANG(ISPE(I-1))
        END DO
        ISH = 0
        JSH = 0
        DO I = 1, NAT
          JSH = IND(ISPE(I))
          DO J = 1, MAXANG(ISPE(I))
            ISH = ISH + 1
            ISHELL(ISH) = JSH + J
          END DO
        END DO
        ISH = 0
        DO I = 1, NSPE
          DO II = 1, MAXANG(I)
            ISH = ISH + 1
            HUBA = HUBBL(II,I)
            JSH = 0
            DO J = 1, NSPE
              DO JJ = 1, MAXANG(J)
                JSH = JSH + 1
                HUBB = HUBBL(JJ,J)
                CALL DFTB_PREP_GAMMA_HESS(HUBA,HUBB,TMP(1,ISH,JSH),
     *            DFTB3,DAMPXH)
              END DO
            END DO
          END DO
        END DO
C
        ISH0 = 0
        DO I = 1, NAT
          NSP1 = ISPE(I)
          CHARA1 = SPE(ISPE(I))
          JSH0 = 0
          DO J = 1, NAT
            NSP2 = ISPE(J)
            CHARA2 = SPE(ISPE(J))
            CALL DFTB_CNVSQ(I,J,NSEQ)
            DIST = DISTMAT(NSEQ)
            IF (DAMPXH.AND.(CHARA1.EQ.H.OR.CHARA2.EQ.H)) THEN
              HDAMP = .TRUE.
            ELSE
              HDAMP = .FALSE.
            END IF
            DO II = 1, MAXANG(ISPE(I))
              ISH = ISH0 + II
              HUBA = HUBBL(II,ISPE(I))
              NSP1 = ISHELL(ISH)
              HUBDERTMP = HUBDER(NSP1)
              DO JJ = 1, MAXANG(ISPE(J))
                JSH = JSH0 + JJ
                HUBB = HUBBL(JJ,ISPE(J))
                NSP2 = ISHELL(JSH)
C               WRITE (*,*) I, J
                CALL DFTB_CNVSQ(ISH,JSH,NSEQ)
                CALL DFTB_GAMHESSF(GRAD2(NSEQ),HESS2(NSEQ),
     *            GRAD3(ISH,JSH),HESS3(ISH,JSH),HUBA,HUBB,HUBDERTMP,
     *            DIST,DAMPXHE,TMP(1,NSP1,NSP2),DFTB3,HDAMP)
C      write (*,'(6i3,f20.10)') i,j,ish,jsh,nsp1,nsp2,gamma(nseq)
C       WRITE (*,'(I3,X,I3,X,I3,F20.10,X,F20.10)')
C    *    ISH,JSH,NSEQ,GRAD2(NSEQ),HESS2(NSEQ)
              END DO
            END DO
            JSH0 = JSH0 + MAXANG(ISPE(J))
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(I))
        END DO
      ELSE
        DO I = 1, NSPE
          HUBA  = HUBBL(1,I)
          DO J = 1, NSPE
            HUBB = HUBBL(1,J)
C           WRITE (*,*) I,J
            CALL DFTB_PREP_GAMMA_HESS(HUBA,HUBB,TMP(1,I,J),DFTB3,DAMPXH)
C             write (*,'(x,f20.10)') tmp(1,i,j)
C             write (*,'(x,f20.10)') tmp(2,i,j)
C             write (*,'(x,f20.10)') tmp(3,i,j)
C             write (*,'(x,f20.10)') tmp(4,i,j)
C             write (*,'(x,f20.10)') tmp(5,i,j)
C             write (*,'(x,f20.10)') tmp(6,i,j)
C             write (*,'(x,f20.10)') tmp(7,i,j)
C             write (*,'(x,f20.10)') tmp(8,i,j)
C             write (*,'(x,f20.10)') tmp(9,i,j)
C             write (*,'(x,f20.10)') tmp(10,i,j)
C             write (*,'(x,f20.10)') tmp(11,i,j)
C             write (*,*)
          END DO
        END DO
C
        DO I = 1, NAT
          NSP1 = ISPE(I)
          HUBA = HUBBL(1,NSP1)
          CHARA1 = SPE(ISPE(I))
          HUBDERTMP = HUBDER(NSP1)
          DO J = 1, NAT !! I
C           WRITE (*,*) I,J
            NSP2 = ISPE(J)
            HUBB = HUBBL(1,NSP2)
            CHARA2 = SPE(ISPE(J))
            CALL DFTB_CNVSQ(I,J,NSEQ)
            DIST = DISTMAT(NSEQ)
            IF (DAMPXH.AND.(CHARA1.EQ.H.OR.CHARA2.EQ.H)) THEN
              HDAMP = .TRUE.
            ELSE
              HDAMP = .FALSE.
            END IF
            CALL DFTB_GAMHESSF(GRAD2(NSEQ),HESS2(NSEQ),GRAD3(I,J),
     *        HESS3(I,J),HUBA,HUBB,HUBDERTMP,DIST,DAMPXHE,
     *        TMP(1,NSP1,NSP2),DFTB3,HDAMP)
C       WRITE (*,'(I3,X,I3,X,F12.6,X,F12.6)')
C    *    I,J,GRAD2(NSEQ),HESS2(NSEQ)
          END DO
        END DO
      END IF
C
      END SUBROUTINE DFTB_CALC_GAM_DER2
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_GAM_DER2
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate Hessian contribution of the second-order
C>             derivative of gamma values
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Feb, 2016 - Yoshio Nishimoto
C>    - Added DFTB3 with SRSCC
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NSPE Number of species
C>    @param HUBBL Shell-resolved Hubbar values
C>    @param C Coordinates
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param CHAMUL Atom-reslve mulliken charges
C>    @parma HESSIAN Hessian
C>    @param DFTB3 Whether DFTB3 or not
C>    @param HUBDER Hubbard derivatives
C>    @param DAMPXHE Exponent of X-H damping function
C>    @param ISPE Index of species
C>    @parma MAXANG Maximum angular momentum of each species
C>    @param NSHELL Number of shells
C>    @param NDIMGAM Dimension of gamma
C>    @param NN
C>    @param SPE Name of species
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param DAMPXH Whether H-X damping is used or not
C>           --- OUTPUT ---
C>    @param GRADMAT 1st-order derivative of DFTB2 gamma
C>    @param HESSMAT 2nd-order derivative of DFTB2 gamma
C>    @param GRADMAT3 1st-order derivative of DFTB3 gamma
C>    @param HESSMAT3 2nd-order derivative of DFTB3 gamma
C>
C
      SUBROUTINE DFTB_GAM_DER2(NAT,NSPE,HUBBL,C,DISTMAT,GRADMAT,HESSMAT,
     *  GRADMAT3,HESSMAT3,CHAMUL,HESSIAN,DFTB3,HUBDER,DAMPXHE,ISPE,
     *  MAXANG,NSHELL,NDIMGAM,NN,SPE,SRSCC,DAMPXH,CHAMULAT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NSPE,ISPE(NAT),MAXANG(NSPE),NSHELL,
     *  NDIMGAM,NN
      DOUBLE PRECISION, INTENT(IN) :: HUBBL(3,NSPE),C(3,*),DISTMAT(*),
     *  CHAMUL(*),HUBDER(NSPE),DAMPXHE,SPE(*),CHAMULAT(*)
      DOUBLE PRECISION, INTENT(OUT) :: GRADMAT(*),HESSMAT(*),
     *  GRADMAT3(NDIMGAM,NDIMGAM),HESSMAT3(NDIMGAM,NDIMGAM)
      DOUBLE PRECISION, INTENT(INOUT) :: HESSIAN(3*NAT,3*NAT)
      LOGICAL, INTENT(IN) :: DFTB3,SRSCC,DAMPXH
C
      INTEGER :: I,J,K,NI,NJ,NK,ISH,ISH0,JSH,JSH0,KSH,KSH0,KK,KI,KJ,IR,
     *  JR,NSEQ
      DOUBLE PRECISION :: VEC(3),CHAMUL1,CHAMUL2,HESS_TMP,DIST,DISTI,
     *  GRAD,HESS,GRAD3C,GRAD3A,HESS3C,HESS3A,HESS_TMPA,HESS_TMPC
      DOUBLE PRECISION, PARAMETER :: ONE=1.0D+00,ONE_THIRD=ONE/3.0D+00
C
C     CALL DFTB_CALC_GAM_DER2(HUBBL,DISTMAT,GRADMAT,HESSMAT,GRADMAT3,
C    *  HESSMAT3)
      CALL DFTB_CALC_GAM_DER2(GRADMAT,HESSMAT,GRADMAT3,HESSMAT3,DISTMAT,
     *  HUBBL,HUBDER,DAMPXHE,ISPE,MAXANG,NAT,NSPE,NSHELL,NDIMGAM,NN,SPE,
     *  DFTB3,SRSCC,DAMPXH)
C     do i = 1, nshell
C       do j = 1, nshell
C        call DFTB_CNVSQ(i,j,nseq)
C       write (*,'(3i3,2f20.10)') i,j,nseq,gradmat(nseq),hessmat(nseq)
C     end do
C     end do
C
      IF (SRSCC) THEN
        ISH0 = 0
        DO NI = 1, NAT !! A
          DO I = 1, MAXANG(ISPE(NI))
            ISH = ISH0 + I
            CHAMUL1 = CHAMUL(ISH)
            JSH0 = 0
            DO NJ = 1, NAT !! B
              IF (NI.EQ.NJ) THEN
                KSH0 = 0
                DO NK = 1, NAT !! C
                  IF (NI.EQ.NK) THEN
                    KSH0 = KSH0 + MAXANG(ISPE(NK))
                    CYCLE
                  END IF
                  CALL DFTB_CNVSQ(NI,NK,NSEQ)
                  DIST = DISTMAT(NSEQ)
                  DISTI = ONE/DIST
                  DO K = 1, MAXANG(ISPE(NK))
                    KSH = KSH0 + K
                    CHAMUL2 = CHAMUL(KSH)
                    CALL DFTB_CNVSQ(ISH,KSH,NSEQ)
                    GRAD = GRADMAT(NSEQ)
                    HESS = HESSMAT(NSEQ)
C                   write (*,'(3i3,2f20.10)') ish,ksh,nseq,grad,hess
                    IF (DFTB3) THEN
                      GRAD3C = GRADMAT3(KSH,ISH)
                      GRAD3A = GRADMAT3(ISH,KSH)
                      HESS3C = HESSMAT3(KSH,ISH)
                      HESS3A = HESSMAT3(ISH,KSH)
                    END IF
                    DO KK = 1, 3
                      VEC(KK) = C(KK,NI) - C(KK,NK)
                      VEC(KK) = VEC(KK)*DISTI
                    END DO
                    DO KI = 1, 3
                      IR = 3*(NI-1)+KI
                      DO KJ = 1, 3
                        JR = 3*(NJ-1)+KJ
                        IF (KI.EQ.KJ) THEN
                          HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                      + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                          IF (DFTB3) THEN
                            HESS_TMPA = VEC(KI)*VEC(KJ)*HESS3A
     *                        + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3A
                            HESS_TMPC = VEC(KI)*VEC(KJ)*HESS3C
     *                        + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3C
                          END IF
                        ELSE
                          HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                      - VEC(KI)*VEC(KJ)*DISTI*GRAD
                          IF (DFTB3) THEN
                            HESS_TMPA = VEC(KI)*VEC(KJ)*HESS3A
     *                        - VEC(KI)*VEC(KJ)*DISTI*GRAD3A
                            HESS_TMPC = VEC(KI)*VEC(KJ)*HESS3C
     *                        - VEC(KI)*VEC(KJ)*DISTI*GRAD3C
                          END IF
                        END IF
                        HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *                    + HESS_TMP*CHAMUL1*CHAMUL2
C                       write (*,'(i3,i3,3f20.10)')
C    *                  ir,jr,hess_tmp,chamul1,chamul2
C                       write (*,'(i3,i3,3f20.10)')
C    *                  ir,jr,dist,grad,hess
                        IF (DFTB3) THEN
                          HESSIAN(IR,JR)= HESSIAN(IR,JR)+CHAMUL1*CHAMUL2
     *                      *(CHAMULAT(NI)*HESS_TMPA
     *                      + CHAMULAT(NK)*HESS_TMPC)*ONE_THIRD
C                        HESSIAN(IR,JR) = HESSIAN(IR,JR)+CHAMUL1*CHAMUL2
C    *                    *(CHAMUL1*HESS_TMPA+CHAMUL2*HESS_TMPC)/3.0D+00
C                         WRITE (*,*) HESS_TMPA,HESS_TMPC
                        END IF
                      END DO
                    END DO
                  END DO
                  KSH0 = KSH0 + MAXANG(ISPE(NK))
                END DO
              ELSE
                CALL DFTB_CNVSQ(NI,NJ,NSEQ)
                DIST = DISTMAT(NSEQ)
                DISTI = ONE/DIST
                DO J = 1, MAXANG(ISPE(NJ))
                  JSH = JSH0 + J
                  CHAMUL2 = CHAMUL(JSH)
                  CALL DFTB_CNVSQ(ISH,JSH,NSEQ)
                  GRAD = GRADMAT(NSEQ)
                  HESS = HESSMAT(NSEQ)
                  IF (DFTB3) THEN
                    GRAD3C = GRADMAT3(JSH,ISH)
                    GRAD3A = GRADMAT3(ISH,JSH)
                    HESS3C = HESSMAT3(JSH,ISH)
                    HESS3A = HESSMAT3(ISH,JSH)
                  END IF
                  DO KK = 1, 3
                    VEC(KK) = C(KK,NI) - C(KK,NJ)
                    VEC(KK) = VEC(KK)*DISTI
                  END DO
                  DO KI = 1, 3
                    IR = 3*(NI-1)+KI
                    DO KJ = 1, 3
                      JR = 3*(NJ-1)+KJ
                      IF (KI.EQ.KJ) THEN
                        HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                           - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                        IF (DFTB3) THEN
                          HESS_TMPA = -VEC(KI)*VEC(KJ)*HESS3A
     *                              - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3A
                          HESS_TMPC = -VEC(KI)*VEC(KJ)*HESS3C
     *                              - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3C
                        END IF
                      ELSE
                        HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                           + VEC(KI)*VEC(KJ)*DISTI*GRAD
                        IF (DFTB3) THEN
                          HESS_TMPA = -VEC(KI)*VEC(KJ)*HESS3A
     *                              + VEC(KI)*VEC(KJ)*DISTI*GRAD3A
                          HESS_TMPC = -VEC(KI)*VEC(KJ)*HESS3C
     *                              + VEC(KI)*VEC(KJ)*DISTI*GRAD3C
                        END IF
                      END IF
                      HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *                  + HESS_TMP*CHAMUL1*CHAMUL2
C                       write (*,'(i3,i3,3f20.10)')
C    *                  ir,jr,hess_tmp,chamul1,chamul2
                      IF (DFTB3) THEN
                        HESSIAN(IR,JR)= HESSIAN(IR,JR)+CHAMUL1*CHAMUL2
     *                    *(CHAMULAT(NI)*HESS_TMPA
     *                    + CHAMULAT(NJ)*HESS_TMPC)*ONE_THIRD
C                       HESSIAN(IR,JR) = HESSIAN(IR,JR)+CHAMUL1*CHAMUL2
C    *                  *(CHAMUL1*HESS_TMPA+CHAMUL2*HESS_TMPC)*ONE_THIRD
C                         WRITE (*,*) HESS_TMPA,HESS_TMPC
                      END IF
                    END DO
                  END DO
                END DO
              END IF
              JSH0 = JSH0 + MAXANG(ISPE(NJ))
            END DO
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(NI))
        END DO
      ELSE
        DO NI = 1, NAT !! A
          CHAMUL1 = CHAMUL(NI)
          DO NJ = 1, NAT !! B
            IF (NI.EQ.NJ) THEN
              DO NK = 1, NAT !! C
                IF (NI.EQ.NK) CYCLE
                CHAMUL2 = CHAMUL(NK)
                CALL DFTB_CNVSQ(NI,NK,NSEQ)
                DIST = DISTMAT(NSEQ)
                GRAD = GRADMAT(NSEQ)
                HESS = HESSMAT(NSEQ)
                IF (DFTB3) THEN
                  GRAD3C = GRADMAT3(NK,NI)
                  GRAD3A = GRADMAT3(NI,NK)
                  HESS3C = HESSMAT3(NK,NI)
                  HESS3A = HESSMAT3(NI,NK)
                END IF
                DISTI = ONE/DIST
                DO KK = 1, 3
                  VEC(KK) = C(KK,NI) - C(KK,NK)
                  VEC(KK) = VEC(KK)*DISTI
                END DO
                DO KI = 1, 3
                  IR = 3*(NI-1)+KI
                  DO KJ = 1, 3
                    JR = 3*(NJ-1)+KJ
                    IF (KI.EQ.KJ) THEN
                      HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                         + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                      IF (DFTB3) THEN
                        HESS_TMPA = VEC(KI)*VEC(KJ)*HESS3A
     *                            + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3A
                        HESS_TMPC = VEC(KI)*VEC(KJ)*HESS3C
     *                            + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3C
                      END IF
                    ELSE
                      HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                         - VEC(KI)*VEC(KJ)*DISTI*GRAD
                      IF (DFTB3) THEN
                        HESS_TMPA = VEC(KI)*VEC(KJ)*HESS3A
     *                            - VEC(KI)*VEC(KJ)*DISTI*GRAD3A
                        HESS_TMPC = VEC(KI)*VEC(KJ)*HESS3C
     *                            - VEC(KI)*VEC(KJ)*DISTI*GRAD3C
                      END IF
                    END IF
                    HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *                + HESS_TMP*CHAMUL1*CHAMUL2
C                       write (*,'(i3,i3,3f20.10)')
C    *                  ir,jr,hess_tmp,chamul1,chamul2
                    IF (DFTB3) THEN
                      HESSIAN(IR,JR) = HESSIAN(IR,JR) + CHAMUL1*CHAMUL2
     *                  *(CHAMUL1*HESS_TMPA+CHAMUL2*HESS_TMPC)*ONE_THIRD
C                     WRITE (*,*) HESS_TMPA,HESS_TMPC
                    END IF
                  END DO
                END DO
              END DO
            ELSE
              CHAMUL2 = CHAMUL(NJ)
              CALL DFTB_CNVSQ(NI,NJ,NSEQ)
              DIST = DISTMAT(NSEQ)
              GRAD = GRADMAT(NSEQ)
              HESS = HESSMAT(NSEQ)
              DISTI = ONE/DIST
              IF (DFTB3) THEN
                GRAD3C = GRADMAT3(NJ,NI)
                GRAD3A = GRADMAT3(NI,NJ)
                HESS3C = HESSMAT3(NJ,NI)
                HESS3A = HESSMAT3(NI,NJ)
              END IF
              DO KK = 1, 3
                VEC(KK) = C(KK,NI) - C(KK,NJ)
                VEC(KK) = VEC(KK)*DISTI
              END DO
              DO KI = 1, 3
                IR = 3*(NI-1)+KI
                DO KJ = 1, 3
                  JR = 3*(NJ-1)+KJ
                  IF (KI.EQ.KJ) THEN
                    HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                       - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                    IF (DFTB3) THEN
                      HESS_TMPA = -VEC(KI)*VEC(KJ)*HESS3A
     *                          - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3A
                      HESS_TMPC = -VEC(KI)*VEC(KJ)*HESS3C
     *                          - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3C
                    END IF
                  ELSE
                    HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                       + VEC(KI)*VEC(KJ)*DISTI*GRAD
                    IF (DFTB3) THEN
                      HESS_TMPA = -VEC(KI)*VEC(KJ)*HESS3A
     *                          + VEC(KI)*VEC(KJ)*DISTI*GRAD3A
                      HESS_TMPC = -VEC(KI)*VEC(KJ)*HESS3C
     *                          + VEC(KI)*VEC(KJ)*DISTI*GRAD3C
                    END IF
                  END IF
                  HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *              + HESS_TMP*CHAMUL1*CHAMUL2
C                       write (*,'(i3,i3,3f20.10)')
C    *                  ir,jr,hess_tmp,chamul1,chamul2
                  IF (DFTB3) THEN
                    HESSIAN(IR,JR) = HESSIAN(IR,JR) + CHAMUL1*CHAMUL2
     *                *(CHAMUL1*HESS_TMPA+CHAMUL2*HESS_TMPC)*ONE_THIRD
C                     WRITE (*,*) HESS_TMPA,HESS_TMPC
                  END IF
                END DO
              END DO
            END IF
          END DO
        END DO
      END IF
C
      END SUBROUTINE DFTB_GAM_DER2
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DEDB
C>
C>    @brief   Hessian of DFTB
C>
C>    @details Calculate Hessian contribution of U-dependent terms and
C>             de/db dependent terms
C>
C>    @author  Yoshio Nishimoto
C>             Sep, 2014 - Subroutine written
C>    @date    Feb, 2016 - Yoshio Nishimoto and Hiroya Nakata
C>             - Performance improvement
C>             - Implementation of FMO-DFTB Hessian
C>
C>           --- INPUT ---
C>    @param TSDERAO Working matrix to store the derivative of overlap
C>                   in AO basis
C>    @param THDERMO Working matrix to store H_{ij}^a + V_{ij}^a
C>    @param TSDERMO Working matrix to store S_{ij}^a
C>    @param WRK     Working array
C>    @param H_ES    Working array: store Hij - ei*Sij
C>    @param FDERMO  \sum_{\mu \nu} c_{\mu i} c_{\nu j} dF_{\mu \nu}/dB
C>    @param DEDB    Derivative of eigenvalues of each MO
C>    @param HDERMO  Contains all H_{ij}^a + V_{ij}^a
C>    @param SDERMO  Contains all S_{ij}^a
C>    @param SDERAO  Contains all S_{\mu \nu}/da
C>    @param U       U matrix (derivative of MO coefficients)
C>    @param VEC     MO coefficients
C>    @param D       Density matrix
C>    @param EIG     Eigenvalues of each MO
C>    @param OCC     Occupation number of each MO
C>    @param FONDER  Derivative of occupatin numbers
C>    @param DOMEGA  Derivatives of shift contribution in atom basis
C>    @param SDERMOJ S_{ij}^b
C>    @parma SHIFT   Shift contribution (atom-resolved)
C>    @param SHIFTSA Shift contribution of alpha orbitals (shell-res.)
C>    @param SHIFTSB Shift contribution of beta  orbitals (shell-res.)
C>    @param C       Coordinates
C>    @param BETA    1/kT
C>    @param EFERMI  Fermi level
C>    @param DEGTHR1 Near degenerate threshold
C>    @param DEGTHR2 Quasi-degenerate threshold
C>    @param NAT     Number of atoms
C>    @param L0      NQMT
C>    @param L1      Number of basis functions
C>    @param L2      L1*(L1+1)/2
C>    @param NSPIN   Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param NDIMSH  If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param NDOCC   Number of doubly occupied orbitals
C>    @param NPART   Number of partially occupied orbitals
C>    @param NSPE    Number of species
C>    @param ISPE    Index of species
C>    @parma MAXANG  Maximum angular momentum of each species
C>    @param IND     AO index of each atom
C>    @param INDSH   Index of shell for each atom
C>    @param INDSAO  AO index of each shell
C>    @param IRAF    20
C>    @param IORA    Status of .F20
C>    @param ID_HDERMO,ID_SDERMO,ID_SDERAO IDs of HDERIJ,SDERIJ,SDER
C>                   stored on DDI memory pool.
C>    @param IDW     ID_WORLD (GDDI)
C>    @param INDP    AO index of given independent pair
C>    @param NVEC    Number of vectors to be calcualted in the call
C>    @param INDVEC  Index of vectors
C>    @param SCC     Whether SCC or not
C>    @param DISK    Whether disk-based algorithm or not
C>    @param FON     Whether fractional occupation or not
C>    @param ROHF    Whether (same-electron) RO-DFTB or not
C>    @param SRSCC   Whether shell-resolved SCC or not
C>    @param UHF     Whether U-DFTB or not
C>    @param DIRECT  Integral direct ... meaningless option now
C>    @param ISGDDI  Group DDI or not
C>    @param MASWRK  MASWRK
C>    @param SOME    Some output
C>    @param PARALL3 Logic of parallel
C>           --- OUTPUT ---
C>    @param FONCON  Square of FON contribution
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_DEDB(HESSIAN,TSDERAO,THDERMO,TSDERMO,WRK,
     *  H_ES,FDERMO,DEDB,
     *  HDERMO,SDERMO,SDERAO,U,VEC,D,EIG,OCC,
     *  FONDER,DOMEGA,SDERMOJ,SHIFT,SHIFTSA,
     *  SHIFTSB,C,FONCON,BETA,EFERMI,DEGTHR1,DEGTHR2,
     *  NAT,L0,L1,L2,NSPIN,NDIMSH,NDOCC,NPART,
     *  NSPE,ISPE,MAXANG,IND,INDSH,INDSAO,IRAF,IORA,ID_HDERMO,
     *  ID_SDERMO,ID_SDERAO,IDW,INDP,NVEC,NDIM,INDVEC,
     *  SCC,DISK,FON,ROHF,SRSCC,UHF,DIRECT,ISGDDI,MASWRK,SOME,
     *  PARALL3)
C
      IMPLICIT NONE
C
      COMMON /FMCOM / X(1)
      DOUBLE PRECISION :: X
C
      INTEGER, INTENT(IN) :: NAT,L0,L1,L2,NSPIN,NDIMSH,NDOCC(2),
     *  NPART(2),NSPE,
     *  ISPE(NAT),MAXANG(NSPE),IND(*),INDSH(*),INDSAO(*),IRAF,
     *  IORA(3*NAT*5),ID_HDERMO,ID_SDERMO,ID_SDERAO,IDW,
     *  INDP((NDOCC(1)+NPART(1))*L1,NSPIN),NVEC,NDIM,INDVEC(NVEC)
      DOUBLE PRECISION, INTENT(INOUT) :: HESSIAN(3*NAT,*),
     *  TSDERAO(L2),THDERMO(L2),TSDERMO(L2),WRK(L2),H_ES(*),
     *  FDERMO(L2,NSPIN,NVEC),DEDB(L1,NSPIN,NVEC),FONCON
      DOUBLE PRECISION, INTENT(IN) :: HDERMO(L2,3,NAT,NSPIN),
     *  SDERMO(L2,3,NAT,NSPIN),SDERAO(L2,3,NAT),U(L1,NDIM,NSPIN,NVEC),
     *  VEC(L1,L1,NSPIN),D(L2,NSPIN),EIG(L1,NSPIN),OCC(L1,NSPIN),
     *  FONDER(L1,NSPIN,NVEC),DOMEGA(NDIMSH,NSPIN,NVEC),
     *  SDERMOJ(L2,NSPIN,NVEC),
     *  SHIFT(NAT),SHIFTSA(NDIMSH),SHIFTSB(NDIMSH),C(3,NAT),BETA,EFERMI,
     *  DEGTHR1,DEGTHR2
      LOGICAL, INTENT(IN) :: SCC,DISK,FON(3),ROHF,SRSCC,UHF,DIRECT,
     *  ISGDDI,MASWRK,SOME,PARALL3
C
      INTEGER :: IO,MO,NSEQ,ISPIN,
     *  N2,IRA1,IRA2,IRA3,IRA4,IRA5,IR,NI,KI,N,NN,LOADFM,LWRK,LWRK1,
     *  LWRK2,LWRK3,LAST,NEED,IVEC
      DOUBLE PRECISION :: EI,EJ,OCCI,OCCJ,TMP,TMP2,VAL,AAA,FONTMP(2),
     *  SCAL,BETAINV,DDOT,XDOT,TRACEP
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,TWO=2.0D+00
      LOGICAL :: PART
C
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      INTEGER :: nfg,nlayer,natfmo,nbdfg,naotyp,nbody
C
C     CALCULATE CONTRIBUTIONS OF U-DEPENDENT TERMS AND DE/DB DEPENDENT
C     TERMS
C
C     FOR FON, FONDER (LDNDR) SHOULD BE CALCULATED
C     OUTSIDE THIS SUBROUTINE (IN DFTB_CALC_DNDR)
C
      IRA1 = 0
      IRA2 = IRA1 + 3*NAT
      IRA3 = IRA2 + 3*NAT
      IRA4 = IRA3 + 3*NAT
      IRA5 = IRA4 + 3*NAT
C
C     CALCULATE CONTRIBUTIONS.
C     D.O. (NDOCC) = DOUBLE OCCUPIED (OR SINGLY OCCUPIED FOR UHF)
C     P.O. (NPART) = PARTLY OCCUPIED
C     U.O. (NVIRT) = UNOCCUPIED (VIRTUAL ORBITALS)
C
      IF (SCC) CALL VCLR(WRK,1,L2)
      IF (DIRECT) THEN
        CALL VALFM(LOADFM)
        LWRK  = LOADFM + 1
        LWRK1 = LWRK   + L2
        LWRK2 = LWRK1  + L2
        LWRK3 = LWRK2  + L1*L1
        LAST  = LWRK3  + L1*L1
        NEED  = LAST - LOADFM - 1
        CALL GETFM(NEED)
      ELSE IF (ISGDDI) THEN
        CALL VALFM(LOADFM)
        LWRK  = LOADFM + 1
        LWRK1 = LWRK   + L2*3*NSPIN
        LWRK2 = LWRK1  + L2*3*NSPIN
        LAST  = LWRK2  + L2*3
        NEED  = LAST - LOADFM - 1
        CALL GETFM(NEED)
      END IF
C
      SCAL = 1.0D+00
      IF (NVEC.EQ.1.AND..NOT.MASWRK) SCAL = ZERO
      IF (FON(3)) BETAINV = 1.0D+00/BETA
C
      IR = 0
      DO NI = 1, NAT
        IF (ISGDDI.AND..NOT.DISK) THEN
         IF (SCC) CALL DDI_GET_COMM(ID_SDERAO,1,L2*3,NI,NI,X(LWRK2),IDW)
          CALL DDI_GET_COMM(ID_HDERMO,1,L2*3*NSPIN,NI,NI,X(LWRK),IDW)
          CALL DDI_GET_COMM(ID_SDERMO,1,L2*3*NSPIN,NI,NI,X(LWRK1),IDW)
        END IF
        DO KI = 1, 3
          IR = IR + 1
          VAL = ZERO
          IF (DISK) THEN
            IRA1 = IRA1 + 1
            IRA2 = IRA2 + 1
            IRA3 = IRA3 + 1
            IRA4 = IRA4 + 1
            IRA5 = IRA5 + 1
          END IF
          !! DO SDERAO WORK FIRST
          IF (SCC) THEN
            IF (DISK) THEN
              CALL RAREAD(IRAF,IORA,TSDERAO,L2,IRA3,0)
            ELSE IF (ISGDDI) THEN
              CALL DCOPY(L2,X(LWRK2+L2*(KI-1)),1,TSDERAO,1)
            ELSE IF (DIRECT) THEN
              CALL DFTB_HESS_DIRECT(THDERMO,TSDERMO,TSDERAO,C,
     *          VEC,SHIFT,SHIFTSA,SHIFTSB,X(LWRK),X(LWRK1),X(LWRK2),
     *          X(LWRK3),NI,KI,NAT,L0,L1,L2,IND,NDIMSH,NSPE,NSPIN,INDSH,
     *          INDSAO,ISPE,MAXANG,SCC,SRSCC,UHF)
            ELSE
              CALL DCOPY(L2,SDERAO(1,KI,NI),1,TSDERAO,1)
            END IF
            TMP = ZERO
            !! CALCULATE DELTA OMEGA TERM
            DO IVEC = 1, NVEC
              TMP = ZERO
              DO ISPIN = 1, NSPIN
                IF (SRSCC.OR.UHF) THEN
                  IF (ISGDDI.AND..NOT.DISK) THEN
                    CALL SHIFT_TRIANGLE_DER_SHELL(NAT,NI,L2,IND,INDSH,
     *                INDSAO,NSPE,ISPE,MAXANG,DOMEGA(1,ISPIN,IVEC),
     *                X(LWRK2+L2*(KI-1)),WRK)
                  ELSE
                    CALL SHIFT_TRIANGLE_DER_SHELL(NAT,NI,L2,IND,INDSH,
     *                INDSAO,NSPE,ISPE,MAXANG,DOMEGA(1,ISPIN,IVEC),
     *                TSDERAO,WRK)
                  END IF
                ELSE
                  IF (ISGDDI.AND..NOT.DISK) THEN
                    CALL SHIFT_TRIANGLE_DER(NAT,NI,L2,IND,
     *                DOMEGA(1,ISPIN,IVEC),X(LWRK2+L2*(KI-1)),WRK)
                  ELSE
                    CALL SHIFT_TRIANGLE_DER(NAT,NI,L2,IND,
     *                DOMEGA(1,ISPIN,IVEC),TSDERAO,WRK)
                  END IF
                END IF
                CALL DDOT_DER(NAT,NI,L2,IND,TMP,D(1,ISPIN),WRK)
                CALL SHIFT_TRIANGLE_DER_CLEAR(NAT,NI,L2,IND,WRK)
              END DO
              !! INITIALIZE WRK ARRAY
              !! NOTE THAT DIAGONAL PART IS ZERO.
              VAL = TMP * TWO
              VAL = VAL*SCAL
              IF (PARALL3) THEN
                HESSIAN(IR,INDVEC(IVEC))
     *            = HESSIAN(IR,INDVEC(IVEC)) + VAL
              ELSE IF (ISGDDI) THEN
                HESSIAN(IR,IVEC+INDVEC(IVEC))
     *            = HESSIAN(IR,IVEC+INDVEC(IVEC)) + VAL
              ELSE
                HESSIAN(IR,IVEC) = HESSIAN(IR,IVEC) + VAL
              END IF
            END DO
          END IF
          !! READ ONLY SDERMO
          DO ISPIN = 1, NSPIN
            IF (ISGDDI.AND..NOT.DISK) THEN
              CALL DCOPY(L2,X(LWRK+L2*(KI-1)+L2*3*(ISPIN-1)),1,
     *                   THDERMO,1)
              CALL DCOPY(L2,X(LWRK1+L2*(KI-1)+L2*3*(ISPIN-1)),1,
     *                   TSDERMO,1)
            ELSE IF (DISK) THEN
              IF (ISPIN.EQ.1) THEN
                CALL RAREAD(IRAF,IORA,THDERMO,L2,IRA1,0)
                CALL RAREAD(IRAF,IORA,TSDERMO,L2,IRA2,0)
              ELSE
                CALL RAREAD(IRAF,IORA,THDERMO,L2,IRA4,0)
                CALL RAREAD(IRAF,IORA,TSDERMO,L2,IRA5,0)
              END IF
            ELSE IF (.NOT.DIRECT) THEN
              CALL DCOPY(L2,HDERMO(1,KI,NI,ISPIN),1,THDERMO,1)
              CALL DCOPY(L2,SDERMO(1,KI,NI,ISPIN),1,TSDERMO,1)
            END IF
C
            !! CALCULATE DEDB TERM FIRST
            DO IVEC = 1, NVEC
              VAL = ZERO
              IF(NFG.EQ.0) THEN
                !! CALCULATE DEDB TERM FIRST
                NSEQ = 0
                DO IO = 1, NDOCC(ISPIN)+NPART(ISPIN)
                  NSEQ = NSEQ + IO
                  VAL = VAL-DEDB(IO,ISPIN,IVEC)*OCC(IO,ISPIN)
     *              *TSDERMO(NSEQ)
                END DO
                !! THEN, CALCULATE CONTRIBUTIONS OF D.O.-D.O. SPACE
                TMP = TRACEP(TSDERMO,FDERMO (1,ISPIN,IVEC),NDOCC(ISPIN))
     *              + TRACEP(THDERMO,SDERMOJ(1,ISPIN,IVEC),NDOCC(ISPIN))
                VAL = VAL - TMP*OCC(1,ISPIN)
              ELSE
                NN = NDOCC(ISPIN)*(NDOCC(ISPIN)+1)/2
                CALL DCOPY(NN,TSDERMO,1,H_ES,1)
                NSEQ = 1
                !! H_ES: (Ei+Ej)*Sij
                DO IO = 1, NDOCC(ISPIN)
                  EI = EIG(IO,ISPIN)
                  DO N = 1, IO-1
                    EJ = EIG(N,ISPIN)
                    H_ES(NSEQ) = (EI+EJ)*H_ES(NSEQ)
                    NSEQ = NSEQ + 1
                  END DO
                  H_ES(NSEQ) = EI*H_ES(NSEQ)
                  NSEQ = NSEQ + 1
c                 write(6,'("IOCHK=",I3,F8.4)') IO,OCC(IO,ISPIN) 
                END DO
                VAL = VAL + OCC(1,ISPIN)*
     *             (DDOT(NN,H_ES,1,SDERMOJ(1,ISPIN,IVEC),1)
     *            - DDOT(NN,TSDERMO,1,FDERMO(1,ISPIN,IVEC),1)
     *            - TRACEP(SDERMOJ(1,ISPIN,IVEC),THDERMO,NDOCC(ISPIN)))
              END IF
C
              !! PREPARE Hij - Ei*Sij
              N2 = 1
              DO IO = 1, NDOCC(ISPIN)
                EI = EIG(IO,ISPIN)
                DO MO = NDOCC(ISPIN)+1, L1
                  NSEQ = INDP(N2,ISPIN)
                  H_ES(N2) = THDERMO(NSEQ)-EI*TSDERMO(NSEQ)
                  N2 = N2 + 1
                END DO
              END DO
              DO IO = NDOCC(ISPIN)+1, NDOCC(ISPIN)+NPART(ISPIN)
                EI = EIG(IO,ISPIN)
                DO MO = 1, L1
                  NSEQ = INDP(N2,ISPIN)
                  H_ES(N2) = THDERMO(NSEQ)-EI*TSDERMO(NSEQ)
                  N2 = N2 + 1
                END DO
              END DO
C
              !! CALCULATE ALL U-TERMS
              !! FIRST COUPLING BETWEEN D.O.-P.O AND D.O.-U.O
              NSEQ = 1
              TMP2 = ZERO
              DO IO = 1, NDOCC(ISPIN)
                TMP2 = TMP2 + DDOT(L1-NDOCC(ISPIN),
     *            U(NDOCC(ISPIN)+1,IO,ISPIN,IVEC),1,H_ES(NSEQ),1)
                NSEQ = NSEQ + L1-NDOCC(ISPIN)
              END DO
              VAL = VAL + TMP2*TWO*OCC(1,ISPIN)
C
              N2 = 1 + NDOCC(ISPIN)*(L1-NDOCC(ISPIN))
              !! IF W/O FON, ALL CONTRIBUTIONS HAVE BEEN DONE
              !! THEN COUPLING BETWEEN P.O.-D.O, P.O.-P.O, P.O.-U.O.
              DO IO = NDOCC(ISPIN)+1, NDOCC(ISPIN)+NPART(ISPIN)
                EI = EIG(IO,ISPIN)
                OCCI = OCC(IO,ISPIN)
                TMP = ZERO
                TMP2 = ZERO
                DO MO = 1, L1 !! ORIGINAL
                  NSEQ = INDP(N2,ISPIN)
                  EJ = EIG(MO,ISPIN)
                  OCCJ = OCC(MO,ISPIN)
                  PART = MO.GT.NDOCC(ISPIN) .AND.
     *                   MO.LE.NDOCC(ISPIN)+NPART(ISPIN)
                  IF (IO.EQ.MO) THEN !!.OR.OCCI.EQ.ONE.AND.OCCJ.EQ.ONE) THEN
                    TMP = TMP - SDERMOJ(NSEQ,ISPIN,IVEC)*H_ES(N2)
                  ELSE IF (ABS(EJ-EI).LE.DEGTHR1.AND.PART) THEN
                    IF (OCCI.EQ.OCCJ.AND..NOT.FON(3)) THEN !! FOR ROHF
                      TMP = TMP - TSDERMO(NSEQ)*FDERMO(NSEQ,ISPIN,IVEC)
     *                    - THDERMO(NSEQ)*SDERMOJ(NSEQ,ISPIN,IVEC)
                    ELSE IF (ABS(EJ-EI).GE.DEGTHR2.AND.MO.GT.IO) THEN
                      !! AVOID EXPLICIT CALCULATION OF
                      !! NEARLY-DEGENERATED PAIRS.
                      !! IF MO.LT.IO, U ELEMENT IS ZERO, SO SKIP IT.
                      AAA =
     *                  (U(MO,IO,ISPIN,IVEC)+SDERMOJ(NSEQ,ISPIN,IVEC))
     *                  *(OCCJ*EJ-OCCI*EI)/(OCCJ-OCCI)
     *                  - EI*SDERMOJ(NSEQ,ISPIN,IVEC)
                      TMP2 = TMP2 + U(MO,IO,ISPIN,IVEC)*THDERMO(NSEQ)
     *                  - AAA*TSDERMO(NSEQ)
                    ELSE IF (MO.GT.IO) THEN
                      !! QUASI-DEGENERATED PAIRS, DO MACLAURIN EXPANSION
                      AAA =
     *                  (U(MO,IO,ISPIN,IVEC)+SDERMOJ(NSEQ,ISPIN,IVEC))
     *                  *(EI-BETAINV*(1.0D+00+EXP((EFERMI-EI)*BETA)))
     *                  - EI*SDERMOJ(NSEQ,ISPIN,IVEC)
                      TMP2 = TMP2 + U(MO,IO,ISPIN,IVEC)*THDERMO(NSEQ)
     *                  - AAA*TSDERMO(NSEQ)
                    END IF
                  ELSE
                    TMP2 = TMP2 + U(MO,IO,ISPIN,IVEC)*H_ES(N2)
                  END IF
                  N2 = N2 + 1
                END DO
                VAL = VAL + (TMP+TMP2*TWO)*OCC(IO,ISPIN)
              END DO
              IF (FON(ISPIN).AND..NOT.ROHF) THEN
                FONTMP(ISPIN) = ZERO
                NSEQ = NDOCC(ISPIN)*(NDOCC(ISPIN)+1)/2
                DO IO = NDOCC(ISPIN)+1, NDOCC(ISPIN)+NPART(ISPIN)
                  NSEQ = NSEQ + IO
                  TMP = (THDERMO(NSEQ)-EIG(IO,ISPIN)*TSDERMO(NSEQ))
     *              *FONDER(IO,ISPIN,IVEC)
                  VAL = VAL + TMP
                  FONTMP(ISPIN) = FONTMP(ISPIN) + TMP
                END DO
                FONTMP(ISPIN) = FONTMP(ISPIN)*SCAL
                IF (ISPIN.EQ.1) THEN
                  FONCON = FONCON + FONTMP(1)*FONTMP(1)
                ELSE
                  FONCON = FONCON + FONTMP(2)*FONTMP(2)
     *                   + TWO*FONTMP(1)*FONTMP(2)
                END IF
              END IF
              VAL = VAL*SCAL
              IF (PARALL3) THEN
                HESSIAN(IR,INDVEC(IVEC))
     *            = HESSIAN(IR,INDVEC(IVEC)) + VAL
              ELSE IF (ISGDDI) THEN
                HESSIAN(IR,IVEC+INDVEC(IVEC))
     *            = HESSIAN(IR,IVEC+INDVEC(IVEC)) + VAL
              ELSE
                HESSIAN(IR,IVEC) = HESSIAN(IR,IVEC) + VAL
              END IF
            END DO !! END OF NVEC LOOP
          END DO !! END OF SPIN LOOP
        END DO
      END DO
C
      IF (DIRECT.OR.ISGDDI) CALL RETFM(NEED)
C
      RETURN
C
      END SUBROUTINE DFTB_DEDB
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DDOT_DER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate vector multiplication.  Either MAT1 or MAT2
C>             should be a derivative matrix, then most matrix elements
C>             will be trivial, and this subroutine will hopefully be
C>             faster than ordinary DDOT (function).
C>
C>    @author  Yoshio Nishimoto
C>             - Sep, 2014 - Subroutine written
C>    @date    Feb, 2016 - Hiroya Nakata
C>             - Added FMO-DFTB Hessian
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NI Atom differentiated
C>    @param L2 L1*(L1+1)/2
C>    @param IND AO index of each atom
C>    @param MAT1,MAT2 Vecotrs to be multiplied
C>           --- OUTPUT ---
C>    @param VALUE Result of dot product
C>
C
      SUBROUTINE DDOT_DER(NAT,NI,L2,IND,VALUE,MAT1,MAT2)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,L2,IND(*)
      DOUBLE PRECISION, INTENT(IN) :: MAT1(L2),MAT2(L2)
      DOUBLE PRECISION, INTENT(INOUT) :: VALUE
C
      INTEGER :: L,M,MU,NU,NSEQ,NJ
C
      IF (NI.EQ.1) GO TO 100
C
      NSEQ = IND(NI)*(IND(NI)+1)/2
      DO M = 1, IND(NI+1)-IND(NI)
        MU = IND(NI)+M
        DO NJ = 1, NI-1
          DO L = 1, IND(NJ+1) - IND(NJ)
            NU = IND(NJ)+L
            NSEQ = NSEQ + 1
            VALUE = VALUE + MAT1(NSEQ)*MAT2(NSEQ)
          END DO
        END DO
        NSEQ = NSEQ + M
      END DO
C
100   IF (NI.EQ.NAT) GO TO 200
C
      NSEQ = IND(NI+1)*(IND(NI+1)+1)/2 + IND(NI)
      DO NJ = NI+1, NAT
        DO L = 1, IND(NJ+1) - IND(NJ)
          NU = IND(NJ)+L
          DO M = 1, IND(NI+1)-IND(NI)
            MU = IND(NI)+M
            NSEQ = NSEQ + 1
            VALUE = VALUE + MAT1(NSEQ)*MAT2(NSEQ)
          END DO
          NSEQ = NSEQ + IND(NI) + NU - MU
        END DO
      END DO
C
200   RETURN
C
      END SUBROUTINE DDOT_DER
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DISPLACEMENT
C>
C>    @brief Hessian of DFTB
C>
C>    @details Make a vector between atom NI and NJ.  If KI and KJ are
C>             zero, V is simply the vector between two atoms.
C>             Otherwise, this subroutine permits to add DELTA step
C>             displacement, which will be useful for numerical
C>             differentiation.  Now, all Slater-Koster transformations
C>             are analytically done, this suborutine may be useless?
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NI Atom at the begining of vector
C>    @param NJ Atom at the end of vector
C>    @param KI First axis displacement is added
C>    @param KJ Second axis displacement is added
C>    @param C Coordinates
C>    @param DELTA Step length of displacement
C>           --- OUTPUT ---
C>    @param V Vector of NI -> NJ
C>
C
      SUBROUTINE DFTB_DISPLACEMENT(NI,NJ,KI,KJ,V,C,DELTA)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: NI,NJ,KI,KJ
      DOUBLE PRECISION,INTENT(OUT) :: V(3)
      DOUBLE PRECISION,INTENT(IN) :: C(3,*),DELTA
      INTEGER :: I
C
      DO I = 1, 3
        V(I) = C(I,NJ) - C(I,NI)
      END DO
      IF (KI.EQ.0.AND.KJ.EQ.0) RETURN
      IF (KI.GT.0) V( KI) = V( KI) + DELTA
      IF (KI.LT.0) V(-KI) = V(-KI) - DELTA
      IF (KJ.EQ.0) RETURN
      IF (KJ.GT.0) V( KJ) = V( KJ) + DELTA
      IF (KJ.LT.0) V(-KJ) = V(-KJ) - DELTA
C
      RETURN
C
      END SUBROUTINE DFTB_DISPLACEMENT
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DER2
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate second-order geometrical derivatives of
C>             non-perturbed Hamiltonian and overlap matrix (AO basis)
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param L2 L1*(L1+1)/2
C>    @param NI Atom at the begining of vector
C>    @param NJ Atom at the end of vector
C>    @param KI First axis displacement is added
C>    @param KJ Second axis displacement is added
C>    @param NAT Number of atoms
C>    @param IND AO index of each atom
C>    @param C Coordinates
C>           --- OUTPUT ---
C>    @param HDER2 2nd der. of Hamiltonian
C>    @param SDER2 2nd der. of overlap
C>
C
      SUBROUTINE DFTB_DER2(L2,NI,KI,NJ,KJ,NAT,IND,C,HDER2,SDER2,DOH2)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: L2,NI,KI,NJ,KJ,NAT,IND(*)
      DOUBLE PRECISION, INTENT(IN) :: C(3,*)
      DOUBLE PRECISION, INTENT(OUT) :: HDER2(L2),SDER2(L2)
C
      INTEGER :: NK,L,M,MU,NU,NSEQ
      DOUBLE PRECISION :: V(3),AUMM(9,9),BUMM(9,9),DHDR,DSDR
      LOGICAL :: SKP,DOH2
C
      IF(DOH2) CALL VCLR(HDER2,1,L2)
      CALL VCLR(SDER2,1,L2)
C
C     write (*,*) "ni,ki = ", ni, ki
C     write (*,*) "nj,kj = ", kj, kj
      IF (NI.EQ.NJ .AND. KI.EQ.KJ) THEN
        DO NK = 1, NAT
          IF (NI.EQ.NK) CYCLE
C         write (*,*) "nk = ", nk
          V(1) = C(1,NK) - C(1,NI)
          V(2) = C(2,NK) - C(2,NI)
          V(3) = C(3,NK) - C(3,NI)
          CALL DFTB_SKODE_HELPA(2,NI,NK,KI,KI,V,AUMM,BUMM,DOH2,
     *      .TRUE.,SKP)
          IF (SKP) CYCLE
          DO L = 1, IND(NK+1) - IND(NK)
            NU = IND(NK)+L
            DO M = 1, IND(NI+1) - IND(NI)
              MU = IND(NI)+M
              CALL DFTB_CNVSQ(MU,NU,NSEQ)
              DHDR = AUMM(M,L)
              DSDR = BUMM(M,L)
c             write (6,'(I3,2(X,F20.10))'),NSEQ,DHDR,DSDR
              IF(DOH2) HDER2(NSEQ) = DHDR
              SDER2(NSEQ) = DSDR
            END DO
          END DO
        END DO
      ELSE IF (NI.EQ.NJ .AND. KI.NE.KJ) THEN
        DO NK = 1, NAT
          IF (NI.EQ.NK) CYCLE
C         write (*,*) "nk = ", nk
          V(1) = C(1,NK) - C(1,NI)
          V(2) = C(2,NK) - C(2,NI)
          V(3) = C(3,NK) - C(3,NI)
          CALL DFTB_SKODE_HELPA(2,NI,NK,KI,KJ,V,AUMM,BUMM,DOH2,
     *      .TRUE.,SKP)
          DO L = 1, IND(NK+1) - IND(NK)
            NU = IND(NK)+L
            DO M = 1, IND(NI+1) - IND(NI)
              MU = IND(NI)+M
              CALL DFTB_CNVSQ(MU,NU,NSEQ)
              DHDR = AUMM(M,L)
              DSDR = BUMM(M,L)
C             write (*,'(I3,2(X,F20.10))'),NSEQ,DHDR,DSDR
              IF(DOH2) HDER2(NSEQ) = DHDR
              SDER2(NSEQ) = DSDR
            END DO
          END DO
        END DO
      ELSE
        V(1) = C(1,NJ) - C(1,NI)
        V(2) = C(2,NJ) - C(2,NI)
        V(3) = C(3,NJ) - C(3,NI)
        CALL DFTB_SKODE_HELPA(2,NI,NJ,KI,KJ,V,AUMM,BUMM,DOH2,
     *    .TRUE.,SKP)
        DO L = 1, IND(NJ+1) - IND(NJ)
          NU = IND(NJ)+L
          DO M = 1, IND(NI+1) - IND(NI)
            MU = IND(NI)+M
            CALL DFTB_CNVSQ(MU,NU,NSEQ)
            DHDR = AUMM(M,L)
            DSDR = BUMM(M,L)
c           write (6,'("CHK=",I3,2(X,F20.10))'),NSEQ,DHDR,DSDR
            IF(DOH2) HDER2(NSEQ) = DHDR
            SDER2(NSEQ) = DSDR
          END DO
        END DO
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_DER2
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_D2HS
C>
C>    @brief   Hessian of DFTB
C>
C>    @details Calculate Hessian contribution of second-order
C>             geometrical derivatives of non-perturbed Hamiltonian
C>             and overlap matrix
C>
C>    @author  Yoshio Nishimoto
C>             - Sep, 2014 - Subroutine written
C>    @date    Feb, 2016 - Hiroya Nakata
C>             - Added FMO-DFTB Hessian
C>
C>           --- INPUT ---
C>    @param D Density matrix
C>    @param DEIG Energy-weighted density matrix
C>    @param SHIFT Shift contribution (atom-resolved)
C>    @param SHIFTSA Shift contribution of alpha orbitals (shell-res.)
C>    @param SHIFTSB Shift contribution of beta  orbitals (shell-res.)
C>    @param C Coordinates
C>    @param NAT Number of atoms
C>    @param L2 L1*(L1+1)/2
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param IND AO index of each atom
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>    @param INDSAO AO index of each shell
C>    @param SCC Whether SCC or not
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param UHF Whether U-DFTB or not
C>           --- OUTPUT ---
C>    @param HDER2 2nd der. of Hamiltonian
C>    @param SDER2 2nd der. of overlap
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_D2HS(HDER2,SDER2,D,DEIG,SHIFT,SHIFTSA,SHIFTSB,
     *  C,HESSIAN,NAT,L2,NSPIN,IND,NSHELL,NSPE,ISPE,
     *  MAXANG,INDSAO,SCC,SRSCC,UHF)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: L2,NAT,NSPIN,NSHELL
      DOUBLE PRECISION,INTENT(IN) :: D(L2,NSPIN),DEIG(L2,NSPIN),
     *  SHIFT(NAT),SHIFTSA(NSHELL),SHIFTSB(NSHELL),
     *  C(3,NAT)
      DOUBLE PRECISION,INTENT(INOUT) :: HDER2(L2),SDER2(L2),
     *  HESSIAN(3*NAT,3*NAT)
      INTEGER,INTENT(IN) :: IND(*),NSPE,ISPE(NAT),MAXANG(NSPE),INDSAO(*)
      LOGICAL,INTENT(IN) :: SCC,SRSCC,UHF
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      INTEGER ME,MASTER,NPROC,IBTYP,IPTIM,NSUBGR,MeUniv,NPUniv
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      INTEGER ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP
      LOGICAL MYJOB,ISGDDI,PAROUT,INITGDDI,WASGDDI,MLGDDI
C
      INTEGER :: NI,NJ,NK,KI,KJ,I,J,K,L,M,MU,NU,ISH,ISH0,JSH,JSH0,
     *  KSH,KSH0,NSEQ,LGROUP
      DOUBLE PRECISION :: TMP_HESS(3,3),SHIFTI,SHIFTJ,SHIFTIJ,
     *  SHIFTIA,SHIFTIB,SHIFTJA,SHIFTJB,SHIFTIJA,SHIFTIJB,VAL,
     *  TMP,D2HDR,D2SDR
C
      INTEGER, PARAMETER :: DDI_WORLD=0,DDI_GROUP=1
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00,TWO=2.0D+00,
     *  HALF=0.5D+00
C
      IF (ISGDDI) THEN
        CALL GDDI_SCOPE(DDI_GROUP)
        CALL GDDICOUNT(-1,LGROUP,MYJOB)
      END IF
C
      IF (UHF.OR.SRSCC) THEN
        ISH0 = 0
        DO NI = 1, NAT
          IF (ISGDDI) THEN
            CALL GDDICOUNT(0,LGROUP,MYJOB)
            IF (.NOT.MYJOB) THEN
              ISH0 = ISH0 + MAXANG(ISPE(NI))
              CYCLE
            END IF
          ELSE IF (GOPARR) THEN
            IF (MOD(NI,NPROC).NE.ME) CYCLE
          END IF
          JSH0 = 0
          DO NJ = 1, NI
            IF (ISGDDI.AND.GOPARR) THEN
              IF (MOD(NJ,NPROC).NE.ME) CYCLE
            END IF
            DO KI = 1, 3
              DO KJ = 1, KI
                CALL DFTB_DER2(L2,NI,KI,NJ,KJ,NAT,IND,C,HDER2,SDER2,
     *               .true.)
                CALL VCLR(TMP_HESS,1,9)
                VAL = ZERO
                IF (NI.EQ.NJ) THEN
                  DO I = 1, MAXANG(ISPE(NI))
                    ISH = ISH0 + I
                    SHIFTIA = SHIFTSA(ISH)
                    SHIFTIB = SHIFTSB(ISH)
                    KSH0 = 0
                    DO NK = 1, NAT
                      DO K = 1, MAXANG(ISPE(NK))
                        KSH = KSH0 + K
                        IF (NI.EQ.NK) CYCLE
                        SHIFTJA = SHIFTSA(KSH)
                        SHIFTJB = SHIFTSB(KSH)
                        SHIFTIJA = (SHIFTIA+SHIFTJA)*HALF
                        SHIFTIJB = (SHIFTIB+SHIFTJB)*HALF
                        DO L = 1, INDSAO(KSH+1) - INDSAO(KSH)
                          NU = INDSAO(KSH)+L
                          DO M = 1, INDSAO(ISH+1) - INDSAO(ISH)
                            MU = INDSAO(ISH)+M
                            CALL DFTB_CNVSQ(MU,NU,NSEQ)
                            D2HDR = HDER2(NSEQ)
                            D2SDR = SDER2(NSEQ)
                            IF (UHF) THEN
                              TMP = D(NSEQ,1)*(D2HDR+SHIFTIJA*D2SDR)
     *                            + D(NSEQ,2)*(D2HDR+SHIFTIJB*D2SDR)
     *                            - (DEIG(NSEQ,1)+DEIG(NSEQ,2))*D2SDR
                            ELSE
                              TMP = D(NSEQ,1)*(D2HDR+SHIFTIJA*D2SDR)
     *                            - DEIG(NSEQ,1)*D2SDR
                            END IF
                            VAL = VAL + TMP
                          END DO
                        END DO
                      END DO
                      KSH0 = KSH0 + MAXANG(ISPE(NK))
                    END DO
                  END DO
                  TMP_HESS(KI,KJ) = TMP_HESS(KI,KJ) + VAL*TWO
                  IF (KI.NE.KJ)
     *              TMP_HESS(KJ,KI) = TMP_HESS(KJ,KI) + VAL*TWO
                ELSE
                  DO I = 1, MAXANG(ISPE(NI))
                    ISH = ISH0 + I
                    SHIFTIA = SHIFTSA(ISH)
                    SHIFTIB = SHIFTSB(ISH)
                    DO J = 1, MAXANG(ISPE(NJ))
                      JSH = JSH0 + J
                      SHIFTJA = SHIFTSA(JSH)
                      SHIFTJB = SHIFTSB(JSH)
                      SHIFTIJA = (SHIFTIA+SHIFTJA)*HALF
                      SHIFTIJB = (SHIFTIB+SHIFTJB)*HALF
                      DO L = 1, INDSAO(JSH+1) - INDSAO(JSH)
                        NU = INDSAO(JSH)+L
                        DO M = 1, INDSAO(ISH+1) - INDSAO(ISH)
                          MU = INDSAO(ISH)+M
                          CALL DFTB_CNVSQ(MU,NU,NSEQ)
                          D2HDR = HDER2(NSEQ)
                          D2SDR = SDER2(NSEQ)
                          IF (UHF) THEN
                            TMP = D(NSEQ,1)*(D2HDR+SHIFTIJA*D2SDR)
     *                          + D(NSEQ,2)*(D2HDR+SHIFTIJB*D2SDR)
     *                          - (DEIG(NSEQ,1)+DEIG(NSEQ,2))*D2SDR
                          ELSE
                            TMP = D(NSEQ,1)*(D2HDR+SHIFTIJA*D2SDR)
     *                          - DEIG(NSEQ,1)*D2SDR
                          END IF
                          VAL = VAL + TMP
                        END DO
                      END DO
                    END DO
                  END DO
                  TMP_HESS(KI,KJ) = TMP_HESS(KI,KJ) - VAL*TWO
                  IF (KI.NE.KJ)
     *              TMP_HESS(KJ,KI) = TMP_HESS(KJ,KI) - VAL*TWO
                END IF
                CALL ADD_HESS(NI,NJ,NAT,TMP_HESS,HESSIAN)
              END DO
            END DO
            JSH0 = JSH0 + MAXANG(ISPE(NJ))
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(NI))
        END DO
      ELSE
        DO NI = 1, NAT
          IF (ISGDDI) THEN
            CALL GDDICOUNT(0,LGROUP,MYJOB)
            IF (.NOT.MYJOB) CYCLE
          ELSE IF (GOPARR) THEN
            IF (MOD(NI,NPROC).NE.ME) CYCLE
          END IF
          SHIFTI = SHIFT(NI)
          DO NJ = 1, NI
            IF (ISGDDI.AND.GOPARR) THEN
              IF (MOD(NJ,NPROC).NE.ME) CYCLE
            END IF
            DO KI = 1, 3
              DO KJ = 1, KI
                CALL DFTB_DER2(L2,NI,KI,NJ,KJ,NAT,IND,C,HDER2,SDER2,
     *               .true.)
                VAL = ZERO
                CALL VCLR(TMP_HESS,1,9)
                IF (NI.EQ.NJ) THEN
                  DO NK = 1, NAT
                    IF (NI.EQ.NK) CYCLE
                    SHIFTJ = SHIFT(NK)
                    SHIFTIJ = (SHIFTI+SHIFTJ)*HALF
                    DO L = 1, IND(NK+1) - IND(NK)
                      NU = IND(NK)+L
                      DO M = 1, IND(NI+1) - IND(NI)
                        MU = IND(NI)+M
                        CALL DFTB_CNVSQ(MU,NU,NSEQ)
                        D2HDR = HDER2(NSEQ)
                        D2SDR = SDER2(NSEQ)
                        IF (SCC) THEN
                          TMP = D(NSEQ,1)*(D2HDR+SHIFTIJ*D2SDR)
     *                        - DEIG(NSEQ,1)*D2SDR
                        ELSE
                          TMP = D(NSEQ,1)*D2HDR - DEIG(NSEQ,1)*D2SDR
                        END IF
                        VAL = VAL + TMP
                      END DO
                    END DO
                  END DO
                  TMP_HESS(KI,KJ) = TMP_HESS(KI,KJ) + VAL*TWO
                  IF (KI.NE.KJ)
     *              TMP_HESS(KJ,KI) = TMP_HESS(KJ,KI) + VAL*TWO
                ELSE
                  SHIFTJ = SHIFT(NJ)
                  SHIFTIJ = (SHIFTI+SHIFTJ)*HALF
                  DO L = 1, IND(NJ+1) - IND(NJ)
                    NU = IND(NJ)+L
                    DO M = 1, IND(NI+1) - IND(NI)
                      MU = IND(NI)+M
                      CALL DFTB_CNVSQ(MU,NU,NSEQ)
                      D2HDR = HDER2(NSEQ)
                      D2SDR = SDER2(NSEQ)
                      IF (SCC) THEN
                        TMP = D(NSEQ,1)*(D2HDR+SHIFTIJ*D2SDR)
     *                      - DEIG(NSEQ,1)*D2SDR
                      ELSE
                        TMP = D(NSEQ,1)*D2HDR - DEIG(NSEQ,1)*D2SDR
                      END IF
                      VAL = VAL + TMP
                    END DO
                  END DO
                  TMP_HESS(KI,KJ) = TMP_HESS(KI,KJ) - VAL*TWO
                  IF (KI.NE.KJ)
     *              TMP_HESS(KJ,KI) = TMP_HESS(KJ,KI) - VAL*TWO
                END IF
                CALL ADD_HESS(NI,NJ,NAT,TMP_HESS,HESSIAN)
              END DO
            END DO
          END DO
        END DO
      END IF
C
      IF (ISGDDI) THEN
        CALL GDDICOUNT( 1,LGROUP,MYJOB)
      END IF
C
C     IF (.NOT.MASWRK) THEN
C       CALL VCLR(HESSIAN,1,9*NAT*NAT)
C     END IF
C
      IF (GOPARR.OR.ISGDDI) THEN
        CALL GDDI_SCOPE(DDI_WORLD)
        CALL DDI_GSUMF(1,HESSIAN,9*NAT*NAT)
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_D2HS
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_SLKODE_HELPA
C>
C>    @brief Hessian of DFTB
C>
C>    @details Helps analytical Slater-Koster transformation ...
C>
C>    @author  Yoshio Nishimoto
C>             - Sep, 2014 - Subroutine written
C>    @date    Feb, 2016 - Yoshio Nishimoto
C>             - Changes due to the DFTBSK common block
C>
C>           --- INPUT ---
C>    @param NDER Order of derivative to be calculated
C>    @param NI Atom at the begining of vector
C>    @param NJ Atom at the end of vector
C>    @param KI First axis displacement is added
C>    @param KJ Second axis displacement is added
C>    @param VEC Vector
C>    @param T1 Whether Hamiltonian derivative is needed or not
C>    @param T2 Whether overlap derivative is needed or not
C>           --- OUTPUT ---
C>    @param MAT1,MAT2 NDER-th derivative of Hamiltonian and overlap
C>
C
      SUBROUTINE DFTB_SKODE_HELPA(NDER,NI,NJ,KI,KJ,VEC,MAT1,MAT2,T1,T2,
     *  SKP)
C
      IMPLICIT NONE

      INTEGER, PARAMETER :: MXATM=2000,MXSPE=10
C
      INTEGER, INTENT(IN) :: NDER,NI,NJ,KI,KJ
      DOUBLE PRECISION, INTENT(INOUT) :: VEC(3),MAT1(9,9),MAT2(9,9)
      LOGICAL, INTENT(INOUT) :: T1,T2,SKP
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      DOUBLE PRECISION :: ETEMP,DFTBDP,DAMPXHE,HUBDER,ZREF,SPNCST,SPE
      INTEGER :: NSPE,MAXANG,ISPE,IND,IDFTBD
C
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
      DOUBLE PRECISION SKDIM,SKSPIN,QREFL,HUBBL,QREF,HUBB,SKCUT2
      INTEGER NEEDSK,LSKHTAB,LSKSTAB,LSKGRID,LSKSELF
C
      COMMON /FMCOM / X(1)
      DOUBLE PRECISION X
C
      IF (T1) CALL VCLR(MAT1,1,81)
      IF (T2) CALL VCLR(MAT2,1,81)
      CALL DFTB_SKODEA(NI.EQ.NJ,ISPE(NI),ISPE(NJ),NDER,KI,KJ,
     *  MAXANG(ISPE(NI)),MAXANG(ISPE(NJ)),VEC,
     *  X(LSKGRID(ISPE(NI),ISPE(NJ))),X(LSKGRID(ISPE(NJ),ISPE(NI))),
     *  SKDIM(ISPE(NI),ISPE(NJ)),SKDIM(ISPE(NJ),ISPE(NI)),
     *  X(LSKHTAB(ISPE(NI),ISPE(NJ))),X(LSKHTAB(ISPE(NJ),ISPE(NI))),
     *  X(LSKSTAB(ISPE(NI),ISPE(NJ))),X(LSKSTAB(ISPE(NJ),ISPE(NI))),
     *  X(LSKSELF(ISPE(NI))),SKCUT2,MAT1,MAT2,T1,T2,SKP)
C
      RETURN
C
      END SUBROUTINE DFTB_SKODE_HELPA
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HSDERIJ
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate and store the integrals of derivative
C>               H_{ij}^a = \sum_{\mu \nu} c_{\mu i} c_{\nu j}
C>                 \frac{\partial H_{\mu \nu}}{\partial a}
C>               S_{ij}^a = \sum_{\mu \nu} c_{\mu i} c_{\nu j}
C>                 \frac{\partial S_{\mu \nu}}{\partial a}
C>               V_{ij}^a = \sum_{\mu \nu} c_{\mu i} c_{\nu j}
C>                 \frac{\partial S_{\mu \nu}}{\partial a}
C>                 \frac{\partial \Omega_{AB}}{\partial a}
C>             Practically, H_{ij}^a and V_{ij}^a are usually used
C>             simultaneously; therefore HDERMO contains both terms.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L0 NQMT
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param IND AO index of each atom
C>    @param IRAF 20
C>    @param IORA Status of .F20
C>    @param NSHELL Number of shells
C>    @param C Coordinates
C>    @param SHIFT Shift contribution (atom-resolved)
C>    @param SHIFTSA Shift contribution of alpha orbitals (shell-res.)
C>    @param SHIFTSB Shift contribution of beta  orbitals (shell-res.)
C>    @param VEC MO coefficients
C>    @param WRKH,WRKS Working array for AO derivative of non-perturbed
C>           Hamiltonian and overlap matrix
C>    @param WRK,WRK1 Working array
C>    @param SCC Whether SCC or not
C>    @param DISK Whether intergrals are stored on disk or not
C>    @param UHF Whether U-DFTB or not
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param INDSH Index of shell for each atom
C>    @param INDSAO AO index of each shell
C>    @param MAXANG Maximum angular momentum of each species
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param ID_HDERMO,ID_SDERMO,ID_SDERAO IDs of HDERIJ,SDERIJ,SDER
C>           stored on DDI memory pool.
C>           --- OUTPUT ---
C>    @param HDERMO H_{ij}^a + V_{ij}^a
C>    @param SDERMO S_{ij}^a
C>    @param SDERAO S_{\mu \nu}^a
C>
C
      SUBROUTINE DFTB_HSDERIJ(NAT,L0,L1,L2,IND,IRAF,IORA,NSHELL,C,
     *  HDERMO,SDERMO,SDERAO,SHIFT,SHIFTSA,SHIFTSB,VEC,WRKH,WRKS,WRK,
     *  WRK1,SCC,DISK,UHF,SRSCC,NSPIN,INDSH,INDSAO,MAXANG,NSPE,ISPE,
     *  ID_HDERMO,ID_SDERMO,ID_SDERAO,NOCC,DDIHSD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /FMCOM / X(1)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      LOGICAL MYJOB,ISGDDI,PAROUT,INITGDDI,WASGDDI,MLGDDI
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      INTEGER, PARAMETER :: DDI_WORLD=0,DDI_GROUP=1,DDI_MASTERS=2
      DOUBLE PRECISION :: AUP(9,9),BUP(9,9),V(3)
C
      INTEGER :: IND(*),NSEQ,O,IRAF,IORA(3*NAT*5),NSPIN,INDSH(*),
     *  INDSAO(*),MAXANG(*),NSPE,ISPE(NAT),NOCC(2)
      !! SHIFTS  :: ATOMIC SHIFT (NORMAL 2ND ORDER DFTB)
      !! SHIFTSA :: SHELL-RESOLVED SHIFT + SPIN SHIFT
      !! SHIFTSB :: SHELL-RESOLVED SHIFT - SPIN SHIFT
      !! USE SHIFTSA FOR SRSCC
      DOUBLE PRECISION :: C(3,NAT),HDERMO(L2,3,NAT,NSPIN),
     *  SDERMO(L2,3,NAT,NSPIN),
     *  SDERAO(L2,3,NAT),SHIFT(NAT),VEC(L1,L1,NSPIN),WRKH(L2),
     *  WRKS(L2),
     *  WRK(*),WRK1(*),SHIFTSA(NSHELL),SHIFTSB(NSHELL)
      LOGICAL :: SCC,DISK,UHF,SRSCC,SKP,SOME,DDIHSD
C
C     THIS SUBROUTINE CALCULATES THE DERIVATIVE OF OVERLAP MATRIX.
C     IT WILL BE INTEGRATED INTO DFTB_GRAD SUBROUTINE, BECAUSE
C     NOW THE OVERLAP-DERIVATIVE IS CALCULATED TWICE.
C
C     ----- CALCULATE DH/DR AND DS/DR NUMERICALLY -----
C     DS/DR = (BUP - BUM)/DELTA * 0.5
C
      IF (.NOT.DISK.AND..NOT.ISGDDI) THEN
        CALL VCLR(HDERMO,1,L2*3*NAT*NSPIN)
        CALL VCLR(SDERMO,1,L2*3*NAT*NSPIN)
        CALL VCLR(SDERAO,1,L2*3*NAT)
      END IF
      CALL VCLR(WRK1,1,L2)
      SOME = .TRUE.
C
C     IF DISK IS TRUE, H/S AO DERIVATIVES ARE STORED ON DISK.  THE
C     IR AND JR VARIABLES DETERMINE WHERE MATRICES ARE PUT.  FOR THE
C     DISPLACEMENT OF I-TH ATOM ALONG K-TH VECTOR, THE MATRIX IS STORED
C     AT THE POSITION OF IR = 3*(I-1)+K.
C
      IRA1 = 0
      IRA2 = IRA1 + NAT*3
      IRA3 = IRA2 + NAT*3
      IRA4 = IRA3 + NAT*3
      IRA5 = IRA4 + NAT*3
      NVEC = -1
C
      IW=6
      IF (ISGDDI) THEN
        IF (DISK) THEN
          IF (DDIHSD) THEN
            CALL GDDI_SCOPE(DDI_GROUP)
            CALL GOTFM(NGOTMX)
            DO NVEC = 1, 3*NAT
              MEM = 2*NVEC*L2*NSPIN + NVEC
              IF (SCC) MEM = MEM + NVEC*L2
              IF (MEM.GT.NGOTMX) EXIT
            END DO
            IF (NVEC.NE.1.AND.NVEC.NE.2) THEN
              NVEC = NVEC - 1
            ELSE
              NVEC = 1
            END IF
            IF (MASWRK.AND.SOME) THEN
              WRITE (IW,'(" BUNDLE ",I3," VECTORS FOR GDDI-DISK")') NVEC
            END IF
C
            IF (NVEC.GT.1) THEN
              CALL VALFM(LOADFM)
              LHDERMO   = LOADFM  + 1
              LSDERMO   = LHDERMO + L2*NVEC*NSPIN
              LSDERAO   = LSDERMO + L2*NVEC*NSPIN
              IF (SCC) THEN
                LINDVEC = LSDERAO + L2*NVEC
              ELSE
                LINDVEC = LSDERAO
              END IF
              LAST      = LINDVEC + NVEC
              NEED      = LAST - LOADFM - 1
              CALL GETFM(NEED)
              CALL VCLR(X(LHDERMO),1,L2*NVEC*NSPIN)
              CALL VCLR(X(LSDERMO),1,L2*NVEC*NSPIN)
              IF (SCC) CALL VCLR(X(LSDERAO),1,L2*NVEC)
              IF (MASWRK.AND.SOME) THEN
                WRITE (IW,'(" ...... ALLOCATED MEMORY IN DFTB_HSDERIJ",
     *         " = ",I10," WORDS")') NEED
                WRITE (IW,*)
              END IF
            END IF
          ELSE
            NVEC = 0
          END IF
        ELSE
          CALL DDI_NDISTRIB(ID_HDERMO,MYGROUP,IL_HDERMO,IH_HDERMO,
     *      JL_HDERMO,JH_HDERMO)
          CALL GDDI_SCOPE(DDI_WORLD)
        END IF
        CALL GDDI_SCOPE(DDI_GROUP)
        CALL DDI_COMMID(DDI_WORLD,IDWORLD)
        IDW = IDWORLD
        CALL GDDICOUNT(-1,LGROUP,MYJOB)
      END IF
C
      NVECTMP = 0
      NITMP = 1
      KITMP = 1
      DO I = 1, NAT
        IF (ISGDDI.AND..NOT.DISK.AND.
     *     (I.GT.JH_HDERMO.OR.I.LT.JL_HDERMO)) CYCLE
        DO K = 1, 3
          IF (NVEC.GT.1) THEN
            NVECTMP = NVECTMP + 1
            CALL IXSTOR(X(LINDVEC+NVECTMP-1),1,
     *            3*(I-1)+K-(3*(NITMP-1)+KITMP)+1) !! -NVECTMP+1)
            CALL GDDICOUNT(0,LGROUP,MYJOB)
            IF (.NOT.MYJOB) GO TO 100
          END IF
          CALL VCLR(WRKH,1,L2)
          CALL VCLR(WRKS,1,L2)
          DO J = 1, NAT
            IF (I.EQ.J) CYCLE
            V(1) = C(1,J) - C(1,I)
            V(2) = C(2,J) - C(2,I)
            V(3) = C(3,J) - C(3,I)
            CALL DFTB_SKODE_HELPA(1,I,J,K,0,V,AUP,BUP,.TRUE.,.TRUE.,SKP)
            IF (SKP) CYCLE
            DO L = 1, IND(J+1) - IND(J)
              O = IND(J)+L
              DO M = 1, IND(I+1) - IND(I)
                N = IND(I)+M
                CALL DFTB_CNVSQ(N,O,NSEQ)
                WRKH(NSEQ) = AUP(M,L)
                WRKS(NSEQ) = BUP(M,L)
              END DO
            END DO
          END DO
          IF (DISK.OR.ISGDDI) THEN
C
C           USE DISK OR DDI MEMORY POOL FOR INTEGRAL STORAGE
C
            IF (SCC) THEN
              CALL DCOPY(L2,WRKS,1,SDERAO(1,K,1),1)
              DO ISPIN = 1, NSPIN
                IF (UHF.OR.SRSCC) THEN
                  IF (ISPIN.EQ.1) THEN
                    CALL SHIFT_TRIANGLE_DER_SHELL(NAT,I,L2,IND,INDSH,
     *                INDSAO,NSPE,ISPE,MAXANG,SHIFTSA,SDERAO(1,K,1),
     *                WRKS)
                  ELSE
                    CALL SHIFT_TRIANGLE_DER_SHELL(NAT,I,L2,IND,INDSH,
     *                INDSAO,NSPE,ISPE,MAXANG,SHIFTSB,SDERAO(1,K,1),
     *                WRKS)
                  END IF
                ELSE
                  CALL SHIFT_TRIANGLE_DER(NAT,I,L2,IND,SHIFT,
     *                 SDERAO(1,K,1),WRKS)
                END IF
                CALL VADD(WRKS,1,WRKH,1,WRKS,1,L2)
                !! (H+V)DERMO
                CALL DFTB_TFTRI0(0,NOCC(ISPIN),HDERMO(1,K,ISPIN,1),WRKS,
     *            VEC(1,1,ISPIN),WRK,L0,L1,L1)
                !! SDERMO
                CALL DFTB_TFTRI0(0,NOCC(ISPIN),SDERMO(1,K,ISPIN,1),
     *            SDERAO(1,K,1),VEC(1,1,ISPIN),WRK,L0,L1,L1)
              END DO
            ELSE
              CALL DFTB_TFTRI0(0,NOCC(1),HDERMO(1,K,1,1),WRKH,
     *          VEC(1,1,1),WRK,L0,L1,L1)
              CALL DFTB_TFTRI0(0,NOCC(1),SDERMO(1,K,1,1),WRKS,
     *           VEC(1,1,1),WRK,L0,L1,L1)
            END IF
            IF (.NOT.ISGDDI.OR.NVEC.EQ.0) THEN
              IRA1 = IRA1 + 1
              IRA2 = IRA2 + 1
              IRA3 = IRA3 + 1
              IRA4 = IRA4 + 1
              IRA5 = IRA5 + 1
              CALL RAWRIT(IRAF,IORA,HDERMO(1,K,1,1),L2,IRA1,0)
              CALL RAWRIT(IRAF,IORA,SDERMO(1,K,1,1),L2,IRA2,0)
              IF (SCC) THEN
                CALL RAWRIT(IRAF,IORA,SDERAO(1,K,1),L2,IRA3,0)
                IF (UHF) THEN
                  CALL RAWRIT(IRAF,IORA,HDERMO(1,K,2,1),L2,IRA4,0)
                  CALL RAWRIT(IRAF,IORA,SDERMO(1,K,2,1),L2,IRA5,0)
                END IF
              END IF
            END IF
          ELSE
C
C           USE MEMORY FOR INTEGRAL STORAGE
C
            IF (SCC) THEN
              CALL DCOPY(L2,WRKS,1,SDERAO(1,K,I),1)
              DO ISPIN = 1, NSPIN
                IF (UHF.OR.SRSCC) THEN
                  IF (ISPIN.EQ.1) THEN
                    CALL SHIFT_TRIANGLE_DER_SHELL(NAT,I,L2,IND,INDSH,
     *               INDSAO,NSPE,ISPE,MAXANG,SHIFTSA,SDERAO(1,K,I),WRKS)
                  ELSE
                    CALL SHIFT_TRIANGLE_DER_SHELL(NAT,I,L2,IND,INDSH,
     *               INDSAO,NSPE,ISPE,MAXANG,SHIFTSB,SDERAO(1,K,I),WRKS)
                  END IF
                ELSE
                  CALL SHIFT_TRIANGLE_DER(NAT,I,L2,IND,SHIFT,
     *                 SDERAO(1,K,I),WRKS)
                END IF
                CALL VADD(WRKS,1,WRKH,1,WRKS,1,L2)
                !! (H+V)DERMO
                CALL DFTB_TFTRI0(0,NOCC(ISPIN),HDERMO(1,K,I,ISPIN),WRKS,
     *            VEC(1,1,ISPIN),WRK,L0,L1,L1)
                !! SDERMO
                CALL DFTB_TFTRI0(0,NOCC(ISPIN),SDERMO(1,K,I,ISPIN),
     *            SDERAO(1,K,I),VEC(1,1,ISPIN),WRK,L0,L1,L1)
              END DO
            ELSE
              CALL TFTRI0(HDERMO(1,K,I,1),WRKH,VEC(1,1,1),
     *          WRK,L0,L1,L1)
              CALL TFTRI0(SDERMO(1,K,I,1),WRKS,VEC(1,1,1),
     *          WRK,L0,L1,L1)
            END IF
          END IF
  100     CONTINUE
C
C         ----- SYNCHRONIZE AND WRITE INTEGRALS USING GDDI? -----
C
          IF (NVEC.GT.1) THEN
            IF (MYJOB) THEN
              CALL DFTB_COPY_HSDERIJ(NVECTMP,L2,NSPIN,X(LINDVEC),
     *          X(LHDERMO),X(LSDERMO),X(LSDERAO),HDERMO(1,K,1,1),
     *          HDERMO(1,K,2,1),SDERMO(1,K,1,1),SDERMO(1,K,2,1),
     *          SDERAO(1,K,1),SCC)
            END IF
            IF (NVECTMP.EQ.NVEC.OR.(I.EQ.NAT.AND.K.EQ.3)) THEN
              CALL GDDICOUNT( 1,LGROUP,MYJOB)
              CALL GDDI_SCOPE(DDI_MASTERS)
C
C             ---- SUM ALL INTEGRALS UP -----
C
              MEM = 2*L2*NVEC*NSPIN
              IF (SCC) MEM = MEM + L2*NVEC
              CALL DDI_GSUMF(520,X(LHDERMO),MEM)
C
C             ---- SYNCHRONIZE ALL INTEGRAL DATA BETWEEN GROUPS -----
C             BROADCAST IS NOT NEEDED BECAUSE ONLY MASTERS WRITE DISK
C
C             CALL DDI_BCAST(525,'F',X(LHDERMO),MEM,MASTER)
C
C             ---- WRITE INTEGRALS ON DISK IN EACH GROUP -----
C
              CALL GDDI_SCOPE(DDI_GROUP)
              DO N = 1, NVECTMP
                IRA1 = IRA1 + 1
                IRA2 = IRA2 + 1
                IRA3 = IRA3 + 1
                IRA4 = IRA4 + 1
                IRA5 = IRA5 + 1
                CALL DFTB_WRTINT(IRAF,IORA,NVECTMP,N,L2,NSPIN,IRA1,IRA2,
     *            IRA3,IRA4,IRA5,X(LHDERMO),X(LSDERMO),X(LSDERAO),SCC)
              END DO
              CALL TSECND(TIME0)
              IF (I.NE.NAT.OR.K.NE.3) THEN
                NITMP = I
                KITMP = K+1
                IF (KITMP.EQ.4) THEN
                  NITMP = NITMP + 1
                  KITMP = 1
                END IF
                NVECTMP = 0
                CALL VCLR(X(LHDERMO),1,L2*NVEC*NSPIN)
                CALL VCLR(X(LSDERMO),1,L2*NVEC*NSPIN)
                IF (SCC) CALL VCLR(X(LSDERAO),1,L2*NVEC)
                CALL VCLR(X(LINDVEC),1,NVEC)
                CALL GDDICOUNT(-1,LGROUP,MYJOB)
              ELSE
                CALL RETFM(NEED)
              END IF
            END IF
          END IF !! END OF GDDI-DISK BRANCH
        END DO !! K LOOP
        IF (ISGDDI.AND..NOT.DISK) THEN
          IF (SCC) CALL DDI_PUT_COMM(ID_SDERAO,1,L2*3,I,I,SDERAO,IDW)
          CALL DDI_PUT_COMM(ID_HDERMO,1,L2*3*NSPIN,I,I,HDERMO,IDW)
          CALL DDI_PUT_COMM(ID_SDERMO,1,L2*3*NSPIN,I,I,SDERMO,IDW)
        END IF
      END DO
C
      IF (ISGDDI) THEN
        IF (.NOT.DISK.OR.NVEC.EQ.0) CALL GDDICOUNT( 1,LGROUP,MYJOB)
        CALL GDDI_SCOPE(DDI_WORLD)
C       IF (DISK.AND.NVEC.GT.1) THEN
C         IF (MASWRK) THEN
C           WRITE (IW,'("   SYNCHRONIZATION, DATA TRANSFER, AND DISK"
C    *        " WRITING OF")')
C           MEM = 2*L2*NAT*3*NSPIN
C           IF (SCC) MEM = MEM + L2*NAT*3
C           WRITE (IW,'("   ",I12," WORDS TOOK",F7.2,",",F7.2,", AND",
C    *        F7.2," SECONDS")') MEM,WALLS,WALLD,WALLW
C         END IF
C       END IF
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_HSDERIJ
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_WRTINT
C>
C>    @brief   Hessian of DFTB
C>
C>    @details Write integrals on disk (F20). This is used only when
C>             DDIHSD is .TRUE. with which integrals are written
C>             after DDI_GSUMF
C>
C>    @author  Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param IRAF    20
C>    @param IORA    Status of .F20
C>    @param NVEC    Number of vectors to be stored
C>    @param NVECTMP Index of the current vectors
C>    @param L2      L1*(L1+1)/2
C>    @param NSPIN   Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param IRA1    Location of H_{ij}^a + V_{ij}^a
C>    @param IRA2                S_{ij}^a
C>    @param IRA3                S_{mn}^a
C>    @param IRA4                H_{ij}^a + V_{ij}^a (only for UHF)
C>    @param IRA5                S_{ij}^a            (only for UHF)
C>    @param HDERMO  H_{ij}^a + V_{ij}^a
C>    @param SDERMO  S_{ij}^a
C>    @param SDERAO  S_{mn}^a
C>    @param SCC     Whether SCC or not
C>
C
      SUBROUTINE DFTB_WRTINT(IRAF,IORA,NVEC,NVECTMP,L2,NSPIN,IRA1,IRA2,
     *  IRA3,IRA4,IRA5,HDERMO,SDERMO,SDERAO,SCC)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: IRAF,NVEC,NVECTMP,L2,NSPIN,IRA1,IRA2,
     *  IRA3,IRA4,IRA5
      INTEGER, INTENT(INOUT) :: IORA(*)
      DOUBLE PRECISION, INTENT(INOUT) :: HDERMO(L2*NSPIN,NVEC),
     *  SDERMO(L2*NSPIN,NVEC),SDERAO(L2,NVEC)
      LOGICAL, INTENT(IN) :: SCC
C
      CALL RAWRIT(IRAF,IORA,HDERMO(1,NVECTMP),L2,IRA1,0)
      CALL RAWRIT(IRAF,IORA,SDERMO(1,NVECTMP),L2,IRA2,0)
      IF (SCC) THEN
        CALL RAWRIT(IRAF,IORA,SDERAO(1,NVECTMP),L2,IRA3,0)
        IF (NSPIN.EQ.2) THEN
          CALL RAWRIT(IRAF,IORA,HDERMO(L2+1,NVECTMP),L2,IRA4,0)
          CALL RAWRIT(IRAF,IORA,SDERMO(L2+1,NVECTMP),L2,IRA5,0)
        END IF
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_WRTINT
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_COPY_HSDERIJ
C>
C>    @brief   Hessian of DFTB
C>
C>    @details Save integrals at proper location for DDIHSD. Because
C>             DDI_GSUMF will sum of all integrals, this subroutine
C>             is implemented to avoid double counting.
C>
C>    @author  Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NVEC      (Current) index of vectors to be stored
C>    @param L2        L1*(L1+1)/2
C>    @param INDVEC    Pointer to the location for saving integrals
C>    @param HDERMOTMP Stored H_{ij}^a + V_{ij}^a
C>    @param SDERMOTMP        S_{ij}^a
C>    @param SDERAOTMP        S_{mn}^a
C>    @param HDERMOA   Calculated H_{ij}^a + V_{ij}^a (alpha)
C>    @param HDERMOB              H_{ij}^a + V_{ij}^a (beta)
C>    @param SDERMOA              S_{ij}^a            (alpha)
C>    @param SDERMOB              S_{ij}^a            (beta)
C>    @param SDERAOT              S_{mn}^a
C>    @param SCC       Whether SCC or not
C>
C
      SUBROUTINE DFTB_COPY_HSDERIJ(NVEC,L2,NSPIN,INDVEC,HDERMOTMP,
     *  SDERMOTMP,SDERAOTMP,HDERMOA,HDERMOB,SDERMOA,SDERMOB,SDERAO,SCC)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NVEC,L2,NSPIN,INDVEC(*)
      DOUBLE PRECISION, INTENT(IN) :: HDERMOA(L2),HDERMOB(L2),
     *  SDERMOA(L2),SDERMOB(L2),SDERAO(L2)
      DOUBLE PRECISION, INTENT(INOUT) :: HDERMOTMP(L2*NSPIN,*),
     *  SDERMOTMP(L2*NSPIN,*),SDERAOTMP(L2,*)
      LOGICAL, INTENT(IN) :: SCC
C
C     If (maswrk) write (6,*) "nvec,indvec(nvec) = ", nvec,indvec(nvec)
      CALL DCOPY(L2,HDERMOA,1,HDERMOTMP(1,INDVEC(NVEC)),1)
      IF (NSPIN.EQ.2) THEN
        CALL DCOPY(L2,HDERMOB,1,HDERMOTMP(L2+1,INDVEC(NVEC)),1)
      END IF
      CALL DCOPY(L2,SDERMOA,1,SDERMOTMP(1,INDVEC(NVEC)),1)
      IF (NSPIN.EQ.2) THEN
        CALL DCOPY(L2,SDERMOB,1,SDERMOTMP(L2+1,INDVEC(NVEC)),1)
      END IF
      IF (SCC) CALL DCOPY(L2,SDERAO,1,SDERAOTMP(1,INDVEC(NVEC)),1)
C
      RETURN
C
      END SUBROUTINE DFTB_COPY_HSDERIJ
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_EREP_HESSIAN
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate Hessian contribution from Erep
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param GRADMAT Matrix of gradient
C>    @param HESSMAT Matrix of Hessian
C>           --- OUTPUT ---
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_EREP_HESSIAN(DISTMAT,GRADMAT,HESSMAT,HESSIAN,
     *           REPINTV,REPSHORT,REPCOEFF)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXSPE=10, MXINT=150)
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBRE/ REPCUT(MXSPE,MXSPE),NUMREP(MXSPE,MXSPE),
     *                LREPINTV(MXSPE,MXSPE),LREPSHORT(MXSPE,MXSPE),
     *                LREPCOEFF(MXSPE,MXSPE)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C
      DOUBLE PRECISION :: DISTMAT(*),GRADMAT(*),HESSMAT(*),
     *  HESSIAN(3*NAT,3*NAT),REPINTV(2,MXINT,NSPE,NSPE),
     *  REPSHORT(3,NSPE,NSPE),REPCOEFF(6,MXINT,NSPE,NSPE)
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00
C
      DO I = 1, NAT
        ISP1 = ISPE(I)
        DO J = 1, I
          ISP2 = ISPE(J)
          GRAD = ZERO
          HESS = ZERO
          CALL DFTB_CNVSQ(I,J,NSEQ)
          DIST = DISTMAT(NSEQ)
          IF (DIST.LT.1.0D-02) THEN
C         ----- VAL = 0.0 IF DISTANCE IS LESS THAN 0.01 AU
            GRAD = ZERO
            HESS = ZERO
          ELSE IF (DIST.GT.REPCUT(ISP1,ISP2)) THEN
C         ----- VAL = 0.0 IF DISTANCE IS MORE THAN CUTOFF
            GRAD = ZERO
            HESS = ZERO
          ELSE
            IF (DIST.LT.REPINTV(1,1,ISP1,ISP2)) THEN
C            --- SHORT RANGE REPULSIVE PART ---
              GRAD = -REPSHORT(1,ISP1,ISP2)
     &            * EXP(-REPSHORT(1,ISP1,ISP2)*DIST
     &                 + REPSHORT(2,ISP1,ISP2))
              HESS = (REPSHORT(1,ISP1,ISP2)**2)
     &            * EXP(-REPSHORT(1,ISP1,ISP2)*DIST
     &                 + REPSHORT(2,ISP1,ISP2))
            ELSE
              DO K = 1, NUMREP(ISP1,ISP2)
                IF (DIST.GE.REPINTV(1,K,ISP1,ISP2)
     &              .AND. DIST.LE.REPINTV(2,K,ISP1,ISP2)) EXIT
              END DO
              X1  = DIST - REPINTV(1,K,ISP1,ISP2)
              X0  = ONE
              X00 = ONE
              IF (K.LT.NUMREP(ISP1,ISP2)) THEN
C            --- MEDIUM RANGE REPULSIVE PART ---
                DO L = 2, 4
                  GRAD = GRAD + (L-1)*REPCOEFF(L,K,ISP1,ISP2) * X0
                  HESS = HESS + (L-1)*(L-2)*REPCOEFF(L,K,ISP1,ISP2)*X00
                  IF (L.NE.2) X00 = X00 * X1
                  X0  = X0 * X1
                END DO
              ELSE
C            --- LONG RANGE REPULSIVE PART ---
                DO L = 2, 6
                  GRAD = GRAD + (L-1)*REPCOEFF(L,K,ISP1,ISP2) * X0
                  HESS = HESS + (L-1)*(L-2)*REPCOEFF(L,K,ISP1,ISP2)*X00
                  IF (L.NE.2) X00 = X00 * X1
                  X0  = X0 * X1
                END DO
              END IF
            END IF
          END IF
C         WRITE (*,'(I3,X,I3,X,F12.6,X,F12.6)') I,J,GRAD,HESS
          GRADMAT(NSEQ) = GRAD
          HESSMAT(NSEQ) = HESS
        END DO
      END DO
C
C     ----- ADD CONTRIBUTIONS (GRADMAT AND HESSMAT) TO HESSIAN -----
C
      CALL DFTB_MAT_HESS(NAT,C,DISTMAT,GRADMAT,HESSMAT,HESSIAN)
C
      END SUBROUTINE DFTB_EREP_HESSIAN
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK ADD_HESS
C>
C>    @brief Hessian of DFTB
C>
C>    @details Add Hessian contribution to NI and NJ blocks
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NI,NJ Atom block to be added
C>    @param NAT Nymber of atoms
C>    @param TMP Block Hessian
C>           --- OUTPUT ---
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE ADD_HESS(NI,NJ,NAT,TMP,HESSIAN)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NI,NJ,NAT
      DOUBLE PRECISION, INTENT(INOUT) :: TMP(3,3)
      DOUBLE PRECISION, INTENT(OUT) :: HESSIAN(3*NAT,3*NAT)
C
      INTEGER :: I,ITMP,JTMP
      DOUBLE PRECISION :: VTMP,ONE=1.0D+00
C
      IF (NI.EQ.NJ) THEN
        ITMP = 3*(NI-1)+1
        JTMP = 3*(NI-1)
        DO I = 1, 3
          JTMP = JTMP + 1
          CALL DAXPY(3,ONE,TMP(1,I),1,HESSIAN(ITMP,JTMP),1)
        END DO
      ELSE
        ITMP = 3*(NJ-1)+1
        JTMP = 3*(NI-1)
        DO I = 1, 3
          JTMP = JTMP + 1
          CALL DAXPY(3,ONE,TMP(1,I),1,HESSIAN(ITMP,JTMP),1)
        END DO
        VTMP = TMP(2,1)
        TMP(2,1) = TMP(1,2)
        TMP(1,2) = VTMP
        VTMP = TMP(3,1)
        TMP(3,1) = TMP(1,3)
        TMP(1,3) = VTMP
        VTMP = TMP(3,2)
        TMP(3,2) = TMP(2,3)
        TMP(2,3) = VTMP
        ITMP = 3*(NI-1)+1
        JTMP = 3*(NJ-1)
        DO I = 1, 3
          JTMP = JTMP + 1
          CALL DAXPY(3,ONE,TMP(1,I),1,HESSIAN(ITMP,JTMP),1)
        END DO
      END IF
C
      RETURN
C
      END SUBROUTINE ADD_HESS
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DISP_HESS
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate Hessian contribution of dispersion correction.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Nov, 2014 - Yoshio Nishimoto
C>    - Added SKHP
C>
C>           --- INPUT ---
C>    @param NAT Nymber of atoms
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param DFTBDP Parameters of dispersion correction
C>    @param ZREF Nuclear charges of a given atom.  In FMO-DFTB, ZREF
C>           of BDA or BAA is differet from QREF
C>    @param QREF Nuclear charges of a given species.  This is taken
C>           from Slater-Koster files
C>    @param C Coordinates
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param IDFTBD (1) UFF (2) SK
C>    @param IWRK
C>           --- OUTPUT ---
C>    @param GRADMAT Matrix of 1st-order derivatives of dispersion
C>    @param HESSMAT Matrix of 2nd-order derivatives of dispersion
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_DISP_HESS(NAT,NSPE,ISPE,DFTBDP,ZREF,QREF,C,
     *  DISTMAT,GRADMAT,HESSMAT,HESSIAN,IDFTBD,IWRK)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00
C
      INTEGER, INTENT(IN) :: NAT,NSPE,ISPE(*),IDFTBD
      DOUBLE PRECISION :: RDMAT(3,NSPE,NSPE)
      DOUBLE PRECISION, INTENT(IN) :: DFTBDP(*),ZREF(*),QREF(*),
     *  DISTMAT(*)
      DOUBLE PRECISION, INTENT(INOUT) :: GRADMAT(*),HESSMAT(*),
     *  HESSIAN(3*NAT,3*NAT)
      INTEGER, INTENT(INOUT) :: IWRK(*)
C
      DOUBLE PRECISION :: NEA, NEB
C
      NN = NAT*(NAT+1)/2
      CALL VCLR(GRADMAT,1,NN)
      CALL VCLR(HESSMAT,1,NN)
C
      NSP1 = 0
      NSP2 = 0
      IF (IDFTBD.EQ.1) THEN
        C1 = 4.78947150872246D+01 !! 2^(5/6)*672/25
        C2 = 3.50498152274578D+01 !! 2^(2/3)*552/25
        CR0 = 8.908987181D-01
        !! FIRST CALCULATE SOME CONSTANTS FOR ALL PAIRS OF SPECIES
        DO I = 1, NSPE
          RI = DFTBDP(I*2-1)
          DI = DFTBDP(I*2  )
          DO J = I, NSPE
            RJ = DFTBDP(J*2-1)
            DJ = DFTBDP(J*2  )
            RIJ = SQRT(RI*RJ) !! van der Waals distance
            DIJ = SQRT(DI*DJ) !! well depth
            R0 = CR0*RIJ
            RDMAT(1,I,J) = R0
            RDMAT(2,I,J) = RIJ
            RDMAT(3,I,J) = DIJ
            RDMAT(1,J,I) = R0
            RDMAT(2,J,I) = RIJ
            RDMAT(3,J,I) = DIJ
          END DO
        END DO
        !! CALCULATE DISPERSION CORRECTION
        DO I = 1, NAT
          NSP1 = ISPE(I)
          CI = ZREF(I)/QREF(NSP1)
          DO J = 1, I
            CALL DFTB_CNVSQ(I,J,NSEQ)
            IF (I.EQ.J) THEN
              GRADMAT(NSEQ) = ZERO
              HESSMAT(NSEQ) = ZERO
              CYCLE
            END IF
            NSP2 = ISPE(J)
            CJ = ZREF(J)/QREF(NSP2)
            GRAD = ZERO
            HESS = ZERO
            R0  = RDMAT(1,NSP1,NSP2)
            RIJ = RDMAT(2,NSP1,NSP2)
            DIJ = RDMAT(3,NSP1,NSP2)
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DIJ = DIJ * CI * CJ
            IF (DIST.GE.R0) THEN !! ATTRACTIVE POTENTIAL
              TMP = RIJ/DIST
              R6 = TMP**6
              R12 = R6**2
              GRAD = 1.2D+01*DIJ*(R6-R12)*DISTI
              HESS = 1.2D+01*DIJ*(-7.0D+00*R6+1.3D+01*R12)*DISTI*DISTI
            ELSE !! REPULSIVE POTENTIAL
              TMP = DIST/RIJ
              R5 = TMP**5
              R10 = R5**2
              GRAD = DIJ*(-5.0D+00*C1*R5+1.0D+01*C2*R10)*DISTI
              HESS = DIJ*(-2.0D+01*C1*R5+9.0D+01*C2*R10)*DISTI*DISTI
            END IF
            GRADMAT(NSEQ) = GRAD
            HESSMAT(NSEQ) = HESS
          END DO
        END DO
      ELSE IF (IDFTBD.EQ.2) THEN
        !! FIRST CALCULATE SOME CONSTANTS FOR ALL PAIRS OF SPECIES
        DO I = 1, NSPE
          PA  = DFTBDP(I*3-2)
          R0A = DFTBDP(I*3-1)
          NEA = DFTBDP(I*3  )
          C6A = 7.5D-01*SQRT(NEA*PA*PA*PA)
          DO J = I, NSPE
            PB  = DFTBDP(J*3-2)
            R0B = DFTBDP(J*3-1)
            NEB = DFTBDP(J*3  )
            C6B = 7.5D-01*SQRT(NEB*PB*PB*PB)
C
            C6AB = (2.0D+00*C6A*C6B*PA*PB) / (PA*PA*C6B+PB*PB*C6A)
            R0AB = (R0A**3 + R0B**3) / (R0A**2 + R0B**2)
            R0AB7I = 1.0D+00 / R0AB**7
            RDMAT(1,I,J) = C6AB
            RDMAT(2,I,J) = R0AB7I
            RDMAT(1,J,I) = C6AB
            RDMAT(2,J,I) = R0AB7I
          END DO
        END DO
        DO I = 1, NAT
          NSP1 = ISPE(I)
          CI = ZREF(I)/QREF(NSP1)
          DO J = I+1, NAT
            NSP2 = ISPE(J)
            CJ = ZREF(J)/QREF(NSP2)
            C6AB   = RDMAT(1,NSP1,NSP2)
            R0AB7I = RDMAT(2,NSP1,NSP2)
            C6AB = C6AB * CI * CJ
            CALL DFTB_CNVSQ(I,J,NSEQ)
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DIST7  = DIST**7
            DIST7I = DISTI**7
            R7R07 = DIST7*R0AB7I
            VEXP = EXP(-3.0D+00*R7R07)
            DAMP1 = ONE - VEXP
            DAMP2 = DAMP1 * DAMP1
            DAMP3 = DAMP2 * DAMP1
            VAL = 8.4D+01*VEXP*R7R07-6.0D+00*DAMP1
            GRAD = -VAL*C6AB*DAMP3*DIST7I
            VAL = 2.52D+02*R7R07*VEXP*(-2.0D+00*DAMP1
     *                 +7.0D+00*R7R07*(3.0D+00-4.0D+00*DAMP1))
     *          + 4.2D+01*DAMP2
            HESS = VAL*C6AB*DAMP2*DIST7I*DISTI
            GRADMAT(NSEQ) = GRAD
            HESSMAT(NSEQ) = HESS
          END DO
        END DO
      ELSE IF (IDFTBD.EQ.4) THEN
        !! COUNT NUMBER OF BONDS FOR ALL ATOMS
        CALL VICLR(IWRK,1,NAT)
        NSEQ = 0
        DO I = 1, NAT
          NSP1 = ISPE(I)
          R0A = DFTBDP(NSP1*14-13) !! COVALENT RADIUS
          DO J = 1, I-1
            NSP2 = ISPE(I)
            R0B = DFTBDP(NSP2*14-13)
            NSEQ = NSEQ + 1
            DIST = DISTMAT(NSEQ)
            IF (DIST.LT.(R0A+R0B)) THEN
              IWRK(I) = IWRK(I) + 1
              IWRK(J) = IWRK(J) + 1
            END IF
          END DO
          NSEQ = NSEQ + 1 !! SKIP THE INDEX FOR SAME ATOM
        END DO
        DO I = 1, NAT
          IF (IWRK(I).GT.5) IWRK(I) = 5 !! MAX NEIGHBORS SHOULD BE 5
        END DO
        !! CALCULATE DISPERSION CORRECTION
        NSEQ = 0
        DO I = 1, NAT
          NSP1 = ISPE(I)
          PA   = DFTBDP(NSP1*14-12+IWRK(I))
          R0A  = DFTBDP(NSP1*14- 6+IWRK(I))
          NEA  = DFTBDP(NSP1*14)
          C6A  = 7.5D-01*SQRT(NEA*PA*PA*PA)
          CI = ZREF(I)/QREF(NSP1)
          DO J = 1, I-1 !! I+1, NAT
            NSP2 = ISPE(J)
            PB   = DFTBDP(NSP2*14-12+IWRK(J))
            R0B  = DFTBDP(NSP2*14- 6+IWRK(J))
            NEB  = DFTBDP(NSP2*14)
            C6B  = 7.5D-01*SQRT(NEB*PB*PB*PB)
            CJ = ZREF(J)/QREF(NSP2)
            C6AB = (2.0D+00*C6A*C6B*PA*PB) / (PA*PA*C6B+PB*PB*C6A)
            R0AB = (R0A**3 + R0B**3) / (R0A**2 + R0B**2)
            R0AB7I = 1.0D+00 / R0AB**7
            C6AB = C6AB * CI * CJ
            NSEQ = NSEQ + 1
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DIST7  = DIST**7
            DIST7I = DISTI**7
            R7R07 = DIST7*R0AB7I
            VEXP = EXP(-3.0D+00*R7R07)
            DAMP1 = ONE - VEXP
            DAMP2 = DAMP1 * DAMP1
            DAMP3 = DAMP2 * DAMP1
            VAL = 8.4D+01*VEXP*R7R07-6.0D+00*DAMP1
            GRAD = -VAL*C6AB*DAMP3*DIST7I
            VAL = 2.52D+02*R7R07*VEXP*(-2.0D+00*DAMP1
     *                 +7.0D+00*R7R07*(3.0D+00-4.0D+00*DAMP1))
     *          + 4.2D+01*DAMP2
            HESS = VAL*C6AB*DAMP2*DIST7I*DISTI
            GRADMAT(NSEQ) = GRAD
            HESSMAT(NSEQ) = HESS
          END DO
          NSEQ = NSEQ + 1
        END DO
      END IF
C
C     ----- ADD CONTRIBUTIONS (GRADMAT AND HESSMAT) TO HESSIAN -----
C
      CALL DFTB_MAT_HESS(NAT,C,DISTMAT,GRADMAT,HESSMAT,HESSIAN)
C
      RETURN
C
      END SUBROUTINE DFTB_DISP_HESS
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_MAT_HESS
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate Hessian contribution of classical terms from
C>             1st- and 2nd-order derivatives
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Nymber of atoms
C>    @param C Coordinates
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param GRADMAT Matrix of 1st-order derivatives of dispersion
C>    @param HESSMAT Matrix of 2nd-order derivatives of dispersion
C>           --- OUTPUT ---
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_MAT_HESS(NAT,C,DISTMAT,GRADMAT,HESSMAT,HESSIAN)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00
C
      INTEGER :: NAT
      DOUBLE PRECISION, INTENT(IN) :: C(3,*),DISTMAT(*),GRADMAT(*),
     *  HESSMAT(*)
      DOUBLE PRECISION, INTENT(INOUT) :: HESSIAN(3*NAT,3*NAT)
      DOUBLE PRECISION :: TMP(3,3),VEC(3)
C
C     NI :: DISPLACEMENT OF ATOM A
C     KI :: DIRECTION ALONG X, Y, OR Z (ATOM A)
C     NJ :: DISPLACEMENT OF ATOM B
C     KJ :: DIRECTION ALONG X, Y, OR Z (ATOM B)
C     NK :: SUM FOR WHEN NI = NJ
C
      DO NI = 1, NAT
        DO NJ = 1, NI
          CALL VCLR(TMP,1,9)
          IF (NI.EQ.NJ) THEN
            DO NK = 1, NAT
              IF (NI.EQ.NK) CYCLE
              CALL DFTB_CNVSQ(NI,NK,NSEQ)
              GRAD = GRADMAT(NSEQ)
              HESS = HESSMAT(NSEQ)
              IF (GRAD.EQ.ZERO.AND.HESS.EQ.ZERO) CYCLE
              DIST = DISTMAT(NSEQ)
              DISTI = ONE/DIST
              DO KK = 1, 3
                VEC(KK) = C(KK,NI) - C(KK,NK)
                VEC(KK) = VEC(KK)*DISTI
              END DO
              DO KI = 1, 3
                DO KJ = 1, KI
                  IF (KI.EQ.KJ) THEN
                    HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                       + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                    TMP(KI,KJ) = TMP(KI,KJ) + HESS_TMP
                  ELSE
                    HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                       - VEC(KI)*VEC(KJ)*DISTI*GRAD
                    TMP(KI,KJ) = TMP(KI,KJ) + HESS_TMP
                    TMP(KJ,KI) = TMP(KJ,KI) + HESS_TMP
                  END IF
                END DO
              END DO
            END DO
          ELSE
            CALL DFTB_CNVSQ(NI,NJ,NSEQ)
            GRAD = GRADMAT(NSEQ)
            HESS = HESSMAT(NSEQ)
            IF (GRAD.EQ.ZERO.AND.HESS.EQ.ZERO) CYCLE
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DO KK = 1, 3
              VEC(KK) = C(KK,NI) - C(KK,NJ)
              VEC(KK) = VEC(KK)*DISTI
            END DO
            DO KI = 1, 3
              DO KJ = 1, KI
                IF (KI.EQ.KJ) THEN
                  HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                     - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                  TMP(KI,KJ) = TMP(KI,KJ) + HESS_TMP
                ELSE
                  HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                     + VEC(KI)*VEC(KJ)*DISTI*GRAD
                  TMP(KI,KJ) = TMP(KI,KJ) + HESS_TMP
                  TMP(KJ,KI) = TMP(KJ,KI) + HESS_TMP
                END IF
              END DO
            END DO
          END IF
          CALL ADD_HESS(NI,NJ,NAT,TMP,HESSIAN)
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_MAT_HESS
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_TFTRI0
C>
C>    @brief Hessian of DFTB
C>
C>    @details See below
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C
      SUBROUTINE DFTB_TFTRI0(NDOCC,NPART,H,F,T,WRK,M,N,LDT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION H(*),F(*),T(LDT,M),WRK(N)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,PARALL3
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     ----- TRANSFORM THE TRIANGULAR MATRIX F USING VECTORS T -----
C                      H = T-DAGGER * F * T
C     THE ORDER OF THE TRIANGULAR MATRIX -H- IS -M-   AND   -F- IS -N-
C     THIS SUBROUTINE CALCULATES ONLY INDEPENDENT (OCCUPIED-VIRTUAL
C     COUPLING) TERMS.
C
      M2 = (M*M+M)/2
C
      PARALL3 = GOPARR  .AND.  M.GT.MXSQN3()
      IF (PARALL3) CALL VCLR(H,1,M2)
      IPCOUNT = ME - 1
C
C        THE COMPUTATION HERE IS H = T-DAGGER * (F * T),
C        WITH THE -DSPMV- FIRST PRODUCING ONE COLUMN OF F*T,
C        THEN THE -DGEMV- GENERATES AN ENTIRE ROW -J- OF -H-.
C
      DO 100 J = NDOCC+1, M
         IF(PARALL3) THEN
           IPCOUNT = IPCOUNT + 1
           IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 100
         END IF
         IJ = (J*J-J)/2
         CALL DSPMV('U',N,ONE,F,T(1,J),1,ZERO,WRK,1)
         CALL DGEMV('T',M,MIN(J,NDOCC+NPART),ONE,T,LDT,WRK,1,ZERO,
     *              H(IJ+1),1)
  100 CONTINUE
C
      IF(PARALL3) CALL DDI_GSUMF(520,H,M2)
C
      RETURN
      end
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HESS_CHKOCC
C>
C>    @brief Hessian of DFTB
C>
C>    @details Check occupation of all orbitals in alpha and beta
C>             space.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param OCC Occupation number of each MO
C>    @param EIG Eigenvalues of each MO
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param L1 Number of basis functions
C>    @param IW 6
C>    @param MASWRK
C>    @param SOME Some output
C>    @param SCFTYP
C>           --- OUTPUT ---
C>    @param NDOCC Numer of doubly occupied orbitals in R-DFTB, but
C>           of singly occupied orbitals in U-DFTB.
C>    @param NPART Number of partially occupied orbitals
C>    @param NVIRT Number of virtual orbitals
C>    @param FON Whether fractional occupation is used or not
C>    @param ROHF Whether (same-electron) RO-DFTB or not
C>
C
      SUBROUTINE DFTB_HESS_CHKOCC(OCC,EIG,NDOCC,NPART,NVIRT,NSPIN,L1,IW,
     *  FON,ROHF,MASWRK,SOME,SCFTYP)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NSPIN,L1
      DOUBLE PRECISION, INTENT(IN) :: OCC(L1,NSPIN),EIG(L1,NSPIN),SCFTYP
      INTEGER, INTENT(OUT) :: NDOCC(2),NPART(2),NVIRT(2)
      INTEGER, INTENT(IN) :: IW
      LOGICAL, INTENT(OUT) :: FON(3),ROHF
      LOGICAL, INTENT(IN) :: MASWRK,SOME
C
      INTEGER :: IO,NHALF,ISPIN
      DOUBLE PRECISION :: DOC,OCCI
      DOUBLE PRECISION, PARAMETER :: ONE=1.0D+00,TWO=2.0D+00
      DOUBLE PRECISION RHF/8HRHF     /,ROHFC/8HROHF    /,UHF/8HUHF     /
C
      !! NHALF SHOULD BE USED, MAYBE
      !! FIRST ONLY FOR ALPHA
C
      IF (SCFTYP.EQ.RHF)  DOC = TWO
      IF (SCFTYP.EQ.UHF)  DOC = ONE
      IF (SCFTYP.EQ.ROHFC) DOC = TWO
C
      DO ISPIN = 1, NSPIN
        FON(ISPIN) = .FALSE.
        NDOCC(ISPIN) = 0
        NPART(ISPIN) = 0
        NVIRT(ISPIN) = 0
        NHALF = 0
        DO IO = 1, L1
          OCCI = OCC(IO,ISPIN)
          IF (OCCI+1.0D-10.GT.DOC) THEN
            NDOCC(ISPIN) = NDOCC(ISPIN) + 1
          ELSE IF (OCCI.LE.1.0D-10) THEN
            NVIRT(ISPIN) = NVIRT(ISPIN) + 1
          ELSE
            NPART(ISPIN) = NPART(ISPIN) + 1
            IF (OCCI.EQ.ONE) NHALF = NHALF + 1
            IF (.NOT.FON(ISPIN).AND.MASWRK.AND.SOME) THEN
              IF (ISPIN.EQ.1) THEN
                WRITE (IW,'(/" CHECK PARTLY OCCUPIED ALPHA-ORBITALS"/)')
              ELSE
                WRITE (IW,'(/" CHECK PARTLY OCCUPIED  BETA-ORBITALS"/)')
              END IF
              WRITE (IW,*) " #ORB       EIGENVALUES(AU)      OCCUPATION
     * NUM."
            END IF
            IF (MASWRK.AND.SOME) WRITE (IW,'(2X,I4,2(X,F20.10))')
     *        IO,EIG(IO,ISPIN),OCC(IO,ISPIN)
            FON(ISPIN) = .TRUE.
          END IF
        END DO
        !! ASSUME ROHF WAVE FUNCTION, IF THE OCCUPATION OF ALL PARTLY
        !! OCCUPIED ARE ONE.
      END DO
      IF (NSPIN.EQ.1.AND.NHALF.NE.0.AND.NHALF.EQ.NPART(1)) ROHF=.TRUE.
C
      RETURN
C
      END SUBROUTINE DFTB_HESS_CHKOCC
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HESS_DIRECT
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate derivative integrals in integral direct way.
C>             This will be abolished, unless someone finds a better
C>             algorithm.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param C Coordinates
C>    @param SHIFT Shift contribution (atom-resolved)
C>    @param SHIFTSA Shift contribution of alpha orbitals (shell-res.)
C>    @param SHIFTSB Shift contribution of beta  orbitals (shell-res.)
C>    @param WRKH,WRKS Working array for AO derivative of non-perturbed
C>           Hamiltonian and overlap matrix
C>    @param NI Atom to be differenciated
C>    @param KI Axis to be differenciated
C>    @param NAT Number of atoms
C>    @param L0 LQMT
C>    @parma L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param IND AO index of each atom
C>    @param NSHELL Number of shells
C>    @param NSPE Number of species
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param INDSH Index of shell for each atom
C>    @param INDSAO AO index of each shell
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>    @param SCC Whether SCC or not
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param UHF Whether U-DFTB or not
C>           --- OUTPUT ---
C>    @param HDERMO H_{ij}^a + V_{ij}^a
C>    @param SDERMO S_{ij}^a
C>    @param SDERAO S_{\mu \nu}^a
C>
C
      SUBROUTINE DFTB_HESS_DIRECT(HDERMO,SDERMO,SDERAO,C,VEC,SHIFT,
     *  SHIFTSA,SHIFTSB,WRKH,WRKS,WRK,WRK1,NI,KI,NAT,L0,L1,L2,IND,
     *  NSHELL,NSPE,NSPIN,INDSH,INDSAO,ISPE,MAXANG,SCC,SRSCC,UHF)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L0,L1,L2,NAT,NSHELL,NSPIN
      DOUBLE PRECISION, INTENT(OUT) :: HDERMO(L2,NSPIN),
     *  SDERMO(L2,NSPIN),SDERAO(L2)
      DOUBLE PRECISION, INTENT(IN) :: C(3,NAT),VEC(L1,L1,NSPIN),
     *  SHIFT(NAT),SHIFTSA(NSHELL),SHIFTSB(NSHELL)
      DOUBLE PRECISION, INTENT(INOUT) :: WRKH(L2),WRKS(L2),WRK(*),
     *  WRK1(*)
      INTEGER, INTENT(IN) :: NI,KI,IND(*),NSPE,
     *                       INDSH(*),INDSAO(*),ISPE(NAT),MAXANG(NSPE)
      LOGICAL, INTENT(IN) :: SCC,SRSCC,UHF
C
      DOUBLE PRECISION :: AU(9,9),BU(9,9),V(3)
      INTEGER :: NSEQ,NJ,M,N,MU,NU,ISPIN
      LOGICAL :: SKP
C
      CALL VCLR(WRKH,1,L2)
      CALL VCLR(WRKS,1,L2)
      DO NJ = 1, NAT
        IF (NI.EQ.NJ) CYCLE
C       CALL VCLR(AU,1,81)
C       CALL VCLR(BU,1,81)
        CALL DFTB_DISPLACEMENT(NI,NJ,KI,0,V,C,0)
        CALL DFTB_SKODE_HELPA(1,NI,NJ,KI,0,V,AU,BU,.TRUE.,.TRUE.,SKP)
        IF (SKP) CYCLE
        DO N = 1, IND(NJ+1) - IND(NJ)
          NU = IND(NJ)+N
          DO M = 1, IND(NI+1) - IND(NI)
            MU = IND(NI)+M
            CALL DFTB_CNVSQ(MU,NU,NSEQ)
            WRKH(NSEQ) = AU(M,N)
            WRKS(NSEQ) = BU(M,N)
          END DO
        END DO
      END DO
C
      !! HDERMO
      DO ISPIN = 1, NSPIN
        CALL TFTRI0(HDERMO(1,ISPIN),WRKH,VEC(1,1,ISPIN),WRK,L0,L1,L1)
      END DO
C
      !! SDERMO
      DO ISPIN = 1, NSPIN
        CALL TFTRI0(SDERMO(1,ISPIN),WRKS,VEC(1,1,ISPIN),WRK,L0,L1,L1)
      END DO
C
      IF (SCC) THEN
        !! SAVE SDERAO
        CALL DCOPY(L2,WRKS,1,SDERAO,1)
        IF (UHF.OR.SRSCC) THEN
          CALL SHIFT_TRIANGLE_DER_SHELL(NAT,NI,L2,IND,INDSH,
     *      INDSAO,NSPE,ISPE,MAXANG,SHIFTSA,SDERAO,WRKS)
        ELSE
          CALL SHIFT_TRIANGLE_DER(NAT,NI,L2,IND,SHIFT,
     *         SDERAO,WRKS)
        END IF
        CALL TFTRI0(WRK1,WRKS,VEC,WRK,L0,L1,L1) !! WRK1 = V_{IJ}^a
        CALL VADD(WRK1,1,HDERMO,1,HDERMO,1,L2)
        IF (UHF) THEN
          CALL SHIFT_TRIANGLE_DER_SHELL(NAT,NI,L2,IND,INDSH,
     *       INDSAO,NSPE,ISPE,MAXANG,SHIFTSB,SDERAO,WRKS)
          CALL TFTRI0(WRK1,WRKS,VEC(1,1,2),WRK,L0,L1,L1) !! WRK1 = V_{IJ}^a
          CALL VADD(WRK1,1,HDERMO(1,2),1,HDERMO(1,2),1,L2)
        END IF
      END IF
C
      END SUBROUTINE DFTB_HESS_DIRECT
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DISP_HESS_ESDIM
C>
C>    @brief Hessian of FMO-DFTB
C>
C>    @details Calculate dispersion Hessian of FMO-DFTB for separated
C>
C>    @author Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param IFG     I fragment index
C>    @param JFG     J fragment index
C>    @param NATI    Number of atoms in IFG
C>    @param NATJ    Number of atoms in JFG
C>    @param NC1     NATFMO*3
C>    @param NATFMO  Number of atoms in the whole system
C>    @param DISTMAT Contains distance matrix
C>    @param GRADMAT Working array for first derivative
C>    @param HESSMAT Working array for second derivative
C>    @param NBOND   Number of bonds
C>    @param INDFRG  First atom of each fragment in terms of NATFMOB?
C>    @param IATFRG  Global atom index with NBDFG?
C>    @param ISPEFMO ISPE for all atoms (NATFMO)
C>    @param DCTMP   Constants for dispersion correction, see DFTB_DCFMO
C>    @param ZREFFMO ZREF for all atoms (NATFMO)
C>    @param FMOC    Coordinates of allatoms (NATFMO)
C>    @param SCAL    Scaling factor of contributions
C>           --- IN/OUTPUT ---
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_DISP_HESS_ESDIM(IFG,JFG,NATI,NATJ,NC1,NATFMO,
     *  DISTMAT,GRADMAT,HESSMAT,HESSIAN,NBOND,
     *  INDFRG,IATFRG,ISPEFMO,DCTMP,ZREFFMO,FMOC,SCAL)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER,PARAMETER :: MXATM=2000,MXSPE=10
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                ZREF(MXATM),SPNCST(6,MXSPE),SPE(MXATM),NSPE,
     *                MAXANG(MXATM),ISPE(MXATM),IND(MXATM+1),IDFTBD
      COMMON /DFTBSK/ SKDIM(MXSPE,MXSPE),SKSPIN(MXSPE),QREFL(3,MXSPE),
     *                HUBBL(3,MXSPE),QREF(MXSPE),HUBB(MXSPE),SKCUT2,
     *                NEEDSK,LSKHTAB(MXSPE,MXSPE),LSKSTAB(MXSPE,MXSPE),
     *                LSKGRID(MXSPE,MXSPE),LSKSELF(MXSPE)
C
      INTEGER, INTENT(IN) :: IFG,JFG,NATI,NATJ,NC1,NATFMO,
     *  NBOND(*),INDFRG(*),IATFRG(*),ISPEFMO(*)
      DOUBLE PRECISION :: RDMAT(3,NSPE,NSPE),VEC(3)
      DOUBLE PRECISION, INTENT(IN) :: DISTMAT(*),
     *  DCTMP(*),ZREFFMO(*),FMOC(3,NATFMO)
      DOUBLE PRECISION, INTENT(INOUT) :: GRADMAT(*),HESSMAT(*),
     *  HESSIAN(3*NATFMO,3*NATFMO)
C
      DOUBLE PRECISION :: NEA, NEB
C
      CALL VCLR(GRADMAT,1,NATI*NATJ)
      CALL VCLR(HESSMAT,1,NATI*NATJ)
C
      INDI = INDFRG(IFG)
      INDJ = INDFRG(JFG)
      CALL DCOPY(3*NSPE*NSPE,DCTMP,1,RDMAT,1)
      IF (IDFTBD.EQ.1) THEN
        C1 = 4.78947150872246D+01 !! 2^(5/6)*672/25
        C2 = 3.50498152274578D+01 !! 2^(2/3)*552/25
C       CR0 = 8.908987181D-01
        !! CALCULATE DISPERSION CORRECTION
        NSEQ = 0
        DO I = 1, NATI
          IAG = IATFRG(INDI+I-1)
          ISP = ISPEFMO(IAG)
          CI = ZREFFMO(INDI+I-1)/QREF(ISP)
          DO J = 1, NATJ
            NSEQ = NSEQ + 1
            JAG = IATFRG(INDJ+J-1)
            JSP = ISPEFMO(JAG)
            CJ = ZREFFMO(INDJ+J-1)/QREF(JSP)
            R0  = RDMAT(1,ISP,JSP)
            RIJ = RDMAT(2,ISP,JSP)
            DIJ = RDMAT(3,ISP,JSP)
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DIJ = DIJ * CI * CJ
            IF (DIST.GE.R0) THEN !! ATTRACTIVE POTENTIAL
              TMPV = RIJ/DIST
              R6 = TMPV**6
              R12 = R6**2
              GRAD = 1.2D+01*DIJ*(R6-R12)*DISTI
              HESS = 1.2D+01*DIJ*(-7.0D+00*R6+1.3D+01*R12)*DISTI*DISTI
            ELSE !! REPULSIVE POTENTIAL
              TMPV = DIST/RIJ
              R5 = TMPV**5
              R10 = R5**2
              GRAD = DIJ*(-5.0D+00*C1*R5+1.0D+01*C2*R10)*DISTI
              HESS = DIJ*(-2.0D+01*C1*R5+9.0D+01*C2*R10)*DISTI*DISTI
            END IF
            GRADMAT(NSEQ) = GRAD
            HESSMAT(NSEQ) = HESS
          END DO
        END DO
      ELSE IF (IDFTBD.EQ.2) THEN
        NSEQ = 0
        DO I = 1, NATI
          IAG = IATFRG(INDI+I-1)
          ISP = ISPEFMO(IAG)
          CI = ZREFFMO(INDI+I-1)/QREF(ISP)
          DO J = 1, NATJ
            JAG = IATFRG(INDJ+J-1)
            JSP = ISPEFMO(JAG)
            CJ = ZREFFMO(INDJ+J-1)/QREF(JSP)
            C6AB   = RDMAT(1,ISP,JSP)
            R0AB7I = RDMAT(2,ISP,JSP)
            C6AB = C6AB * CI * CJ
            NSEQ = NSEQ + 1
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DIST7  = DIST**7
            DIST7I = DISTI**7
            R7R07 = DIST7*R0AB7I
            VEXP = EXP(-3.0D+00*R7R07)
            DAMP1 = ONE - VEXP
            DAMP2 = DAMP1 * DAMP1
            DAMP3 = DAMP2 * DAMP1
            VAL = 8.4D+01*VEXP*R7R07-6.0D+00*DAMP1
            GRAD = -VAL*C6AB*DAMP3*DIST7I
            VAL = 2.52D+02*R7R07*VEXP*(-2.0D+00*DAMP1
     *                 +7.0D+00*R7R07*(3.0D+00-4.0D+00*DAMP1))
     *          + 4.2D+01*DAMP2
            HESS = VAL*C6AB*DAMP2*DIST7I*DISTI
            GRADMAT(NSEQ) = GRAD
            HESSMAT(NSEQ) = HESS
          END DO
        END DO
      ELSE IF (IDFTBD.EQ.4) THEN
        !! CALCULATE DISPERSION CORRECTION
        NSEQ = 0
        DO I = 1, NATI
          IAG = IATFRG(INDI+I-1)
          ISP = ISPEFMO(IAG)
          PA  = DFTBDP(ISP*14-12+NBOND(IAG))
          R0A = DFTBDP(ISP*14- 6+NBOND(IAG))
          NEA = DFTBDP(ISP*14)
          C6A = 7.5D-01*SQRT(NEA*PA*PA*PA)
          CI  = ZREFFMO(INDI+I-1)/QREF(ISP)
          DO J = 1, NATJ
            JAG = IATFRG(INDJ+J-1)
            JSP = ISPEFMO(JAG)
            PB  = DFTBDP(JSP*14-12+NBOND(JAG))
            R0B = DFTBDP(JSP*14- 6+NBOND(JAG))
            NEB = DFTBDP(JSP*14)
            C6B = 7.5D-01*SQRT(NEB*PB*PB*PB)
            CJ  = ZREFFMO(INDJ+J-1)/QREF(JSP)
            C6AB = (2.0D+00*C6A*C6B*PA*PB) / (PA*PA*C6B+PB*PB*C6A)
            R0AB = (R0A**3 + R0B**3) / (R0A**2 + R0B**2)
            R0AB7I = 1.0D+00 / R0AB**7
            C6AB = C6AB * CI * CJ
            NSEQ = NSEQ + 1
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DIST7  = DIST**7
            DIST7I = DISTI**7
            R7R07 = DIST7*R0AB7I
            VEXP = EXP(-3.0D+00*R7R07)
            DAMP1 = ONE - VEXP
            DAMP2 = DAMP1 * DAMP1
            DAMP3 = DAMP2 * DAMP1
            VAL = 8.4D+01*VEXP*R7R07-6.0D+00*DAMP1
            GRAD = -VAL*C6AB*DAMP3*DIST7I
            VAL = 2.52D+02*R7R07*VEXP*(-2.0D+00*DAMP1
     *                 +7.0D+00*R7R07*(3.0D+00-4.0D+00*DAMP1))
     *          + 4.2D+01*DAMP2
            HESS = VAL*C6AB*DAMP2*DIST7I*DISTI
            GRADMAT(NSEQ) = GRAD
            HESSMAT(NSEQ) = HESS
          END DO
        END DO
      END IF
C
      IF (SCAL.NE.ONE) THEN
        CALL DSCAL(NATI*NATJ,SCAL,GRADMAT,1)
        CALL DSCAL(NATI*NATJ,SCAL,HESSMAT,1)
      END IF
C
C     ----- ADD CONTRIBUTIONS (GRADMAT AND HESSMAT) TO HESSIAN -----
C
      NSEQ = 0
      DO NI = 1, NATI
        IAG = IATFRG(INDI+NI-1)
        IGZ = (IAG-1)*3
        DO NJ = 1, NATJ
          JAG = IATFRG(INDJ+NJ-1)
          JGZ = (JAG-1)*3
          NSEQ = NSEQ + 1
          GRAD = GRADMAT(NSEQ)
          HESS = HESSMAT(NSEQ)
          IF (GRAD.EQ.ZERO.AND.HESS.EQ.ZERO) CYCLE
          DIST = DISTMAT(NSEQ)
          DISTI = ONE/DIST
          DO KK = 1, 3
            VEC(KK) = FMOC(KK,IAG) - FMOC(KK,JAG)
            VEC(KK) = VEC(KK)*DISTI
          END DO
          DO KI = 1, 3
            DO KJ = 1, 3
              VAL = VEC(KI)*VEC(KJ)*(HESS-GRAD*DISTI)
              IF (KI.EQ.KJ) VAL = VAL + GRAD*DISTI
              HESSIAN(IGZ+KI,IGZ+KJ) = HESSIAN(IGZ+KI,IGZ+KJ) + VAL
              HESSIAN(JGZ+KI,JGZ+KJ) = HESSIAN(JGZ+KI,JGZ+KJ) + VAL
              HESSIAN(IGZ+KI,JGZ+KJ) = HESSIAN(IGZ+KI,JGZ+KJ) - VAL
              HESSIAN(JGZ+KI,IGZ+KJ) = HESSIAN(JGZ+KI,IGZ+KJ) - VAL
            END DO
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_DISP_HESS_ESDIM
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DISP_HESS_ESDIM
C>
C>    @brief   DFTB Hessian
C>
C>    @details Check the degeneracy of orbitals
C>
C>    @author  Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NSPIN   Number of spins
C>    @param L1      Number of atomic orbitals
C>    @param EIG     e_i
C>    @param OCC     f_i
C>    @param DEGTHR1 Near-degenerate threshold
C>    @param DEGTHR2 Quasi-degenerate threshold
C>    @param NDOCC   Number of doubly occupied orbitals
C>    @param NPART   Number of partially occupied orbitals
C>    @param IW      6
C>    @param NDEG    Number of quasi-degenerate orbitals?
C>    @param MASWRK  MASWRK
C>
C
      SUBROUTINE DFTB_HESS_CHKDEG(NSPIN,L1,EIG,OCC,DEGTHR1,DEGTHR2,
     *                            NDOCC,NPART,IW,NDEG,MASWRK)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NSPIN,L1,NDOCC(2),NPART(2),IW
      INTEGER, INTENT(OUT) :: NDEG
      DOUBLE PRECISION,INTENT(IN) :: DEGTHR1,DEGTHR2,OCC(L1,*),EIG(L1,*)
      LOGICAL, INTENT(IN) :: MASWRK
C
      INTEGER :: IO,JO,ISPIN,NNDEG
      DOUBLE PRECISION :: EI,EJ,OCCI,OCCJ
      LOGICAL :: FIRST
C
      FIRST = .TRUE.
      NDEG = 0
      NNDEG = 0
      DO ISPIN = 1, NSPIN
        DO IO = NDOCC(ISPIN)+1, NDOCC(ISPIN)+NPART(ISPIN)-1
          EI   = EIG(IO,ISPIN)
          OCCI = OCC(IO,ISPIN)
          DO JO = IO+1, NDOCC(ISPIN)+NPART(ISPIN)
            EJ   = EIG(JO,ISPIN)
            OCCJ = OCC(JO,ISPIN)
C           IF (ABS(EI-EJ).LT.DEGTHR2.OR.ABS(OCCI-OCCJ).LT.DEGTHR2) THEN
            IF (ABS(EI-EJ).LT.DEGTHR2) THEN
              IF (FIRST) THEN
                IF (MASWRK) THEN
                  WRITE (IW,'(" * FOLLOWING PAIRS OF ORBITALS ARE",
     *                        " DEGENERATED")')
                WRITE (IW,'("   THRESHOLD: ABS(EIG(I)-EIG(J)/EIG(I) < ",
     *                         E8.2)') DEGTHR2
                  WRITE (IW,'(" #ORB(I)  #ORB(J)  EIG(I)-EIG(J)",
     *                        "  OCC(I)-OCC(J)")')
                END IF
                FIRST = .FALSE.
              END IF
              IF (MASWRK) WRITE (IW,'(3X,I4,5X,I4,4X,E11.4,4X,E11.4)')
     *          IO,JO,EI-EJ,OCCI-OCCJ
              NDEG = NDEG + 1
            ELSE IF (ABS(EI-EJ).LT.DEGTHR1) THEN
              NNDEG = NNDEG + 1
            END IF
          END DO
        END DO
      END DO
      IF (MASWRK) THEN
        IF (FIRST) THEN
        WRITE (IW,*) "  THERE ARE NO DEGENERATED ORBITALS IN PARTIALLY",
     *                 " OCCUPIED REGION"
          WRITE (IW,*)
        ELSE
          WRITE (IW,*) "  IN ORDER TO PREVENT DIVERGENCE OF U MATRIX,"
          WRITE (IW,*) "  MACLAURIN EXPANSION IS USED FOR THESE PAIRS"
        END IF
C       IF (NNDEG.NE.0) THEN
          WRITE (IW,'("  NUMBER OF NEARLY DEGENERATED ORBITAL PAIRS:",
     *                I3)') NNDEG
C       END IF
        WRITE (IW,*)
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_HESS_CHKDEG
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HESS_PCM1
C>
C>    @brief   DFTB/PCM Hessian
C>
C>    @details Calculate the derivative of shift contributions that come
C>             from PCM (SHIFT). dq/da contribution is calculated
C>             somewhere. Additionally, this calculates some of
C>             derivative contributions of ESP on tesserae (PCMTMP).
C>
C>    @author  Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT    Number of atoms
C>    @param NI     Atom to be differenciated
C>    @param KI     Axis to be differenciated
C>    @param NTS    Number of tesserae
C>    @param C      Coordinate of the solute
C>    @param XCTS   X coordinate of tesserae
C>    @param YCTS   Y coordinate of tesserae
C>    @param ZCTS   Z coordinate of tesserae
C>    @param QSE    Induced charges by the pristine density matrix
C>    @param CHAMUL Mulliken charges
C>    @param ISPHE  Which atom the tessera belongs
C>           --- IN/OUTPUT ---
C>    @param SHIFT  Shift contributions
C>    @param PCMTMP Derivative contributions of ESP on tesserae
C>
C
      SUBROUTINE DFTB_HESS_PCM1(NAT,NI,KI,NTS,C,XCTS,YCTS,ZCTS,QSE,
     *                          SHIFT,CHAMUL,PCMTMP,ISPHE)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /PCMPLY/ STOT,VOL,CCX,CCY,CCZ,RDIF,NESF,NESFP,NESFF,I_NESF,
     *                L_AST
C
      INTEGER, INTENT(IN) :: NAT,NI,KI,ISPHE(*)
      DOUBLE PRECISION, INTENT(IN) :: C(3,NAT),XCTS(NTS),YCTS(NTS),
     *  ZCTS(NTS),QSE(NTS),CHAMUL(NAT)
      DOUBLE PRECISION, INTENT(INOUT) :: SHIFT(NAT),PCMTMP(NTS)
C
      CX = C(1,NI)
      CY = C(2,NI)
      CZ = C(3,NI)
      CC = C(KI,NI)
      DO IPT = 1, NTS
        XP = XCTS(IPT)
        YP = YCTS(IPT)
        ZP = ZCTS(IPT)
        IF (KI.EQ.1) PP = XP
        IF (KI.EQ.2) PP = YP
        IF (KI.EQ.3) PP = ZP
C
        IF (ISPHE(IPT).NE.NI.OR.NESFP.GT.0) THEN
          DIST = SQRT((CX-XP)*(CX-XP)+(CY-YP)*(CY-YP)+(CZ-ZP)*(CZ-ZP))
          DISTI = 1.0D+00/DIST
          DISTI3 = DISTI*DISTI*DISTI
          !! explicit term 2
          !! negative sign, because of -S()
          SHIFT(NI) = SHIFT(NI) - QSE(IPT)*(PP-CC)*DISTI3
          !! for implicit term 2-a
          !! negative sign, because of the formulation
          !! -Dq_a*dR/da
          PCMTMP(IPT) = -CHAMUL(NI)*(PP-CC)*DISTI3
        ELSE IF (ISPHE(IPT).EQ.NI.AND.NESFP.EQ.0) THEN
C
C       DUE TO ASC DISPLACEMENT
C
          DO NJ = 1, NAT
            IF (NI.EQ.NJ) CYCLE
            CXJ = C(1,NJ)
            CYJ = C(2,NJ)
            CZJ = C(3,NJ)
            CCJ = C(KI,NJ)
            DIST = SQRT((CXJ-XP)*(CXJ-XP)+(CYJ-YP)*(CYJ-YP)
     *                 +(CZJ-ZP)*(CZJ-ZP))
            DISTI = 1.0D+00/DIST
            DISTI3 = DISTI*DISTI*DISTI
            PCMTMP(IPT) = PCMTMP(IPT) + CHAMUL(NJ)*(PP-CCJ)*DISTI3
  
            SHIFT(NJ) = SHIFT(NJ) + QSE(IPT)*(PP-CCJ)*DISTI3
          END DO
        END IF
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_HESS_PCM1
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_QPOTEN
C>
C>    @brief   DFTB/PCM Hessian
C>
C>    @details Calculate ESP, exerted by CHAMUL, on tesserae
C>
C>    @author  Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT    Number of atoms
C>    @param NTS    Number of tesserae
C>    @param C      Coordinate of the solute
C>    @param XCTS   X coordinate of tesserae
C>    @param YCTS   Y coordinate of tesserae
C>    @param ZCTS   Z coordinate of tesserae
C>           --- OUTPUT ---
C>    @param PCMTMP Contributions of ESP on tesserae
C>
C
      SUBROUTINE DFTB_QPOTEN(NAT,NTS,C,XCTS,YCTS,ZCTS,CHAMUL,PCMPOT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER, INTENT(IN) :: NAT,NTS
      DOUBLE PRECISION, INTENT(IN) :: C(3,NAT),XCTS(NTS),YCTS(NTS),
     *  ZCTS(NTS),CHAMUL(NTS)
      DOUBLE PRECISION, INTENT(INOUT) :: PCMPOT(NAT)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      IF (GOPARR) CALL VCLR(PCMPOT,1,NTS)
      IPCOUNT = ME - 1
C
      DO ITS = 1, NTS
        IF(GOPARR) THEN
          IPCOUNT = IPCOUNT + 1
          IF(MOD(IPCOUNT,NPROC).NE.0) CYCLE
        END IF
        XP = XCTS(ITS)
        YP = YCTS(ITS)
        ZP = ZCTS(ITS)
        TMP = 0.0D+00
        DO IAT = 1, NAT
          CX = C(1,IAT)
          CY = C(2,IAT)
          CZ = C(3,IAT)
          DIST = SQRT((CX-XP)*(CX-XP)+(CY-YP)*(CY-YP)+(CZ-ZP)*(CZ-ZP))
          TMP = TMP - CHAMUL(IAT)/DIST
        END DO
        PCMPOT(ITS) = TMP
      END DO
C
      IF(GOPARR) CALL DDI_GSUMF(2418,PCMPOT,NTS)
C
      RETURN
C
      END SUBROUTINE DFTB_QPOTEN
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_QSHIFT
C>
C>    @brief   DFTB/PCM Hessian
C>
C>    @details Calculate shift contributions due to ASCs (QSE)
C>
C>    @author  Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT    Number of atoms
C>    @param NTS    Number of tesserae
C>    @param C      Coordinate of the solute
C>    @param XCTS   X coordinate of tesserae
C>    @param YCTS   Y coordinate of tesserae
C>    @param ZCTS   Z coordinate of tesserae
C>    @param QSE    Induced charges on tesserae
C>           --- IN/OUTPUT ---
C>    @param SHIFT  Shift contribution
C>
C
      SUBROUTINE DFTB_QSHIFT(NAT,NTS,C,XCTS,YCTS,ZCTS,QSE,SHIFT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER, INTENT(IN) :: NAT,NTS
      DOUBLE PRECISION, INTENT(IN) :: C(3,NAT),XCTS(NTS),YCTS(NTS),
     *  ZCTS(NTS),QSE(NTS)
      DOUBLE PRECISION, INTENT(INOUT) :: SHIFT(NAT)
C
      DO IAT = 1, NAT
        TMP = 0.0D+00
        CX = C(1,IAT)
        CY = C(2,IAT)
        CZ = C(3,IAT)
        DO ITS = 1, NTS
          XP = XCTS(ITS)
          YP = YCTS(ITS)
          ZP = ZCTS(ITS)
          DIST = SQRT((CX-XP)*(CX-XP)+(CY-YP)*(CY-YP)+(CZ-ZP)*(CZ-ZP))
          TMP = TMP + QSE(ITS)/DIST
        END DO
        SHIFT(IAT) = SHIFT(IAT) - TMP
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_QSHIFT
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HESS_PCM2
C>
C>    @brief   DFTB/PCM Hessian
C>
C>    @details Calculate remaining Hessian contributions due to PCM
C>
C>    @author  Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT     Number of atoms
C>    @param NTS     Number of tesserae
C>    @param C       Coordinate of the solute
C>    @param XCTS    X coordinate of tesserae
C>    @param YCTS    Y coordinate of tesserae
C>    @param ZCTS    Z coordinate of tesserae
C>    @param QSE     Induced charges on tesserae
C>    @param QSEDER  dq/da (where q is ASC)
C>    @param QDER    dq/da (where q is Mulliken charge)
C>    @parma CHAMUL  Mulliken charges
C>    @param AS      Area of tessera
C>    @param ISPHE   Which atom the tessera belongs
C>    @param EPSHET  Epsilon of tesserae
C>    @param IDDAI   ?? used in FIXPVA
C>    @param DAI     ?? used in FIXPVA
C>    @param DCDAQ   dC/da*\bar{q} if available
C>    @param DCDAQ   dC/da*\bar{q} is stored or not
C>           --- IN/OUTPUT ---
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_HESS_PCM2(NAT,NTS,C,XCTS,YCTS,ZCTS,QSE,QSEDER,
     *                          QDER,CHAMUL,AS,ISPHE,EPSHET,IDDAI,
     *                          DAI,PCMTMP,HESSIAN,DCDAQ,SAVDCQ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER, INTENT(IN) :: NAT,ISPHE(*),IDDAI(21,*)
      DOUBLE PRECISION, INTENT(IN) :: C(3,NAT),XCTS(NTS),YCTS(NTS),
     *  ZCTS(NTS),QSE(NTS),QSEDER(NTS),QDER(NAT),CHAMUL(NAT),AS(*),
     *  EPSHET(*),DAI(3,20,*),DCDAQ(NTS,3,NAT)
      DOUBLE PRECISION, INTENT(INOUT) :: PCMTMP(*),HESSIAN(3*NAT)
      LOGICAL, INTENT(IN) :: SAVDCQ
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL GOPARR,DSKWRK,MASWRK,PARALL2
      COMMON /PCMPLY/ STOT,VOL,CCX,CCY,CCZ,RDIF,NESF,NESFP,NESFF,I_NESF,
     *                L_AST
C
      DIMENSION VEC(3)
C
C     MUST BE PARALLELIZED!
C
      PARALL2 = GOPARR !.AND.  M.GT.MXSQN2()
      IPCOUNT = ME - 1
C
      DO NI = 1, NAT
        IF(PARALL2) THEN
          IPCOUNT = IPCOUNT + 1
          IF (MOD(IPCOUNT,NPROC).NE.0) CYCLE
        END IF
        IR = 3*(NI-1)+1
        DO IPT = 1, NTS
          IF (ISPHE(IPT).NE.NI.OR.NESFP.GT.0) THEN
C           Due to other ASCs
            VEC(1) = C(1,NI) - XCTS(IPT)
            VEC(2) = C(2,NI) - YCTS(IPT)
            VEC(3) = C(3,NI) - ZCTS(IPT)
            DIST = SQRT(VEC(1)*VEC(1)+VEC(2)*VEC(2)+VEC(3)*VEC(3))
            DISTI = 1.0D+00/DIST
            DISTI3 = DISTI*DISTI*DISTI
            TMP = (QSE(IPT)*QDER(NI)+QSEDER(IPT)*CHAMUL(NI))*DISTI3
            HESSIAN(IR  ) = HESSIAN(IR  ) + TMP*VEC(1)
            HESSIAN(IR+1) = HESSIAN(IR+1) + TMP*VEC(2)
            HESSIAN(IR+2) = HESSIAN(IR+2) + TMP*VEC(3)
          ELSE IF (ISPHE(IPT).EQ.NI.AND.NESFP.EQ.0) THEN
C           Due to ASC displacement
            DO NJ = 1, NAT
              IF (NI.EQ.NJ) CYCLE
              VEC(1) = C(1,NJ) - XCTS(IPT)
              VEC(2) = C(2,NJ) - YCTS(IPT)
              VEC(3) = C(3,NJ) - ZCTS(IPT)
              DIST = SQRT(VEC(1)*VEC(1)+VEC(2)*VEC(2)+VEC(3)*VEC(3))
              DISTI = 1.0D+00/DIST
              DISTI3 = DISTI*DISTI*DISTI
              TMP = (QSE(IPT)*QDER(NJ)+QSEDER(IPT)*CHAMUL(NJ))*DISTI3
              HESSIAN(IR  ) = HESSIAN(IR  ) - TMP*VEC(1)
              HESSIAN(IR+1) = HESSIAN(IR+1) - TMP*VEC(2)
              HESSIAN(IR+2) = HESSIAN(IR+2) - TMP*VEC(3)
            END DO
          END IF
        END DO
        DO KI = 1, 3
          IF (SAVDCQ) THEN
            TMP = DDOT(NTS,DCDAQ(1,KI,NI),1,QSEDER,1)
          ELSE
            CALL VCLR(PCMTMP,1,NTS)
            CALL DFTB_CALC_DCDA(NTS,NI,KI,XCTS,YCTS,ZCTS,AS,ISPHE,
     *                          EPSHET,IDDAI,DAI,QSE,PCMTMP)
            TMP = DDOT(NTS,PCMTMP,1,QSEDER,1)
          END IF
          IR = 3*(NI-1)+KI
          HESSIAN(IR) = HESSIAN(IR) + TMP
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_HESS_PCM2
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CALC_DCDA
C>
C>    @brief   DFTB/PCM Hessian
C>
C>    @details Calculate dC/da*\bar{q}. This is taken from QCDERQ.
C>             This does not work for EFP, TD, etc.
C>
C>    @author  Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param NTS     Number of tesserae
C>    @param NI     Atom to be differenciated
C>    @param KI     Axis to be differenciated
C>    @param XCTS    X coordinate of tesserae
C>    @param YCTS    Y coordinate of tesserae
C>    @param ZCTS    Z coordinate of tesserae
C>    @param AS      Area of tessera
C>    @param ISPHE   Which atom the tessera belongs
C>    @param EPSHET  Epsilon of tesserae
C>    @param IDDAI   ?? used in FIXPVA
C>    @param DAI     ?? used in FIXPVA
C>    @param QSE     Induced charges on tesserae
C>           --- IN/OUTPUT ---
C>    @param PCMTMP  dC/da*\bar{q}
C>
C
      SUBROUTINE DFTB_CALC_DCDA(NTS,NI,KI,XCTS,YCTS,ZCTS,AS,ISPHE,
     *                          EPSHET,IDDAI,DAI,QSE,PCMTMP)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPLY/ STOT,VOL,CCX,CCY,CCZ,RDIF,NESF,NESFP,NESFF,I_NESF,
     *                L_AST
C
      DIMENSION XCTS(NTS),YCTS(NTS),ZCTS(NTS),AS(NTS),ISPHE(*),
     *          EPSHET(*),IDDAI(21,*),DAI(3,20,*),QSE(NTS),PCMTMP(NTS)
C
      DATA ONE/1.0D+00/
C
      !THIS IS FOR FMO?
C     IF (IAN(NI).NE.1.AND.ABS(ZAN(NI)-ONE).LT.1.0D-08) GOTO 100
C
      IF(NESFP.EQ.0)THEN
        DO ITS = 1, NTS
          IF(ISPHE(ITS).EQ.NI) THEN
            XI = XCTS(ITS)
            YI = YCTS(ITS)
            ZI = ZCTS(ITS)
            DO JTS = 1, NTS
              IF(ISPHE(JTS).NE.NI) THEN
                XJ = XCTS(JTS)
                YJ = YCTS(JTS)
                ZJ = ZCTS(JTS)
                R2 = (XJ-XI)**2+(YJ-YI)**2+(ZJ-ZI)**2
                R  = SQRT(R2)
                R3 = R*R2
                EI=EPSHET(ISPHE(ITS))/(EPSHET(ISPHE(ITS))-ONE)
                EJ=EPSHET(ISPHE(JTS))/(EPSHET(ISPHE(JTS))-ONE)
                FT = 0.5D+00*(EJ+EI)/R3
                IF (KI.EQ.1) THEN
                  PCMTMP(ITS) = PCMTMP(ITS) - (XI-XJ)*FT*QSE(JTS)
                  PCMTMP(JTS) = PCMTMP(JTS) - (XI-XJ)*FT*QSE(ITS)
                ELSE IF (KI.EQ.2) THEN 
                  PCMTMP(ITS) = PCMTMP(ITS) - (YI-YJ)*FT*QSE(JTS)
                  PCMTMP(JTS) = PCMTMP(JTS) - (YI-YJ)*FT*QSE(ITS)
                ELSE IF (KI.EQ.3) THEN
                  PCMTMP(ITS) = PCMTMP(ITS) - (ZI-ZJ)*FT*QSE(JTS)
                  PCMTMP(JTS) = PCMTMP(JTS) - (ZI-ZJ)*FT*QSE(ITS)
                END IF
              END IF
            END DO
          END IF
        END DO
      END IF
C
      IF(IPCDER.EQ.3 .AND. NESFP.EQ.0) THEN
        SQRTPI = SQRT(3.1415926535897932D+00)
        DO ITS = 1, NTS
          DO III = 1, IDDAI(21,ITS)
            IF(NI.EQ.IDDAI(III,ITS)) THEN
              DUM=-1.07D+00*SQRTPI*QSE(ITS)/SQRT(AS(ITS)**3)
              SCALE=EPSHET(ISPHE(ITS))/(EPSHET(ISPHE(ITS))-ONE)
              PCMTMP(ITS) = PCMTMP(ITS) + DUM*DAI(KI,III,ITS)*SCALE
            END IF
          ENDDO
        ENDDO
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_DCDA
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PRJGRD_HESS
C>
C>    @brief   DFTB/PCM Hessian
C>
C>    @details Expeimental code to project rotation mode out in PCM
C>
C>    @author Yoshio Nishimoto
C>    - Feb, 2016- Subroutine written
C>
C>           --- INPUT ---
C>    @param IMODE   Choose method?
C>    @param EGRAD   Gradient?
C>    @param KI      Axis to be differenciated
C>    @param C       Coordinate of the solute
C>    @param NAT     Number of atoms
C>    @param WRK     Working array 1
C>    @param WRK2    Working array 2
C>           --- IN/OUTPUT ---
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_PRJGRD_HESS(IMODE,EGRAD,HESSIAN,C,RUNTYP,NAT,WRK,
     *                            WRK2)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (ONE=1.0D+00)
C
      DIMENSION EGRAD(3,NAT),HESSIAN(3*NAT,3*NAT),C(3,NAT),WRK(*),
     *          WRK2(*)
      DIMENSION D(2)
      DATA GRADIENT/8HGRADIENT/
C
      IF (IMODE.EQ.1) THEN
        DO I = 1, 3*NAT
          CALL DFTB_PRJGRD(HESSIAN(1,I),C,RUNTYP,NAT)
        END DO
        CALL TRPOSQ(HESSIAN,3*NAT)
        DO I = 1, 3*NAT
          CALL DFTB_PRJGRD(HESSIAN(1,I),C,RUNTYP,NAT)
        END DO
      ELSE IF (IMODE.EQ.2) THEN
        NVIB   = 2 
        VIBSIZ = 1.0D-04
        D(1)   =  VIBSIZ
        D(2)   = -VIBSIZ
        SCAL   = ONE/(VIBSIZ*DBLE(NVIB))
        CALL DCOPY(3*NAT,EGRAD,1,WRK,1)
        DO NI = 1, NAT
          DO KI = 1, 3
            DO IVIB = 1, NVIB
              C(KI,NI)= C(KI,NI) + D(IVIB)
              CALL DFTB_PRJGRD(EGRAD,C,GRADIENT,NAT)
              IF (IVIB.EQ.1) CALL DCOPY(3*NAT,EGRAD,1,WRK2,1)
              IF (IVIB.EQ.2) CALL DAXPY(3*NAT,-ONE,EGRAD,1,WRK2,1)
              C(KI,NI)= C(KI,NI) - D(IVIB)
              CALL DCOPY(3*NAT,WRK,1,EGRAD,1)
            END DO
            CALL DSCAL(3*NAT,SCAL,WRK2,1)
            CALL DAXPY(3*NAT,ONE,WRK2,1,HESSIAN(1,3*(NI-1)+KI),1)
          END DO
        END DO
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_PRJGRD_HESS
