C  1 Apr 16 - TN,HN,DGF - changes for FMO 5.2
c 22 Oct 14 - KRB,NM,SRP,DGF - changes for FMO 5.1
c 21 May 13 - DGF - changes for FMO 5.0
C 11 Aug 10 - DGF - synch FMO common blocks and uncapitalise
c 14 oct 09 - DGF - changes for FMO 3.3
c 15 dec 08 - DGF - various changes for FMO 3.2 release
c 20 aug 07 - KK,DGF - new module added
c
c*module fmopbc  *deck cellvol
      function cellvol(abclat,anglat)
      implicit double precision(a-h,o-z)
      parameter (eps=1.0d-06,one=1.0d+00,two=2.0d+00)
      dimension abclat(3),anglat(3)
c
      ca=cos(anglat(1))
      cb=cos(anglat(2))
      cg=cos(anglat(3))
      if(abs(ca).le.eps) ca=0
      if(abs(cb).le.eps) cb=0
      if(abs(cg).le.eps) cg=0
c
      cellvol=abclat(1)*abclat(2)*abclat(3)*
     *        sqrt(one-ca*ca-cb*cb-cg*cg+two*ca*cb*cg)
c
      return
      end
c
c*module fmopbc  *deck chksymop
      subroutine chksymop(nat,cc,cct1,cct2)
      implicit double precision(a-h,o-z)
      parameter (rlarge=1.0d+12,rshort=0.25d+00)
      common /iofile/ ir,iw,ip,is,ipk,idaf,nav,ioda(950)
      common /fmolat/ untang(3),untorg(3),respbc(4),abclat(3),anglat(3),
     *                symtra(3,24),symope(3,3,24),iatorg,nsymop,maxklms,
     *                ioporg(3),iopdir(3),iopabc(3),iopang(3)
      dimension cc(3,*),cct1(3,*),cct2(3,*)
      dimension trmat(3,3)
c     dimension xyzbox(3,8),u(3,3)
c     data      xyzbox/zero,zero,zero, one,zero,zero,
c    *                 zero,one,zero,  zero,zero,one,
c    *                 one,one,zero,   zero,one,one,
c    *                 one,zero,one,   one,one,one  /
c     check coordinates gererated by symmetry operations
      ismin=0
      jsmin=0
      iamin=0
      jamin=0
      do ig=1,nsymop
         call symolcc(0,0,0,ig,nat,cc,cct1,trmat)
c        if(idebug.eq.1) then
c           write(iw,9999) ik,il,im,ig
c           call prtmolcc(nat,ian,cct1)
c        endif
         do jg=ig,nsymop
            if(ig.ne.jg) then
               call symolcc(0,0,0,jg,nat,cc,cct2,trmat)
               rmin2=rlarge
               do i=1,nat
                  do j=1,nat
                     rij2=(cct1(1,i)-cct2(1,j))**2
     *                   +(cct1(2,i)-cct2(2,j))**2
     *                   +(cct1(3,i)-cct2(3,j))**2
                     if(rij2.lt.rmin2) then
                        rmin2=rij2
                        ismin=ig
                        jsmin=jg
                        iamin=i
                        jamin=j
                     endif
                  enddo
               enddo
            endif
         enddo
      enddo
c
c     if(idebug.ne.0) then
c        rij2=dsqrt(rmin2)/tobohr
c        write(iw,9998) rij2,iamin,jamin,ismin,jsmin
c        write(iw,9997)
c        call txctox(u,ierr)
c        do i=1,8
c           xf=xyzbox(1,i)
c           yf=xyzbox(2,i)
c           zf=xyzbox(3,i)
c           tx=u(1,1)*xf+u(1,2)*yf+u(1,3)*zf
c           ty=u(2,1)*xf+u(2,2)*yf+u(2,3)*zf
c           tz=u(3,1)*xf+u(3,2)*yf+u(3,3)*zf
c           write(iw,9996) i,tx/tobohr,ty/tobohr,tz/tobohr
c        enddo
c     endif
      if(rmin2.lt.rshort) then
         write(iw,9995) dsqrt(rmin2),iamin,jamin,ismin,jsmin
         call abrt
      endif
c
      return
c9999 format(' chksymop: atomic coordinates for (k,l,m,is)',4i4)
c9998 format(' chksymop: the shortest interatomic distance is, r=',f12.6
c    *,' a',/,10x,' between ia =',i3,' and ja =',i3,' generated by symme
c    *try operations,',/,10x,' is =',i2,' and js =',i2,
c    * ' , respectively, in (0,0,0) cell.')
c9997 format(' chksymop: cartesian coordinates of (0,0,0) box corners (a
c    *)')
c9996 format(i5,3f12.6)
 9995 format(' chksymop: too short interatomic diatance, r=',f12.6,
     * ' a',/,10x,' between ia =',i3,' and ja =',i3,' generated by symme
     *try operations,',/,10x,' is =',i2,' and js =',i2,
     * ' , respectively, in (0,0,0) cell.')
      end
c
c*module fmopbc  *deck fmon123
      subroutine fmon123(numfrg,n1fmo,n2fmo,n3fmo)
      implicit double precision (a-h,o-z)
      dimension numfrg(*)
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
c
      n1fmo=0
      n2fmo=0
      n3fmo=0
      do ifg=1,nfg
        l1i=iand(numfrg(ifg),65535)
        n1fmo=n1fmo+l1i
        n2fmo=n2fmo+(l1i*l1i+l1i)/2
        n3fmo=n3fmo+l1i*l1i
      enddo
      return
      end
c
c*module fmopbc  *deck genklms
      subroutine genklms(k0,l0,m0,ig0,ngrint,ngresp,ngrptc,klms)
      implicit double precision(a-h,o-z)
      parameter (zero=0.0d+00)
      common /iofile/ ir,iw,ip,is,ipk,idaf,nav,ioda(950)
      common /fmolat/ untang(3),untorg(3),respbc(4),abclat(3),anglat(3),
     *                symtra(3,24),symope(3,3,24),iatorg,nsymop,maxklms,
     *                ioporg(3),iopdir(3),iopabc(3),iopang(3)
      dimension klms(4,*)
      dimension mxklm(3),miklm(3),rrmax2(4)
      dimension u(3,3),w(3,3),xyz(3),xyz0(3),xyzi(3)
c
c     set groups which are within threshould distance.
c     note that distance is measured from (xorg,yorg,zorg).
c     rcutint < rcutesp < rptcint. rptcint is possibly zero (no use).
c
c     idebug=1
c
      ngrint=0
      ngresp=0
      ngrptc=0
      rcutint=respbc(1)
      rcutesp=respbc(2)
      rptcint=respbc(3)
c     if(igroup.le.0) then
         rmax=max(rcutint,rcutesp,rptcint)
c     else
c        rmax=rcutesp
c     endif
      rmax2=rmax*rmax
      xyz(1)=zero
      xyz(2)=zero
      xyz(3)=zero
      call symolcc(k0,l0,m0,ig0,1,xyz,xyz0,w)
c
c     rough estimation of maximum k,l,m
      mxklm(1)=int(rmax/abclat(1))
      mxklm(2)=int(rmax/abclat(2))
      mxklm(3)=int(rmax/abclat(3))
      do i=1,3
         if(mxklm(i).gt.0) mxklm(i)=mxklm(i)-1
      enddo
c     estimation of maximum k,l,m
      call txctox(u,ierr)
      do i=1,3
   20    continue
         mxklm(i)=mxklm(i)+1
         xi=mxklm(i)*u(1,i)
         yi=mxklm(i)*u(2,i)
         zi=mxklm(i)*u(3,i)
         r00=xi**2+yi**2+zi**2
         if(r00.le.rmax2) go to 20
      enddo
c
      miklm(1)=-mxklm(1)+k0
      miklm(2)=-mxklm(2)+l0
      miklm(3)=-mxklm(3)+m0
      mxklm(1)= mxklm(1)+k0
      mxklm(2)= mxklm(2)+l0
      mxklm(3)= mxklm(3)+m0
c
c     if(idebug.eq.1) then
c        write(iw,9999) (mxklm(i),i=1,3)
c        write(iw,9998) (miklm(i),i=1,3)
c     endif
c     if(igroup.le.0) then
         nset=3
         if(rptcint.eq.zero) nset=2
         rrmax2(1)=zero
         rrmax2(2)=rcutint**2
         rrmax2(3)=rcutesp**2
         rrmax2(4)=rptcint**2
c     else
c        nset=1
c        rrmax2(1)=zero
c        rrmax2(2)=rcutesp**2
c     endif
c     start of cell loop
      ncount=0
      do ii=1,nset
         do ik=miklm(1),mxklm(1)
            do il=miklm(2),mxklm(2)
               do im=miklm(3),mxklm(3)
                  do ig=1,nsymop
                     if(ik.eq.k0.and.il.eq.l0.and.im.eq.m0.and.
     *                  ig.eq.ig0) go to 100
c                    generate centers of (ik,il,im,ig) molecules
                     xyz(1)=zero
                     xyz(2)=zero
                     xyz(3)=zero
                     call symolcc(ik,il,im,ig,1,xyz,xyzi,w)
                     r0i=(xyz0(1)-xyzi(1))**2+(xyz0(2)-xyzi(2))**2
     *                                       +(xyz0(3)-xyzi(3))**2
                     if(r0i.gt.rrmax2(ii).and.r0i.le.rrmax2(ii+1)) then
                        ncount=ncount+1
                        if(ncount.gt.maxklms) call abrt
                        klms(1,ncount)=ik
                        klms(2,ncount)=il
                        klms(3,ncount)=im
                        klms(4,ncount)=ig
                     endif
  100                continue
                  enddo
               enddo
            enddo
         enddo
         if(ii.eq.1) ngrint=ncount
         if(ii.eq.2) ngresp=ncount
         if(ii.eq.3) ngrptc=ncount
      enddo
c     if(igroup.eq.1) then
c        ngrtot=ncount
c        if(ngrptc.eq.0) ngrptc=ngrtot
c     endif
c
c     if(igroup.le.0) then
         if(nset.eq.2) ngrptc=ngresp
         write(iw,9996) ngrint,ngresp,ngrptc
c     else
c        ngresp=ngrint
c        write(iw,9995) igroup,ngrint
c     endif
c     end cell loop
c
c     print lattice index list
c
      return
c9995 format(' igroup =',i4,/,' ngresp =',i10)
c9996 format(' igroup =',i4,/,' ngrint =',i10,/,' ngrint+ngresp =',
 9996 format(1x,' ngrint =',i10,/,' ngrint+ngresp =',
     *         i10,/,' ngrint+ngresp+ngrptc =',i10)
      end
c
c*module fmopbc  *deck genlatv
      subroutine genlatv(ifg,l1,l2,n2fmo,klms,untrot,espi,espg,r,wrk,
     *                   esplat)
      implicit double precision (a-h,o-z)
      logical goparr,dskwrk,maswrk
      parameter (mxatm=2000,mxsh=5000)
c     common /iofile/ ir,iw,ip,is,ipk,idaf,nav,ioda(950)
      common /par   / me,master,nproc,ibtyp,iptim,goparr,dskwrk,maswrk
      common /symtry/ mapshl(mxsh,48),mapctr(mxatm,48),
     *                tt(432),invt(48),nt
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2,maxrij
      common /fmorun/ espscf,e0scf(2),emp2s,idafmo,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                iesdppc,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo,ifmobas,itmfmo(2)
      dimension klms(4,*),untrot(3,3,*),espi(*),espg(*),r(*),
     *          wrk(*),esplat(n2fmo,*)
c
c     compute rotated monomer potentials vi for all group operations.
c     save them to esplat only on masters to avoid double counting in
c     the global sums later.
c
c     assume equal in size fragments!
      maxl2=(maxl1*maxl1+maxl1)/2
      ind=(ifg-1)*maxl2+1
      if(maswrk) call dcopy(l2,espi,1,esplat(ind,1),1)
c     if(maswrk) write(iw,9000) 1
c     call prtri(espi,l1)
      do iu=1,nunesp
        ik=klms(1,iu)
        il=klms(2,iu)
        im=klms(3,iu)
        ig=klms(4,iu)
        if(ik.eq.0.and.il.eq.0.and.im.eq.0) then
c         if(maswrk) write(iw,9000) ig
          call dcopy(3*3,untrot(1,1,iu+1),1,tt,1)
          call trposq(tt,3)
c         note we produce inverse rotation here, as needed below.
          call trmat
          call rotmom(r,l1,l1,0,0)
          call tftri(espg,espi,r,wrk,l1,l1,l1)
          if(maswrk) call dcopy(l2,espg,1,esplat(ind,ig),1)
c         call prtri(espg,l1)
        else
c         do ifg=1,nfg
c           iifg=ifg
c           call makemol(iifg,0,0,ilay,1,0,0,0,0,0,0,.true.)
c         enddo
        endif
      enddo
      call runitv(3,3,tt)
      call trmat
c
      return
c9000 format(1x,'computing esp for group operation = ',i2)
      end
c
c*module fmopbc  *deck pairvij
      subroutine pairvij(ilay,ifg,jfg,iu,nati,natfmob,nunptc,untxyz,
     *                   cfrg,espij,esp1i,esp1j,czi,czj,dolat)
      implicit double precision (a-h,o-z)
      logical dolat
      dimension untxyz(3,natfmob,0:nunptc+1),cfrg(*),espij(*),esp1i(*),
     *          esp1j(*),czi(*),czj(*)
      parameter (mxatm=2000,one=1.0d+00)
      common /infoa / nat,ich,mul,num,nqmt,ne,na,nb,
     *                zan(mxatm),c(3,mxatm),ian(mxatm)
      common /fmolat/ untang(3),untorg(3),respbc(4),abclat(3),anglat(3),
     *                symtra(3,24),symope(3,3,24),iatorg,nsymop,maxklms,
     *                ioporg(3),iopdir(3),iopabc(3),iopang(3)
      common /fmorun/ espscf,e0scf(2),emp2s,idafmo,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                iesdppc,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,nzmtfmo,ifmobas,itmfmo(2)
c
      nat1es=nat1e
      ncurshs=ncursh
      maxklmss=maxklms
      iskipesps=iskipesp
      nunesps=nunesp
c     ifmostps=ifmostp
c     modesps=modesp
      nunesp=0
      ifmostp=4
c     modesp=iand(modesp,inot(4))
      if(.not.dolat) maxklms=1
c     (to trigger fmoatfrg into following the lattice code).
      iskipesp=0
c
c     generate jfg with its coordinates (unit cell iu)
c
      if(dolat) call dcopy(3*natfmob,untxyz(1,1,iu),1,cfrg,1)
      call closda('delete')
      call openda(0)
      call makemol(jfg,0,0,ilay,0,0,0,0,0,0,0,.true.)
      natj=nat
      l2=(num*num+num)/2
c
c     store ifg coordinates for the 2e esp calculation
c     (ifg is always from unit cell 0)
c
      if(dolat) call dcopy(3*natfmob,untxyz(1,1,0),1,cfrg,1)
c
c     compute esp vj(i) (store in esp1j), j-block.
c
      nat1e=natj+nati
      icurfg=jfg
      jcurfg=ifg
      ncursh=-1
c     a silly way to signal fmoesp.
c
c     store ifg coordinates for the 1e esp calculation
c
      call dcopy(nati,czi,1,zan(natj+1),1)
      call dcopy(nati*3,czi(nati+1),1,c(1,natj+1),1)
c
      call oneei
c     write(6,*) 'wwwv1j',jfg
c     call prtril(espij,num)
      call daxpy(l2,-one,espij,1,esp1j,1)
      call dcopy(natj,zan,1,czj,1)
      call dcopy(natj*3,c,1,czj(natj+1),1)
c
c     generate ifg with its coordinates
c
      call closda('delete')
      call openda(0)
      call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0,.true.)
      l2=(num*num+num)/2
c
c     store jfg coordinates for the esp calculation
c
      if(dolat) call dcopy(3*natfmob,untxyz(1,1,iu),1,cfrg,1)
c
c     compute esp vi(j) (store in esp1i), i-block.
c
c     nat1e is the same.
c
      icurfg=ifg
      jcurfg=jfg
      ncursh=-1-iu
      call dcopy(natj,czj,1,zan(nati+1),1)
      call dcopy(natj*3,czj(natj+1),1,c(1,nati+1),1)
c
      call oneei
c     write(6,*) 'wwwv1i',ifg
c     call prtril(espij,num)
      call daxpy(l2,-one,espij,1,esp1i,1)
c
      ncursh=ncurshs
      nat1e=nat1es
      nunesp=nunesps
c     modesp=modesps
c     ifmostp=ifmostps
      maxklms=maxklmss
      iskipesp=iskipesps
c
      if(dolat) call dcopy(3*natfmob,untxyz(1,1,iu),1,cfrg,1)
      return
      end
c
c*module fmopbc  *deck rotmo
      subroutine rotmo(v,ldv,nmo,l1i,ni,rotv)
      implicit double precision (a-h,o-z)
      parameter (mxsh=5000,mxgtot=20000)
      common /nshel / ex(mxgtot),cs(mxgtot),cp(mxgtot),cd(mxgtot),
     *                cf(mxgtot),cg(mxgtot),ch(mxgtot),ci(mxgtot),
     *                kstart(mxsh),katom(mxsh),ktype(mxsh),kng(mxsh),
     *                kloc(mxsh),kmin(mxsh),kmax(mxsh),nshell
      common /symspd/ ptr(3,144),dtr(6,288),ftr(10,480),gtr(15,720)
      dimension v(ldv,nmo),rotv(ldv,nmo)
c
c     rotate lcao coefficients using precomputed ao transformation matrices
c     (set up in trmat, for a given rotation). in plain language, find the
c     new mos, after the atoms are rotated.
c     mos in v are a l1xl1 matrix, of which only the first nmo are rotated.
c     rotated mos in rotv are a l1xl1 matrix, only the first nmo columns are set
c     (l1i is the argument to shift dimer kloc into monomer;
c     l1 itself is tacitly defined by nshel/basis set).
c     the rotation is easily set up by storing the rotation matrix in tt,
c     assigning nt=1 and calling trmat.
c     ni gives the number of shells to skip in nshel (can be 0).
c
c     call prsq(ptr,3,3,3)
c     call prsq(v,ldv,ldv,ldv)
      do ii=ni+1,nshell
        mini=kmin(ii)
        loci=kloc(ii)-l1i
        lit = ktype(ii)
c       write(6,*) 'wwwi',ii,mini,loci,lit
c       s and the s part of l: spherically symmetric
        if(mini.eq.1) then
          call dcopy(nmo,v(loci,1),ldv,rotv(loci,1),ldv)
c         shift to p for l shells
          if(lit.eq.2) loci=loci+1
        endif
        if(lit.eq.2) then
          call mrarbr(ptr, 3, 3, 3,v(loci,1),ldv,nmo,rotv(loci,1),ldv)
        else if(lit.eq.3) then
          call mrarbr(dtr, 6, 6, 6,v(loci,1),ldv,nmo,rotv(loci,1),ldv)
        else if(lit.eq.4) then
          call mrarbr(ftr,10,10,10,v(loci,1),ldv,nmo,rotv(loci,1),ldv)
        else if(lit.eq.5) then
          call mrarbr(gtr,15,15,15,v(loci,1),ldv,nmo,rotv(loci,1),ldv)
        endif
      enddo
c     call prsq(rotv,ldv,ldv,ldv)
      return
      end
c
c*module fmopbc  *deck rotmom
      subroutine rotmom(r,ldr,l1,ni,l1i)
      implicit double precision (a-h,o-z)
      parameter (mxsh=5000,mxgtot=20000,one=1.0d+00)
      common /nshel / ex(mxgtot),cs(mxgtot),cp(mxgtot),cd(mxgtot),
     *                cf(mxgtot),cg(mxgtot),ch(mxgtot),ci(mxgtot),
     *                kstart(mxsh),katom(mxsh),ktype(mxsh),kng(mxsh),
     *                kloc(mxsh),kmin(mxsh),kmax(mxsh),nshell
      common /symspd/ ptr(3,144),dtr(6,288),ftr(10,480),gtr(15,720)
      dimension r(ldr,l1)
c
c     prepare the l1xl1 matrix to rotate mo coefficients (lcao), for some
c     rotation (see rotmo).
c     ni,l1i gives the number of shells/aos to skip (typically, 0).
c
      call vclr(r,1,l1*l1)
      do ii=ni+1,nshell
        mini=kmin(ii)
        loci=kloc(ii)-l1i
        lit = ktype(ii)
c       write(6,*) 'wwwi',ii,mini,loci,lit
c       s and the s part of l: spherically symmetric
        if(mini.eq.1) then
          r(loci,loci)=one
c         shift to p for l shells
          if(lit.eq.2) loci=loci+1
        endif
        if(lit.eq.2) then
          call blkcpy(ptr,3,3,r,l1,l1,loci,loci)
        else if(lit.eq.3) then
          call blkcpy(dtr,6,6,r,l1,l1,loci,loci)
        else if(lit.eq.4) then
          call blkcpy(ftr,10,10,r,l1,l1,loci,loci)
        else if(lit.eq.5) then
          call blkcpy(gtr,15,15,r,l1,l1,loci,loci)
        endif
      enddo
c     call prsq(r,l1,ldr,l1)
      return
      end
c
c*module fmopbc  *deck symolcc
      subroutine symolcc(ik,il,im,ig,nat,ccinp,ccout,trmat)
      implicit double precision(a-h,o-z)
c     common /iofile/ ir,iw,ip,is,ipk,idaf,nav,ioda(950)
      common /fmolat/ untang(3),untorg(3),respbc(4),abclat(3),anglat(3),
     *                symtra(3,24),symope(3,3,24),iatorg,nsymop,maxklms,
     *                ioporg(3),iopdir(3),iopabc(3),iopang(3)
      dimension ccinp(3,*),ccout(3,*),trmat(3,3)
      dimension u(3,3),uinv(3,3),v(3,3)
c
c     generates molecules by symmetry operations, (kk,ll,mm,ig).
c     form u * tg * u**-1,
c     u unit reorientation matrix (from untlat)
c     tg group symmetry operation.
      call txctox(u,ierr)
      call matinv3(u,uinv,ierr)
      call mrarbr(symope(1,1,ig),3,3,3,uinv,3,3,v,3)
      call mrarbr(u,3,3,3,v,3,3,trmat,3)
c     call prsq(trmat,3,3,3)
c
c     translation in cell coordinates
      xf=untorg(1)+ik+symtra(1,ig)
      yf=untorg(2)+il+symtra(2,ig)
      zf=untorg(3)+im+symtra(3,ig)
c     translation in cartesian coordinates
      tx=u(1,1)*xf+u(1,2)*yf+u(1,3)*zf
      ty=u(2,1)*xf+u(2,2)*yf+u(2,3)*zf
      tz=u(3,1)*xf+u(3,2)*yf+u(3,3)*zf
c     generate atomic coordinates
      do i=1,nat
         xf=ccinp(1,i)
         yf=ccinp(2,i)
         zf=ccinp(3,i)
         ccout(1,i)=trmat(1,1)*xf+trmat(1,2)*yf+trmat(1,3)*zf+tx
         ccout(2,i)=trmat(2,1)*xf+trmat(2,2)*yf+trmat(2,3)*zf+ty
         ccout(3,i)=trmat(3,1)*xf+trmat(3,2)*yf+trmat(3,3)*zf+tz
c        write(6,*) 'xyz',ccout(1,i)-tx,ccout(2,i)-ty,ccout(3,i)-tz
      enddo
c     call prsq(ccinp,nat,3,3)
c     write(6,*) ' '
c     call prsq(ccout,nat,3,3)
c
c     if(idebug.eq.1) then
c        write(iw,9999) ik,il,im,ig
c        call prtmolcc(nat,ian,ccout)
c     endif
      return
c9999 format(' symolcc: generated atomic cartesian coordinates (a)',/,
c    *       '          for (k,l,m,is)=(',4i3,' )')
      end
c
c*module fmopbc  *deck txctox
      subroutine txctox(u,ierr)
      implicit double precision(a-h,o-z)
      parameter (zero=0.0d+00,one=1.0d+00,eps=1.0d-16)
      common /fmolat/ untang(3),untorg(3),respbc(4),abclat(3),anglat(3),
     *                symtra(3,24),symope(3,3,24),iatorg,nsymop,maxklms,
     *                ioporg(3),iopdir(3),iopabc(3),iopang(3)
      dimension u(3,3)
c     u ... transformation matrix from fractional coordinates
c           to cartessian coordinates, x(cc)=u*x(fc).
c     put b-axis in y-axis and a-axis in (x,y)-plane, and c-axis in z-axis.
c
      ierr=0
      a=abclat(1)
      b=abclat(2)
      c=abclat(3)
      cos4=cos(anglat(1))
      cos5=cos(anglat(2))
      cos6=cos(anglat(3))
      sin6=sin(anglat(3))
      if(abs(sin6).lt.eps) then
         ierr=1
         return
      endif
      v = (cos5-cos4*cos6)
      vv=one-cos4*cos4-cos5*v-cos6*(cos6-cos4*cos5)
      vv=sqrt(vv)
      v = v/sin6
      u(1,1)=a*sin6
      u(1,2)=zero
      u(1,3)=c*v
      u(2,1)=a*cos6
      u(2,2)=b
      u(2,3)=c*cos4
      u(3,1)=zero
      u(3,2)=zero
      u(3,3)=c*vv/sin6
      return
      end
c
c*module fmopbc  *deck uniqpair
      subroutine uniqpair(fmozan,untxyz,unitnr,nsymeq,natfmob,nunptc,
     *                    iu1,iu2,nsu)
      implicit double precision (a-h,o-z)
      logical goparr,dskwrk,maswrk
      parameter (tol=1.0d-10,np=24)
      common /iofile/ ir,iw,ip,is,ipk,idaf,nav,ioda(950)
      common /par   / me,master,nproc,ibtyp,iptim,goparr,dskwrk,maswrk
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      dimension fmozan(*),untxyz(3,natfmob,0:nunptc),unitnr(*),
     *          nsymeq(*),lp(np)
c
c     24 - roughly corresponds to the group operations
c
      ntot=0
      nsu=0
      do iu=iu1,iu2
        en=0
        do iat=1,natfmo
          cx=untxyz(1,iat,0)
          cy=untxyz(2,iat,0)
          cz=untxyz(3,iat,0)
          za=fmozan(iat)
          do jat=1,natfmo
            en=en+za*fmozan(jat)/sqrt((untxyz(1,jat,iu)-cx)**2+
     *               (untxyz(2,jat,iu)-cy)**2+(untxyz(3,jat,iu)-cz)**2)
          enddo
        enddo
        unitnr(iu)=en
c
        nsymeq(iu)=1
        do ju=iu1,iu-1
          if(abs(en-unitnr(ju)).lt.tol) then
            nsymeq(ju)=nsymeq(ju)+1
            nsymeq(iu)=-ju
            unitnr(iu)=0
            goto 100
          endif
        enddo
        nsu=nsu+1
  100   continue
        ntot=ntot+1
      enddo
      if(maswrk) then
        write(iw,9900)
        do iu=iu1,iu2
          if(nsymeq(iu).gt.0) then
            ii=0
            do ju=iu+1,iu2
              if(nsymeq(ju).eq.-iu.and.ii.lt.np) then
                ii=ii+1
                lp(ii)=ju
              endif
            enddo
            write(iw,9910) iu,nsymeq(iu),(lp(i),i=1,ii)
          endif
        enddo
        write(iw,9920) ntot,nsu
      endif
      return
 9900 format(1x,'equivalent groups are:',/1x,'  i    ni  equiv groups')
 9910 format(i5,i5,9999(i5))
 9920 format(1x,'total number of groups=',i5,', unique=',i5,/)
      end
c
c*module fmopbc  *deck pbcvij
      subroutine addv2(l1,l2,mapi,mapj,vi,vj,vij)
      implicit double precision (a-h,o-z)
      dimension mapi(*),mapj(*),vi(*),vj(*),vij(*)
c
      call vclr(vij,1,l2)
      loop=0
      do i=1,l1
        ii=mapi(i)
        ji=mapj(i)
        do j=1,i
          loop=loop+1
          ij=mapi(j)
          jj=mapj(j)
c         fill the i-block, as v(i)-vi(j)
          if(ii.ne.0.and.ij.ne.0) then
            ii1=max(ii,ij)
            ij1=min(ii,ij)
            loopi=(ii1*ii1-ii1)/2+ij1
            vij(loop)=vi(loopi)
          endif
c         fill the j-block, as v(j)-vj(i)
          if(ji.ne.0.and.jj.ne.0) then
            ji1=max(ji,jj)
            jj1=min(ji,jj)
            loopj=(ji1*ji1-ji1)/2+jj1
c           vij(loop)=vij(loop)+vj(loopj)
            vij(loop)=vj(loopj)
c           the overlapping piece is computed twice (in i and j),
c           with exactly the same values, since it corresponds
c           to the effect of environment upon the "ao" junction of
c           two connected fragments. the values shold not be added.
          endif
        enddo
      enddo
c     call prtril(vij,l1)
c     call vclr(vij,1,l2)
      return
      end
c*module fmopbc  *deck latrij
      subroutine latrij(ifg,indat,fmozan,natfmob,untxyz,iabdfg,jabdfg,
     *                  rij,rwrk,vdwrad,nunptc,nsymeq)
      implicit double precision(a-h,o-z)
      dimension indat(*),fmozan(*),untxyz(3,natfmob,*),iabdfg(*),
     *          jabdfg(*),vdwrad(*),rij(*),rwrk(*),nsymeq(*)
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
c
      mfg2=(nfg*nfg-nfg)/2
      noff=mfg2+(ifg-1)*nfg+1
      do iu=1,nunptc
c       skip symmetry equivalent groups.
        if(nsymeq(iu).gt.0) then
          idum=0
          call monor(.false.,ifg,indat,fmozan,untxyz(1,1,iu+1),iabdfg,
     *               jabdfg,rij(noff),idum,rwrk,vdwrad,0,0.0d+00,.true.)
          noff=noff+nfg*nfg
        endif
      enddo
c     write(6,*) 'wwwrr',(rij(mfg2+i),i=1,nunptc)
      return
      end
C
C*MODULE fmopbc  *DECK FMOMDIN
C> @brief THIS ROUTINE READS $FMOMD
C>
C> @author     Unknown
C>             -October 23, 2014
C>
C> @details THIS ROUTINE READS $FMOMD GROUP TO RUN THE FMO MD SIMULATION WITH
C>          THE PERIODIC BOUNDARY CONDITION (PBC).
C>
C> @date October 23, 2014-Spencer R. Pruitt
C>
C> @param DOPBCMD
C> @param MDXCALLED
C> @param INSUBMDX
C
      SUBROUTINE FMOMDIN(DOPBCMD,MDXCALLED,INSUBMDX)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DOPBCMD,MDXCALLED,DBGPRT,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00, TOBOHR=1.0D+00/0.52917724924D+00)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /FMOPMD/ FMOBOX(3),MDWPBC,NIMGCELL,IMGLVL,
     *                LTRVEC,LFMOGCTR,LFMOCTMP,LINDATMD,LWRKDSAV,LINDXIU
     *               ,IPBCFST
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,MODFD,modfmm,ncentm,ndualb
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (NNAM=5)
      DIMENSION QNAM(NNAM),KQNAM(NNAM)
      DATA QNAM/8HPBC     ,8HIMGLVL  ,8HFMOBOX  ,8HDBGPRT  ,8HPBCFST  /
      DATA KQNAM/0,1,33,0,1/
      DATA FMOMD /8HFMOMD   /
      DATA DEFVAL/-1.0D+00/
C
      LOGICAL REACHMDX
      SAVE REACHMDX
      DATA REACHMDX/.FALSE./
C
      IF(INSUBMDX.NE.0) THEN
        REACHMDX = .TRUE.
        RETURN
      END IF
      MDXCALLED = REACHMDX
C
      DOPBCMD   = .FALSE.
      MDWPBC    = 0
      NIMGCELL  = 0
      IPBCFST   = 0
C
C     ----- SET DEFAULT VALUES FOR $FMOCMD -----
C
      IMGLVL  = 1
      CALL DACOPY(3,DEFVAL,FMOBOX,1)
C
      JRET = 0
      CALL NAMEIO(IR,JRET,FMOMD,NNAM,QNAM,KQNAM,
     *            DOPBCMD,IMGLVL,FMOBOX,DBGPRT,IPBCFST,
     *       0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *     0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *     0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
C
      IF(JRET.EQ.2) THEN
        IF(MASWRK)
     *        WRITE(IW,*) ' NAMELIST $FMOMD SYNTAX ERROR FOUND.'
        CALL ABRT
      END IF
C
      IF(DOPBCMD) THEN
        MDWPBC = 1
      ELSE
        MDWPBC = 0
        RETURN
      END IF
C
C     ----- CHECK INPUT PARAMETERS -----
C
      NERR = 0
      IF(IMGLVL.LE.0) THEN
        IF(MASWRK)
     *        WRITE(IW,*) 'ERROR: INDSW MUST BE POSITIVE INTEGER, ',
     *                    'BUT IMGLVL= ',IMGLVL
        NERR = NERR + 1
      END IF
      NIMGCELL = (2*IMGLVL + 1)**3 - 1
C
C     ----- CHECK BOX LENGTH -----
C
C FURTHER TESTS ARE PERFORMED AFTER READING ATOMIC COORDINATES
      DO IXYZ=1,3
        IF(FMOBOX(IXYZ).EQ.DEFVAL) THEN
          IF(MASWRK) WRITE(IW,*) ' ERROR: SET FMOBOX( ',IXYZ,' )'
          NERR = NERR + 1
        ELSE IF(FMOBOX(IXYZ).LT.ZERO) THEN
          IF(MASWRK)
     *          WRITE(IW,*) 'ERROR: ILLEGAL PARAMETER FMOBOX( ',IXYZ,
     *                      ' )= ',FMOBOX(IXYZ)
          NERR = NERR + 1
        END IF
      END DO
C
C     ----- CHECK PRINT-OUT OPTION -----
C
      IF(IAND(NPRFMO,2).EQ.0 .AND. .NOT.DBGPRT) THEN
        IF(MASWRK) WRITE(IW,*) ' NOTE: NPRINT DEFINED IN $FMOPRP IS',
     *        ' INCREMENTED BY 2 TO REDUCE OUTPUT.'
        NPRFMO = NPRFMO + 2
      END IF
C
C     ----- CHECK DISTANCE DEPENDENT OPTIONS -----
C
      IF(RESPAP(1).NE.ZERO .OR. RESPAP(2).NE.ZERO) THEN
        IF(MASWRK) WRITE(IW,*) 'ERROR: RESPAP MUST BE ZERO.'
        NERR = NERR + 1
      END IF
C
      IF(RESPPC(1).NE.ZERO .OR. RESPPC(2).NE.ZERO) THEN
        IF(MASWRK) WRITE(IW,*) 'ERROR: RESPPC MUST BE ZERO.'
        NERR = NERR + 1
      END IF
C
      IF(RESDIM.EQ.ZERO) THEN
        IF(MASWRK) WRITE(IW,*) 'ERROR: RESDIM MUST BE NONZERO.'
        NERR = NERR + 1
      END IF
C
      IF(NERR.GT.0) THEN
        IF(MASWRK) WRITE(IW,*) 'ERROR(S) IN READING $FMOMD'
        CALL ABRT
      END IF
      CALL DSCAL(3,TOBOHR,FMOBOX,1) ! ANGSTROM -> BOHR
C
      RETURN
      END
C
C*MODULE fmopbc  *DECK SUPCELL
C> @brief SUPERCELLS
C>
C> @author     Unknown
C>             -October 23, 2014
C>
C> @details FORM IMAGES OF THE SIMULATION CELL
C>
C> @date October 23, 2014-Spencer R. Pruitt
C>
C> @param NATFMOB
C> @param UNTXYZ
C> @param TRVEC
C> @param NSYMEQ
C
      SUBROUTINE SUPCELL(NATFMOB,UNTXYZ,TRVEC,NSYMEQ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,DEBUG
C
      COMMON /FMOPMD/ FMOBOX(3),MDWPBC,NIMGCELL,IMGLVL,
     *                LTRVEC,LFMOGCTR,LFMOCTMP,LINDATMD,LWRKDSAV,LINDXIU
     *               ,IPBCFST
      COMMON /IOFILE/ IR,IW,IP,IS,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION UNTXYZ(3,NATFMOB,0:*),TRVEC(3,*),NSYMEQ(*)
C
      DATA DEBUG/.FALSE./
C
C     ---- FORMING IMAGES OF THE SIMULATION CELL -----
C
      IU = 0
      DO IZ=-IMGLVL,IMGLVL
        DO IY=-IMGLVL,IMGLVL
          DO IX=-IMGLVL,IMGLVL
            IF(IX.NE.0 .OR. IY.NE.0 .OR. IZ.NE.0) THEN
              IU = IU + 1
              TRVEC(1,IU) = IX*FMOBOX(1)
              TRVEC(2,IU) = IY*FMOBOX(2)
              TRVEC(3,IU) = IZ*FMOBOX(3)
            END IF
          END DO
        END DO
      END DO
      IF(IU.NE.NIMGCELL) CALL ABRT
C
C     UNTXYZ(*,*,IU):
C     IU = 0 ... ATOMIC COORDINATES OF THE SIMULATION CELL
C     IU > 0 ...                    OF THE REPLICATED CELLS
      DO IU=1,NIMGCELL
        DO I=1,NATFMOB
          DO IXYZ=1,3
            UNTXYZ(IXYZ,I,IU) = UNTXYZ(IXYZ,I,0) + TRVEC(IXYZ,IU)
          END DO
        END DO
      END DO
C
C     ----- CHECK INVERSION SYMMETRY -----
C
      DO IU=1,NIMGCELL
        NSYMEQ(IU) = 1
        DO JU=1,IU-1
          DUM =  ABS(TRVEC(1,IU) + TRVEC(1,JU))
     *         + ABS(TRVEC(2,IU) + TRVEC(2,JU))
     *         + ABS(TRVEC(3,IU) + TRVEC(3,JU))
          IF(DUM.LT.1.0D-05) THEN
            NSYMEQ(JU) = NSYMEQ(JU) + 1
            NSYMEQ(IU) = -JU
            GO TO 10
          END IF
        END DO
   10   CONTINUE
      END DO
C
C     ----- OUTPUT -----
C
      IF(DEBUG.AND.MASWRK) THEN
        WRITE(IW,*) ' UNTXYZ IN SUBROUTINE -SUPCELL-'
        WRITE(IW,*) ' # OF REPLICATED CELLS= ',NIMGCELL
        DO IU=0,NIMGCELL
          WRITE(IW,*) ' CELL #',IU
          IF(IU.GT.0) THEN
            WRITE(IW,*) ' NSYMEQ= ',NSYMEQ(IU)
            WRITE(IW,*) ' TRVEC = ',(TRVEC(IXYZ,IU),IXYZ=1,3)
          END IF
          WRITE(IW,*) ' ATOMIC COORDINATES'
          DO I=1,NATFMOB
      WRITE(IW,'(3F20.10)') (UNTXYZ(IXYZ,I,IU)*0.529177249D+00,IXYZ=1,3)
          END DO
        END DO
      END IF
C
      RETURN
      END
C
C*MODULE fmopbc  *DECK FMOBOXMK
C> @brief MAKE BOX
C>
C> @author     Unknown
C>             -October 23, 2014
C>
C> @details FIND GEOMETRIC CENTER, SHIFT COORDINATES, AND MAKE BOX
C>
C> @date October 23, 2014-Spencer R. Pruitt
C>
C> @param FMOC
C> @param INDAT
C> @param NATFMO
C> @param NFG
C
      SUBROUTINE FMOBOXMK(FMOC,INDAT,NATFMO,NFG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL INIT,SHIFT,GOPARR,DSKWRK,MASWRK,DEBUG
C
      PARAMETER (ONE=1.0D+00, TWO=2.0D+00)
      PARAMETER (TOANGS=0.52917724924D+00)
C
      COMMON /FMOPMD/ FMOBOX(3),MDWPBC,NIMGCELL,IMGLVL,
     *                LTRVEC,LFMOGCTR,LFMOCTMP,LINDATMD,LWRKDSAV,LINDXIU
     *               ,IPBCFST
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION FMOC(3,*),INDAT(*),CENTER(3),CMIN(3),CMAX(3)
C
      DATA DEBUG/.FALSE./
C
      SAVE INIT
      DATA INIT/.TRUE./
C
      IF(.NOT.INIT) RETURN
C                   ******
C
C     ----- FIND GEOMETRIC CENTER -----
C
      CALL DACOPY(3, 1.0D+40,CMIN,1)
      CALL DACOPY(3,-1.0D+40,CMAX,1)
C
      DO IIFG=1,NFG
        CALL VCLR(CENTER,1,3)
        NATFRG = 0
        DO IAT=1,NATFMO
          IF(INDAT(IAT).EQ.IIFG) THEN
            NATFRG = NATFRG + 1
            DO IXYZ=1,3
              CENTER(IXYZ) = CENTER(IXYZ) + FMOC(IXYZ,IAT)
            END DO
          END IF
        END DO
        CALL DSCAL(3,ONE/NATFRG,CENTER,1)
C
        DO IXYZ=1,3
          CMIN(IXYZ) = MIN(CMIN(IXYZ),CENTER(IXYZ))
          CMAX(IXYZ) = MAX(CMAX(IXYZ),CENTER(IXYZ))
        END DO
      END DO
C
C     ----- CHECK BOX LENGTH -----
C
      SHIFT = .FALSE.
      NERR = 0
      DO IXYZ=1,3
        DUM = CMAX(IXYZ) - CMIN(IXYZ)
        IF(DUM.GT.FMOBOX(IXYZ)) THEN
          IF(MASWRK) WRITE(IW,9999) IXYZ,FMOBOX(IXYZ)*TOANGS,DUM*TOANGS
          NERR = NERR + 1
        END IF
        CENTER(IXYZ) = (CMIN(IXYZ) + CMAX(IXYZ))/TWO
        SHIFT = SHIFT .OR. CMIN(IXYZ) .LT. -FMOBOX(IXYZ)/TWO
     *                .OR. CMAX(IXYZ) .GT.  FMOBOX(IXYZ)/TWO
      END DO
      IF(NERR.GT.0) CALL ABRT
C
C     ----- SHIFT ATOMIC COORDINATES IF NECESSARY -----
C
      IF(SHIFT) THEN
        IF(MASWRK) THEN
          WRITE(IW,*) ' THE WHOLE MOLECULAR SYSTEM HAS BEEN MOVED',
     *                ' TO FIT INTO THE BOX [-FMOBOX/2:FMOBOX/2].'
        END IF
C       SHIFT ATOMIC COORDINATES
        DO IAT=1,NATFMO
          DO IXYZ=1,3
            FMOC(IXYZ,IAT) = FMOC(IXYZ,IAT) - CENTER(IXYZ)
          END DO
        END DO
C
        CALL DACOPY(3, 1.0D+40,CMIN,1)
        CALL DACOPY(3,-1.0D+40,CMAX,1)
C
        DO IIFG=1,NFG
          CALL VCLR(CENTER,1,3)
          NATFRG = 0
          DO IAT=1,NATFMO
            IF(INDAT(IAT).EQ.IIFG) THEN
              NATFRG = NATFRG + 1
              DO IXYZ=1,3
                CENTER(IXYZ) = CENTER(IXYZ) + FMOC(IXYZ,IAT)
              END DO
            END IF
          END DO
          CALL DSCAL(3,ONE/NATFRG,CENTER,1)
C
          DO IXYZ=1,3
            CMIN(IXYZ) = MIN(CMIN(IXYZ), CENTER(IXYZ))
            CMAX(IXYZ) = MAX(CMAX(IXYZ), CENTER(IXYZ))
          END DO
        END DO
C
        NERR = 0
        DO IXYZ=1,3
          IF(CMIN(IXYZ) .LT. -FMOBOX(IXYZ)/TWO) NERR = NERR + 1
          IF(CMAX(IXYZ) .GT.  FMOBOX(IXYZ)/TWO) NERR = NERR + 1
        END DO
        IF(NERR.GT.0) CALL ABRT
      END IF
C
      IF(DEBUG.AND.MASWRK) THEN
        WRITE(IW,'(1X,A6,3F12.7)') 'FMOBOX',(FMOBOX(IXYZ),IXYZ=1,3)
        WRITE(IW,'(1X,A6,3F12.7)') 'CMIN  ',(  CMIN(IXYZ),IXYZ=1,3)
        WRITE(IW,'(1X,A6,3F12.7)') 'CMAX  ',(  CMAX(IXYZ),IXYZ=1,3)
        WRITE(IW,*) ' UNIT: BOHR'
      END IF
C
      INIT = .FALSE.
      RETURN
 9999 FORMAT(/1X,'ERROR: FMOBOX(',I2,' )/A=',F9.4,
     *           ' IS TOO SMALL TO CONTAIN ALL FRAGMENTS.'/
     *        1X,'IT MUST BE LARGER THAN AT LEAST ',F9.4,' A.')
      END
C
C*MODULE fmopbc  *DECK CSHFTBYL
C> @brief SHIFT COORDINATES
C>
C> @author     Unknown
C>             -October 23, 2014
C>
C> @details SHIFT COORDINATES FOR SIMUALTION CELL
C>
C> @date October 23, 2014-Spencer R. Pruitt
C>
C> @param C
C> @param FMOGCTR
C> @param INDAT
C> @param FMOBOX
C> @param NAT
C> @param NFG
C
      SUBROUTINE CSHFTBYL(C,FMOGCTR,INDAT,FMOBOX,NAT,NFG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL DEBUG,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ONE=1.0D+00, TWO=2.0D+00)
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION C(3,*),FMOGCTR(3,*),INDAT(*),FMOBOX(3),CENTER(3)
C
      DATA DEBUG/.FALSE./
C
      IF(DEBUG.AND.MASWRK) THEN
        WRITE(IW,*) ' IN SUBROUTINE -CSHFTBYL-'
        WRITE(IW,*) ' ATOMIC COORDINATES BEFORE SHIFT'
        CALL PRATM(IW,1)
      END IF
C
C     ----- FIND GEOMETRIC CENTER -----
C
      DO IIFG=1,NFG
        CALL VCLR(CENTER,1,3)
        NATFRG = 0
        DO IAT=1,NAT
          IF(INDAT(IAT).EQ.IIFG) THEN
            NATFRG = NATFRG + 1
            DO IXYZ=1,3
              CENTER(IXYZ) = CENTER(IXYZ) + C(IXYZ,IAT)
            END DO
          END IF
        END DO
        CALL DSCAL(3,ONE/NATFRG,CENTER,1)
        CALL DCOPY(3,CENTER,1,FMOGCTR(1,IIFG),1)
        IF(DEBUG.AND.MASWRK)
     *    WRITE(IW,'("  GEOMETRIC CENTER",I8,3X,3F15.10)')
     *      IIFG,(CENTER(IXYZ),IXYZ=1,3)
      END DO
C
C     ----- SHIFT ATOMIC COORDINATES IF NECESSARY -----
C
      DO IAT=1,NAT
        DO IXYZ=1,3
          DUM = FMOGCTR(IXYZ,INDAT(IAT))
          IF(DUM.LT.-FMOBOX(IXYZ)/TWO) THEN
            WRAP = -FMOBOX(IXYZ)/TWO - DUM + FMOBOX(IXYZ)
            C(IXYZ,IAT) = C(IXYZ,IAT)
     *               + INT(WRAP/FMOBOX(IXYZ))*FMOBOX(IXYZ)
          ELSE IF(DUM.GT.FMOBOX(IXYZ)/TWO) THEN
            WRAP =  DUM - FMOBOX(IXYZ)/TWO + FMOBOX(IXYZ)
            C(IXYZ,IAT) = C(IXYZ,IAT)
     *             - INT(WRAP/FMOBOX(IXYZ))*FMOBOX(IXYZ)
          END IF
        END DO
      END DO
C
      IF(DEBUG.AND.MASWRK) THEN
        WRITE(IW,*) ' SHIFTED ATOMIC COORDINATES'
        CALL PRATM(IW,1)
      END IF
C
      RETURN
      END
C
C*MODULE fmopbc  *DECK MAKEINDEXIU
C> @brief MAKE INDEX
C>
C> @author     Unknown
C>             -October 23, 2014
C>
C> @details CALCULATE INTER-FRAGMENT DISTANCES
C>
C> @date October 23, 2014-Spencer R. Pruitt
C>
C> @param ILAY
C> @param LOADHF
C> @param LOADM
C> @param INDAT
C> @param FMOZAN
C> @param FMOC
C> @param IABDFG
C> @param JABDFG
C> @param SCFFRG
C> @param NEEDR0
C> @param RIJ
C> @param RWRK
C> @param MFG2
C> @param VDWRAD
C> @param NPRFRG
C> @param ISGDDI0
C> @param NUNPTC
C> @param NATFMOB
C> @param UNTXYZ
C> @param UNITS
C> @param INDXIU
C> @param doindxiu
C
      SUBROUTINE MAKEINDEXIU(ILAY,LOADHF,LOADM,INDAT,FMOZAN,FMOC,IABDFG,
     *                       JABDFG,SCFFRG,NEEDR0,RIJ,RWRK,MFG2,VDWRAD,
     *                       NPRFRG,ISGDDI0,NUNPTC,NATFMOB,UNTXYZ,
     *                       UNITS,INDXIU,doindxiu)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER DDI_GROUP,DDI_MASTERS
      PARAMETER(DDI_GROUP=1,DDI_MASTERS=2)
C
      LOGICAL ISGDDI0,MYJOB,INIREV
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL DOINDXIU
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,MODFD,modfmm,ncentm,ndualb
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION LOADM(*),RIJ(*),SCFFRG(*),INDAT(*),FMOZAN(*),FMOC(3,*),
     *          IABDFG(*),JABDFG(*),RWRK(*),VDWRAD(*),NPRFRG(*),
     *          UNTXYZ(3,NATFMOB,0:*),INDXIU(*)
C
      DATA RNONE/8HNONE    /
C
      INIREV = IAND(MODPAR,8).NE.0
C
C     ----- CALCULATE INTER-FRAGMENT DISTANCE -----
C
      IF(ISGDDI0) CALL GDDICOUNT(-1,LGROUP,MYJOB)
      DO 100 IIFG=1,NFG
        IFG = IIFG
        IF(LOADHF.EQ.1) IFG = LOADM(IIFG)
        IF(INIREV) IFG = NFG - IIFG + 1
        ICURFG = IFG
        IF(ISGDDI0) THEN
          CALL GDDICOUNT(0,LGROUP,MYJOB)
          IF(.NOT.MYJOB) GO TO 100
        END IF
C
        CALL CLOSDA('DELETE')
        CALL OPENDA(0)
        CALL MAKEMOL(IFG,0,0,ILAY,0,0,0,0,0,0,0,SCFFRG(IFG).NE.RNONE)
C
        IF(NEEDR0.NE.0) THEN
          IF(IFG.GT.1) THEN
            idum=0
            CALL MONOR(.TRUE.,IFG,INDAT,FMOZAN,FMOC,IABDFG,JABDFG,
     *                 RIJ((IFG*IFG-3*IFG)/2+2),idum,RWRK,VDWRAD,
     *                 IAND(NPRFRG(IFG),256).NE.0,UNITS,.true.)
          END IF
          CALL PBCMDRIJ(IFG,INDAT,FMOZAN,NATFMOB,UNTXYZ,IABDFG,JABDFG,
     *                  RIJ,RWRK,VDWRAD,NUNPTC)
        END IF
 100  CONTINUE
      IF(ISGDDI0) CALL GDDICOUNT(1,LGROUP,MYJOB)
C
      IF(ISGDDI0) THEN
        CALL GDDI_SCOPE(DDI_MASTERS)
        IF(MASWRK.AND.NEEDR0.NE.0) CALL DDI_GSUMF(2419,RIJ,MFG2)
        CALL GDDI_SCOPE(DDI_GROUP)
        IF(GOPARR.AND.NEEDR0.NE.0)
     *    CALL DDI_BCAST(2423,'F',RIJ,MFG2,MASTER)
      END IF
        call flshbf(6)
C
C     ----- NEAREST NEIGHBOR -----
C
C      if(.not.doindxiu) write(6,*) 'KRB skipping nearest neighbor'
      IF(DOINDXIU) then
      NPAIR = (NFG*NFG-NFG)/2
      DO IFG=1,NFG
        DO JFG=1,NFG
          IF(IFG.GT.JFG) THEN
C           IFG IS ALWAYS GREATER THAN 1.
            RIJ0 = RIJ((IFG*IFG-3*IFG)/2+JFG+1)
          ELSE IF(IFG.EQ.JFG) THEN
            RIJ0 = 0.0D+00
          ELSE
            RIJ0 = RIJ((JFG*JFG-3*JFG)/2+IFG+1)
          END IF
          RIJMIN = RIJ0
          MINIU = 0
          DO IU=1,NUNPTC
            DUM = RIJ(NPAIR+NFG*NFG*(IU-1)+(IFG-1)*NFG+JFG)
            IF(DUM.LT.RIJMIN) THEN
              RIJMIN = DUM
              MINIU = IU
            END IF
          END DO
          INDXIU((IFG-1)*NFG+JFG) = MINIU
C
C         WRITE(6,'("MN1U",3I5,F9.5)') IFG,JFG,MINIU,RIJMIN
C
C         FIND THE SECOND LARGEST RIJ, WHICH IS ASSUMED TO BE
C         GREATER THAN ESDIM.
C
          IF(MINIU.EQ.0) THEN
            IU = 1
            RIJMIN = RIJ(NPAIR+NFG*NFG*(IU-1)+(IFG-1)*NFG+JFG)
        MINIU2 = 1
            DO IU=2,NUNPTC
              DUM = RIJ(NPAIR+NFG*NFG*(IU-1)+(IFG-1)*NFG+JFG)
              IF(DUM.LT.RIJMIN) THEN
            MINIU2 = IU
                RIJMIN = DUM
              END IF
            END DO
          ELSE
            RIJMIN = RIJ0
        MINIU2 = 0
            DO IU=1,NUNPTC
              IF(IU.NE.MINIU) THEN
                DUM = RIJ(NPAIR+NFG*NFG*(IU-1)+(IFG-1)*NFG+JFG)
                IF(DUM.LT.RIJMIN) THEN
              MINIU2 = IU
                  RIJMIN = DUM
                END IF
              END IF
            END DO
          END IF
C          WRITE(6,'("MN2U",3I5,F9.5)') IFG,JFG,MINIU2,RIJMIN
          IF(RIJMIN.LT.RESDIM) then
           if(MASWRK) then
             WRITE(6,'("MN2U",3I5,F9.5)') IFG,JFG,MINIU2,RIJMIN
             WRITE(6,'("RESDIM is Too large compared to system size")')
           end if
           CALL ABRT
          endif
        END DO
      END DO
      ENDIF
c        call flshbf(6)
C
      RETURN
      END
C
C*MODULE fmopbc  *DECK PBCMDRIJ
C> @brief RIJ FOR PBC
C>
C> @author     Unknown
C>             -October 23, 2014
C>
C> @details WRAPPER FOR CALLING MONOR FROM PBC CODE
C>
C> @date October 23, 2014-Spencer R. Pruitt
C>
C> @param IFG
C> @param INDAT
C> @param FMOZAN
C> @param NATFMOB
C> @param UNTXYZ
C> @param IABDFG
C> @param JABDFG
C> @param RIJ
C> @param RWRK
C> @param VDWRAD
C> @param NUNPTC
C
      SUBROUTINE PBCMDRIJ(IFG,INDAT,FMOZAN,NATFMOB,UNTXYZ,IABDFG,JABDFG,
     *                    RIJ,RWRK,VDWRAD,NUNPTC)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
C
      DIMENSION INDAT(*),FMOZAN(*),UNTXYZ(3,NATFMOB,0:*),IABDFG(*),
     *          JABDFG(*),VDWRAD(*),RIJ(*),RWRK(*)
C
      MFG2 = (NFG*NFG - NFG)/2
      NOFF = MFG2 + (IFG-1)*NFG + 1
      DO IU=1,NUNPTC
        idum=0
        CALL MONOR(.FALSE.,IFG,INDAT,FMOZAN,UNTXYZ(1,1,IU),IABDFG,
     *             JABDFG,RIJ(NOFF),idum,RWRK,VDWRAD,0,0.0D+00,.true.)
        NOFF = NOFF + NFG*NFG
      END DO
C
      RETURN
      END
C
C*MODULE fmopbc  *DECK GENIMAGEFG
C> @brief COMPUTE UNTXYZ
C>
C> @author     Unknown
C>             -October 23, 2014
C>
C> @details Backup fmoc
C>           1: Compute untxyz etc. using the original fmoc
C>           2: compute untxyz etc. using fmoc generated according to
C>              the minimum image convention for the fragment ifg
C>
C> @date October 23, 2014-Spencer R. Pruitt
C>
C> @param NSTAT
C> @param IFG
C
      SUBROUTINE GENIMAGEFG(NSTAT,IFG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOPMD/ FMOBOX(3),MDWPBC,NIMGCELL,IMGLVL,
     *                LTRVEC,LFMOGCTR,LFMOCTMP,LINDATMD,LWRKDSAV,LINDXIU
     *               ,IPBCFST
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,LIACTFG,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
C
C     NSTAT=0: Backup fmoc
C           1: Compute untxyz etc. using the original fmoc
C           2: compute untxyz etc. using fmoc generated according to
C              the minimum image convention for the fragment ifg
C
      IF(NSTAT.EQ.0) THEN
        CALL DCOPY(3*NATFMO,X(LFMOC),1,X(LFMOCTMP),1)
      ELSE IF(NSTAT.EQ.1) THEN
        CALL DCOPY(3*NATFMO,X(LFMOCTMP),1,X(LFMOC),1)
        CALL GENREPFRG(IFG,X(LFMOC),X(LUNTXYZ),X(LCFRG),X(LTRVEC),
     *                 X(LINDAT),X(LINDXIU),X(LIABDFG),X(LJABDFG),NFG,
     *                 NATFMO+NBDFG,NIMGCELL,.FALSE.)
      ELSE IF(NSTAT.EQ.2) THEN
        CALL DCOPY(3*NATFMO,X(LFMOCTMP),1,X(LFMOC),1)
        CALL GENREPFRG(IFG,X(LFMOC),X(LUNTXYZ),X(LCFRG),X(LTRVEC),
     *                 X(LINDAT),X(LINDXIU),X(LIABDFG),X(LJABDFG),NFG,
     *                 NATFMO+NBDFG,NIMGCELL,.TRUE.)
      END IF
C
      RETURN
      END
C
C*MODULE fmopbc  *DECK GENREPFRG
C> @brief IMAGE CELL COORDINATES
C>
C> @author     Unknown
C>             -October 23, 2014
C>
C> @details GENERATE COORDINATES FOR IMAGE CELLS
C>
C> @date October 23, 2014-Spencer R. Pruitt
C>
C> @param IFG
C> @param FMOC
C> @param UNTXYZ
C> @param CFRG
C> @param TRVEC
C> @param INDAT
C> @param INDXIU
C> @param IABDFG
C> @param JABDFG
C> @param N
C> @param NATFMOB
C> @param NIMGCELL
C> @param SHIFT
C
      SUBROUTINE GENREPFRG(IFG,FMOC,UNTXYZ,CFRG,TRVEC,INDAT,INDXIU,
     *                     IABDFG,JABDFG,N,NATFMOB,NIMGCELL,SHIFT)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL SHIFT,DEBUG,GOPARR,DSKWRK,MASWRK
C
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      DIMENSION FMOC(3,*),UNTXYZ(3,NATFMOB,0:*),CFRG(3,*),TRVEC(3,*),
     *          INDAT(*),INDXIU(N,N),IABDFG(*),JABDFG(*)
C
      DATA DEBUG/.FALSE./
C
C     ----- FMOC IN THE SIMULATION CELL (IU=0) -----
C
      IF(SHIFT) THEN
        DO IAT=1,NATFMO
          KFG = INDAT(IAT)
          IF(KFG.NE.IFG) THEN
            MINIU = INDXIU(KFG,IFG)
            IF(MINIU.NE.0) THEN
              DO IXYZ=1,3
                FMOC(IXYZ,IAT) = FMOC(IXYZ,IAT) + TRVEC(IXYZ,MINIU)
              END DO
            END IF
          END IF
        END DO
      END IF
C
C     ----- UNTXYZ (IU=0) -----
C
      IND = 0
      DO KFG=1,NFG
        DO IAT=1,NATFMO
          IF(INDAT(IAT).EQ.KFG) THEN
            IND = IND + 1
            DO IXYZ=1,3
              UNTXYZ(IXYZ,IND,0) = FMOC(IXYZ,IAT)
            END DO
          END IF
        END DO
        DO IBDFG=1,NBDFG
          IA = ABS(IABDFG(IBDFG))
          JA =     JABDFG(IBDFG)
          IF(INDAT(JA).EQ.KFG) THEN
            IND = IND + 1
            UNTXYZ(IXYZ,IND,0) = FMOC(IXYZ,IA)
          END IF
        END DO
      END DO
      IF(IND.NE.NATFMOB) CALL ABRT
C
      CALL DCOPY(3*NATFMOB,UNTXYZ,1,CFRG,1)
C
C     ----- FORM IMAGE FRAGMENTS -----
C
      DO IU=1,NIMGCELL
        DO IND=1,NATFMOB
          DO IXYZ=1,3
            UNTXYZ(IXYZ,IND,IU) = UNTXYZ(IXYZ,IND,0) + TRVEC(IXYZ,IU)
          END DO
        END DO
      END DO
C
C     ----- DEBUG PRINT -----
C
      IF(DEBUG.AND.MASWRK) THEN
        WRITE(IW,*) ' UNTXYZ IN SUBROUTINE -GENREPFRG-'
        DO IU=0,NIMGCELL
          WRITE(IW,*) ' CELL #',IU
          IF(IU.GT.0) THEN
            WRITE(IW,*) ' TRANSLATION VECTOR'
            WRITE(IW,'(3F9.4)') (TRVEC(IXYZ,IU),IXYZ=1,3)
          END IF
          WRITE(IW,*) ' ATOMIC COORDINATES'
          DO IND=1,NATFMOB
        WRITE(IW,'(3F15.10)')
     *  (UNTXYZ(IXYZ,IND,IU)/1.8897164D+00,IXYZ=1,3)
          END DO
        END DO
      END IF
C
      RETURN
      END
