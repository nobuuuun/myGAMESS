C  1 Apr 16 - TN,HN,DGF - changes for FMO 5.2
c 22 Oct 14 - DGF - changes for FMO 5.1 
c 21 May 13 - TN  - save polarization in EFPFM2 differently
C 19 Oct 12 - MWS - synchronize FRGINF common
C 24 Jul 12 - DGF,HN - code update to finish FMO 4.3
C 23 MAR 12 - CHC,TN - code update to finish FMO 4.2
C 28 Dec 11 - TN  - changes for FMO 4.2 
C 15 Apr 11 - TN  - new module for multiscale solvation in FMO 
c
C*MODULE MLTFMO  *DECK FMOPCMREMD
C>    @brief   FMO-DFTB/PCM gradient
C>
C>    @details Calculate gradient that comes from \Delta q etc.
C>
C>    @author  Takeshi Nagata
C>
C>    @date Feb, 2016- Yoshio Nishimoto
C>    - Added FMO-DFTB/PCM
C>
      SUBROUTINE FMOPCMREMD(ISTEP,NTS,ILAY,LOADHF,LOADM,DA,IPTLG,
     *                      ZVLAG,IPTZC,ZVEC0,FMODE,ORBXCH,NUMFRG,
     *                      IODFMO,LAYFRG,SCFFRG,IREC0,
     *                      NGRFMO,MANNOD,MASTID,NQMTFG,mulfg,
     *                      lfmasc,needasc,needmul,mappcm)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK,ISGDDI,PAROUT,INITGDDI,wasgddi,mlgddi
      LOGICAL MYJOB
      LOGICAL ORBXCH
      LOGICAL DOSCZV,DODISTR,LCNTCAL,outpcm
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      INTEGER DDI_WORLD,DDI_GROUP
      PARAMETER (DDI_WORLD=0,DDI_GROUP=1)
      PARAMETER (MXATM=2000,MAXPST=10)
      PARAMETER (MXFRG=1050)

      PARAMETER (ONE=1.0D+00,HALF=0.5D+00)
C
      DIMENSION DA(1)
      DIMENSION LOADM(*),NUMFRG(*),NQMTFG(*)
      DIMENSION IODFMO(*),LAYFRG(*),SCFFRG(*)
      DIMENSION NGRFMO(MAXPST,*),MANNOD(*),MASTID(*)
      DIMENSION FMODE(3,*)
      DIMENSION IPTLG(*),ZVLAG(*),IPTZC(*),ZVEC0(*),mulfg(*),mappcm(*)
C
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,NFMOPCM,IHET
      COMMON /PCMTMP/ IDSP(MXATM+MXFRG*5),DPCMFRG(6,MXFRG),
     *                EGPCM(3,MXATM)
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /FMCOM / X(1)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2,maxrij
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MLTFMO/ Q_MUL,IMLTFMO,ISWPFD,ISWNEW1
      COMMON /MLTPNT/ LDELEPOT,LDELQSE,LQSETMP,LFZVEC,LMAPCMFD,LQBL2FD
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED,LEPSPCM
      COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
C
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA RMC/8HMCSCF   /
      DATA RHF/8HRHF     /
      DATA UHF/8HUHF     /
      DATA ROHF/8HROHF    /
CZ
CZ    THIS ROUTINE CALCULATES THE REMAINING CONTRIBUTION
CZ    IN FMO/PCM<1> GRADIENT
CZ
CZ    ISTEP=0
CZ    IAND(MODGRD,32).EQ.0: DERIVATIVE INTEGRALS 
CZ    IAND(MODGRD,32).NE.0: JUST GET LAGRANGIAN 
CZ
CZ    ISTEP=1 (ALWAYS COMES WITH IAND(MODGRD,32).NE.0)
CZ    DERIVATIVE INTEGRALS+RESPONSE TERM
CZ
      SCFSAV=SCFTYP
C
      IF (ISWNEW1.NE.1) RETURN
C
      ISWPFD  = 1
      IESDPPC = 0
      DOSCZV  = IAND(MODGRD, 32).NE.0
      DODISTR = IAND(MODPAR,512+1024).NE.0
      LCNTCAL = (ISTEP.EQ.0.AND..NOT.DOSCZV).OR.(ISTEP.EQ.1.AND.DOSCZV)
      IF (DFTBFL) THEN
        IFMOSTPS=IFMOSTP
        IF (LCNTCAL) IFMOSTP=4
      END IF
CZ    IF (MASWRK) WRITE(6,*) 'LCNTCAL', ISTEP,LCNTCAL
      modep=0
      if(iand(nprfmo,3).eq.3) modep=1
CZ
CZ    MEMORY ALLOCATION 
CZ
      MAXL2 = (MAXL1*MAXL1+MAXL1)/2
      MAXL3 =  MAXL1*MAXL1
      CALL VALFM(LOADFM)
      NDASC = 0
      LFPNT = LOADFM
      IF (ISTEP.EQ.0.and.modfd.eq.0) THEN
        if(isgddi) then
          NTSPAR=(NTS-1)/npglob+1
        else
          NTSPAR=(NTS-1)/NPROC+1
        endif
        CALL INDQPROD(0,NTSPAR,LFPNT,NDASC,DUM,DUM,DUM,modep)
      END IF
      LFZVEC  = LFPNT  + NDASC + 1
      LWRKA   = LFZVEC + MAXL2
      LAST    = LWRKA  + MAXL3
      NEED    = LAST - LOADFM -1
      CALL GETFM(NEED)
CZ
CZ    WORLD SCOPE
CZ
      IF (ISGDDI) THEN
        CALL GDDI_SCOPE(DDI_WORLD)
        CALL EFPPARL
      END IF
C
      IF     (ISTEP.EQ.0) THEN
        IF (GOPARR) CALL DDI_GSUMF(3003,X(LDELEPOT),NTS)
CZ      IF (MASWRK) THEN
CZ        WRITE(6,*) 'DELTA POTENTIAL IN FMOPCM'
CZ        LXX = LDELEPOT - 1
CZ        WRITE(6,'(8F12.8)') (X(LXX+I),I=1,NTS)
CZ      END IF
        nlen = nts
        if(modfd.eq.0) then
         LPNT=LDELQSE
         IF(IHET.EQ.1) LPNT=LDELQSE+NTS
         CALL INDQPROD(1,NTSPAR,LOADFM,NDASC,X(LDELEPOT),X(LDELQSE),
     *                X(LPNT),modep)
         if(ihet.eq.1) nlen= nts*2
        else
         call mltfmopcm(3,lfmasc,needasc,needmul,mappcm,idum)
        end if
        CALL DCOPY(nlen,X(LDELQSE),1,X(LQSETMP),1)
CZ      IF (MASWRK) THEN
CZ        WRITE(6,*) 'DELTA INDUCED CHARGE IN FMOPCM'
CZ        LXX = LQSETMP - 1
CZ        WRITE(6,'(8F12.8)') (X(LXX+I),I=1,NTS)
CZ      END IF
CZ      IF (MASWRK) THEN
CZ        WRITE(6,*) 'PCMCDR IN  FMOPCM'
CZ        DO I = 1, NATFMO
CZ          LXX = LPCMCDR + (I-1)*3
CZ          WRITE(6,'(3F12.8)') X(LXX),X(LXX+1),X(LXX+2)
CZ        END DO
CZ      END IF
      ELSEIF (ISTEP.EQ.1) THEN
        ! LQSETMP HERE IS INDUCED CHARGE DUE TO Z-VECTORS
        ! SEE FMOCP.SRC
C
        if(modfd.ne.0) then
C        Q = q^{ij,K} * U_{ij}^K (LQSETMP) +  Delta q + 0.5D+00*Q^b (DELEPOT)
C        For  Q C^a q^B
         CALL DAXPY(NTS,ONE,X(LQSETMP),1,X(LDELEPOT),1)
        end if
        nlen = nts
        if(ihet.eq.1) nlen= nts*2
C       \tilde{Q}  =  -0.5D+00*QF + Delta Q + q^{ij,K} * U_{ij}^K
C        For   V^a \tilde{Q} 
        CALL DAXPY(nlen,ONE,X(LDELQSE),1,X(LQSETMP),1)
      END IF
C
CZ
CZ    SWITCH TO GROUP
CZ
      IF (ISGDDI) THEN
        CALL GDDI_SCOPE(DDI_GROUP)
        CALL EFPPARL
      END IF
      IF (ISGDDI.AND.NGRFMO(1,ILAY).NE.0)
     *  CALL FMOPRE(ILAY,1,NGRFMO,MANNOD,MASTID,1)
C
      JCURFG  = 0
      KCURFG  = 0
      ICURLAY = ILAY
      IF (ISGDDI) CALL GDDICOUNT(-1,LGROUP,MYJOB)
      DO 230 IIFG = 1,NFG
        IFG = IIFG
        IF (LOADHF.EQ.1) IFG = LOADM(IIFG)
C
        IF (LAYFRG(IFG).LT.ILAY) GOTO 230
        ICURFG = IFG
        IF (ISGDDI) THEN
          CALL GDDICOUNT(0,LGROUP,MYJOB)
          IF (.NOT.MYJOB) GOTO 230
        END IF
C
        CALL CLOSDA('DELETE')
        CALL OPENDA(0)
        CALL MAKEMOL(IFG,0,0,ILAY,0,0,0,0,0,0,0,.TRUE.)
        L1 = NUM
        L2 = (L1*L1+L1)/2
        L3 =  L1*L1
        IDMREC0I = IFG + IREC0
C
        SCFTYP=SCFFRG(IFG)
C
        IF (DOSCZV.or.SCFFRG(IFG).NE.RHF) THEN
          NQI    = IAND(NQMTFG(IFG),65535)
          NAI    = ISHFT(NUMFRG(IFG),-16)
          NBI    = NAI
          NOCI   = NAI
          NVRI   = NQI - NOCI
          NOCVRI = NOCI*NVRI
          LENREC = L3+L1
          NTMP   = NOCVRI
          LCCB   = L2+1
          IF(SCFFRG(IFG).EQ.UHF.OR.SCFFRG(IFG).EQ.ROHF) THEN
            IF(SCFFRG(IFG).EQ.UHF)  LCCB   = L3    + L2  + 1
            LZVWRKB= LZVWRK+ NOCI*NVRI
            NBI    = NAI   + 1   - mulfg(ifg)
            NOCIB  = NBI
            NVRIB  = NQI   - NOCIB
c           NOCVRIB= NOCIB * NVRIB
            IF(SCFFRG(IFG).EQ.UHF)  LENREC =(L3+L1)* 2
            NTMP   = NTMP  + NBI * (NQI-NBI)
          END IF
C
          ! MO COEF. AND ORBITAL ENERGIES
          CALL RAREADS(IDAFMO,IODFMO,DA(L2+1),LENREC,IDMREC0I,0)
          CALL DMTX2(DA,DA(L2+1),NAI,L1,L1,NBI)
          IF(SCFFRG(IFG).EQ.UHF) THEN
            CALL DMTX2(DA,DA(L2+1),NAI,L1,L1,0)
            CALL DMTX2(X(LWRKA),DA(LCCB),NBI,L1,L1,0)
            CALL DAXPY(L2,ONE,X(LWRKA),1,DA,1)
          END IF
        ELSE
          CALL READMOND(DA,ORBXCH,SCFFRG(IFG).EQ.RMC,NA,NB,L1,
     *                  IODFMO,IDMREC0I,SCFFRG(IFG).EQ.UHF)
        END IF

C
c       IF (MASWRK) WRITE(6,*) 'DENSITY FOR ',IFG
c       CALL PRTRI(DA,L1)

        CALL VALFM(LOADFM)
        LCSD  = LOADFM + 1
        NDIM  = 1
        IF(SCFFRG(IFG).EQ.UHF.or.SCFFRG(IFG).EQ.ROHF) NDIM =2
        LWRK1 = LCSD   + L2
        LWRK2 = LWRK1  + L3 * NDIM 
        LWRK3 = LWRK2  + L3 * NDIM
        LAST  = LWRK3  + L3 * NDIM
        NDPCM = LAST - LOADFM -1
        CALL GETFM(NDPCM)

        IF (LCNTCAL) THEN
          CALL VCLR(DE,1,NAT*3)
CZ
CZ        GET Z-VECTOR FOR FRAGMENT IFG
CZ
          IF (ISTEP.EQ.1) THEN
            IF (DODISTR) THEN
              CALL ZVECPUTGET(1,0,IFG,NTMP,X(LIPTZVEC),X(LWRK1))
            ELSE
              CALL DCOPY(NTMP,ZVEC0(IPTZC(IFG)),1,X(LWRK1),1)
            END IF 
            CALL SWBASIS(0,L1,NOCI,NVRI,DA(L2+1),X(LWRK1),NVRI,
     *                   X(LWRK2),L1,X(LWRK3))
            CALL SQ2TRI(L1,L1,X(LWRK2),X(LFZVEC),HALF)
            IF(SCFFRG(IFG).EQ.UHF.or.SCFFRG(IFG).EQ.ROHF) THEN
             CALL SWBASIS(0,L1,NOCIB,NVRIB,DA(LCCB),X(LWRK1+NOCVRI),
     *                    NVRIB,X(LWRK2),L1,X(LWRK3))
             CALL SQ2TRI(L1,L1,X(LWRK2),X(LWRK2+L3),HALF)
             CALL DAXPY(L2,ONE,X(LWRK2+L3),1,X(LFZVEC),1)
c            CALL DAWRIT(IDAF,IODA,X(LWRK2+L2),L2,20,0)
            END IF 
          END IF 

          ! THIS IS FOR DERCCM: DA IS RHF DENSITY
          CALL DAWRIT(IDAF,IODA,DA,L2,16,0)
          IF(SCFFRG(IFG).EQ.UHF.or.SCFFRG(IFG).EQ.ROHF) THEN
            CALL VCLR(X(LWRK2),1,L2)
            CALL DAWRIT(IDAF,IODA,X(LWRK2),L2,20,0)
          END IF
  
          ! CALCULATION OF PCM CONTRIBUTIONS
          CALL DERCCM
          IF (MASWRK) CALL DAXPY(NAT*3,ONE,EGPCM,1,DE,1)
CZ        IF (MASWRK) THEN
CZ          WRITE(6,*) 'TESTTEST', NPROC, IFG
CZ          DO II1 = 1, NAT
CZ            WRITE(6,'(3F12.8)') DE(1,II1),DE(2,II1),DE(3,II1)
CZ          END DO
CZ        END IF
        END IF
C
C
        outpcm=iand(nprfmo,3).eq.0
        CALL PCMPOT(X(LCSD),X(LCSD),NTS,X(LQSETMP),X(LAXYZCT),L2,1,
     *              outpcm)

CZCZ    IF (GOPARR) CALL DDI_GSUMF(3003,X(LCSD),L2)
CZ
CZ      GET LAGRANGIAN CONTRIBUTION FOR Z-VECTOR CALCULATION
CZ
        IF (ISTEP.EQ.0.AND.DOSCZV) THEN
          CALL CPYTSQ(X(LCSD),X(LWRK1),L1,1)
          ! LPEX IS USED AS A WORK SPACE
          CALL SWBASIS(1,L1,NOCI,NVRI,DA(L2+1),X(LWRK1),L1,X(LZVWRK),
     *                 NVRI,X(LWRK2))
          IF(SCFFRG(IFG).NE.UHF.AND.SCFFRG(IFG).NE.ROHF) THEN
            CALL ZVLGMULT(NOCVRI,1,IFG,IPTLG,DODISTR,ZVLAG,X(LZVWRK),
     *                    X(LWRK2))
          ELSE IF(SCFFRG(IFG).EQ.UHF.OR.SCFFRG(IFG).EQ.ROHF) THEN
           CALL SWBASIS(1,L1,NOCIB,NVRIB,DA(LCCB),X(LWRK1),L1,
     *                  X(LZVWRKB),NVRIB,X(LWRK2))
           CALL ZVLGMULT(NTMP,1,IFG,IPTLG,DODISTR,ZVLAG,X(LZVWRK),
     *                  X(LWRK2))
          END IF
        END IF
CZ
        IF (LCNTCAL) THEN
          IF(SCFFRG(IFG).NE.UHF.AND.SCFFRG(IFG).NE.ROHF) THEN
            CALL CPYTSQ(DA,DA(L2+1),L1,1)
            CALL TFTRI(X(LWRK1),X(LCSD),DA(L2+1),X(LWRK2),L1,L1,L1)
            CALL DSCAL(L2,-HALF,X(LWRK1),1)
          ELSE IF(SCFFRG(IFG).EQ.UHF.or.SCFFRG(IFG).EQ.ROHF) THEN
C          Alpha
            CALL DMTX2(DA,DA(L2+1),NAI,L1,L1,0)
            CALL CPYTSQ(DA,X(LWRK2),L1,1)
            CALL TFTRI(X(LWRK1),X(LCSD),X(LWRK2),X(LWRK3),L1,L1,L1)
C          Beta
            CALL DMTX2(DA,DA(LCCB),NBI,L1,L1,0)
            CALL CPYTSQ(DA,X(LWRK2),L1,1)
            CALL TFTRI(X(LWRK1+L2),X(LCSD),X(LWRK2),X(LWRK3),L1,L1,L1)
            CALL DAXPY(L2,ONE,X(LWRK1+L2),1,X(LWRK1),1)
C
            CALL DSCAL(L2,-ONE,X(LWRK1),1)
          END IF
          IF (.NOT.DFTBFL) THEN
            CALL SDER(X(LWRK1),X(LWRK2),L1,L2,.FALSE.)
          ELSE
            CALL DFTB_SDER(X(LWRK1),X(LWRK2),DA,X(LCSD),L1,L2)
          END IF
          IF (GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
          IF (MASWRK) CALL FMODEG(1,FMODE,X(LFMOPG),X(LIAGLOB))
        END IF

        CALL RETFM(NDPCM)
  230 CONTINUE
C
      ISWPFD = 0
      CALL RETFM(NEED)
      IF (ISGDDI) CALL GDDICOUNT( 1,LGROUP,MYJOB)
C
      SCFTYP=SCFSAV
      IF (DFTBFL) IFMOSTP=IFMOSTPS
C
      RETURN
      END
C*MODULE MLTFMO  *DECK INDQPROD 
      SUBROUTINE INDQPROD(ITER,NTSPAR,LFPNT,NDASC,POTIN,QOUT,QDOUT,mode)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,PACK2E
CZ    DIMENSION QINI(*)
      DIMENSION POTIN(1),QOUT(1),QDOUT(1)
C 
      PARAMETER (ONE=1.0D+00)
C
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INT2IC/ NINTIC,ININTIC,NXXIC,LBUFPIC,LIXIC,LABSIX,NINTIX
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /PCKLAB/ LABSIZ
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMITR/ RCUT(2),THRES,IPCMIT,IMUL,MXDIIS,NREG,MXITR1,
     *                MXITR2,MODPAP
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,NFMOPCM,IHET
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                MPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED,LEPSPCM
CZCZ  ADDED FOR MULTISCALE solvation in FMO
czcz  COMMON /MLTFMO/ Q_MUL,IMLTFMO,ISWPFD,ISWNEW1
CZCZ
C
C     COMPUTE APPARENT SURFACE CHARGES (ASC). 
C     ITERMSCF=0 ESTIMATE MEMORY NEED 
C     ITERMSCF=1 DO THE WORK 
C     NO MEMORY IS ALLOCATED INSIDE.
C
C     -- MEMORY FOR SALVATION
C
CZCZ  PCMRST=IAND(MODPAP,4).NE.0
      MXDII1 = MXDIIS + 1
C
      LQ0    = LFPNT  + 1
      LQ1    = LQ0    + NTS
      LQ2    = LQ1    + NTS
      LQ3    = LQ2    + NTS
      LD0    = LQ3    + NTS
      LQA    = LD0    + NTS
      LDIMAT = LQA    + NTS
      LTMP0  = LDIMAT + MXDII1*MXDII1
      LTMP1  = LTMP0  + NTS*3
      LTMP2  = LTMP1  + MXDII1
      LIPVT  = LTMP2  + MXDII1*MXDII1
      LRMUL  = LIPVT  + MXDII1
      LAST   = LRMUL  + MXSP*10
C
C     ALLOCATE THE LARGEST PCM ARRAY.
C     TRY BORROWING INTEGRAL MEMORY, IF AVAILABLE.
C     NOTE THAT OPTFMOX ALSO USES IT. 
C     WE CAN USE THE INTEGRAL BUFFER HERE SINCE QREP IS USED IN ASCIT
C     AFTER SCF IS ALL DONE AND THE INTEGRALS ARE NO LONGER NEEDED. 
C     TRY ALLOCATING ALL PCM IN INTEGRALS?
C
      NQREP=NTSPAR*MXDII1*2
      IUSE2E=0
      IF(NINTIC.GT.0) THEN
        LABSIZ2=2/LABSIZ
        N2EBUF=NINTMX+NINTIC+(NINTMX+NINTIC-1)/LABSIZ2+1
C       WRITE(6,*) 'BUFFER',N2EBUF,NHBLOCK
        IF(N2EBUF.GE.NQREP) THEN
          LQREP=LBUFPIC
          IUSE2E=1
        ENDIF
      ENDIF
      IF(IUSE2E.EQ.0) THEN
        LQREP = LAST 
        LAST  = LQREP  + NQREP
      ENDIF
C
      NDASC = LAST - LFPNT -1
      IF (ITER.EQ.0) RETURN
C
      IF(MASWRK.and.mode.eq.0) THEN
        WRITE(IW,9000) NDASC
        IF(IUSE2E.NE.0) WRITE(IW,9010) NQREP
      ENDIF

      CALL DSCAL(NTS,-ONE,POTIN,1)
CZ
C
C     ADD ELECTRON AND NUCLEAR POTENTIALS AND NORMALISE.
C
C     WRITE(6,*) 'WWWPCM-ELPOT'
C     CALL PRSQA(X(LPEL),NTS,1,1)
C     CALL ABRT
C
C
CZCZ  IF(IHAVEQ0.GT.0) THEN
CZCZ    CALL DCOPY(NTS,QINI(1+NTS*INDQE),1,X(LQ0),1)
CZCZ    IF(IEF.EQ.10.AND.EPS.NE.0.AND.ICOMP.EQ.0)
CZCZ *    CALL DSCAL(NTS,EPS/(EPS-ONE),X(LQ0),1)
C       FOR ICOMP=0 QINI HAS CHARGES SCALED BY (EPS-ONE)/EPS (FOR SCF),
C       UNSCALE THEM NOW FOR THE INITIAL GUESS IN ASCIT. 
CZCZ    IHAVEQ0=0
C       WRITE(6,*) 'WWWNTS1',(X(LQ0-1+I),I=1,NTS)
CZCZ  ENDIF
CZ
CZ    ADD EFP CONTRIBUTION TO QPOT FOR MULTISCALE solvation in FMO
CZ
CZCZ  IF (IMLTFMO.EQ.1) THEN
CZCZ    CALL ADDPOT(X(LQPOT),X(LVECMUL),.TRUE.,X(LAXYZCT),
CZCZ *       X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2))
CZCZ    Q_MUL=0.5D+00*DDOT(NTS,X(LVECMUL),1,X(LQSE),1)
CZCZ    WRITE(6,*) 'Q_MUL', Q_MUL 
CZCZ  END IF
CZCZ
      CALL ASCIT(ITER,0,POTIN,X(LQ0),X(LQ1),X(LQ2),X(LQ3),
     *           X(LD0),X(LQA),X(LDIMAT),X(LQREP),X(LTMP0),X(LTMP1),
     *           X(LTMP2),X(LIPVT),X(LRMUL),MXDII1,NTSPAR,X(LAXYZCT),
     *           X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),X(LAXYZCT+MXTS*3),
     *           QOUT,X(LXYZRE),X(LXYZRE+MXSP),X(LXYZRE+MXSP*2),
     *           X(LXYZRE+MXSP*3),X(LISPHE),X(LLIST))
C       WRITE(6,*) 'WWWNTS1A',(X(LQSE-1+I),I=1,NTS)
C
C  SCALE C-PCM CHARGES BY (EPS-1)/EPS
C
CZCZ  IF(PCMRST) CALL DCOPY(NTS,X(LQSE),1,QINI(1+NTS*INDQE),1)
CZCZ  IF(IEF.EQ.10) CALL DSCAL(NTS,(EPS-ONE)/EPS,X(LQSE),1) 
C     - QSED IS REQUIRED EVERYWHERE EVEN IF IHET=0 -
C     - QSED = QSE WHEN IHET=0
CZCZ  IF(IHET.EQ.0) CALL DCOPY(NTS,X(LQSE),1,X(LQSED),1)
      IF(IHET.EQ.0) THEN 
        IF(IEF.EQ.10) CALL DSCAL(NTS,(EPS-ONE)/EPS,QOUT,1) 
        CALL DCOPY(NTS,QOUT,1,QDOUT,1)
      ELSE IF(IHET.NE.0) THEN
        CALL FMOHETPCM(POTIN,X(LEPSPCM),X(LISPHE),NTS)
        CALL ASCIT(ITER,0,POTIN,X(LQ0),X(LQ1),X(LQ2),X(LQ3),
     *           X(LD0),X(LQA),X(LDIMAT),X(LQREP),X(LTMP0),X(LTMP1),
     *           X(LTMP2),X(LIPVT),X(LRMUL),MXDII1,NTSPAR,X(LAXYZCT),
     *           X(LAXYZCT+MXTS),X(LAXYZCT+MXTS*2),X(LAXYZCT+MXTS*3),
     *           QDOUT,X(LXYZRE),X(LXYZRE+MXSP),X(LXYZRE+MXSP*2),
     *           X(LXYZRE+MXSP*3),X(LISPHE),X(LLIST))
        IF(IEF.EQ.10) THEN
C         QOUT  is Q^\prime
C         QDOUT is \tilde{Q} in supporting.pdf
C         q=1/2 (QOUT + QDOUT)
          CALL FMOHETPCM(QOUT,X(LEPSPCM),X(LISPHE),NTS)
          call daxpy(nts,ONE,QDOUT,1,QOUT,1)
          call dscal(nts,0.5D+00,QOUT,1)
        END IF
      END IF
C
C     WRITE(6,*) 'WWWPCM-ASC'
C     CALL PRSQA(QSE,NTS,1,1)
C     ENPCM=-DDOT(NTS,X(LQPOT),1,QSE,1)
C     PX=DDOT(NTS,X(LPEL),1,QSE,1)
C     PB = INTERACTION ELECTRONS-NUCLEAR INDUCED CHARGES
C     PC = INTERACTION NUCLEI-ELECTRONIC INDUCED CHARGES
C     PX = INTERACTION ELECTRONS-ELECTRONIC INDUCED CHARGES
C     PB=ZERO
C     PC=-PX
C     PX=ENPCM - PX
C
C     FMO-PCM DIFFERS FROM THE AB INITIO PCM IN PUTTING ASC-ELECTRON INTEGRALS.
C     IN AB INITIO THEY GO TO THE FOCK MATRIX DIRECTLY.
C     IN FMO-PCM THEY ARE ADDED TO ONE-ELECTRON INTEGRALS (AND THUS TO
C     THE FOCK MATRIX).
C     THE FOCK MATRICES ARE THE SAME BUT THE 1E INTEGRALS DIFFER. THEFORE, THE
C     ENERGY CORRECTION TERM DIFFERS (SUBTRACTING 1/2*TR(D*VEL)=1/2*(PEL*QSE)).
C     P.S. THE REASON FOR THE DIFFERENT BEHAVIOUR IS THAT IN FMO-PCM THE ASCS
C     ARE CONSTANT IN SCF ITERATIONS.
C
C     --- NORMALIZATION ---
C
C  4) NORMALIZZAZIONE DELLE CARICHE VIRTUALI ELEMENTARI ELETTRONICHE.
C     PER ICOMP=1 LA CORREZIONE E' DISTRIBUITA IN PROPORZIONE
C     ALL'AREA DELLA TESSERA.
C     PER ICOMP=2 LA CORREZIONE E' EFFETTUATA CON FATTORI COSTANTI.
C
CZCZ  IF(ICOMP.NE.0) THEN
CZCZ    QN=-(NEFMO+ICHFMO)*(EPS-ONE)/EPS
CZCZ    QE=NEFMO*(EPS-ONE)/EPS
CZCZ    QTE=DDOT(NTS,X(LQSE),1,ONE,0)
CZCZ    QTN=DDOT(NTS,X(LQSN),1,ONE,0)
C       QSE=QE, QSN=QN 
C       WRITE(6,*) 'WWWCC',QE,QTE,QN,QTN
CZCZ    IF(ICOMP.EQ.1) THEN
C       CHARGE RENORMALISATION IS:
C       QT=QT+FE*S+FN*S=QE+QN+(FN+FE)*S
CZCZ      SUPTOT=STOT*ANTOAU*ANTOAU
CZCZ      FE=(QE-QTE)/SUPTOT
CZCZ      FN=(QN-QTN)/SUPTOT
CZCZ      CALL DAXPY(NTS,ONE,X(LQSN),1,X(LQSE),1)
C         X(LAXYZCT+MXTS*3) IS AS
CZCZ      CALL DAXPY(NTS,FN+FE,X(LAXYZCT+MXTS*3),1,X(LQSE),1)
CZCZ    ELSE IF(ICOMP.EQ.2) THEN
C       CHARGE RENORMALISATION IS:
C       QT=QE*FE+QN*FN
CZCZ      FE=QE/QTE
CZCZ      FN=QN/QTN
CZCZ      CALL DSCAL(NTS,FE,X(LQSE),1)
CZCZ      CALL DAXPY(NTS,FN,X(LQSN),1,X(LQSE),1)
CZCZ    END IF
CZCZ    QETN=DDOT(NTS,X(LQSE),1,ONE,0)
CZCZ    IF(MASWRK) WRITE(IW,9200) QTE+QTN,QETN,FN,FE
C       NOTE THAT FE AND FN HAVE VERY DIFFERENT MEANINGS IN ICOMP=1 AND 2.  
CZCZ    IF(PCMRST) CALL DCOPY(NTS,X(LQSN),1,QINI(1+NTS),1)
CZCZ  ELSE
C       WITHOUT CHARGE COMPENSATION, QSE CONTAINS QE+QN ALREADY. 
CZCZ    QET=DDOT(NTS,X(LQSE),1,ONE,0)
CZCZ    TCH=-ICHFMO*(EPS-ONE)/EPS
CZCZ    IF(MASWRK) WRITE(IW,9100) QET,TCH
CZCZ  END IF
CZCZ  IF(PCMRST) CALL DCOPY(NTS,X(LQSE),1,QINI,1)
C     THIS OVERWRITES UNSCALED QINI FOR ICOMP=0 BY SCALED VALUES. 
C
C     WE MUST BE IN WORLD SCOPE NOW, SO BROADCAST CHARGES TO ENSURE
C     NO SCF DEADLOCKS. 
C
C     IF(GOPARR) CALL DDI_BCAST(2422,'F',QSE,NTS,0)
C
      if(mode.eq.0) CALL TIMIT(1)
C
      RETURN
 9000 FORMAT(/1X,'CALCULATING APPARENT SURFACE CHARGES...',
     *       /5X,'USING',I12,' WORDS OF MEMORY.')
 9010 FORMAT(1X,I12,' WORDS ARE BORROWED FROM THE INTEGRAL BUFFER.')
C9050 FORMAT(1X,'CALCULATED NUCLEAR CHARGES, NOW DOING ELECTRONIC...')
C9100 FORMAT(1X,'PCM ASC=',F18.10,' THEORETICAL=  ',F18.10,/)
C9200 FORMAT(1X,'PCM ASC=',F18.10,' NORMALISED TO=',F18.10,/
C    *      1X,'NUCLEAR FACTOR=',F15.10,', ELECTRONIC FACTOR=',F15.10,/)
      END
C*MODULE MLTFMO  *DECK WRAPEPOT 
      SUBROUTINE WRAPEPOT(IMODE,FDA,XCTS,YCTS,ZCTS,DA,DB,NTS,L2,mappcm)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
CZ    LOGICAL GOPARR,MASWRK,DSKWRK,SVDSKW
C
      PARAMETER (ONE=1.0D+00)
      DIMENSION XCTS(1), YCTS(1), ZCTS(1), DA(1), DB(1)
      DIMENSION MAPPCM(*)
C
      COMMON /FMCOM / X(1)
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MLTPNT/ LDELEPOT,LDELQSE,LQSETMP,LFZVEC,LMAPCMFD,LQBL2FD
CZ    COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
cz    COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
cz   *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
cz   *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
cz   *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED,LEPSPCM
C
C     THIS ROUTINE CONSTRUCTS DELTA POTENTIAL
C     LQSETMP IS USED AS TEMPORARY SPACE HERE
C
      IF     (IMODE.EQ.0) THEN
        CALL READHFD(DA,DB,L2)
      ELSEIF (IMODE.EQ.1) THEN
        ! ONLY DENSITY CORRECTION
        CALL DAREAD(IDAF,IODA,DA,L2,307,0)
      ELSE
        CALL ABRT
      END IF
      CALL VCLR(X(LQSETMP),1,NTS)
      if(modfd.eq.0) then
        CALL EPOTEN(FDA,XCTS,YCTS,ZCTS,X(LQSETMP),DA,NTS,L2)
c       write(6,'("CHK=",F11.8)') (X(LQSETMP-1+ITS),ITS=1,NTS) 
      else
        call EPOTEN3(fda,XCTS,YCTS,ZCTS,X(LQSETMP),DA,NTS,L2,mappcm)
c       write(6,'("CHK=",F11.8)') (X(LQSETMP-1+ITS),ITS=1,NTS) 
      end if

      CALL DAXPY(NTS,ONE,X(LQSETMP),1,X(LDELEPOT),1)

      RETURN
      END
C*MODULE MLTFMO  *DECK PCMCNT2ORBH 
      SUBROUTINE PCMCNT2ORBH(L2,CNT)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      logical outpcm
C
      DIMENSION CNT(*)

      COMMON /FMCOM / X(1)
      COMMON /MLTPNT/ LDELEPOT,LDELQSE,LQSETMP,LFZVEC,LMAPCMFD,LQBL2FD
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED,LEPSPCM
CZ
CZ    LQSETMP HERE IS INDUCED DIPOLE DUE Z-VECTORS
CZ
      outpcm=iand(nprfmo,3).eq.0
      CALL PCMPOT(CNT,CNT,NTS,X(LQSETMP),X(LAXYZCT),L2,1,outpcm)

      RETURN
      END
C*MODULE MLTFMO  *DECK MONOTPOL
      SUBROUTINE MONOTPOL(XCTS,YCTS,ZCTS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXFGPT=12000,MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00, GLIM=1.0D-03)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
      LOGICAL DOEFPIEA
C
      CHARACTER*8 POLNAM,DPOLNAM
C
      DIMENSION XCTS(1), YCTS(1), ZCTS(1)
C
      COMMON /EFPFM2/ TOTEFPC,POLTOT,LABFLDT,LDINDF2,LDINDDF2,LDELABFLD,
     *                LDELDIND,LDELDINDD,LALCNT2F
      COMMON /EFFMOP/ LEFLDFMO,LEFADDFMO,LDINDFMO,LDINDDFMO,
     *                LDEFEF,LDEFTF,LTORQF
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FMCOM / XX(1)
      COMMON /FRFD  / PPEFX(MXFGPT), PPEFY(MXFGPT), PPEFZ(MXFGPT)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IEACAL/ REMPOL,IEACAL,NFGIEA,NFRGIEA,NFRGI1,NFRGI2,IEADA,
     *                MXEFPT,MAXPOL,NPRIEA,NATFIEA,IEABDY,ITRLVL,
     *                LIEACNT,ieaold,DOEFPIEA
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MLTFMO/ Q_MUL,IMLTFMO,ISWPFD,ISWNEW1
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                MPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED,LEPSPCM
CZ
CZ    THIS ROUTINE CALCULATES THE INDUCED DIPOLE DUE TO THE SUM OF
CZ    MONOMER ELECTRIC FIELD IN NEW FMO/EFP.
CZ    IF IEFPFMO=2, NEW FMO/EFP IS ACTIVEATED
CZ
CZCZ
      CALL TIMIT(1)
      IF (MASWRK) WRITE(IW,9000)
      IF (IEACAL.EQ.1) DOEFPIEA = .TRUE.
C
      NPTTPT3 = NPTTPT*3
      IF(GOPARR) CALL DDI_GSUMF(668,XX(LABFLDT),NPTTPT3)
      II = 0
      DO LEFP = 1, NPTTPT
        IX = II
        IY = II + 1
        IZ = II + 2
CZ
CZ      MULTISCALE solvation in FMO
CZ
C       -- SOLVENT APPARENT CHARGE FIELD AT THE POINT ----
        PQ_X=ZERO
        PQ_Y=ZERO
        PQ_Z=ZERO
        IF (IMLTFMO.EQ.1) THEN
          DO ITS = 1,NTS
             ! SUPPOSED THAT ALL CONTRIBUTIONS ARE INCLUDED IN LQSE.
             QT = XX(LQSE+ITS-1)
             RR = (EFP(1,LEFP)-XCTS(ITS))**2 +
     *            (EFP(2,LEFP)-YCTS(ITS))**2 +
     *            (EFP(3,LEFP)-ZCTS(ITS))**2
             IF (RR.GE.GLIM) THEN
               RR3 = RR * SQRT(RR)
               PQ_X = PQ_X + QT *(EFP(1,LEFP)-XCTS(ITS))/RR3
               PQ_Y = PQ_Y + QT *(EFP(2,LEFP)-YCTS(ITS))/RR3
               PQ_Z = PQ_Z + QT *(EFP(3,LEFP)-ZCTS(ITS))/RR3
             END IF
          ENDDO
        END IF

        ! ABFLDT CONTAINS BOTH ELECTRON AND NUCLEAR CONTRIBUTIONS
        XX(LEFLDFMO+IX) = XX(LABFLDT+IX) + PPEFX(LEFP) + PQ_X
        XX(LEFLDFMO+IY) = XX(LABFLDT+IY) + PPEFY(LEFP) + PQ_Y
        XX(LEFLDFMO+IZ) = XX(LABFLDT+IZ) + PPEFZ(LEFP) + PQ_Z
        II = II + 3
      ENDDO
C
      CALL DCOPY(NPTTPT3,XX(LDINDF2) ,1,DIND, 1)
      CALL DCOPY(NPTTPT3,XX(LDINDDF2),1,DINDD,1)

      CALL DINDPROD(XX(LEFLDFMO),XX(LDINDF2),XX(LDINDDF2))

C
C     TOTAL POLARIZATION INTERACTION ENERGY
C
      IPCOUNT = ME - 1
      DO 24 LEFP=1,NPTTPT
        IF (GOPARR) THEN
          IPCOUNT = IPCOUNT + 1
          IF (MOD(IPCOUNT,NPROC).NE.0) THEN
            GO TO 24
          END IF
        END IF
C
C       FIELD DUE TO TOTAL FIELD
C
        IC = (LEFP-1)*3
        ! DOES NOT INCLUDE FIELD DUE TO PCM
        TOTFX = XX(LABFLDT+IC  ) + PPEFX(LEFP)
        TOTFY = XX(LABFLDT+IC+1) + PPEFY(LEFP) 
        TOTFZ = XX(LABFLDT+IC+2) + PPEFZ(LEFP)
C
C       INDUCED DIPOLE
C
        PMUX   =  DIND(1,LEFP)
        PMUY   =  DIND(2,LEFP)
        PMUZ   =  DIND(3,LEFP)
        PMUXD  = DINDD(1,LEFP)
        PMUYD  = DINDD(2,LEFP)
        PMUZD  = DINDD(3,LEFP)
        TOTMUX = PMUX + PMUXD
        TOTMUY = PMUY + PMUYD
        TOTMUZ = PMUZ + PMUZD
C
        POLTOT = POLTOT - ( TOTMUX*TOTFX
     *                     +TOTMUY*TOTFY
     *                     +TOTMUZ*TOTFZ)*PT5*PT5
C
        IF (DOEFPIEA) THEN
          REMPOL = REMPOL - ( TOTMUX*PPEFX(LEFP)
     *                       +TOTMUY*PPEFY(LEFP)
     *                       +TOTMUZ*PPEFZ(LEFP))*PT5*PT5
        END IF
 24   CONTINUE
      IF (IEACAL.EQ.1) DOEFPIEA = .FALSE.
C
      CALL TIMIT(1)
      IF (MASWRK) WRITE(IW,9010)
      RETURN
 9000 FORMAT(1X,'POLARIZATION CALCULATION STARTS IN NEW FMO/EFP')
 9010 FORMAT(1X,'CALCULATED POLARIZATION IN NEW FMO/EFP')
      END
C*MODULE MLTFMO  *DECK GETABFLDT
C>
C>     @brief unknown 
C>
C>     @details unknown 
C>
C>     @author takeshi Nagata 
C>
      SUBROUTINE GETABFLDT(IMODE,IRHF,IDA,L1,L2,ABFLDT,DINDF2,DINDDF2,
     *                     DA,DB,LGRAD)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXFGPT=12000,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ZERO=0.0D+00, PT5=0.5D+00)
C
      DIMENSION DA(1),DB(1),ABFLDT(3,*),DINDF2(3,*),DINDDF2(3,*)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
      LOGICAL LGRAD
C
      COMMON /EFPFM2/ TOTEFPC,POLTOT,LABFLDT,LDINDF2,LDINDDF2,LDELABFLD,
     *                LDELDIND,LDELDINDD,LALCNT2F
      COMMON /FMCOM / X(1)
CZ    COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PNUC  / PPNX(MXFGPT),PPNY(MXFGPT),PPNZ(MXFGPT),PNZRF(3)
CZ
CZ    AFTER THE SCF CALCULATION IN RHFCL,
CZ    QM FIELD IS CALCLATED IN NEW FMO/EFP
CZ    IF IEFPFMO=2, NEW FMO/EFP IS ACTIVEATED
CZ
      IF (.NOT.LGRAD.AND.IFMOSTP.GT.2) RETURN

      IF (LGRAD) THEN
        IF     (IMODE.EQ.0) THEN
          ! READ RHF DENSITY
          CALL READHFD(DA,DB,L2)
        ELSEIF (IMODE.EQ.1) THEN
          ! ONLY DENSITY CORRECTION FOR MP2 GRAD
          CALL DAREAD(IDAF,IODA,DA,L2,307,0)
        ELSE
          CALL ABRT
        END IF
      ELSE
        ! ENERGY CALCULATION
        CALL DAREAD(IDAF,IODA,DA,L2,16,0)
      END IF
C
      CALL VALFM(LOADFM)
      LXEFI   = LOADFM + 1
      LYEFI   = LXEFI  + L2
      LZEFI   = LYEFI  + L2
      LFLDTMP = LZEFI  + L2
      LAST    = LFLDTMP + NPTTPT*3
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      DUM = ZERO
      CALL VCLR(X(LFLDTMP),1,NPTTPT*3)
      CALL DRCTPOL(1,NPTTPT,L1,L2,.FALSE.,.TRUE.,DUM,X(LFLDTMP),DA,
     *             DUM,DINDF2,DINDDF2,X(LXEFI),X(LYEFI),X(LZEFI))
C
C     IMODE=0 MEANS RHF
C 
      IF (IFMOSTP.EQ.2.AND.IRHF.EQ.1) THEN
        CNT2POL = ZERO
        IPCOUNT = ME - 1
        DO 25 LEFP=1,NPTTPT
C
C       ----- GO PARALLEL! -----
C
           IF (GOPARR) THEN
              IPCOUNT = IPCOUNT + 1
              IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 25
           END IF
C
           PNX=PPNX(LEFP)
           PNY=PPNY(LEFP)
           PNZ=PPNZ(LEFP)
           TOTMUX =  DINDF2(1,LEFP) + DINDDF2(1,LEFP)
           TOTMUY =  DINDF2(2,LEFP) + DINDDF2(2,LEFP)
           TOTMUZ =  DINDF2(3,LEFP) + DINDDF2(3,LEFP)
C
C          ----- PREPARE POLARIZED ENVIRONMENT FOR NEXT SCF ITER -----
C
           ! THE SUM OF FRAGMENT FIELDS
           LTMP = LFLDTMP + (LEFP-1)*3
           EFLDXX = X(LTMP  )
           EFLDYY = X(LTMP+1)
           EFLDZZ = X(LTMP+2)

           CNT2POL = CNT2POL
     *             - PT5*(TOTMUX*EFLDXX+TOTMUY*EFLDYY+TOTMUZ*EFLDZZ)
           ABFLDT(1,LEFP) = ABFLDT(1,LEFP) + EFLDXX + PNX
           ABFLDT(2,LEFP) = ABFLDT(2,LEFP) + EFLDYY + PNY
           ABFLDT(3,LEFP) = ABFLDT(3,LEFP) + EFLDZZ + PNZ
 25     CONTINUE
        IF(GOPARR) CALL DDI_GSUMF(688,CNT2POL,1)
        IF (MASWRK) POLTOT = POLTOT - CNT2POL 
      END IF
C
CZ
CZ    HERE IDA IS COUNTING THE NUMBER OF MONOMERS IN SUM_I>J(E_IJ-E_I-E_J)
CZ
      IF (LGRAD.AND.IDA.NE.0) THEN
        DDA = IDA
        IF (MASWRK) CALL DAXPY(NPTTPT*3,DDA,X(LFLDTMP),1,X(LDELABFLD),1)
      END IF
      CALL RETFM(NEED)
      RETURN
      END
C*MODULE MLTFMO  *DECK DNEWIND
      SUBROUTINE DNEWIND(DIND,DINDD)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
      PARAMETER (MXFRG=1050, MXDFG=5, MXFGPT=12000,
     *           MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (ONE=1.0D+00)
C
      DIMENSION DIND(3,*),DINDD(3,*)
C
      COMMON /EFFMOP/ LEFLDFMO,LEFADDFMO,LDINDFMO,LDINDDFMO,
     *                LDEFEF,LDEFTF,LTORQF
      COMMON /EFPGES/ DESFRG(6,MXFRG)
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FMCOM / XX(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
CZ
CZ    NON-ELECTRONIC POLARIZATION CONTRIBUTION TO GRADIENT 
CZ    IN NEW FMO/EFP 
CZ
      NFRG_3 = 3*NFRG
      CALL DEFPCLR
      CALL DEFEFIND(DIND,DINDD,DESFRG)
CZCZ  IF(GOPARR) CALL DDI_GSUMF(778,DESFRG,6*MXFRG)
C
      ! DEFT AND TORQ ARE ALWAYS CLEARED IN EFFT.
      CALL VCLR(DEFT,1,NFRG_3)
      CALL VCLR(TORQ,1,NFRG_3)
      IF (MASWRK) THEN
        CALL DESFRGMV(NFRG,DESFRG,DEFT,TORQ)
C
        DO I = 0, NBODY - 1
          CALL DAXPY(NFRG_3,ONE,DEFT,1,XX(LDEFTF+NFRG_3*I),1)
          CALL DAXPY(NFRG_3,ONE,TORQ,1,XX(LTORQF+NFRG_3*I),1)
        END DO
      END IF

      CALL DEFPCLR
      RETURN
      END
C*MODULE MLTFMO  *DECK DESFRGMV 
      SUBROUTINE DESFRGMV(NFRG,DESFRG,DEFT,TORQ) 
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      DIMENSION DESFRG(6,*), DEFT(3,*),TORQ(3,*)
C
      DO IFRG = 1, NFRG
        DEFT(1,IFRG) = DEFT(1,IFRG) + DESFRG(1,IFRG)
        DEFT(2,IFRG) = DEFT(2,IFRG) + DESFRG(2,IFRG)
        DEFT(3,IFRG) = DEFT(3,IFRG) + DESFRG(3,IFRG)
        TORQ(1,IFRG) = TORQ(1,IFRG) + DESFRG(4,IFRG)
        TORQ(2,IFRG) = TORQ(2,IFRG) + DESFRG(5,IFRG)
        TORQ(3,IFRG) = TORQ(3,IFRG) + DESFRG(6,IFRG)
      END DO

      RETURN
      END
C*MODULE MLTFMO  *DECK DNEWIND2
      SUBROUTINE DNEWIND2(ISTEP,ILAY,LOADHF,LOADM,DA,IPTLG,ZVLAG,
     *                    IPTZC,ZVEC0,FMODE,ORBXCH,NUMFRG,IODFMO,
     *                    LAYFRG,SCFFRG,ISGDDI,IREC0,NGRFMO,
     *                    MANNOD,MASTID,NQMTFG,CPWT1,CPWK1,CPWK2,CPWK3)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
      LOGICAL ISGDDI,MYJOB
      LOGICAL ORBXCH
      LOGICAL DOSCZV,DODISTR,LCNTCAL
C
      CHARACTER*8 POLNAM,DPOLNAM
C
      PARAMETER (MXATM=2000,MAXPST=10)
      INTEGER DDI_WORLD,DDI_GROUP
      PARAMETER (DDI_WORLD=0,DDI_GROUP=1)
      PARAMETER (MXFRG=1050, MXFGPT=12000,MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)

      PARAMETER (ONE=1.0D+00,HALF=0.5D+00)
C
      DIMENSION DA(1)
      DIMENSION LOADM(*),NUMFRG(*),NQMTFG(*)
      DIMENSION IODFMO(*),LAYFRG(*),SCFFRG(*)
      DIMENSION NGRFMO(MAXPST,*),MANNOD(*),MASTID(*)
      DIMENSION FMODE(3,*)
      DIMENSION IPTLG(*),ZVLAG(*),IPTZC(*),ZVEC0(*)
      DIMENSION CPWT1(*),CPWK1(*),CPWK2(*),CPWK3(*)
C
      COMMON /EFPFM2/ TOTEFPC,POLTOT,LABFLDT,LDINDF2,LDINDDF2,LDELABFLD,
     *                LDELDIND,LDELDINDD,LALCNT2F
      COMMON /EFFMOP/ LEFLDFMO,LEFADDFMO,LDINDFMO,LDINDDFMO,
     *                LDEFEF,LDEFTF,LTORQF
      COMMON /EFPGES/ DESFRG(6,MXFRG)
      COMMON /EFPOTD/ METHOF,ISCCHG,MOVE,nfrag
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /FMCOM / X(1)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas,itmfmo(2)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
      COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
C
      DATA RMC/8HMCSCF   /
CZ
CZ    THIS ROUTINE CALCULATES THE CONTRIBUTION OF INDUCED DIPOLE DERIVATIVE
CZ    TERM (ELECTRONIC PART ONLY) TO THE GRADIENT IN NEW FMO/EFP METHOD.
CZ
CZ    ISTEP=0
CZ    IAND(MODGRD,32).EQ.0: DERIVATIVE INTEGRALS 
CZ    IAND(MODGRD,32).NE.0: LAGRANGIAN 
CZ
CZ    ISTEP=1 (ALWAYS WITH IAND(MODGRD,32).NE.0)
CZ    DERIVATIVE INTEGRALS+RESPONSE TERM  
CZ
CZCZ  IF (IEFP.EQ.0) RETURN
C
      NGREAT  = MAX(NMTTPT,NPTTPT,4*NRTTPT)
      NTOTPT  = NMTTPT+NPTTPT+NRTTPT
      L4      = 300*NGREAT
      NPTTPT3 = NPTTPT*3
      DOSCZV  = IAND(MODGRD, 32).NE.0
      DODISTR = IAND(MODPAR,512+1024).NE.0
      LCNTCAL = (ISTEP.EQ.0.AND..NOT.DOSCZV).OR.(ISTEP.EQ.1.AND.DOSCZV)
CZ    IF (MASWRK) WRITE(6,*) 'LCNTCAL', ISTEP,LCNTCAL

CZ
CZ    WORLD SCOPE
CZ
      IF (ISGDDI) THEN
        CALL GDDI_SCOPE(DDI_WORLD)
        CALL EFPPARL
      END IF
C
      IF (IEFP.EQ.1) THEN
        IF (ISTEP.EQ.0) THEN
          IF (GOPARR) CALL DDI_GSUMF(3003,X(LDELABFLD),NPTTPT3)
CZ        IF (MASWRK) THEN
CZ          WRITE(6,*) 'DELTA ABFIELD'
CZ          DO I = 1, NPTTPT
CZ            LXX = LDELABFLD + (I-1)*3
CZ            WRITE(6,'(3F12.8)') X(LXX),X(LXX+1),X(LXX+2) 
CZ          END DO
CZ        END IF
          CALL VCLR(X(LDELDIND), 1,NPTTPT3)
          CALL VCLR(X(LDELDINDD),1,NPTTPT3)
          CALL DINDPROD(X(LDELABFLD),X(LDELDIND),X(LDELDINDD))
          LDINDTMP  = LDELDIND
          LDINDDTMP = LDELDINDD
        ELSEIF (ISTEP.EQ.1) THEN
          ! AFTER SCZV, LDINDFMO CONTAINS INDUCED DIPOLES 
          ! DUE TO Z-VECTORS
          CALL DAXPY(NPTTPT3,ONE,X(LDELDIND) ,1,X(LDINDFMO), 1)
          CALL DAXPY(NPTTPT3,ONE,X(LDELDINDD),1,X(LDINDDFMO),1)
          LDINDTMP  = LDINDFMO
          LDINDDTMP = LDINDDFMO
        END IF
      END IF
C
      IF (IEFP.EQ.1.AND.LCNTCAL.AND.MOVE.NE.0) THEN
        CALL VCLR(DESFRG,1,NFRG*6)
        IFMO = 1
        IF (IEFC.EQ.1) CALL DCHIND(X(LDINDTMP),X(LDINDDTMP),DESFRG,IFMO)
        IF (IEFD.EQ.1) CALL DDPIND(X(LDINDTMP),X(LDINDDTMP),DESFRG,IFMO)
        IF (IEFQ.EQ.1) THEN
          CALL VALFM(LOADFM)
          LQUA = LOADFM   + 1
          LAST = LQUA + 6*NMTTPT
          NEED = LAST - LOADFM - 1
          CALL GETFM(NEED)
          CALL DQDIND(X(LQUA),X(LDINDTMP),X(LDINDDTMP),DESFRG,IFMO)
          CALL RETFM(NEED)
        END IF
        ! LDINDF2, LDINDDF2 ARE INCUDED DIPOLES DUE TO 
        ! MONOMER DENSITIES + NUCLEI + EFPS
        CALL DININ(X(LDINDF2),X(LDINDDTMP),DESFRG,IFMO)
        CALL DININ(X(LDINDTMP),X(LDINDDF2),DESFRG,IFMO)
C
        NFRG_3 = NFRG*3
        CALL VCLR(DEFT,1,NFRG_3)
        CALL VCLR(TORQ,1,NFRG_3)
        IF(GOPARR) CALL DDI_GSUMF(778,DESFRG,6*NFRG)
        IF (MASWRK) THEN
          CALL DESFRGMV(NFRG,DESFRG,DEFT,TORQ)
          DO I = 1, NBODY - 1
            CALL DAXPY(NFRG_3,ONE,DEFT,1,X(LDEFTF+NFRG_3*I),1)
            CALL DAXPY(NFRG_3,ONE,TORQ,1,X(LTORQF+NFRG_3*I),1)
          END DO
        END IF
        CALL DEFPCLR
        CALL VCLR(DEF,  1,MXFGPT*3)
        CALL VCLR(ATORQ,1,NFRG_3)
      END IF

      IF (IEFP.EQ.1.AND.LCNTCAL) THEN
        CALL DCOPY(NPTTPT3,X(LDINDTMP) ,1,DIND, 1)
        CALL DCOPY(NPTTPT3,X(LDINDDTMP),1,DINDD,1)
      END IF
CZ
CZ    SWITCH TO GROUP
CZ
      IF (ISGDDI) THEN
        CALL GDDI_SCOPE(DDI_GROUP)
        CALL EFPPARL
      END IF
      IF (ISGDDI.AND.NGRFMO(1,ILAY).NE.0)
     *  CALL FMOPRE(ILAY,1,NGRFMO,MANNOD,MASTID,1)
C
      JCURFG  = 0
      KCURFG  = 0
      ICURLAY = ILAY
      IF (ISGDDI) CALL GDDICOUNT(-1,LGROUP,MYJOB)
      DO 230 IIFG = 1,NFG
        IFG = IIFG
        IF (LOADHF.EQ.1) IFG = LOADM(IIFG)
C
        IF (LAYFRG(IFG).LT.ILAY) GOTO 230
        ICURFG = IFG
        IF (ISGDDI) THEN
          CALL GDDICOUNT(0,LGROUP,MYJOB)
          IF (.NOT.MYJOB) GOTO 230
        END IF
C
        CALL CLOSDA('DELETE')
        CALL OPENDA(0)
        CALL MAKEMOL(IFG,0,0,ILAY,0,0,0,0,0,0,0,.TRUE.)
        L1 = NUM
        L2 = (L1*L1+L1)/2
        L3 =  L1*L1
        IDMREC0I = IFG + IREC0
C
        IF (DOSCZV) THEN
          NQI    = IAND(NQMTFG(IFG),65535)
          NAI    = ISHFT(NUMFRG(IFG),-16)
          NOCI   = NAI
          NVRI   = NQI - NOCI
          NOCVRI = NOCI*NVRI
C
          ! MO COEF. AND ORBITAL ENERGIES
          CALL RAREADS(IDAFMO,IODFMO,DA(L2+1),L3+L1,IDMREC0I,0)
          CALL DMTX2(DA,DA(L2+1),NAI,L1,L1,NAI)
        ELSE
          CALL READMOND(DA,ORBXCH,SCFFRG(IFG).EQ.RMC,NA,NB,L1,
     *                  IODFMO,IDMREC0I,.false.)
        END IF
C
CZCZ    IF (MASWRK) WRITE(6,*) 'DENSITY FOR ',IFG
CZCZ    CALL PRTRI(DA,L1)
CZ
CZ      COMPUTATION OF SUM_IJ{DELTA P_IJ} * DE_IFG/DA
CZ
        CALL VALFM(LOADFM)
        LPEX  = LOADFM + 1
        LPEY  = LPEX   + L2
        LPEZ  = LPEY   + L2
        LCSD  = LPEZ   + L2
        LWRK1 = LCSD   + L2
        LWRK2 = LWRK1  + L3
        LCH   = LWRK2  + L1
        LEF3  = LCH    + L4
        LAST  = LEF3   + NTOTPT*3
        NDEFP = LAST - LOADFM -1
        CALL GETFM(NDEFP)

        IF (LCNTCAL) THEN
          CALL VCLR(DE,1,NAT*3)
          CALL VCLR(X(LEF3),1,NTOTPT*3)
          IF (IEFP.EQ.1) THEN
            CALL DCOPY(NPTTPT3,X(LDINDTMP) ,1,DIND, 1)
            CALL DCOPY(NPTTPT3,X(LDINDDTMP),1,DINDD,1)
            ! NOTE THAT DNUCP IS NOT PARALELLIZED AND ATORQ IS IMBEDDED
            CALL DNUCP(DE,X(LEF3))
            CALL DAXPY(NTOTPT*3,ONE,X(LEF3),1,DEF,1)
          END IF
CZ
CZ        GET Z-VECTOR FOR FRAGMENT IFG
CZ
          IF (ISTEP.EQ.1) THEN
            IF (DODISTR) THEN
              CALL ZVECPUTGET(1,0,IFG,NOCVRI,X(LIPTZVEC),CPWK1)
            ELSE
              CALL DCOPY(NOCVRI,ZVEC0(IPTZC(IFG)),1,CPWK1,1)
            END IF 
            CALL SWBASIS(0,L1,NOCI,NVRI,DA(L2+1),CPWK1,NVRI,
     *                   CPWK2,L1,CPWK3)
            CALL SQ2TRI(L1,L1,CPWK2,CPWT1,HALF)
C
          END IF 
CZ        IF (MASWRK) THEN
CZ          WRITE(6,*) 'TESTTEST', NPROC, IFG
CZ          DO II1 = 1, NAT
CZ            WRITE(6,'(3F12.8)') DE(1,II1),DE(2,II1),DE(3,II1)
CZ          END DO
CZ        END IF
          IF (GOPARR) CALL DSCAL(NAT*3,ONE/NPROC,DE,1)
          IF (IEFP.EQ.1) THEN
            CALL EFPDER(DA)
            ! CONTRIBUTIONS DUE TO PURE Z-VECTOR
            IF (MOVE.NE.0) THEN
              IF (GOPARR) CALL DSCAL(NTOTPT*3,ONE/NPROC,DEF,1)
              IF (GOPARR) CALL DSCAL(NFRG_3,ONE/NPROC,ATORQ,1)
              ! DEF
              CALL EFPDEF(DA,X(LCH),L4)
              ! ATORQ
              CALL EFTORP(DA,X(LCH),L4)
              IF (GOPARR) CALL DDI_GSUMF(2418,DEF,NTOTPT*3)
              IF (GOPARR) CALL DDI_GSUMF(2418,ATORQ,NFRG_3)
            END IF
          END IF
          IF (ISTEP.EQ.1) THEN
            CALL DCOPY(NPTTPT3,X(LDINDF2) ,1,DIND, 1)
            CALL DCOPY(NPTTPT3,X(LDINDDF2),1,DINDD,1)
            CALL FRGDER(CPWT1,L2)
          END IF
        END IF
C
        IF (IEFP.EQ.1) THEN
          DUM = 0.0D+00
          CALL VCLR(X(LCSD),1,L2)
          CALL DRCTPOL(1,NPTTPT,L1,L2,.TRUE.,.FALSE.,X(LCSD),DUM,DA,
     *                 HALF,X(LDINDTMP),X(LDINDDTMP),X(LPEX),X(LPEY),
     *                 X(LPEZ))
          IF (GOPARR) CALL DDI_GSUMF(3003,X(LCSD),L2)
CZ
CZ        GET LAGRANGIAN CONTRIBUTION FOR Z-VECTOR CALCULATION
CZ
          IF (ISTEP.EQ.0.AND.DOSCZV) THEN
            CALL CPYTSQ(X(LCSD),X(LWRK1),L1,1)
            ! LPEX IS USED AS A WORK SPACE
            CALL SWBASIS(1,L1,NOCI,NVRI,DA(L2+1),X(LWRK1),L1,X(LZVWRK),
     *                   NVRI,X(LPEX))
            CALL ZVLGMULT(NOCVRI,1,IFG,IPTLG,DODISTR,ZVLAG,X(LZVWRK),
     *                    X(LPEX))
          END IF
CZ
          IF (LCNTCAL) THEN
            CALL CPYTSQ(DA,DA(L2+1),L1,1)
            CALL TFTRI(X(LWRK1),X(LCSD),DA(L2+1),X(LWRK2),L1,L1,L1)
            CALL DSCAL(L2,-HALF,X(LWRK1),1)
            CALL SDER(X(LWRK1),X(LWRK2),L1,L2,.FALSE.)
            IF (GOPARR) CALL DDI_GSUMF(2418,DE,NAT*3)
            IF (MASWRK) CALL FMODEG(1,FMODE,X(LFMOPG),X(LIAGLOB))
          END IF
        END IF

        CALL RETFM(NDEFP)
  230 CONTINUE
      IF (ISGDDI) CALL GDDICOUNT( 1,LGROUP,MYJOB)

      IF (LCNTCAL.AND.MOVE.NE.0) THEN
        CALL EFFT
        IF (MASWRK) THEN
          DO I = 1, NBODY - 1
            CALL DAXPY(NFRG_3,ONE,DEFT,1,X(LDEFTF+NFRG_3*I),1)
            CALL DAXPY(NFRG_3,ONE,TORQ,1,X(LTORQF+NFRG_3*I),1)
          END DO
        END IF
      END IF
C
      RETURN
      END
C*MODULE MLTFMO  *DECK DRCTPOLWRP 
      SUBROUTINE DRCTPOLWRP(L1,L2,POT,PEX,PEY,PEZ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (HALF=0.5D+00)

      LOGICAL GOPARR,MASWRK,DSKWRK
C
      DIMENSION POT(*), PEX(*), PEY(*), PEZ(*)
      COMMON /EFPFM2/ TOTEFPC,POLTOT,LABFLDT,LDINDF2,LDINDDF2,LDELABFLD,
     *                LDELDIND,LDELDINDD,LALCNT2F
      COMMON /FMCOM / X(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      CALL VCLR(POT,1,L2)
      DUM = 0.0D+00
      CALL DRCTPOL(1,NPTTPT,L1,L2,.TRUE.,.FALSE.,POT,DUM,DUM,
     *             HALF,X(LDINDF2),X(LDINDDF2),PEX,PEY,PEZ)
      IF (GOPARR) CALL DDI_GSUMF(921,POT,L2)
CZ    CALL PRTRI(POT,L1)

      ! USE PEX AS A WORK SPACE
      CALL DAREAD(IDAF,IODA,PEX,L2,11,0)
      CALL VADD(PEX,1,POT,1,PEX,1,L2)
      CALL DAWRIT(IDAF,IODA,PEX,L2,11,0)
C     
      CALL DAREAD(IDAF,IODA,PEX,L2,89,0)
      CALL VADD(PEX,1,POT,1,PEX,1,L2)
      CALL DAWRIT(IDAF,IODA,PEX,L2,89,0)

      RETURN
      END
C*MODULE MLTFMO  *DECK DRCTPOL 
      SUBROUTINE DRCTPOL(NPT0,NPT1,L1,L2,LPOT,LFLD,POT,ABFLD,
     *                   DA,CNST,DINDF,DINDDF,PEX,PEY,PEZ)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      CHARACTER*8 POLNAM,DPOLNAM
C
      LOGICAL IANDJ,NORM,DOUBLE,OUT
      LOGICAL GOPARR,MASWRK,DSKWRK
      LOGICAL LPOT, LFLD
C
      PARAMETER (MXATM=2000, MXSH=5000, MXGTOT=20000,
     *           MXFRG=1050, MXFGPT=12000, MXIFRQ=12,
     *           MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
C
      DIMENSION PEX(*),PEY(*),PEZ(*)
      DIMENSION DINDF(3,*), DINDDF(3,*), POT(*), ABFLD(3,*), DA(*)
C
      DIMENSION XIN(128),YIN(128),ZIN(128),
     1          PLX(100),PLY(100),PLZ(100)
      DIMENSION DIJ(100),FIJ(100)
      DIMENSION IX(20),IY(20),IZ(20),JX(20),JY(20),JZ(20)
      DIMENSION IJX(100),IJY(100),IJZ(100)
C
      COMMON /CSSTV / CX,CY,CZ
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     1                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     2                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /STV   / XINT,YINT,ZINT,T,X0,Y0,Z0,XI,YI,ZI,XJ,YJ,ZJ,NI,NJ
C
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     1          3, 0, 0, 2, 2, 1, 0, 1, 0, 1/
      DATA IX / 1, 5, 1, 1, 9, 1, 1, 5, 5, 1,
     1         13, 1, 1, 9, 9, 5, 1, 5, 1, 5/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     1          0, 3, 0, 1, 0, 2, 2, 0, 1, 1/
      DATA IY / 1, 1, 5, 1, 1, 9, 1, 5, 1, 5,
     1          1,13, 1, 5, 1, 9, 9, 1, 5, 5/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     1          0, 0, 3, 0, 1, 0, 1, 2, 2, 1/
      DATA IZ / 1, 1, 1, 5, 1, 1, 9, 1, 5, 5,
     1          1, 1,13, 1, 5, 1, 5, 9, 9, 5/
C
      DATA ZERO,ONE/0.0D+00,1.0D+00/
      DATA PI212 /1.1283791670955D+00/
      DATA SQRT3 /1.73205080756888D+00/
      DATA SQRT5 /2.23606797749979D+00/
      DATA RLN10 /2.30258D+00/
      DATA DBUGME  /8HINT1    /
C
C------- THIS VERSION HAS THE METHOD=1 STUFF OF HONDO CUT OUT.
C
      OUT = NPRINT.EQ.3 .OR. EXETYP.EQ.DBUGME
C
C     ----- INTIALIZE PARALLEL -----
C
      IPCOUNT = ME - 1
C
CZ    NEFP = NPTTPT
      TOL=RLN10*ITOL
      NORM=NORMF.NE.1.OR.NORMP.NE.1
C
C        THE ELECTRIC FIELD INTEGRAL IS TO BE A DISTRIBUTED FILE
C
CZCZ  DSKSAV = DSKWRK
CZCZ  DSKWRK = .TRUE.
CZCZ  NFT25 = 25
CZCZ  CALL SEQREW(NFT25)
C
CZCZ  DO 9200 IC=1,NEFP
      DO 9200 IC=NPT0,NPT1
C
C     ----- GO PARALLEL! -----
C
       IF (GOPARR.AND.NPT0.NE.NPT1) THEN
        IPCOUNT = IPCOUNT + 1
        IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 9199
       END IF
C
      DO 41 I=1,L2
      PEX(I) = ZERO
      PEY(I) = ZERO
      PEZ(I) = ZERO
  41  CONTINUE
C     IF(MASWRK) WRITE(6,*)'FOR POLARIZABLE POINT ',IC
      CX=EFP(1,IC)
      CY=EFP(2,IC)
      CZ=EFP(3,IC)
C
C     ----- ISHELL
C
      DO 9000 II=1,NSHELL
      I=KATOM(II)
      XI=C(1,I)
      YI=C(2,I)
      ZI=C(3,I)
      I1=KSTART(II)
      I2=I1+KNG(II)-1
      LIT=KTYPE(II)
      MINI=KMIN(II)
      MAXI=KMAX(II)
      LOCI=KLOC(II)-MINI
C
C     ----- JSHELL
C
      DO 8000 JJ=1,II
C
C     ----- GO PARALLEL! -----
C
C            IF (GOPARR) THEN
C               IPCOUNT = IPCOUNT + 1
C               IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 8000
C            END IF
      J=KATOM(JJ)
      XJ=C(1,J)
      YJ=C(2,J)
      ZJ=C(3,J)
      J1=KSTART(JJ)
      J2=J1+KNG(JJ)-1
      LJT=KTYPE(JJ)
      MINJ=KMIN(JJ)
      MAXJ=KMAX(JJ)
      LOCJ=KLOC(JJ)-MINJ
      NROOTS=(LIT+LJT+1-2)/2 + 1
      RR=(XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2
      IANDJ=II.EQ.JJ
C
C     ----- PREPARE INDICES FOR PAIRS OF (I,J) FUNCTIONS
C
      IJ=0
      MAX=MAXJ
      DO 50 I=MINI,MAXI
      NX=IX(I)
      NY=IY(I)
      NZ=IZ(I)
      IF(IANDJ) MAX=I
      DO 50 J=MINJ,MAX
      IJ=IJ+1
      IJX(IJ)=NX+JX(J)
      IJY(IJ)=NY+JY(J)
      IJZ(IJ)=NZ+JZ(J)
   50 CONTINUE
      DO 60 I=1,IJ
      PLX(I) = ZERO
      PLY(I) = ZERO
  60  PLZ(I) = ZERO
C
C     ----- I PRIMITIVE
C
      JGMAX=J2
      DO 7000 IG=I1,I2
      AI=EX(IG)
      ARRI=AI*RR
      AXI=AI*XI
      AYI=AI*YI
      AZI=AI*ZI
      CSI=CS(IG)
      CPI=CP(IG)
      CDI=CD(IG)
      CFI=CF(IG)
C
C     ----- J PRIMITIVE
C
      IF(IANDJ) JGMAX=IG
      DO 6000 JG=J1,JGMAX
      AJ=EX(JG)
      AA=AI+AJ
      AA1=ONE/AA
      DUM=AJ*ARRI*AA1
      IF(DUM.GT.TOL) GO TO 6000
      FAC=EXP(-DUM)
      CSJ=CS(JG)
      CPJ=CP(JG)
      CDJ=CD(JG)
      CFJ=CF(JG)
      AX=(AXI+AJ*XJ)*AA1
      AY=(AYI+AJ*YJ)*AA1
      AZ=(AZI+AJ*ZJ)*AA1
C
C     ----- DENSITY FACTOR
C
      DOUBLE=IANDJ.AND.IG.NE.JG
      MAX=MAXJ
      NN=0
      DO 310 I=MINI,MAXI
      GO TO ( 70, 80,180,180, 90,180,180,100,180,180,
     1       110,180,180,120,180,180,180,180,180,130),I
   70 DUM1=CSI*FAC
      GO TO 180
   80 DUM1=CPI*FAC
      GO TO 180
   90 DUM1=CDI*FAC
      GO TO 180
  100 IF(NORM) DUM1=DUM1*SQRT3
      GO TO 180
  110 DUM1=CFI*FAC
      GO TO 180
  120 IF(NORM) DUM1=DUM1*SQRT5
      GO TO 180
  130 IF(NORM) DUM1=DUM1*SQRT3
  180 IF(IANDJ) MAX=I
      DO 310 J=MINJ,MAX
      GO TO (190,200,300,300,210,300,300,220,300,300,
     1       230,300,300,240,300,300,300,300,300,250),J
  190 DUM2=DUM1*CSJ
      IF(.NOT.DOUBLE) GO TO 300
      IF(I.GT.1) GO TO 195
      DUM2=DUM2+DUM2
      GO TO 300
  195 DUM2=DUM2+CSI*CPJ*FAC
      GO TO 300
  200 DUM2=DUM1*CPJ
      IF(DOUBLE) DUM2=DUM2+DUM2
      GO TO 300
  210 DUM2=DUM1*CDJ
      IF(DOUBLE) DUM2=DUM2+DUM2
      GO TO 300
  220 IF(NORM) DUM2=DUM2*SQRT3
      GO TO 300
  230 DUM2=DUM1*CFJ
      IF(DOUBLE) DUM2=DUM2+DUM2
      GO TO 300
  240 IF(NORM) DUM2=DUM2*SQRT5
      GO TO 300
  250 IF(NORM) DUM2=DUM2*SQRT3
  300 NN=NN+1
  310 DIJ(NN)=DUM2
C
      AAX=AA*AX
      AAY=AA*AY
      AAZ=AA*AZ
      DUM=PI212*AA1
      DUM=DUM+DUM
      DO 800 I=1,IJ
  800 FIJ(I)=DIJ(I)*DUM
C
      XX=AA*((AX-CX)**2+(AY-CY)**2+(AZ-CZ)**2)
      IF(NROOTS.LE.3) CALL RT123
      IF(NROOTS.EQ.4) CALL ROOT4
      MM=0
      DO 830 K=1,NROOTS
      UU=AA*U(K)
      WW=W(K)
      WW=WW*UU
      TT=ONE/(AA+UU)
      T=SQRT(TT)
      X0=(AAX+UU*CX)*TT
      Y0=(AAY+UU*CY)*TT
      Z0=(AAZ+UU*CZ)*TT
      IN=-4+MM
      DO 820 I=1,LIT
      IN=IN+4
      NI=I
      DO 820 J=1,LJT
      JN=IN+J
      NJ=J
      CALL STVINT
      XIN(JN)=XINT
      YIN(JN)=YINT
      ZIN(JN)=ZINT*WW
      CALL POLXYZ
      XIN(JN+64)=XINT
      YIN(JN+64)=YINT
      ZIN(JN+64)=ZINT*WW
  820 CONTINUE
  830 MM=MM+16
      DO 850 I=1,IJ
      NX=IJX(I)
      NY=IJY(I)
      NZ=IJZ(I)
      DUMX=ZERO
      DUMY=ZERO
      DUMZ=ZERO
      MM=0
      DO 840 K=1,NROOTS
      DUMX=DUMX+XIN(NX+MM+64)*YIN(NY+MM   )*ZIN(NZ+MM   )
      DUMY=DUMY+XIN(NX+MM   )*YIN(NY+MM+64)*ZIN(NZ+MM   )
      DUMZ=DUMZ+XIN(NX+MM   )*YIN(NY+MM   )*ZIN(NZ+MM+64)
  840 MM=MM+16
      DUM=FIJ(I)
      PLX(I) = PLX(I) + DUM*DUMX
      PLY(I) = PLY(I) + DUM*DUMY
      PLZ(I) = PLZ(I) + DUM*DUMZ
  850 CONTINUE
C
 6000 CONTINUE
 7000 CONTINUE
C
C
      MAX=MAXJ
      NN=0
      DO 7500 I=MINI,MAXI
      LI=LOCI+I
      IN = (LI*(LI-1))/2
      IF(IANDJ) MAX=I
      DO 7500 J=MINJ,MAX
      LJ=LOCJ+J
      JN=LJ+IN
      NN=NN+1
      PEX(JN)=PLX(NN)
      PEY(JN)=PLY(NN)
      PEZ(JN)=PLZ(NN)
 7500 CONTINUE
C     ----- END PARALLEL
 8000 CONTINUE
 9000 CONTINUE
C
C  COLLECT MATRICES ON DISK FOR TWO ELECTRON OPERATOR CONSTRUCTION
C
C      IF (GOPARR) CALL DDI_GSUMF(924,PEX,NUM2)
C      IF (GOPARR) CALL DDI_GSUMF(925,PEY,NUM2)
C      IF (GOPARR) CALL DDI_GSUMF(926,PEZ,NUM2)
CZ
CZ     CONTRIBUTION TO FOCK
CZ
       IF (LPOT) THEN
         TOTMUX = DINDF(1,IC) + DINDDF(1,IC)
         TOTMUY = DINDF(2,IC) + DINDDF(2,IC)
         TOTMUZ = DINDF(3,IC) + DINDDF(3,IC)
         DO IUM = 1, L2 
           POT(IUM) = POT(IUM) 
     *               -CNST*( TOTMUX*PEX(IUM)
     *                      +TOTMUY*PEY(IUM)
     *                      +TOTMUZ*PEZ(IUM))
         END DO
       END IF
CZ
CZ     AB INITIO FIELD
CZ
       IF (LFLD) THEN
         ABFLD(1,IC) = ABFLD(1,IC) + TRACEP(DA,PEX,L1)
         ABFLD(2,IC) = ABFLD(2,IC) + TRACEP(DA,PEY,L1)
         ABFLD(3,IC) = ABFLD(3,IC) + TRACEP(DA,PEZ,L1)
       END IF
CZCZ
C
C
      IF(OUT) THEN
        IF (MASWRK) WRITE(IW,9500)
        CALL PRTRIL(PEX,L1)
        CALL PRTRIL(PEY,L1)
        CALL PRTRIL(PEZ,L1)
      END IF
C
 9199 CONTINUE
 9200 CONTINUE
C
      IF (NPT0.EQ.NPT1) RETURN
CZCZ  DSKWRK = DSKSAV
CZCZ  IF (GOPARR) CALL DDI_GSUMF(926,POT,L2)
      IF (LFLD.AND.GOPARR) CALL DDI_GSUMF(927,ABFLD,NPTTPT*3)
CZCZ
C
      RETURN
 9500 FORMAT(/1X,'X, Y, AND Z COMPONENTS OF THE INDUCED DIPOLE',
     *       ' ONE ELECTRON INTEGRALS')
      END
C*MODULE MLTFMO  *DECK DINDPROD 
      SUBROUTINE DINDPROD(FLDIN,DINDOUT,DINDDOUT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXDFG=5, MXFGPT=12000,
     *           MXIFRQ=12,MXDPPT=MXFRG*MXDFG*12)
C
      CHARACTER*8 POLNAM,DPOLNAM
C
      DIMENSION FLDIN(3,*), DINDOUT(3,*), DINDDOUT(3,*) 
C
      COMMON /EFPPAR/ EFP(3,MXFGPT),EFPOL(9,MXFGPT),
     *                EFDP(3,MXIFRQ*MXFGPT),EFDPOL(9,MXIFRQ*MXFGPT),
     *                ENO,DIND(3,MXFGPT),DINDD(3,MXFGPT),
     *                POLNAM(MXFGPT),DPOLNAM(MXIFRQ*MXFGPT),
     *                POLSCR(MXFGPT),IPLSCR,INDSCR
      COMMON /FMCOM / XX(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
CZCZ
CZ
CZ    THIS ROUTINE PRODUCES THE INDUCED DIPOLES (DINDOUT AND DINDDOUT) 
CZ    DUE TO FLDIN 
CZ
CZCZ
C
      NPTTPT3 = NPTTPT*3
C
      CALL DCOPY(NPTTPT3,DINDOUT ,1,DIND, 1)
      CALL DCOPY(NPTTPT3,DINDDOUT,1,DINDD,1)
C
C     ALWAYS CALL TO DIPIT !
C
      CALL VALFM(LOADFM)
      LEFADD   = LOADFM   + 1
      LDIPNEW  = LEFADD   + NPTTPT3 
      LDIPNWD  = LDIPNEW  + NFRG
      LDINDC   = LDIPNWD  + NFRG
      LDINDDC  = LDINDC   + NPTTPT3
      LDIND_W  = LDINDDC  + NPTTPT3
      LDIND_C  = LDIND_W  + 2*NPTTPT3
      LEWLD1   = LDIND_C  + 2*NPTTPT3
      LEWLD2   = LEWLD1   + NPTTPT3
      LAST     = LEWLD2   + NPTTPT3
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      CALL DIPIT(FLDIN,XX(LEFADD),XX(LDINDC),XX(LDINDDC),
     *           XX(LDIND_W),XX(LDIND_C),
     *           NPTTPT,XX(LDIPNEW),XX(LDIPNWD),
     *           XX(LEWLD1),XX(LEWLD2),NFRG)
      CALL RETFM(NEED)
      CALL DCOPY(NPTTPT3,DIND ,1,DINDOUT, 1)
      CALL DCOPY(NPTTPT3,DINDD,1,DINDDOUT,1)
C
      RETURN
      END
C*MODULE MLTFMO  *DECK EFPCNT2ORBH
      SUBROUTINE EFPCNT2ORBH(L1,L2,CNT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXFRG=1050, MXDFG=5, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (PT5=0.5D+00)
C
      LOGICAL GOPARR,MASWRK,DSKWRK
C
      DIMENSION CNT(*)
C
cz    COMMON /EFPFMO/ RUNEFP,REFFMO,REPNUCEFP,IEFPFMO,ISWENUC,EFPEFP
      COMMON /EFFMOP/ LEFLDFMO,LEFADDFMO,LDINDFMO,LDINDDFMO,
     *                LDEFEF,LDEFTF,LTORQF
      COMMON /FMCOM / X(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
CZ
CZ    CONTRIBUTION TO THE ORBITAL HESSIAN IN NEW FMO/EFP
CZ
      CALL VCLR(CNT,1,L2)
      CALL VALFM(LOADFM)
      LPEX = LOADFM + 1
      LPEY = LPEX   + L2
      LPEZ = LPEY   + L2
      LAST = LPEZ   + L2
      NDEFP = LAST - LOADFM -1
      CALL GETFM(NDEFP)
      DUM = 0.0D+00
      CALL DRCTPOL(1,NPTTPT,L1,L2,.TRUE.,.FALSE.,CNT,DUM,DUM,PT5,
     *             X(LDINDFMO),X(LDINDDFMO),X(LPEX),X(LPEY),X(LPEZ))
      CALL RETFM(NDEFP)
      IF (GOPARR) CALL DDI_GSUMF(3020,CNT,L2)
      RETURN
      END
C
C*MODULE MLTFMO  *DECK mltfmopcm
C>    @brief   FMO/FDD/PCM gradient
C>
C>    @details Driver for pcm/fdd
C>
C>    @author  hiroya  nakata
C>
C>    @date Feb, 2016- Yoshio Nishimoto
C>    - Added FMO-DFTB/PCM
C>  @parm mode    mode
C>  @parm lfmasc  memory 
C>  @parm needasc standard pcm memory
C>  @parm needmul fdd memory
C>  @parm map     map for pcm
C>  @parm ntspre  ntesserae for B
C>
      subroutine mltfmopcm(mode,lfmasc,needasc,needmul,map,ntspre)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      dimension map(*)
C
      COMMON /FMCOM / X(1)
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmoopt/ espsca(9),RESPAP(2),rESPPC(2),rESDIM,restri(4),
     *                rcorsd,respct,convfg,cnvdmp,coroff,rflmo(4),
     *                orshft,orshft2,cnvafo,ascreen(4),IXESP,mxitfg,
     *                nguess,NBSSE,modorb,modpar,irststp,irstlay,nprfmo,
     *                nfmopal,modprp,maxl1c,ipieda,modgrd,modesp,ivmul,
     *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm,lmaxl30
      COMMON /MLTPNT/ LDELEPOT,LDELQSE,LQSETMP,LFZVEC,LMAPCMFD,LQBL2FD
      COMMON /PCMDIM/ mxsp,mxts,mempcm1,mempcm2,NTS
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,nfmopcm,IHET
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                mPEL,lpcmcdr,LDAI,LIDDAI,LQSND,LQSED,LEPSPCM
C
      PARAMETER (ONE=1.0D+00,HALF=0.5D+00)
C     if nof fdd nothing shoud be done
C     mode =-1: get memory and ini Q for fdd/pcm restart
C     mode = 0: get memory for fdd/pcm
C     mode = 1: Q for frozen charge
C     mode = 2: Q for buffer charge
      if(modfd.eq.0) then
        needmul=0
        return
      end if
C
      if(mode.eq.0.or.mode.eq.-1) then
        needmul=0
        CALL VALFM(loadfm)
        LMAP  = LOADFM + 1 
        LAST  = LMAP   + nts
        NEEDW = LAST   - LOADFM - 1
        CALL GETFM(NEEDW)
C
        CALL mltpcmmap(natfmo,X(lmap),nts,X(LISPHE),x(lindat),
     *                 x(llayfrg),nts2lay)
C
        CALL RETFM(NEEDW)
C
        LMAP    = LOADFM + 1 
        LQBL2   = LMAP   + nts
        LQBL1   = LQBL2  + nts2lay
        LQALL   = LQBL1  + nts2lay
        LAST    = LQALL  + nts
C       get nts for Buffer
        needmul = LAST   - LOADFM - 1
C
        CALL GETFM(needmul)
c       write(6,'("CHK VAL=",2I18)') LOADFM,needmul
c       write(6,'("CHK VAL=",I5)') nts2lay
        LMAPCMFD=LMAP
        LQBL2FD =LQBL2
        if(mode.eq.-1) then
          ntspre=nts2lay
        end if
        return
      end if
C     Restore points
      nts2lay=0
      do its=1,nts
       if(map(its).ne.0) nts2lay=nts2lay+1
      end do
C
      LMAP   = lfmasc + needasc + 1
      LQBL2  = LMAP   + nts
      LQBL1  = LQBL2  + nts2lay
      LQALL  = LQBL1  + nts2lay
C
C
      if(mode.eq.1) then
        call getascFMOFDD(mode,nts2lay,X(LQBL1),X(LMAP),X(LAXYZCT),
     *       x(LAXYZCT+MXTS),x(LAXYZCT+MXTS*2),x(LAXYZCT+MXTS*3),
     *       x(LXYZRE),x(LXYZRE+MXSP),x(LXYZRE+MXSP*2),x(LXYZRE+MXSP*3),
     *       x(LISPHE),x(llayfrg),x(lindat),lfmasc,LLIST)
C
        CALL DCOPY(nts2lay,X(LQBL1),1,X(LQBL2),1)
        call dcopy(NTS,x(LQSE),1,x(LQALL),1)
C
      else if(mode.eq.2) then
        call getascFMOFDD(mode,nts2lay,X(LQBL2),X(LMAP),X(LAXYZCT),
     *       x(LAXYZCT+MXTS),x(LAXYZCT+MXTS*2),x(LAXYZCT+MXTS*3),
     *       x(LXYZRE),x(LXYZRE+MXSP),x(LXYZRE+MXSP*2),x(LXYZRE+MXSP*3),
     *       x(LISPHE),x(llayfrg),x(lindat),lfmasc,LLIST)
C  
c       write(6,'("CHK QALL=",I3,F12.8)') (ITS,X(LQALL-1+ITS),ITS=1,nts)
c       write(6,'("CHK QB=",I3,2F12.8)') 
c    *  (ITS,X(LQBL1-1+ITS),X(LQBL2-1+ITS),ITS=1,nts2lay)
C
        CALL VALFM(loadfm)
        LDELE = LOADFM + 1 
        LAST  = LDELE  + nts2lay
        NEEDW = LAST   - LOADFM - 1
        CALL GETFM(NEEDW)
C
        CALL DCOPY(nts2lay,X(LQBL2),1,X(LDELE),1)
        CALL DAXPY(nts2lay,-ONE,X(LQBL1),1,X(LDELE),1)
C
        IF(IEF.EQ.10) CALL DSCAL(nts2lay,(EPS-ONE)/EPS,X(LDELE),1) 
C
        DO ITS=1,NTS
          IF(map(ITS).ne.0) then
            X(LQSE-1+ITS)=X(LQALL-1+ITS) + X(LDELE-1+MAP(ITS))
          END IF
        END DO
        call dcopy(NTS,x(LQSE),1,x(LQSED),1)
C
c       write(6,'("CHK QSE=",I3,F12.8)') (ITS,X(LQSE-1+ITS),ITS=1,nts)
C
        CALL RETFM(NEEDW)
      else if(mode.eq.3) then
        call getascFMOFDD(mode,nts2lay,X(LDELQSE),X(LMAP),X(LAXYZCT),
     *       x(LAXYZCT+MXTS),x(LAXYZCT+MXTS*2),x(LAXYZCT+MXTS*3),
     *       x(LXYZRE),x(LXYZRE+MXSP),x(LXYZRE+MXSP*2),x(LXYZRE+MXSP*3),
     *       x(LISPHE),x(llayfrg),x(lindat),lfmasc,LLIST)
C       Delta q + 0.5D+00*Q^b
        CALL DAXPY(nts2lay,HALF,X(LQBL2),1,X(LDELQSE),1)
        IF(IEF.EQ.10) CALL DSCAL(nts2lay,(EPS-ONE)/EPS,X(LDELQSE),1) 
C       EXPAND B--> Full system
        CALL VCLR(X(LDELEPOT),1,NTS)
        DO ITS=1,NTS
          IF(map(ITS).ne.0) then
            X(LDELEPOT-1+ITS)= X(LDELQSE-1+MAP(ITS))
          END IF
        END DO
        call dcopy(NTS,x(LDELEPOT),1,x(LDELQSE),1)
C      -0.5D+00*QTOT + Delta q + Q^b =-0.5D+00*QF + Delta Q 
        CALL DAXPY(nts,-HALF,X(LQSE),1,X(LDELQSE),1)
c       write(6,'("CHK=",F12.8)') (X(LDELQSE-1+ITS),ITS=1,NTS)
c       write(6,'("CHK=",F12.8)') (X(LQBL2-1+ITS),ITS=1,nts2lay)
      else if(mode.eq.4.or.mode.eq.5) then
        CALL VALFM(loadfm)
        LDELE = LOADFM + 1 
        LAST  = LDELE  + nts2lay
        NEEDW = LAST   - LOADFM - 1
        CALL GETFM(NEEDW)
C       Get previous chage for initial guess
        if(mode.eq.5) then
         DO ITS=1,NTS
           IF(map(ITS).ne.0) then
            X(LDELE-1+MAP(ITS))= X(LQSETMP-1+ITS)
           END IF
         END DO
        end if
        call getascFMOFDD(mode,nts2lay,X(LDELE),X(LMAP),X(LAXYZCT),
     *       x(LAXYZCT+MXTS),x(LAXYZCT+MXTS*2),x(LAXYZCT+MXTS*3),
     *       x(LXYZRE),x(LXYZRE+MXSP),x(LXYZRE+MXSP*2),x(LXYZRE+MXSP*3),
     *       x(LISPHE),x(llayfrg),x(lindat),lfmasc,LLIST)
C       EXPAND Q^{Z,B} to full system
        IF(IEF.EQ.10) CALL DSCAL(nts2lay,(EPS-ONE)/EPS,X(LDELE),1) 
        CALL VCLR(X(LQSETMP),1,NTS)
        DO ITS=1,NTS
          IF(map(ITS).ne.0) then
            X(LQSETMP-1+ITS)= X(LDELE-1+MAP(ITS))
          END IF
        END DO
        CALL RETFM(NEEDW)
      end if
C
      RETURN
      END
C
C*MODULE MLTFMO  *DECK mltpcmmap
C>    @brief   FMO/FDD/PCM
C>
C>    @details Mapping
C>
C>    @author  hiroya  nakata
C>
C>
C>  @param natfmo  number of atom
C>  @param map     map
C>  @param nts     number of tesserae
C>  @param ISPHE   indice for spher
C>  @param indat   indice for date
C>  @param layfrg  layer
C>  @param nts2lay nuesseare for B
C>
      subroutine mltpcmmap(natfmo,map,nts,ISPHE,indat,layfrg,nts2lay)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION map(*),ISPHE(*),indat(*),layfrg(*)
C
      if(natfmo.eq.0) write(6,*) "wwwdummy"
C
      nts2lay=0
      do its=1,nts
        iat  = ISPHE(its)
        ifg  = indat(iat)
        ilay = layfrg(ifg)
c       write(6,'("chk=",3I4)') iat,ifg,ilay
        if(ilay.eq.2) then
          nts2lay  = nts2lay + 1
          map(its) = nts2lay
        else
          map(its) = 0
        end if
      end do
C
c     write(6,'("wwwchk=",2I4)') (its,map(its),its=1,nts)
C
      RETURN
      END
C
C*MODULE MLTFMO  *DECK EPOTEN3
C>    @brief   FMO/FDD/PCM
C>
C>    @details PCM electron Potential
C>
C>    @author  hiroya  nakata
C>
C>
C>  @param natfmo  number of atom
C>  @param map     map
C>  @param nts     number of tesserae
C>  @param ISPHE   indice for spher
C>  @param indat   indice for date
C>  @param layfrg  layer
C>  @param nts2lay nuesseare for B
C>
      SUBROUTINE EPOTEN3(ACONST,XCOORD,YCOORD,ZCOORD,VALUE,DA,
     *           NP,L2,mappcm)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL IANDJ,NORM,DOUBLE,GOPARR,DSKWRK,MASWRK,NXT
C
      DIMENSION XCOORD(NP),YCOORD(NP),ZCOORD(NP),VALUE(NP),DA(L2)
      DIMENSION IX(35),IY(35),IZ(35),JX(35),JY(35),JZ(35),
     *          XIN(125),YIN(125),ZIN(125),
     *          DIJ(225),IJX(225),IJY(225),IJZ(225),
     *          HP(28),WP(28),MINP(7),MAXP(7),mappcm(*)
C
      PARAMETER (MXSH=5000, MXGTOT=20000, MXATM=2000)
C
      COMMON /HERMIT/ H1,H2(2),H3(3),H4(4),H5(5),H6(6),H7(7),
     *                H8(8),H9(9),H10(10),
     *                H11(11),H12(12),H13(13),H14(14),H15(15)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEFPCM,IP_F,NFMOPCM,IHET
      COMMON /PCMITR/ RCUT(2),THRES,IPCMIT,IMUL,MXDIIS,NREG,MXITR1,
     *                MXITR2,MODPAP
      COMMON /ROOT  / XX,U(13),W(13),NROOTS
      COMMON /WERMIT/ W1,W2(2),W3(3),W4(4),W5(5),W6(6),W7(7),
     *                W8(8),W9(9),W10(10),
     *                W11(11),W12(12),W13(13),W14(14),W15(15)
C
      EQUIVALENCE (HP(1),H1),(WP(1),W1)
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0D+00)
      PARAMETER (PI212=1.1283791670955D+00)
      PARAMETER (SQRT3=1.73205080756888D+00)
      PARAMETER (SQRT5=2.23606797749979D+00)
      PARAMETER (SQRT7=2.64575131106459D+00)
      PARAMETER (RLN10=2.30258D+00)
      DATA MINP /1,2,4,7,11,16,22/
      DATA MAXP /1,3,6,10,15,21,28/
      DATA JX / 0, 1, 0, 0, 2, 0, 0, 1, 1, 0,
     *          3, 0, 0, 2, 2, 1, 0, 1, 0, 1,
     *          4, 0, 0, 3, 3, 1, 0, 1, 0, 2,
     *          2, 0, 2, 1, 1/
      DATA IX / 1, 6, 1, 1,11, 1, 1, 6, 6, 1,
     *         16, 1, 1,11,11, 6, 1, 6, 1, 6,
     *         21, 1, 1,16,16, 6, 1, 6, 1,11,
     *         11, 1,11, 6, 6/
      DATA JY / 0, 0, 1, 0, 0, 2, 0, 1, 0, 1,
     *          0, 3, 0, 1, 0, 2, 2, 0, 1, 1,
     *          0, 4, 0, 1, 0, 3, 3, 0, 1, 2,
     *          0, 2, 1, 2, 1/
      DATA IY / 1, 1, 6, 1, 1,11, 1, 6, 1, 6,
     *          1,16, 1, 6, 1,11,11, 1, 6, 6,
     *          1,21, 1, 6, 1,16,16, 1, 6,11,
     *          1,11, 6,11, 6/
      DATA JZ / 0, 0, 0, 1, 0, 0, 2, 0, 1, 1,
     *          0, 0, 3, 0, 1, 0, 1, 2, 2, 1,
     *          0, 0, 4, 0, 1, 0, 1, 3, 3, 0,
     *          2, 2, 1, 1, 2/
      DATA IZ / 1, 1, 1, 6, 1, 1,11, 1, 6, 6,
     *          1, 1,16, 1, 6, 1, 6,11,11, 6,
     *          1, 1,21, 1, 6, 1, 6,16,16, 1,
     *         11,11, 6, 6,11/
C
C     EVALUATE THE VALUES OF THE ELECTROSTATIC POTENTIAL FOR ALL
C     POINTS GIVEN IN X,Y,ZCOORD.
C     AT PRESENT THERE ARE NO APPROXIMATIONS AND NO SCREENING OTHER
C     THAN THE USUAL INTEGRAL SCREENING WITH ITOL. THE INTEGRALS
C     ARE NEITHER ZEROED OUT AT THE BEGINNING NOR PARALLEL SUMMED
C     AT THE END.
C     THIS IS A CLONE OF EPCALC.
C
C     REDUCE THE ACCURACY 50 TIMES (E**4) FOR ITERATIVE SOLVER IN PCM
C     (AT PRESENT THIS ROUTINE IS ONLY CALLED IN CASE OF ITERATIVE PCM
C     SOLVER AND THE REASON FOR ACCURACY REDUCTION IS ITS LIMITED
C     NUMERIC ACCURACY).
C
C     THIS IS USED BY PCM AND FMO, AND IS LIMITED TO SPDFG ONLY.
C
C
      CALL BASCHK(LMAX)
      IF(LMAX.GT.4) THEN
         IF(MASWRK) WRITE(IW,*) 'EPOTEN: CODE IS SPDFG LIMITED'
         CALL ABRT
      END IF
C
      ITOLPCM=ITOL
      IF(IPCM.NE.0.AND.IPCMIT.NE.0) ITOLPCM=ITOLPCM-4
      TOL = RLN10*ITOLPCM
C     ITOLPCM=20
C     TOL  = RLN10*ITOLPCM
      NORM = NORMF .NE. 1 .OR. NORMP .NE. 1
      NXT = IBTYP.EQ.1
      NEXT  = -1
      KOUNT = -1
C
C     PREPARE DENSITY FOR EASY TRACING: DOUBLE OFF-DIAGONAL ELEMENTS.
C
      L1=NUM
      LOOP=0
      DO I=1,L1
        DO J=1,I-1
          LOOP=LOOP+1
          DA(LOOP)=DA(LOOP)*TWO
        ENDDO
C       SKIP THE DIAGONAL
        LOOP=LOOP+1
      ENDDO
C
C                    LOOP OVER SHELLS II
C
      DO 510 II=1,NSHELL
        I    = KATOM(II)
        XI   = C(1,I)
        YI   = C(2,I)
        ZI   = C(3,I)
        I1   = KSTART(II)
        I2   = I1 + KNG(II) - 1
        LIT  = KTYPE(II)
        MINI = KMIN(II)
        MAXI = KMAX(II)
        LOCI = KLOC(II) - MINI
C
C                    LOOP OVER SHELLS JJ
C
        DO 500  JJ=1,II
C
          IF(GOPARR) THEN
            KOUNT=KOUNT+1
            IF(NXT) THEN
              IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.KOUNT) GOTO 500
            ELSE
              IF(MOD(KOUNT,NPROC).NE.ME) GOTO 500
            ENDIF
          ENDIF
          J    = KATOM(JJ)
          XJ   = C(1,J)
          YJ   = C(2,J)
          ZJ   = C(3,J)
          J1   = KSTART(JJ)
          J2   = J1 + KNG(JJ) - 1
          LJT  = KTYPE(JJ)
          MINJ = KMIN(JJ)
          MAXJ = KMAX(JJ)
          LOCJ = KLOC(JJ) - MINJ
C
          RR     = (XI-XJ)**2 + (YI-YJ)**2 + (ZI-ZJ)**2
          NROOTS = (LIT + LJT - 2)/2 + 1
          IANDJ  = II.EQ.JJ
C
C             PREPARE INDICES FOR PAIRS OF (I,J) ORBITALS
C
          IJ = 0
          MAX = MAXJ
          DO 100  I=MINI,MAXI
            NX = IX(I)
            NY = IY(I)
            NZ = IZ(I)
            IF (IANDJ) MAX = I
            DO 100  J=MINJ,MAX
              IJ = IJ+1
              IJX(IJ) = NX+JX(J)
              IJY(IJ) = NY+JY(J)
              IJZ(IJ) = NZ+JZ(J)
  100       CONTINUE
C
C                     LOOP OVER PRIMITIVES IG
C
          JGMAX = J2
          DO 410  IG=I1,I2
            AI  = EX(IG)
            CSI = CS(IG)
            CPI = CP(IG)
            CDI = CD(IG)
            CFI = CF(IG)
            CGI = CG(IG)
C
C                     LOOP OVER PRIMITIVES JG
C
            IF (IANDJ) JGMAX = IG
            DO 400 JG=J1,JGMAX
              AJ  = EX(JG)
              CSJ = CS(JG)
              CPJ = CP(JG)
              CDJ = CD(JG)
              CFJ = CF(JG)
              CGJ = CG(JG)
C
              AA  = AI + AJ
              AA1 = ONE/AA
              FI  = PI212*AA1
C
              AAX = (AI*XI + AJ*XJ)
              AAY = (AI*YI + AJ*YJ)
              AAZ = (AI*ZI + AJ*ZJ)
C
              AX  = AAX*AA1
              AY  = AAY*AA1
              AZ  = AAZ*AA1
C
              DUM = AI*AJ*RR*AA1
              IF(DUM .GT. TOL) GO TO 400
              FAC = FI*EXP(-DUM)
C
C                       CALCULATE DENSITY FACTORS
C
              DOUBLE = IANDJ.AND.IG.NE.JG
              MAX = MAXJ
              NN  = 0
C
              DUM1 = ZERO
              DUM2 = ZERO
              DO 200 I = MINI,MAXI
                IF(I.EQ.1) DUM1=CSI*FAC
                IF(I.EQ.2) DUM1=CPI*FAC
                IF(I.EQ.5) DUM1=CDI*FAC
                IF(I.EQ.8.AND.NORM) DUM1=DUM1*SQRT3
                IF(I.EQ.11) DUM1 = CFI*FAC
                IF((I.EQ.14).AND.NORM) DUM1 = DUM1*SQRT5
                IF((I.EQ.20).AND.NORM) DUM1 = DUM1*SQRT3
                IF(I.EQ.21) DUM1 = CGI*FAC
                IF((I.EQ.24).AND.NORM) DUM1 = DUM1*SQRT7
                IF((I.EQ.30).AND.NORM) DUM1 = DUM1*SQRT5/SQRT3
                IF((I.EQ.33).AND.NORM) DUM1 = DUM1*SQRT3
                IF(IANDJ) MAX = I
                DO 180 J = MINJ,MAX
                  NN = NN+1
                  IF(J.EQ.1) THEN
                    DUM2 = DUM1*CSJ
                    IF(DOUBLE .AND. I.EQ.1) DUM2 = DUM2 + DUM2
                    IF(DOUBLE .AND. I.GT.1) DUM2 = DUM2 + CSI*CPJ*FAC
C
                  ELSE IF(J.EQ.2) THEN
                  DUM2 = DUM1*CPJ
                  IF(DOUBLE) DUM2 = DUM2 + DUM2
C
                  ELSE IF(J.EQ.5) THEN
                    DUM2 = DUM1*CDJ
                    IF(DOUBLE) DUM2 = DUM2 + DUM2
C
                  ELSE IF((J.EQ.8).AND.NORM) THEN
                    DUM2 = DUM2*SQRT3
C
                  ELSE IF (J.EQ.11) THEN
                    DUM2 = DUM1*CFJ
                    IF (DOUBLE) DUM2 = DUM2+DUM2
C
                  ELSE IF ((J.EQ.14).AND.NORM) THEN
                    DUM2 = DUM2*SQRT5
C
                  ELSE IF ((J.EQ.20).AND.NORM) THEN
                    DUM2 = DUM2*SQRT3
C
                  ELSE IF (J.EQ.21) THEN
                    DUM2 = DUM1*CGJ
                    IF (DOUBLE) DUM2 = DUM2+DUM2
C
                  ELSE IF ((J.EQ.24).AND.NORM) THEN
                    DUM2 = DUM2*SQRT7
C
                  ELSE IF ((J.EQ.30).AND.NORM) THEN
                    DUM2 = DUM2*SQRT5/SQRT3
C
                  ELSE IF ((J.EQ.33).AND.NORM) THEN
                    DUM2 = DUM2*SQRT3
C
                  END IF
C
                  DIJ(NN) = DUM2
  180           CONTINUE
  200         CONTINUE
C
C                    LOOP OVER PROPERTY COORDINATES
C
              DO 600 IPT=1,NP
                IIPT= mappcm(ipt)
                if(iipt.eq.0) go to 600
                XPP = XCOORD(IPT)
                YPP = YCOORD(IPT)
                ZPP = ZCOORD(IPT)
C
C       CALCULATE POINTS AND WEIGHTS FOR RYS POLYNOMIAL
C
                XX  = AA * ((AX-XPP)**2 + (AY-YPP)**2 + (AZ-ZPP)**2)
                IF (NROOTS.LE.3) CALL RT123
                IF (NROOTS.EQ.4) CALL ROOT4
                IF (NROOTS.EQ.5) CALL ROOT5
                IF (NROOTS.GE.6) CALL ROOT6
C
C       LOOP OVER ROOTS OF RYS POLYNOMIAL TO CALCULATE INTEGRALS
C
                MM = 0
                DO 340  K=1,NROOTS
C
                  UU = AA*U(K)
                  WW = W(K)
                  TT = ONE/(AA+UU)
                  T  = SQRT(TT)
C
                  X0 = (AAX + UU*XPP)*TT
                  Y0 = (AAY + UU*YPP)*TT
                  Z0 = (AAZ + UU*ZPP)*TT
C
C      CALCULATE 1-DIMENSIONAL INTEGRALS OVER ALL ANGULAR MOMENTA
C
                  IN = -5+MM
                  DO 320  I=1,LIT
                    IN = IN+5
                    NI = I
C
                    DO 320  J=1,LJT
                      JN = IN+J
                      NJ = J
C
C       EVALUATE MOMENT INTEGRALS USING GAUSS-HERMITE QUADRATURE:
C
                      XINT0 = ZERO
                      YINT0 = ZERO
                      ZINT0 = ZERO
C
                      NPTS = (NI + NJ - 2)/2 + 1
                      IMIN = MINP(NPTS)
                      IMAX = MAXP(NPTS)
C
                      DO 310  IROOT=IMIN,IMAX
C
                        DUM = WP(IROOT)
                        PX = DUM
                        PY = DUM
                        PZ = DUM
C
                        DUM = HP(IROOT)*T
                        PTX = DUM + X0
                        PTY = DUM + Y0
                        PTZ = DUM + Z0
C
                        AXI = PTX - XI
                        AYI = PTY - YI
                        AZI = PTZ - ZI
C
                        BXI = PTX - XJ
                        BYI = PTY - YJ
                        BZI = PTZ - ZJ
C
                        GO TO (250,240,230,220,210),NI
C
  210                   PX = PX*AXI
                        PY = PY*AYI
                        PZ = PZ*AZI
C
  220                   PX = PX*AXI
                        PY = PY*AYI
                        PZ = PZ*AZI
C
  230                   PX = PX*AXI
                        PY = PY*AYI
                        PZ = PZ*AZI
C
  240                   PX = PX*AXI
                        PY = PY*AYI
                        PZ = PZ*AZI
C
  250                   CONTINUE
C
                        GO TO (300,290,280,270,260),NJ
C
  260                   PX = PX*BXI
                        PY = PY*BYI
                        PZ = PZ*BZI
C
  270                   PX = PX*BXI
                        PY = PY*BYI
                        PZ = PZ*BZI
C
  280                   PX = PX*BXI
                        PY = PY*BYI
                        PZ = PZ*BZI
C
  290                   PX = PX*BXI
                        PY = PY*BYI
                        PZ = PZ*BZI
C
  300                   CONTINUE
C
                        XINT0 = XINT0 + PX
                        YINT0 = YINT0 + PY
                        ZINT0 = ZINT0 + PZ
C
  310                 CONTINUE
C
                      XIN(JN) = XINT0
                      YIN(JN) = YINT0
                      ZIN(JN) = ZINT0*WW
C
  320               CONTINUE
C
                  MM = MM+25
  340           CONTINUE
C
                NN = 0
                MAX = MAXJ
                SUM = ZERO
C         COMPUTE V(I)=TR(D*V(I)), WHERE V(I) IS THE POTENTIAL
C         AT THE POINT IPT (==I) AND D IS THE ELECTRON DENSITY.
                DO 420  I=MINI,MAXI
                  LI = LOCI + I
                  IN = LI*(LI-1)/2
                  IF (IANDJ) MAX = I
                  DO 420  J=MINJ,MAX
                    LJ = LOCJ + J
                    JN = LJ + IN
                    NN = NN + 1
                    NX = IJX(NN)
                    NY = IJY(NN)
                    NZ = IJZ(NN)
                    MM = 0
                    SUM1 = ZERO
                    DO 350 K=1,NROOTS
                      SUM1=SUM1+XIN(NX+MM)*YIN(NY+MM)*ZIN(NZ+MM)
                      MM = MM+25
  350               CONTINUE
                    SUM=SUM+DIJ(NN)*DA(JN)*SUM1
  420           CONTINUE
                VALUE(IIPT) = VALUE(IIPT) + ACONST*SUM
C
  600         CONTINUE
C
C        END OF LOOP OVER PROPERTY COORDINATES
C
  400       CONTINUE
  410    CONTINUE
C
C        END OF LOOPS OVER PRIMITIVES
C
C
  500   CONTINUE
  510 CONTINUE
C
C        END OF LOOPS OVER SHELLS
C
      IF(GOPARR.AND.NXT) CALL DDI_DLBRESET
C
C     RESTORE DENSITY IN COURTESY
C
      LOOP=0
      DO I=1,L1
        DO J=1,I-1
          LOOP=LOOP+1
          DA(LOOP)=DA(LOOP)/TWO
        ENDDO
C       SKIP THE DIAGONAL
        LOOP=LOOP+1
      ENDDO
C
      IF(NFMOPCM.NE.0) THEN
        IF(MASWRK) WRITE(IW,*) 'DONE PCM POT.'
        CALL TIMIT(1)
      ENDIF
C
      RETURN
      END
C
C*MODULE MLTFMO  *DECK getascFMOFDD
C>    @brief   FMO/FDD/PCM
C>
C>    @details PCM electron Potential
C>
C>    @author  hiroya  nakata
C>
C>  @parm mode        mode
C>  @parm nts2lay     number of tesserae for B
C>  @parm QB          charge for B
C>  @parm MAP         map for B
C>  @parm XCT         tesserae coordinate X
C>  @parm YCT         tesserae coordinate Y
C>  @parm ZCT         tesserae coordinate Z
C>  @parm AS          ASC surface
C>  @parm XE          Coordinate X
C>  @parm YE          Coordinate Y
C>  @parm ZE          Coordinate Z
C>  @parm RE          R
C>  @parm ISPHE       indice for sphere
C>  @parm layfrg      layer for  each fragment
C>  @parm indat       indice for fragment
C>  @parm lfmasc      memory info
C>  @parm LLIST       list
C>
      subroutine  getascFMOFDD(mode,nts2lay,QB,MAP,XCT,YCT,ZCT,AS,
     *            XE,YE,ZE,RE,ISPHE,layfrg,indat,lfmasc,LLIST)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION QB(*)
      DIMENSION MAP(*)
      DIMENSION XCT(*),YCT(*),ZCT(*),AS(*)
      DIMENSION XE(*),YE(*),ZE(*),RE(*)
      DIMENSION ISPHE(*)
      DIMENSION LAYFRG(*),INDAT(*)
C
      logical ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,GOPARR,DSKWRK,MASWRK
C
      COMMON /FMCOM / X(1)
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /MLTPNT/ LDELEPOT,LDELQSE,LQSETMP,LFZVEC,LMAPCMFD,LQBL2FD
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMITR/ RCUT(2),THRES,IPCMIT,IMUL,MXDIIS,NREG,MXITR1,
     *                MXITR2,MODPAP
      COMMON /PCMPLY/ STOT,VOL,CCX,CCY,CCZ,RDIF,NESF,NESFP,NESFF,I_NESF,
     *                L_AST
C
      PARAMETER (ONE=1.0D+00)
C
      MXDII1 = MXDIIS + 1
      nfg2   = (nfg   * nfg  - nfg)/2
      nesolv = nfg*2  + nfg2  * 2
C
      LCHG   = lfmasc + 1
      LQPOT  = LCHG   + NTS
      LQ0    = LQPOT  + NTS
      LQ1    = LQ0    + NTS
      LQ2    = LQ1    + NTS
      LQ3    = LQ2    + NTS
      LD0    = LQ3    + NTS
      LQA    = LD0    + NTS
      LDIMAT = LQA    + NTS
      LTMP0  = LDIMAT + MXDII1*MXDII1
      LTMP1  = LTMP0  + NTS*3
      LTMP2  = LTMP1  + MXDII1
      LIPVT  = LTMP2  + MXDII1*MXDII1
      LRMUL  = LIPVT  + MXDII1
      lesolv = LRMUL  + MXSP*10
      lpel   = lesolv + nesolv
      lvnuc  = lpel   + NTS
c     last   = lvnuc  + NTS
C       
      nat2lay=0
      do iat=1,natfmo
        ifg  = indat(iat)
        ilay = layfrg(ifg)
c       write(6,'("wwwchk=",3I4)') iat,ifg,ilay
        if(ilay.gt.1) nat2lay = nat2lay + 1
      end do
c     write(6,*) "CHK=",nat2lay
      if(isgddi) then
        NTSPAR=(nts2lay-1)/npglob+1
      else
        NTSPAR=(nts2lay-1)/nproc+1
      endif
      nqrep  = NTSPAR * MXDII1* 2
      CALL VALFM(LOADFM)
      LXCT  = LOADFM + 1
      LYCT  = LXCT   + nts2lay
      LZCT  = LYCT   + nts2lay
      LSP2  = LZCT   + nts2lay
      LAS2  = LSP2   + nts2lay
      LXE   = LAS2   + nts2lay
      LYE   = LXE    + nat2lay
      LZE   = LYE    + nat2lay
      LRE   = LZE    + nat2lay
      lmap2 = LRE    + nat2lay
      LQREP = lmap2  + natfmo
      last  = LQREP  + nqrep
      NEED  = LAST   - LOADFM -1
      CALL GETFM(NEED)
C     Construct PCM tesserae for B
      do 100 its=1,nts
        if(map(its).eq.0) go to 100
        X(LXCT-1+map(its)) = XCT(its)
        X(LYCT-1+map(its)) = YCT(its)
        X(LZCT-1+map(its)) = ZCT(its)
        X(LAS2-1+map(its)) = AS(its)
        call ixstor(x(LSP2),map(its),ISPHE(its))
 100  continue
      nattmp=0
      do iat=1,natfmo
        ifg  = indat(iat)
        ilay = layfrg(ifg)
c       write(6,'("wwwchk=",3I4)') iat,ifg,ilay
        iatb=0
        if(ilay.gt.1) then 
          nattmp = nattmp+ 1
          X(LXE-1+nattmp)=XE(iat)
          X(LYE-1+nattmp)=YE(iat)
          X(LZE-1+nattmp)=ZE(iat)
          X(LRE-1+nattmp)=RE(iat)
          iatb=nattmp
        end if
        call ixstor(x(lmap2),iat,iatb)
c       Make a map of atomic IDs in S -> IDs in B.
      end do
c     Change LSP2 so that it points to atoms in B, not S.
      do 200 its=1,nts2lay
        i=ixftch(x(LSP2),its)
        ispb=ixftch(x(lmap2),i)
        if(ispb.gt.nat2lay.or.ispb.le.0) call abrt
        call ixstor(x(LSP2),its,ispb)
c       write(6,*) 'ISPHB=',its,i,ispb
 200  continue
c     write(6,'("wwwchk=",I4)') nattmp,nts2lay
c     Store the total potential in QPOT for the next call to ASCIT.
      if(mode.eq.3) then
        CALL DCOPY(NTS,X(LDELEPOT),1,X(LQPOT),1)
      else if(mode.eq.4.or.mode.eq.5) then
        CALL DCOPY(NTS,X(lpel),1,X(LQPOT),1)
      else
        call vadd(x(lpel),1,x(lVNUC),1,X(LQPOT),1,nts)
      end if
      call dscal(nts,-one,X(LQPOT),1)
c     write(6,'("CHK=",2F12.8)') 
c    *   (X(lpel-1+its),X(lvnuc-1+its),ITS=1,NTS)
c     write(6,'("CHK=",F12.8)') (X(lqpot-1+its),ITS=1,NTS)
      ITER=1
      IJOB=0
      ntssav = nts
      nts    = nts2lay
c     Change the number of spheres, although it does not seem to be used in ASCIT.
      I_NESFsav=I_NESF
      I_NESF=nattmp
      NESFsav=NESF
      NESF=I_NESF
C
      if(mode.eq.2.or.mode.eq.5) then
        IJOB=1
        CALL DCOPY(NTS,QB,1,X(LQ0),1)
      end if
c     write(6,'("wwwchk=",2I4)') (its,map(its),its=1,ntssav)
C
      CALL ASCIT(ITER,IJOB,X(LQPOT),X(LQ0),X(LQ1),X(LQ2),X(LQ3),
     *           X(LD0),X(LQA),X(LDIMAT),X(LQREP),X(LTMP0),X(LTMP1),
     *           X(LTMP2),X(LIPVT),X(LRMUL),MXDII1,NTSPAR,X(lxct),
     *           X(lyct),X(lzct),X(las2),QB,X(LXE),X(LYE),X(LZE),
     *           X(LRE),X(LSP2),X(LLIST))
c    *           X(lyct),X(lzct),X(las2),QB,XE,YE,ZE,
c    *           RE,X(LSP2),X(LLIST))
      I_NESF=I_NESFsav
      nts    = ntssav
      NESF=NESFsav
C
      CALL RETFM(NEED)
C
      RETURN
      END
C
C*MODULE mltfmo  *DECK pcmnup2
C>    @brief   FMO/FDD/PCM
C>
C>    @details PCM nuclear Potential
C>
C>    @author  hiroya  nakata
C>
C>    @param  ida   scal factor
C>    @param  Vnuc  nuclear potential
C>    @param  map   mapping
C>
      SUBROUTINE pcmnup2(ida,vnuc,map)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      logical GOPARR,DSKWRK,MASWRK
      PARAMETER (MXATM=2000,zero=0.0D+00)
      dimension vnuc(*),map(*)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMCHG/ PB,PX,PC,UNZ,QNUC,FN,FE,UNZOR,PORT
      COMMON /PCMDIM/ mxsp,mxts,mempcm1,mempcm2,NTS
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED,LEPSPCM
C
C     Compute nuclear potential due to induced charges in the FMO-PCM.
C
c     if(ida.eq.0) return
      da=ida
c     write(6,*) 'wwwnup',ida
c     write(6,'("map=",2I4)') (its,map(its),its=1,nts)
C
C     THE NUCLEAR POTENTIAL GOES TO VNUC
c     PC will contain nuclear potential contribution to the n-mer energy.
c     VNUC accumulates potential for the whole system, thus it has the DA
c     prefactor, whereas PC is computed for the n-mer only, no prefactor.
c     VNUC is not globally summed here, but PC is.
c
cnb   The present scheme is extravagant. The right way is to compute PCs and
c     VNUC for monomers only, since dimer values are additive of monomers! 
C
      PC=zero
      DO 100 ITS=1,NTS
        IITS=map(ITS)
c       if(IITS.eq.0) go to 100
        if(goparr.and.MOD(ITS,NPROC).NE.me) goto 100
        VITS=zero
        xctsi=x(LAXYZCT+ITS-1)
        yctsi=x(LAXYZCT+MXTS+ITS-1)
        zctsi=x(LAXYZCT+MXTS*2+ITS-1)
        DO IAT=1,NAT
          VITS=VITS+ZAN(IAT)/SQRT((XCTSI-C(1,IAT))**2+
     *                       (YCTSI-C(2,IAT))**2+(ZCTSI-C(3,IAT))**2)
        ENDDO
        if(ida.ne.0.and.IITS.ne.0) VNUC(IITS)=VNUC(IITS)+da*VITS
        PC=PC+VITS*x(lQSE+ITS-1)
  100 continue
      if(goparr) call ddi_gsumf(2416,PC,1)
      RETURN
      END
C
C
C*MODULE mltfmo  *DECK QCDERQ2
C>    @brief   FMO/FDD/PCM
C>
C>    @details PCM nuclear Potential
C>
C>    @author  hiroya  nakata
C>
C>  @param  NATA   number of atom
C>  @param  NATM   number of atom
C>  @param  NTS    number of tesserae
C>  @param  NFRG   EFP
C>  @param  FEQ    gradient
C>  @param  FFRGQ  EFP gradient
C>  @param  QT     total ASC
C>  @param  VECTMP potential
C>  @param  XCTS   asc x coordinate
C>  @param  YCTS   asc y coordinate
C>  @param  ZCTS   asc z coordinate
C>  @param  AS     area of asc
C>  @param  QSN    nuclear charge
C>  @param  QSE    electron charge
C>  @param  QSND   nuclear charge  for hetelo
C>  @param  QSED   electron charge for hetelo
C>  @param  Q_FS   charge for FS
C>  @param  Q_IND  charge for induce
C>  @param  Q2     charge 
C>  @param  XE     solute coordiante for x
C>  @param  YE     solute coordiante for y
C>  @param  ZE     solute coordiante for z
C>  @param  RE     R for solute
C>  @param  ISPHE  indice
C>  @param  DAI    indice for PCM
C>  @param  IDDAI  indice for PCM
C>  @param  QSETM  charge for FMOP  
C>  @param  QSEMP  charge for FMO
C>  @param  QSEXY  charge for FMO
C>  @param  QSEMN  charge for FMO
C>  @param  DSOLQM derivative for solute 
C>  @param  DSOLEF derivative for EFP
C>  @param  MP2PCM logic for MP2 PCM cphf
C>  @param  TDDFT  logic for TD PCM
C>  @param  LFMOPCM1 logic for fmo
C>  @param  IAGLOB  global indice
C>  @param  QDEL    delta Q
C>  @param  QBL2    B charge
C>  @param  MAPPCM  map
C>  @param  EPSHET  epsilon
      SUBROUTINE QCDERQ2(NATA,NATM,NTS,NFRG,FEQ,FFRGQ,QT,VECTMP,
     *                  XCTS,YCTS,ZCTS,AS,QSN,QSE,QSND,QSED,Q_FS,Q_IND,
     *                  Q2,XE,YE,ZE,RE,ISPHE,DAI,IDDAI,QSETMP,QSEMP,
     *                  QSEXY,QSEMN,DSOLQM,DSOLEF,MP2PCM,TDDFT,LFMOPCM1,
     *                  IAGLOB,QDEL,QBL2,MAPPCM,EPSHET)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=2000, MXFRG=1050, MXFGPT=12000)
C
      LOGICAL GOPARR, DSKWRK, MASWRK, TDDFT, MP2PCM
      LOGICAL LFMOPCM1
C
      DIMENSION FEQ(3,NATM,NTS),FFRGQ(6,NFRG,NTS)
      DIMENSION XCTS(1),YCTS(1),ZCTS(1),AS(1)
      DIMENSION QT(1),Q2(1),QSN(1),QSE(1),QSND(1),QSED(1),QSEMP(1),
     *          QSETMP(1),Q_FS(1),Q_IND(1),QSEXY(1),QSEMN(1)
      DIMENSION VECTMP(1),ISPHE(1),DSOLQM(3,*),DSOLEF(6,*)
      DIMENSION DAI(3,20,*),IDDAI(21,*),RE(1),XE(1),YE(1),ZE(1)
      DIMENSION IAGLOB(1),QDEL(*),QBL2(*),MAPPCM(*),EPSHET(*)

      COMMON /FGRAD / DEF(3,MXFGPT),DEFT(3,MXFRG),TORQ(3,MXFRG),
     *                EFCENT(3,MXFRG),FRGMAS(MXFRG),FRGMI(6,MXFRG),
     *                ATORQ(3,MXFRG)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c     COMMON /PCMEPS/ EPSHET(MXATM),IHET
      COMMON /PCMOPT/ RABI,RASC,REFPOL,THRSLS,DENSLS,WB,WA,ETA2,GD,EVAC,
     *                RHOW,PM,AREATL,AREAKP,BONDRY,OMEGA,RET,FRO,EPSINF,
     *                EPS,DR,RSOLV,VMOL,TCE,STEN,DSTEN,CMF,TABS,IDIRCT,
     *                IPCDER,IDP,ICOMP,IFIELD,ICAV,IDISP,IPRINT,IRETCAV,
     *                ICENT,IFAST,NEVAL,IEFPOL,KEEPSM,IMGABI,IMGASC,NADD
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IKREP,IEF,IP_F,NFMOPCM,IHET
      COMMON /PCMPLY/ STOT,VOL,CCX,CCY,CCZ,RDIF,NESF,NESFP,NESFF,I_NESF,
     *                L_AST
      COMMON /PCMTMP/ IDSP(MXATM+MXFRG*5),DPCMFRG(6,MXFRG),
     *                EGPCM(3,MXATM)

      DATA ZERO, ONE /0.0D+00, 1.0D+00/
      DATA PT5/0.5D+00/
      DATA FPI/12.56637062D+00/
C
C     CALCULATE -1/2*Q*DC/DA*Q
C

C     IF (LFMOPCM1) THEN
C       CALL FFRAGQ(FFRGQ,QSETMP,XCTS,YCTS,ZCTS)
C     ELSE
C       CALL FFRAGQ(FFRGQ,QT,XCTS,YCTS,ZCTS)
C     END IF
      if(nts.eq.0) write(6,*) "www Check=",QSE(1),QSN(1)
c     do ITS=1,NTS
c      if(MAPPCM(ITS).ne.0)
c    *  write(6,'("CHK=",I3,F11.8)') MAPPCM(ITS),QBL2(ITS)
c     END DO
C
C     -- COMPUTE THE VECTOR A^(-1)*S*A^(-1)*Q2 STORE IN VECTMP
C
      IF(IEF.EQ.3) THEN
      DO I = 1, NTS
          VECTMP(I)=ZERO
          XI=XCTS(I)
          YI=YCTS(I)
          ZI=ZCTS(I)
          DO J = 1, NTS
            IF(J.EQ.I) THEN
              SIJ=1.070D+00*SQRT(FPI/AS(I))
            ELSE
              XJ=XCTS(J)
              YJ=YCTS(J)
              ZJ=ZCTS(J)
              DRIJ=SQRT((XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2)
              SIJ=1/DRIJ
            END IF
            VECTMP(I)=VECTMP(I)+SIJ*Q2(J)
          END DO
      END DO
      END IF

C
C     - INITIALIZE PARALLEL -
C
      IPCOUNT = ME - 1
C
      DO 100 IAT = 1, NATA
C        GO PARALLEL!
         IF(GOPARR) THEN
           IPCOUNT = IPCOUNT + 1
           IF(MOD(IPCOUNT,NPROC).NE.0) GO TO 100
         END IF
C
         IATGLB = IAT
         IF(NFMOPCM.GT.0) IATGLB = IAGLOB(IAT)
         IF (IAN(IAT).NE.1.AND.ABS(ZAN(IAT)-ONE).LT.1.0D-08) GOTO 100
C
C        TERM 2.A FORCE IMPOSED ON ASC(IAT) BY OTHER ASC
C
         FQQX  = ZERO
         FQQY  = ZERO
         FQQZ  = ZERO
         FQ2QX = ZERO
         FQ2QY = ZERO
         FQ2QZ = ZERO
         IF(NESFP.EQ.0)THEN
         DO 110 ITS = 1, NTS
            IZTS=MAPPCM(ITS)
            IF(IZTS.EQ.0) GO TO 110
            IF(ISPHE(ITS).EQ.IATGLB) THEN
               XI = XCTS(ITS)
               YI = YCTS(ITS)
               ZI = ZCTS(ITS)
               DO 120 JTS = 1, NTS
                  JZTS=MAPPCM(JTS)
                  IF(JZTS.EQ.0) GO TO 120
                  IF(ISPHE(JTS).NE.IATGLB) THEN
                     XJ = XCTS(JTS)
                     YJ = YCTS(JTS)
                     ZJ = ZCTS(JTS)
                     R2 = (XJ-XI)**2+(YJ-YI)**2+(ZJ-ZI)**2
                     R  = SQRT(R2)
                     R3 = R*R2
                     IF(IEF.EQ.10) THEN
                        EI=EPSHET(ISPHE(ITS))/(EPSHET(ISPHE(ITS))-ONE)
                        EJ=EPSHET(ISPHE(JTS))/(EPSHET(ISPHE(JTS))-ONE)
                        QTIITS=QBL2(IZTS)*(EPS-ONE)/EPS
                        QTIJTS=QBL2(JZTS)*(EPS-ONE)/EPS
C                       QB*dC/da*(Delta q + 1/2 Qb) for modfd
                        IF (LFMOPCM1) THEN
                         QTDJTS=QDEL(JTS)
                         QTDITS=QDEL(ITS)
                         FT = (QTDITS*EJ*QTIJTS+QTIITS*EI*QTDJTS)/R3
                        ELSE
                         QTDJTS=QSED(JTS)+QSND(JTS)+Q_FS(JTS)+Q_IND(JTS)
                         QTDITS=QSED(ITS)+QSND(ITS)+Q_FS(ITS)+Q_IND(ITS)
                         FT = PT5*(QTDITS*EJ*QTIJTS+QTIITS*EI*QTDJTS)/R3
                        END IF
C
                        IF(TDDFT) THEN
                           SCALE = EPS/(EPS-ONE)
                           FT=FT+SCALE*(2.0D+00*QSEXY(ITS)*QSEXY(JTS)/R3
     *                                + QTIJTS*QSEMN(ITS)/R3
     *                                + QTIITS*QSEMN(JTS)/R3)
                        END IF
                        IF(MP2PCM)THEN
                           SCALE = EPS/(EPS-ONE)
                           FT=FT+SCALE*(QTIJTS*QSEMP(ITS)/R3
     *                                + QTIITS*QSEMP(JTS)/R3)
                        END IF
C
C                           ALL IEF OTHER THAN CPCM:
                     ELSE
                        IF (LFMOPCM1) THEN
                          ! MAYBE THIS IS WRONG
                          FT = QT(ITS)*QSETMP(JTS)/R3
                        ELSE
                          FT = QT(ITS)*QT(JTS)/R3
                        END IF
                     END IF
C
                     FQQX = FQQX - (XI-XJ)*FT
                     FQQY = FQQY - (YI-YJ)*FT
                     FQQZ = FQQZ - (ZI-ZJ)*FT
C
                     IF(IEF.EQ.3) THEN
                        FT2= -Q2(ITS)*QT(JTS)/R3
                        FQ2QX = FQ2QX - (XI-XJ)*FT2
                        FQ2QY = FQ2QY - (YI-YJ)*FT2
                        FQ2QZ = FQ2QZ - (ZI-ZJ)*FT2
                     END IF
                  END IF
 120           CONTINUE
            END IF
 110     CONTINUE
         END IF
C
C
C
C        TERM 2.B FORCE OF Q2Q2 FOR IEF-PCM PHASE 2
C
         FQ2Q2X=ZERO
         FQ2Q2Y=ZERO
         FQ2Q2Z=ZERO
         IF(IEF.EQ.3 .AND. NESFP.EQ.0) THEN
            DO 130 I = 1, NTS
               XI=XCTS(I)
               YI=YCTS(I)
               ZI=ZCTS(I)
               RIX=ZERO
               RIY=ZERO
               RIZ=ZERO
               IF(ISPHE(I).EQ.IATGLB) THEN
                  RIX=ONE
                  RIY=ONE
                  RIZ=ONE
               END IF
               DO 140 J = 1, NTS
                  AJ=AS(J)
                  LJ=ISPHE(J)
                  RJ=RE(LJ)
                  XJ=XCTS(J)
                  YJ=YCTS(J)
                  ZJ=ZCTS(J)
                  XCJ=(XJ-XE(LJ))/RJ
                  YCJ=(YJ-YE(LJ))/RJ
                  ZCJ=(ZJ-ZE(LJ))/RJ
                  RJX=ZERO
                  RJY=ZERO
                  RJZ=ZERO
                  IF(ISPHE(J).EQ.IATGLB) THEN
                     RJX=ONE
                     RJY=ONE
                     RJZ=ONE
                  END IF
                  IF(J.EQ.I) THEN
                     FT=ZERO
                  ELSE
                     DRIJ=SQRT((XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2)
                     DRIJ3=DRIJ**3
                     FT=-(EPS-ONE)*Q2(I)*AJ/FPI/DRIJ3*VECTMP(J)
                  END IF
                  FQ2Q2X=FQ2Q2X+(RIX-RJX)*XCJ*FT
                  FQ2Q2Y=FQ2Q2Y+(RIY-RJY)*YCJ*FT
                  FQ2Q2Z=FQ2Q2Z+(RIZ-RJZ)*ZCJ*FT
 140           CONTINUE
 130        CONTINUE
         END IF
C
C        TERM 4. FORCE IMPOSED ON ASC(IAT) BY EFPS
C
         FQEFPX = ZERO
         FQEFPY = ZERO
         FQEFPZ = ZERO
         IF (NFRG.NE.0.AND.NESFP.EQ.0) THEN
         DO ITS = 1, NTS
            IF(ISPHE(ITS).EQ.IATGLB) THEN
               DO IFRG = 1, NFRG
                  FQEFPX = FQEFPX - FFRGQ(1,IFRG,ITS)
                  FQEFPY = FQEFPY - FFRGQ(2,IFRG,ITS)
                  FQEFPZ = FQEFPZ - FFRGQ(3,IFRG,ITS)
               END DO
            END IF
         END DO
         END IF
C
C        TERM 5. FORCE DUE TO TESSARA AREA CHANGE (FIXPVA)
C
         FAX = ZERO
         FAY = ZERO
         FAZ = ZERO
         IF(IPCDER.EQ.3 .AND. NESFP.EQ.0) THEN
         SQRTPI = SQRT(3.1415926535897932D+00)
         DO 150 ITS = 1, NTS
            IZTS=MAPPCM(ITS)
            IF(IZTS.EQ.0) GO TO 150
            DO III = 1, IDDAI(21,ITS)
               IF(IATGLB.EQ.IDDAI(III,ITS)) THEN
                  IF(IEF.EQ.10) THEN
                     QTIITS=QBL2(IZTS)*(EPS-ONE)/EPS
                     IF (LFMOPCM1) THEN
C                      QB*dC/da*(Delta q + 1/2 Qb) for modfd
                       QTDITS=QDEL(ITS)
                       DUM=-1.07D+00*SQRTPI/SQRT(AS(ITS)**3)*
     *                      QTDITS*QTIITS
                     ELSE
                       QTDITS=QSED(ITS)+QSND(ITS)+Q_FS(ITS)+Q_IND(ITS)
                       DUM=-1.07D+00*SQRTPI/SQRT(AS(ITS)**3)*
     *                      0.5D+00*QTDITS*QTIITS
                     END IF
C
                     IF(TDDFT) THEN
                        DUM = DUM -1.07D+00*SQRTPI/SQRT(AS(ITS)**3)*
     *                     (QSEXY(ITS)*QSEXY(ITS)+QTIITS*QSEMN(ITS))
                     END IF
                     IF(MP2PCM)THEN
                        DUM = DUM -1.07D+00*SQRTPI/SQRT(AS(ITS)**3)*
     *                     (QTIITS*QSEMP(ITS))
                     END IF
C
                     SCALE=EPSHET(ISPHE(ITS))/(EPSHET(ISPHE(ITS))-ONE)
                     FAX=FAX+DUM*DAI(1,III,ITS)*SCALE
                     FAY=FAY+DUM*DAI(2,III,ITS)*SCALE
                     FAZ=FAZ+DUM*DAI(3,III,ITS)*SCALE
                  ELSE
                     IF (LFMOPCM1) THEN
                       DUM=-1.07D+00*SQRTPI/SQRT(AS(ITS)**3)*
     *                      QSETMP(ITS)*QT(ITS)
                     ELSE
                       DUM=-1.07D+00*SQRTPI/SQRT(AS(ITS)**3)*
     *                      0.5D+00*QT(ITS)*QT(ITS)
                     END IF
                     FAX=FAX+DUM*DAI(1,III,ITS)
                     FAY=FAY+DUM*DAI(2,III,ITS)
                     FAZ=FAZ+DUM*DAI(3,III,ITS)
                  ENDIF
               END IF
            ENDDO
 150     CONTINUE
         END IF
C
C
C        COMBINE THE FORCES
C
         DSOLQM(1,IAT) = DSOLQM(1,IAT)
     *                 + FQQX   + FQ2QX  + FQ2Q2X + FQEFPX + FAX
         DSOLQM(2,IAT) = DSOLQM(2,IAT)
     *                 + FQQY   + FQ2QY  + FQ2Q2Y + FQEFPY + FAY
         DSOLQM(3,IAT) = DSOLQM(3,IAT)
     *                 + FQQZ   + FQ2QZ  + FQ2Q2Z + FQEFPZ + FAZ
 100  CONTINUE
C
      IF (NFRG.EQ.0) RETURN
C
C     ******************************************
C      COMPUTE THE GRADIENTS FOR EACH FRAGMENT
C     ******************************************
C
      DO 200 IFRG = 1, NFRG
C
C        TERM 1. FORCE/TORQUE IMPOSED ON EFP(IFRG) BY ALL ASC
C
         FEFPQX = ZERO
         FEFPQY = ZERO
         FEFPQZ = ZERO
         TEFPQX = ZERO
         TEFPQY = ZERO
         TEFPQZ = ZERO
         DO ITS = 1, NTS
            FEFPQX = FEFPQX + FFRGQ(1,IFRG,ITS)
            FEFPQY = FEFPQY + FFRGQ(2,IFRG,ITS)
            FEFPQZ = FEFPQZ + FFRGQ(3,IFRG,ITS)
            TEFPQX = TEFPQX + FFRGQ(4,IFRG,ITS)
            TEFPQY = TEFPQY + FFRGQ(5,IFRG,ITS)
            TEFPQZ = TEFPQZ + FFRGQ(6,IFRG,ITS)
         END DO
C
C        TERM 2.A FORCE/TORQUE IMPOSED ON ASC(IFRG) BY OTHER ASC
C
         FQQX = ZERO
         FQQY = ZERO
         FQQZ = ZERO
         TQQX = ZERO
         TQQY = ZERO
         TQQZ = ZERO
         FQ2QX = ZERO
         FQ2QY = ZERO
         FQ2QZ = ZERO
         TQ2QX = ZERO
         TQ2QY = ZERO
         TQ2QZ = ZERO
         IF(NESFP.EQ.0) THEN
         DO ITS = 1, NTS
            IF(IDSP(ISPHE(ITS)).EQ.IFRG) THEN
               XI = XCTS(ITS)
               YI = YCTS(ITS)
               ZI = ZCTS(ITS)
               XEI= XE(ISPHE(ITS))
               YEI= YE(ISPHE(ITS))
               ZEI= ZE(ISPHE(ITS))
               QTITS=QT(ITS)
               DO JTS = 1, NTS
                  IF(IDSP(ISPHE(JTS)).NE.IFRG) THEN
                     XJ = XCTS(JTS)
                     YJ = YCTS(JTS)
                     ZJ = ZCTS(JTS)
                     QTJTS=QT(JTS)
                     R2= (XJ-XI)**2+(YJ-YI)**2+(ZJ-ZI)**2
                     R = SQRT(R2)
                     R3= R*R2
                     FT = QTITS*QTJTS/R3
                     IF(TDDFT) THEN
                        FT=FT+2.0D+00*QSEXY(ITS)*QSEXY(JTS)/R3
     *                                + QTJTS*QSEMN(ITS)/R3
     *                                + QTITS*QSEMN(JTS)/R3
                        END IF
                     IF(MP2PCM) THEN
                        FT=FT+(QTJTS*QSEMP(ITS)/R3
     *                       + QTITS*QSEMP(JTS)/R3)
                     END IF
                     FQQX = FQQX - (XI-XJ)*FT
                     FQQY = FQQY - (YI-YJ)*FT
                     FQQZ = FQQZ - (ZI-ZJ)*FT
                     TQQX = TQQX + (YI-YJ)*FT*(ZEI-EFCENT(3,IFRG))
     *                           - (ZI-ZJ)*FT*(YEI-EFCENT(2,IFRG))
                     TQQY = TQQY + (ZI-ZJ)*FT*(XEI-EFCENT(1,IFRG))
     *                           - (XI-XJ)*FT*(ZEI-EFCENT(3,IFRG))
                     TQQZ = TQQZ + (XI-XJ)*FT*(YEI-EFCENT(2,IFRG))
     *                           - (YI-YJ)*FT*(XEI-EFCENT(1,IFRG))
                     IF(IEF.EQ.3) THEN
                        FT2= -Q2(ITS)*QT(JTS)/ R3
                        FQ2QX = FQ2QX - (XI-XJ)*FT2
                        FQ2QY = FQ2QY - (YI-YJ)*FT2
                        FQ2QZ = FQ2QZ - (ZI-ZJ)*FT2
                        TQ2QX = TQ2QX + (YI-YJ)*FT2*(ZEI-EFCENT(3,IFRG))
     *                                - (ZI-ZJ)*FT2*(YEI-EFCENT(2,IFRG))
                        TQ2QY = TQ2QY + (ZI-ZJ)*FT2*(XEI-EFCENT(1,IFRG))
     *                                - (XI-XJ)*FT2*(ZEI-EFCENT(3,IFRG))
                        TQ2QZ = TQ2QZ + (XI-XJ)*FT2*(YEI-EFCENT(2,IFRG))
     *                                - (YI-YJ)*FT2*(XEI-EFCENT(1,IFRG))
                     END IF
                  END IF
               END DO
            END IF
         END DO
         END IF
C
C        SCALE FOR C-PCM
         IF(IEF.EQ.10)THEN
            SCALE=EPS/(EPS-ONE)
            FQQX=FQQX*SCALE
            FQQY=FQQY*SCALE
            FQQZ=FQQZ*SCALE
            TQQX=TQQX*SCALE
            TQQY=TQQY*SCALE
            TQQZ=TQQZ*SCALE
         END IF
C
C        TERM 2.B FORCE/TORQUE OF Q2Q2 FOR IEF-PCM PHASE 2
C
         FQ2Q2X = ZERO
         FQ2Q2Y = ZERO
         FQ2Q2Z = ZERO
         TQ2Q2X = ZERO
         TQ2Q2Y = ZERO
         TQ2Q2Z = ZERO
         IF(IEF.EQ.3 .AND. NESFP.EQ.0) THEN
            DO I = 1, NTS
               XI=XCTS(I)
               YI=YCTS(I)
               ZI=ZCTS(I)
               XEI= XE(ISPHE(I))
               YEI= YE(ISPHE(I))
               ZEI= ZE(ISPHE(I))
               RIX=ZERO
               RIY=ZERO
               RIZ=ZERO
               IF(IDSP(ISPHE(I)).EQ.IFRG) THEN
                  RIX=ONE
                  RIY=ONE
                  RIZ=ONE
               END IF
               DO J = 1, NTS
                  AJ=AS(J)
                  LJ=ISPHE(J)
                  RJ=RE(LJ)
                  XJ=XCTS(J)
                  YJ=YCTS(J)
                  ZJ=ZCTS(J)
                  XCJ=(XJ-XE(LJ))/RJ
                  YCJ=(YJ-YE(LJ))/RJ
                  ZCJ=(ZJ-ZE(LJ))/RJ
                  RJX=ZERO
                  RJY=ZERO
                  RJZ=ZERO
                  IF(IDSP(ISPHE(J)).EQ.IFRG) THEN
                     RJX=ONE
                     RJY=ONE
                     RJZ=ONE
                  END IF
                  IF(J.EQ.I) THEN
                     FT=ZERO
                  ELSE
                     DRIJ=SQRT((XI-XJ)**2+(YI-YJ)**2+(ZI-ZJ)**2)
                     DRIJ3=DRIJ**3
                     FT=-(EPS-ONE)*Q2(I)*AJ/FPI/DRIJ3*VECTMP(J)
                  END IF
                  FQ2Q2X=FQ2Q2X+(RIX-RJX)*XCJ*FT
                  FQ2Q2Y=FQ2Q2Y+(RIY-RJY)*YCJ*FT
                  FQ2Q2Z=FQ2Q2Z+(RIZ-RJZ)*ZCJ*FT
                  TQ2Q2X=TQ2Q2X-(RIY-RJY)*YCJ*FT*(ZEI-EFCENT(3,IFRG))
     *                         +(RIZ-RJZ)*ZCJ*FT*(YEI-EFCENT(2,IFRG))
                  TQ2Q2Y=TQ2Q2Y-(RIZ-RJZ)*ZCJ*FT*(XEI-EFCENT(1,IFRG))
     *                         +(RIX-RJX)*XCJ*FT*(ZEI-EFCENT(3,IFRG))
                  TQ2Q2Z=TQ2Q2Z-(RIX-RJX)*XCJ*FT*(YEI-EFCENT(2,IFRG))
     *                         +(RIY-RJY)*YCJ*FT*(XEI-EFCENT(1,IFRG))
               END DO
            END DO
         END IF
C
C
C        TERM 3.FORCE/TORQUE IMPOSED ON ASC(IFRG) BY QM ELECTRONS/NUCLEI
C
         FQELEX = ZERO
         FQELEY = ZERO
         FQELEZ = ZERO
         TQELEX = ZERO
         TQELEY = ZERO
         TQELEZ = ZERO
         FQNUCX = ZERO
         FQNUCY = ZERO
         FQNUCZ = ZERO
         TQNUCX = ZERO
         TQNUCY = ZERO
         TQNUCZ = ZERO
         IF(NAT.GT.0 .AND. NESFP.EQ.0) THEN
            DO ITS = 1, NTS
               IF(IDSP(ISPHE(ITS)).EQ.IFRG) THEN
                  XI = XCTS(ITS)
                  YI = YCTS(ITS)
                  ZI = ZCTS(ITS)
                  XEI= XE(ISPHE(ITS))
                  YEI= YE(ISPHE(ITS))
                  ZEI= ZE(ISPHE(ITS))
                  DO JAT = 1, NAT
                     FQELEX = FQELEX - FEQ(1,JAT,ITS)
                     FQELEY = FQELEY - FEQ(2,JAT,ITS)
                     FQELEZ = FQELEZ - FEQ(3,JAT,ITS)
                     TQELEX = TQELEX
     *                      + FEQ(2,JAT,ITS)*(ZEI-EFCENT(3,IFRG))
     *                      - FEQ(3,JAT,ITS)*(YEI-EFCENT(2,IFRG))
                     TQELEY = TQELEY
     *                      + FEQ(3,JAT,ITS)*(XEI-EFCENT(1,IFRG))
     *                      - FEQ(1,JAT,ITS)*(ZEI-EFCENT(3,IFRG))
                     TQELEZ = TQELEZ
     *                      + FEQ(1,JAT,ITS)*(YEI-EFCENT(2,IFRG))
     *                      - FEQ(2,JAT,ITS)*(XEI-EFCENT(1,IFRG))
C
                     XN = C(1,JAT)
                     YN = C(2,JAT)
                     ZN = C(3,JAT)
                     R2 = (XN-XI)**2+(YN-YI)**2+(ZN-ZI)**2
                     R  = SQRT(R2)
                     R3 = R*R2
                     DUM = ZAN(JAT) * QT(ITS) /R3
                     IF (TDDFT) DUM = DUM + ZAN(JAT) * QSEMN(ITS) /R3
                     IF(MP2PCM) DUM = DUM + ZAN(JAT) * QSEMP(ITS) /R3
                     FQNUCX = FQNUCX + DUM*(XN-XI)
                     FQNUCY = FQNUCY + DUM*(YN-YI)
                     FQNUCZ = FQNUCZ + DUM*(ZN-ZI)
                     TQNUCX = TQNUCX - DUM*(YN-YI)*(ZEI-EFCENT(3,IFRG))
     *                               + DUM*(ZN-ZI)*(YEI-EFCENT(2,IFRG))
                     TQNUCY = TQNUCY - DUM*(ZN-ZI)*(XEI-EFCENT(1,IFRG))
     *                               + DUM*(XN-XI)*(ZEI-EFCENT(3,IFRG))
                     TQNUCZ = TQNUCZ - DUM*(XN-XI)*(YEI-EFCENT(2,IFRG))
     *                               + DUM*(YN-YI)*(XEI-EFCENT(1,IFRG))
                  END DO
               END IF
            END DO
         END IF
C
C        TERM 4. FORCE/TORQUE IMPOSED ON ASC(IFRG) BY ALL EFPS
C
         FQEFPX = ZERO
         FQEFPY = ZERO
         FQEFPZ = ZERO
         TQEFPX = ZERO
         TQEFPY = ZERO
         TQEFPZ = ZERO
         IF(NESFP.EQ.0) THEN
         DO ITS = 1, NTS
            IF(IDSP(ISPHE(ITS)).EQ.IFRG) THEN
               XI = XCTS(ITS)
               YI = YCTS(ITS)
               ZI = ZCTS(ITS)
               XEI= XE(ISPHE(ITS))
               YEI= YE(ISPHE(ITS))
               ZEI= ZE(ISPHE(ITS))
               DO JFRG = 1, NFRG
                  FQEFPX = FQEFPX - FFRGQ(1,JFRG,ITS)
                  FQEFPY = FQEFPY - FFRGQ(2,JFRG,ITS)
                  FQEFPZ = FQEFPZ - FFRGQ(3,JFRG,ITS)
                  TQEFPX = TQEFPX
     *                   + FFRGQ(2,JFRG,ITS)*(ZEI-EFCENT(3,IFRG))
     *                   - FFRGQ(3,JFRG,ITS)*(YEI-EFCENT(2,IFRG))
                  TQEFPY = TQEFPY
     *                   + FFRGQ(3,JFRG,ITS)*(XEI-EFCENT(1,IFRG))
     *                   - FFRGQ(1,JFRG,ITS)*(ZEI-EFCENT(3,IFRG))
                  TQEFPZ = TQEFPZ
     *                   + FFRGQ(1,JFRG,ITS)*(YEI-EFCENT(2,IFRG))
     *                   - FFRGQ(2,JFRG,ITS)*(XEI-EFCENT(1,IFRG))
               END DO
            END IF
         END DO
         END IF
C
C        TERM 5. FORCE/TORQE DUE TO TESSARA AREA CHANGE (FIXPVA)
C
         FAX = ZERO
         FAY = ZERO
         FAZ = ZERO
         TAX = ZERO
         TAY = ZERO
         TAZ = ZERO
         IF(IPCDER.EQ.3 .AND. NESFP.EQ.0) THEN
         SQRTPI = SQRT(3.1415926535897932D+00)
         DO ISP = 1, I_NESF
            IF(IDSP(ISP).EQ.IFRG)THEN
               XEI= XE(ISP)
               YEI= YE(ISP)
               ZEI= ZE(ISP)
               DO ITS = 1, NTS
                  DO III = 1, IDDAI(21,ITS)
                     IF(ISP.EQ.IDDAI(III,ITS)) THEN
                        DUM=-1.07D+00*SQRTPI/
     *                      SQRT(AS(ITS)**3)*0.5D+00*QT(ITS)*QT(ITS)
                        IF(MP2PCM)THEN
                           DUM = DUM -1.07D+00*SQRTPI/SQRT(AS(ITS)**3)*
     *                        (QT(ITS)*QSEMP(ITS))
                        END IF
                        IF(TDDFT) THEN
                           DUM = DUM -1.07D+00*SQRTPI/SQRT(AS(ITS)**3)*
     *                        (QSEXY(ITS)*QSEXY(ITS)+QT(ITS)*QSEMN(ITS))
                        END IF
                        FAX=FAX+DUM*DAI(1,III,ITS)
                        FAY=FAY+DUM*DAI(2,III,ITS)
                        FAZ=FAZ+DUM*DAI(3,III,ITS)
                        TAX=TAX-DUM*DAI(2,III,ITS)*(ZEI-EFCENT(3,IFRG))
     *                         +DUM*DAI(3,III,ITS)*(YEI-EFCENT(2,IFRG))
                        TAY=TAY-DUM*DAI(3,III,ITS)*(XEI-EFCENT(1,IFRG))
     *                         +DUM*DAI(1,III,ITS)*(ZEI-EFCENT(3,IFRG))
                        TAZ=TAZ-DUM*DAI(1,III,ITS)*(YEI-EFCENT(2,IFRG))
     *                         +DUM*DAI(2,III,ITS)*(XEI-EFCENT(1,IFRG))
                     END IF
                  ENDDO
               END DO
            END IF
         ENDDO
C        SCALE FOR C-PCM
         IF(IEF.EQ.10)THEN
            SCALE=EPS/(EPS-ONE)
            FAX=FAX*SCALE
            FAY=FAY*SCALE
            FAZ=FAZ*SCALE
            TAX=TAX*SCALE
            TAY=TAY*SCALE
            TAZ=TAZ*SCALE
         END IF
         END IF
C
C
C
C        COMBINE THE FORCES/TORQUES
C
         DSOLEF(1,IFRG) = FEFPQX + FQQX   + FQ2QX  + FAX
     *                  + FQ2Q2X + FQELEX + FQNUCX + FQEFPX
         DSOLEF(2,IFRG) = FEFPQY + FQQY   + FQ2QY  + FAY
     *                  + FQ2Q2Y + FQELEY + FQNUCY + FQEFPY
         DSOLEF(3,IFRG) = FEFPQZ + FQQZ   + FQ2QZ  + FAZ
     *                  + FQ2Q2Z + FQELEZ + FQNUCZ + FQEFPZ
         DSOLEF(4,IFRG) = TEFPQX + TQQX   + TQ2QX  + TAX
     *                  + TQ2Q2X + TQELEX + TQNUCX + TQEFPX
         DSOLEF(5,IFRG) = TEFPQY + TQQY   + TQ2QY  + TAY
     *                  + TQ2Q2Y + TQELEY + TQNUCY + TQEFPY
         DSOLEF(6,IFRG) = TEFPQZ + TQQZ   + TQ2QZ  + TAZ
     *                  + TQ2Q2Z + TQELEZ + TQNUCZ + TQEFPZ

 200  CONTINUE
C
      DO IFRG=1,NFRG
        DO IXYZ=1,6
          IF(ICAV.EQ.1 .OR. IDISP.EQ.1) THEN
             DPCMFRG(IXYZ,IFRG)=DSOLEF(IXYZ,IFRG)+DPCMFRG(IXYZ,IFRG)
          ELSE
             DPCMFRG(IXYZ,IFRG)=DSOLEF(IXYZ,IFRG)
          END IF
        END DO
      END DO
C
      RETURN
      END
C
C*MODULE MLTFMO  *DECK readASCFMOFDD
C>    @brief   FMO/FDD/PCM
C>
C>    @details PCM density save
C>
C>    @author  hiroya  nakata
C>
C>    @param YALAG  law-layer density
C>    @param lenrec length for density matrix
      subroutine readASCFMOFDD(YALAG,lenrec)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
    
      CHARACTER*8 PCMELQ
      parameter (MXATM=2000)
      LOGICAL GOPARR,DSKWRK,MASWRK,isgddi,parout,INITGDDI,wasgddi,MLGDDI
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /OPTGRD/ XDUM(3*MXATM),ES,FE(20),
     *                CONVF,FMAXT,DXMAXT,RMAX,RMIN,RLIM,
     *                EIGMAX,EIGMIN,GRDERR,FRMS,FMAX,TRMAX,TRMIN,
     *                IC(20),NSTEP,NSERCH,NPMAX,NP,IFOLOW,
     *                NNEG,IUPHSS,IEXIT,ITRUPD,IPAD,kdiagf
C
      DIMENSION YALAG(*)
C
      Integer ddi_world,ddi_group
      Parameter(ddi_world=0,ddi_group=1)
C
      if(isgddi) call gddi_scope(ddi_world)
      IF(MASWRK) WRITE(IW,'("Read Frozen Den for ASC")')
      IF(MASWRK) WRITE(IW,'("The ASC for FDD/PCM will be in inidfmo")')
C
      IF(NSERCH.EQ.0) THEN
   

       PCMELQ= ' $PCMELQ' 
       CALL SEQREW(IR)
       CALL FNDGRP(IR,PCMELQ,IEOF)
       IF (IEOF.EQ.0) GO TO 200
C
       IF (MASWRK) WRITE(IW,'("NSERCH=",I3)') NSERCH
       IF (MASWRK) WRITE(IW,9020)
       CALL ABRT
       STOP
C
  200  CONTINUE
       IERR=0
       IF (MASWRK) THEN
         read(ir,9150) (YALAG(ii),ii=1,lenrec)
       END IF
       IF (GOPARR) THEN 
         CALL DDI_BCAST(351,'F',YALAG,lenrec,MASTER)
       END IF
      ELSE
       CALL daread(IDAF,IODA,YALAG,lenrec,40,0)
       IERR=0
      END IF
C
C
      IF(IERR.NE.0) THEN
        IF(MASWRK) THEN
          WRITE(IW,'("Failure Reading the ASC for FDD/PCM")')
        END IF 
        call abrt
      ELSE 
        IF(MASWRK) WRITE(IW,'("Successfully Reading Density")')
      END IF
C
C

      if(isgddi) call gddi_scope(ddi_group)
C
      RETURN
 9020 FORMAT(28(1H-),"NO $PCMELQ INPUT FOUND - STOP")
 9150 format(1x,5E15.8)
      END
C
C*MODULE MLTFMO  *DECK fddpcmesolv
C>    @brief   FMO/FDD/PCM
C>
C>    @details PCM energy solve
C>
C>    @author  hiroya  nakata
C>
C>    @param esolve solvent energy   
C>    @param number of fragment
C>    @param job type
      subroutine fddpcmesolv(esolv,nfg,job)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
    
      CHARACTER*8 PCMELQ
      parameter (MXATM=2000,ZERO=0.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK,isgddi,parout,INITGDDI,wasgddi,mlgddi
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI,NSUBGR,
     *                MeUniv,NPUniv
      COMMON /OPTGRD/ XDUM(3*MXATM),ES,FE(20),
     *                CONVF,FMAXT,DXMAXT,RMAX,RMIN,RLIM,
     *                EIGMAX,EIGMIN,GRDERR,FRMS,FMAX,TRMAX,TRMIN,
     *                IC(20),NSTEP,NSERCH,NPMAX,NP,IFOLOW,
     *                NNEG,IUPHSS,IEXIT,ITRUPD,IPAD,kdiagf
C
      DIMENSION esolv(*)
C
      Integer ddi_world,ddi_group
      Parameter(ddi_world=0,ddi_group=1)
C
C
      if(job.eq.0) then

       if(isgddi) call gddi_scope(ddi_world)
C
       IF(NSERCH.EQ.0) THEN
        PCMELQ= ' $FMOSLV' 
        CALL SEQREW(IR)
        CALL FNDGRP(IR,PCMELQ,IEOF)
        IF (IEOF.EQ.0) GO TO 200
C
        IF (MASWRK) WRITE(IW,9020)
        CALL ABRT
        STOP
C
  200   CONTINUE
        IF (MASWRK) THEN
           READ(ir,'(4F20.16)') (esolv(ifg),ifg=1,nfg)
        END IF
       ELSE
        CALL DAREAD(IDAF,IODA,esolv,NFG,41,0)
        if(.not.maswrk) then
         do ifg = 1,NFG
           esolv(ifg)=zero
         end do
        end if
       END IF
C
       if(isgddi) call gddi_scope(ddi_group)
      end if
C
      IF(JOB.EQ.1) THEN
        WRITE(IP,'(" $FMOSLV")')
        WRITE(IP,'(4F20.16)') (ESOLV(IFG),IFG=1,NFG)
      END IF
C
C
      RETURN
 9020 FORMAT(28(1H-),"NO $FMOSLV INPUT FOUND - STOP")
      END
C
C*MODULE MLTFMO  *DECK PCMFDDGMEM1
C>    @brief   FMO/FDD/PCM
C>
C>    @details get memory
C>
C>    @author  hiroya  nakata
C>
C>    @param number of dimension
C>    @param maximum number of dimension
C>    @param number of fragment
C>    @param layer  of fragment
C>    @param number of fragment
      SUBROUTINE  PCMFDDGMEM1(ndim,maxdim,numfrg,layfrg,nfg)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION numfrg(*),layfrg(*)
C
C
      ndim   = 0
      maxdim = 0
      DO I = 1, NFG
        IF(layfrg(I).eq.2) THEN
          numI   = numfrg(I)
          l2i    = (numI + numI*numI)/2
          ndim   = ndim  + l2i
          maxdim = MAX(maxdim,l2i)
C       WRITE(6,*) 'NQMT NAI', NQMT, NAI
        END IF
      END DO

      RETURN
      END
C
C*MODULE MLTFMO  *DECK PCMFDDGMEM2
C>    @brief   FMO/FDD/PCM
C>
C>    @details get memory
C>
C>    @author  hiroya  nakata
C>
C>    @param IPTLG   indice for fragment
C>    @param numfrg  number of orbital for fragment
C>    @param layfrg  layer  of fragment
C>    @param nfg     number of fragment
      SUBROUTINE PCMFDDGMEM2(IPTLG,numfrg,layfrg,nfg)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPTLG(*),numfrg(*),layfrg(*)
C
      IPT = 1
      DO I = 1, NFG
        IPTLG(I) = IPT
        IF(layfrg(I).eq.2) THEN
         numI = numfrg(I) 
         l2I  = (numI+numI*numI)/2
         IPT  = IPT + l2i 
        END IF
      END DO
      IPTLG(NFG+1) = IPT - 1
C
      RETURN
      END
