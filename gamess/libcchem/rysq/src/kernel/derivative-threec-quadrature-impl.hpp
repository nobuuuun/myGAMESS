/**  
 @file 
 @warning Automatically Generated
*/
/**  
 @warning AUTOMATICALLY GENERATED
*/



#ifndef RYSQ_KERNEL_DERIVATIVE_THREEC_QUADRATURE_IMPL_HPP_
#define RYSQ_KERNEL_DERIVATIVE_THREEC_QUADRATURE_IMPL_HPP_

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

// #include <pmmintrin.h>

#ifdef RYSQ_WITH_SSE
#warning "Using SSE3 instructions"
#include <pmmintrin.h>
#include <xmmintrin.h>


#define D128 __m128d
#define ZERO _mm_setzero_pd()
#define SET1(v) _mm_set1_pd((v))

#define LOAD(m) _mm_load_pd((m))
#define LOADU(m) _mm_loadu_pd((m))
#define LOAD1(m) _mm_load_sd((m))
#define	LOADDUP(m) _mm_loaddup_pd((m))

#define STORE(m,r) _mm_store_pd((m), (r))
#define STOREU(m,r) _mm_storeu_pd((m), (r))
#define STORE1(m,r) _mm_store_sd((m), (r))

#define MUL(x,y) _mm_mul_pd((x), (y))
#define ADD(a,b) _mm_add_pd((a), (b))
#define HADD(a,b) _mm_hadd_pd((a), (b))

#define MUL1(x,y) _mm_mul_sd((x), (y))
#define ADD1(a,b) _mm_add_sd((a), (b))

#endif

#include <math.h>
#include "meta.hpp"
#include "kernel/forward.hpp"



namespace rysq {
namespace kernel {
namespace threec_derivative_quadrature {



#define RI_RYSQ_NORMAL_000 1.0000000000000000 /**< @brief (0 0 0) normalization constant */ 
#define RI_RYSQ_NORMAL_100 1.0000000000000000 /**< @brief (1 0 0) normalization constant */ 
#define RI_RYSQ_NORMAL_200 1.0000000000000000 /**< @brief (2 0 0) normalization constant */ 
#define RI_RYSQ_NORMAL_110 1.7320508075688772 /**< @brief (1 1 0) normalization constant */ 
#define RI_RYSQ_NORMAL_300 1.0000000000000000 /**< @brief (3 0 0) normalization constant */ 
#define RI_RYSQ_NORMAL_210 2.2360679774997898 /**< @brief (2 1 0) normalization constant */ 
#define RI_RYSQ_NORMAL_111 3.8729833462074170 /**< @brief (1 1 1) normalization constant */ 
#define RI_RYSQ_NORMAL_400 1.0000000000000000 /**< @brief (4 0 0) normalization constant */ 
#define RI_RYSQ_NORMAL_310 2.6457513110645907 /**< @brief (3 1 0) normalization constant */ 
#define RI_RYSQ_NORMAL_220 3.4156502553198660 /**< @brief (2 2 0) normalization constant */ 
#define RI_RYSQ_NORMAL_211 5.9160797830996161 /**< @brief (2 1 1) normalization constant */ 
#define RI_RYSQ_NORMAL_500 1.0000000000000000 /**< @brief (5 0 0) normalization constant */ 
#define RI_RYSQ_NORMAL_410 3.0000000000000000 /**< @brief (4 1 0) normalization constant */ 
#define RI_RYSQ_NORMAL_320 4.5825756949558398 /**< @brief (3 2 0) normalization constant */ 
#define RI_RYSQ_NORMAL_311 7.9372539331937721 /**< @brief (3 1 1) normalization constant */ 
#define RI_RYSQ_NORMAL_221 10.2469507659595980 /**< @brief (2 2 1) normalization constant */ 



const double NORMALIZE[] = {
	RI_RYSQ_NORMAL_000,
	RI_RYSQ_NORMAL_100, RI_RYSQ_NORMAL_100, RI_RYSQ_NORMAL_100,
	RI_RYSQ_NORMAL_200, RI_RYSQ_NORMAL_200, RI_RYSQ_NORMAL_200,
	RI_RYSQ_NORMAL_110, RI_RYSQ_NORMAL_110, RI_RYSQ_NORMAL_110,
	RI_RYSQ_NORMAL_300, RI_RYSQ_NORMAL_300, RI_RYSQ_NORMAL_300,
	RI_RYSQ_NORMAL_210, RI_RYSQ_NORMAL_210, RI_RYSQ_NORMAL_210, RI_RYSQ_NORMAL_210, RI_RYSQ_NORMAL_210, RI_RYSQ_NORMAL_210,
	RI_RYSQ_NORMAL_111,
	RI_RYSQ_NORMAL_400, RI_RYSQ_NORMAL_400, RI_RYSQ_NORMAL_400,
	RI_RYSQ_NORMAL_310, RI_RYSQ_NORMAL_310, RI_RYSQ_NORMAL_310, RI_RYSQ_NORMAL_310, RI_RYSQ_NORMAL_310, RI_RYSQ_NORMAL_310,
	RI_RYSQ_NORMAL_220, RI_RYSQ_NORMAL_220, RI_RYSQ_NORMAL_220,
	RI_RYSQ_NORMAL_211, RI_RYSQ_NORMAL_211, RI_RYSQ_NORMAL_211,
	RI_RYSQ_NORMAL_500, RI_RYSQ_NORMAL_500, RI_RYSQ_NORMAL_500,
	RI_RYSQ_NORMAL_410, RI_RYSQ_NORMAL_410, RI_RYSQ_NORMAL_410, RI_RYSQ_NORMAL_410, RI_RYSQ_NORMAL_410, RI_RYSQ_NORMAL_410,
	RI_RYSQ_NORMAL_320, RI_RYSQ_NORMAL_320, RI_RYSQ_NORMAL_320, RI_RYSQ_NORMAL_320, RI_RYSQ_NORMAL_320, RI_RYSQ_NORMAL_320,
	RI_RYSQ_NORMAL_311, RI_RYSQ_NORMAL_311, RI_RYSQ_NORMAL_311,
	RI_RYSQ_NORMAL_221, RI_RYSQ_NORMAL_221, RI_RYSQ_NORMAL_221};

    //unrolled bras

#define Ix(a,i,j) (Ix[(a) + (i)*NT + (j)*(NT*Li1)])
#define Iy(a,i,j) (Iy[(a) + (i)*NT + (j)*(NT*Li1)])
#define Iz(a,i,j) (Iz[(a) + (i)*NT + (j)*(NT*Li1)])


/** 
    @brief <ss| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::S,rysq::S> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::S,rysq::S> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 2;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q2 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q3 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q4 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q5 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <ps| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::P,rysq::S> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::P,rysq::S> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q3 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q4 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q5 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q6 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q7 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q8 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q9 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0); // d/dBx
	    q11 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0); // d/dBx
	    q12 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q13 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q14 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q15 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q16 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q17 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <ds| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::D,rysq::S> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::D,rysq::S> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 4;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0); // d/dAx
	    q3 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q5 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAx
	    q6 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q7 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q8 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q9 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q11 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q12 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q13 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q14 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q15 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q16 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q17 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q18 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q19 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0); // d/dBx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0); // d/dBx
	    q21 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0); // d/dBx
	    q22 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0); // d/dBx
	    q23 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0); // d/dBx
	    q24 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q25 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q26 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q27 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q28 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q29 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q31 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q32 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q33 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q34 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q35 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <fs| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::F,rysq::S> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::F,rysq::S> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 5;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,0); // d/dAx
	    q3 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q5 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0); // d/dAx
	    q7 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0); // d/dAx
	    q9 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q11 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q12 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q13 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q14 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q15 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q16 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q17 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q18 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q19 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q21 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q22 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q23 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q24 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q25 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q26 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q27 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q28 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q29 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q31 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0); // d/dBx
	    q32 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0); // d/dBx
	    q33 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0); // d/dBx
	    q34 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0); // d/dBx
	    q35 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0); // d/dBx
	    q36 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0); // d/dBx
	    q37 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0); // d/dBx
	    q38 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0); // d/dBx
	    q39 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0); // d/dBx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q41 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q42 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q43 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q44 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q45 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q46 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q47 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q48 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q49 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q51 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q52 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q53 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q54 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q55 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q56 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q57 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q58 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q59 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <gs| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::G,rysq::S> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::G,rysq::S> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 6;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,5,0)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,0); // d/dAx
	    q3 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q5 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,0); // d/dAx
	    q7 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,0); // d/dAx
	    q9 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,0); // d/dAx
	    q12 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q13 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dAx
	    q14 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dAx
	    q15 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q16 += alpha*Ix(a,0,0)*Iy(a,5,0)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dAy
	    q17 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,0); // d/dAy
	    q18 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q19 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q21 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dAy
	    q22 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q23 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dAy
	    q24 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q25 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q26 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,0)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dAy
	    q27 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q28 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q29 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q31 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,0); // d/dAz
	    q32 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,5,0)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dAz
	    q33 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q34 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q35 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q36 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dAz
	    q37 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q38 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dAz
	    q39 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q41 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dAz
	    q42 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q43 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q44 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q45 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q46 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,0); // d/dBx
	    q47 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,0); // d/dBx
	    q48 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,0); // d/dBx
	    q49 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,0); // d/dBx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,0); // d/dBx
	    q51 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,0); // d/dBx
	    q52 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,0); // d/dBx
	    q53 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,0); // d/dBx
	    q54 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,0); // d/dBx
	    q55 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,0); // d/dBx
	    q56 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,0); // d/dBx
	    q57 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0); // d/dBx
	    q58 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0); // d/dBx
	    q59 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0); // d/dBx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q61 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,0); // d/dBy
	    q62 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,0); // d/dBy
	    q63 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q64 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q65 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q66 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,0); // d/dBy
	    q67 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q68 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,0); // d/dBy
	    q69 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q71 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,0); // d/dBy
	    q72 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q73 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q74 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q75 += beta*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q76 += beta*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,1); // d/dBz
	    q77 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,1); // d/dBz
	    q78 += beta*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q79 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += beta*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q81 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,1); // d/dBz
	    q82 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q83 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,1); // d/dBz
	    q84 += beta*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q85 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q86 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,1); // d/dBz
	    q87 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q88 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q89 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <sps| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::SP,rysq::S> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::SP,rysq::S> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q3 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q4 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q5 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q6 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q7 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q8 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q9 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[1];
	I[2] += q2*C_[1];
	I[3] += q3*C_[1];
	I[4] += q4*C_[0];
	I[5] += q5*C_[1];
	I[6] += q6*C_[1];
	I[7] += q7*C_[1];
	I[8] += q8*C_[0];
	I[9] += q9*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q11 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q12 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q13 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q14 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0); // d/dBx
	    q15 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0); // d/dBx
	    q16 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q17 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q18 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q19 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[1];
	I[11] += q11*C_[1];
	I[12] += q12*C_[0];
	I[13] += q13*C_[1];
	I[14] += q14*C_[1];
	I[15] += q15*C_[1];
	I[16] += q16*C_[0];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q21 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q22 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q23 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[1];
	I[22] += q22*C_[1];
	I[23] += q23*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <sp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::S,rysq::P> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::S,rysq::P> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 2;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1); // d/dAx
	    q3 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q4 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q5 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q6 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q7 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q8 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q9 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q11 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q12 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q13 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q14 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q15 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q16 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q17 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <pp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::P,rysq::P> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::P,rysq::P> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q3 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q4 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAx
	    q5 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAx
	    q6 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q11 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q12 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q13 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q14 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q15 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q16 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q17 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q18 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q19 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q21 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q22 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q23 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q24 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q25 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q26 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q27 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q28 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q29 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q31 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBx
	    q32 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBx
	    q33 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q34 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBx
	    q35 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBx
	    q36 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q37 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q38 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q39 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q41 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q42 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q43 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q44 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q45 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q46 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q47 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q48 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q49 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q51 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q52 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q53 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <dp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::D,rysq::P> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::D,rysq::P> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 4;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q3 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0); // d/dAx
	    q4 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0); // d/dAx
	    q5 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1); // d/dAx
	    q6 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1); // d/dAx
	    q9 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q11 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q12 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q13 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q14 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q15 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAx
	    q16 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAx
	    q17 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAx
	    q18 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q19 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q21 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q22 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q23 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q24 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q25 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q26 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q27 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q28 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q29 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q31 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q32 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q33 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q34 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q35 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	    q36 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q37 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q38 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q39 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q41 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	    q42 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q43 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q44 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q45 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q46 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q47 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q48 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q49 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q51 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q52 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q53 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q54 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q55 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q56 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q57 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q58 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBx
	    q59 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q61 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBx
	    q62 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBx
	    q63 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q64 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBx
	    q65 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBx
	    q66 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q67 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBx
	    q68 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBx
	    q69 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBx
	    q71 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBx
	    q72 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q73 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q74 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q75 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q76 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q77 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	    q78 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q79 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q81 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q82 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q83 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q84 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q85 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q86 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q87 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q88 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q89 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q91 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q92 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q93 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q94 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q95 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q96 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q97 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q98 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q99 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q101 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q102 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q103 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q104 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q105 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q106 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q107 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <fp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::F,rysq::P> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::F,rysq::P> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 5;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q3 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,0); // d/dAx
	    q4 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,0); // d/dAx
	    q5 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,1); // d/dAx
	    q6 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,0); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,1); // d/dAx
	    q9 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q11 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q12 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q13 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q14 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q15 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q16 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAx
	    q17 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAx
	    q18 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0); // d/dAx
	    q19 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1); // d/dAx
	    q21 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q22 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAx
	    q23 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAx
	    q24 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0); // d/dAx
	    q25 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1); // d/dAx
	    q27 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q28 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAx
	    q29 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q31 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q32 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q33 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q34 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAy
	    q35 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAy
	    q36 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q37 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,0); // d/dAy
	    q38 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,1); // d/dAy
	    q39 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q41 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q42 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q43 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q44 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q45 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q46 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q47 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q48 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q49 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAy
	    q51 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q52 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q53 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q54 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q55 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAy
	    q56 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAy
	    q57 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q58 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q59 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q61 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q62 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q63 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q64 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,0); // d/dAz
	    q65 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,1); // d/dAz
	    q66 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q67 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAz
	    q68 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAz
	    q69 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q71 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q72 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q73 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q74 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q75 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q76 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q77 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	    q78 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q79 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAz
	    q81 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q82 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q83 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q84 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q85 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAz
	    q86 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAz
	    q87 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q88 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q89 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q91 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q92 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q93 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBx
	    q94 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0); // d/dBx
	    q95 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1); // d/dBx
	    q96 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBx
	    q97 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0); // d/dBx
	    q98 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1); // d/dBx
	    q99 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBx
	    q101 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBx
	    q102 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q103 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBx
	    q104 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBx
	    q105 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q106 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBx
	    q107 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBx
	    q108 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBx
	    q109 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0); // d/dBx
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1); // d/dBx
	    q111 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q112 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBx
	    q113 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBx
	    q114 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBx
	    q115 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0); // d/dBx
	    q116 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1); // d/dBx
	    q117 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q118 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBx
	    q119 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBx
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q121 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q122 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q123 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q124 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBy
	    q125 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1); // d/dBy
	    q126 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q127 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBy
	    q128 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1); // d/dBy
	    q129 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q131 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q132 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q133 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q134 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q135 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q136 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q137 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	    q138 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q139 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1); // d/dBy
	    q141 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q142 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q143 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q144 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q145 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBy
	    q146 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1); // d/dBy
	    q147 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q148 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q149 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q151 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q152 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q153 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q154 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1); // d/dBz
	    q155 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBz
	    q156 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q157 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1); // d/dBz
	    q158 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBz
	    q159 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q161 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q162 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q163 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q164 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q165 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q166 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q167 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q168 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q169 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBz
	    q171 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q172 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q173 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q174 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q175 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1); // d/dBz
	    q176 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBz
	    q177 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q178 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q179 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <gp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::G,rysq::P> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::G,rysq::P> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 6;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,5,1)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,5,0)*Iy(a,0,1)*Iz(a,0,0)
                     - 4*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,5,0)*Iy(a,0,0)*Iz(a,0,1)
                     - 4*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q3 += alpha*Ix(a,1,1)*Iy(a,4,0)*Iz(a,0,0); // d/dAx
	    q4 += alpha*Ix(a,1,0)*Iy(a,4,1)*Iz(a,0,0); // d/dAx
	    q5 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,1); // d/dAx
	    q6 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,4,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,4,0); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,1); // d/dAx
	    q9 += alpha*Ix(a,4,1)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,4,0)*Iy(a,1,1)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q11 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q12 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q13 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,1,0)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q14 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,1)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q15 += alpha*Ix(a,2,1)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dAx
	    q16 += alpha*Ix(a,2,0)*Iy(a,3,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dAx
	    q17 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dAx
	    q18 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,0); // d/dAx
	    q19 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,0); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,1); // d/dAx
	    q21 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dAx
	    q22 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dAx
	    q23 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dAx
	    q24 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,0); // d/dAx
	    q25 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,0); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,1); // d/dAx
	    q27 += alpha*Ix(a,3,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q28 += alpha*Ix(a,3,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAx
	    q29 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q31 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAx
	    q32 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAx
	    q33 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,0); // d/dAx
	    q34 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,0); // d/dAx
	    q35 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,1); // d/dAx
	    q36 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q37 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAx
	    q38 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAx
	    q39 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dAx
	    q41 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dAx
	    q42 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dAx
	    q43 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dAx
	    q44 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dAx
	    q45 += alpha*Ix(a,4,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q46 += alpha*Ix(a,4,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q47 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q48 += alpha*Ix(a,0,1)*Iy(a,5,0)*Iz(a,0,0)
                     - 4*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dAy
	    q49 += alpha*Ix(a,0,0)*Iy(a,5,1)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,0,0)*Iy(a,5,0)*Iz(a,0,1)
                     - 4*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dAy
	    q51 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,4,0); // d/dAy
	    q52 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,4,0); // d/dAy
	    q53 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,1); // d/dAy
	    q54 += alpha*Ix(a,3,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q55 += alpha*Ix(a,3,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q56 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q57 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q58 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q59 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,1,1)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q61 += alpha*Ix(a,1,0)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAy
	    q62 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAy
	    q63 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,1,0)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dAy
	    q64 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dAy
	    q65 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,1)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dAy
	    q66 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q67 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,0); // d/dAy
	    q68 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,1); // d/dAy
	    q69 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dAy
	    q71 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dAy
	    q72 += alpha*Ix(a,2,1)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q73 += alpha*Ix(a,2,0)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q74 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q75 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q76 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q77 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q78 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dAy
	    q79 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,2,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,1)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dAy
	    q81 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q82 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q83 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	    q84 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q85 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAy
	    q86 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAy
	    q87 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q88 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAy
	    q89 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q91 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q92 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q93 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,1,0); // d/dAz
	    q94 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,1,0); // d/dAz
	    q95 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,1); // d/dAz
	    q96 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,5,0)
                     - 4*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dAz
	    q97 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,5,0)
                     - 4*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dAz
	    q98 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,5,1)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dAz
	    q99 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q101 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q102 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q103 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q104 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q105 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q106 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,0); // d/dAz
	    q107 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,1); // d/dAz
	    q108 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dAz
	    q109 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dAz
	    q111 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q112 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAz
	    q113 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAz
	    q114 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dAz
	    q115 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dAz
	    q116 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dAz
	    q117 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q118 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q119 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q121 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q122 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q123 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dAz
	    q124 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dAz
	    q125 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dAz
	    q126 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q127 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q128 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q129 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAz
	    q131 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAz
	    q132 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q133 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAz
	    q134 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAz
	    q135 += beta*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q136 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q137 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q138 += beta*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,0);  // d/dBx
	    q139 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,0); // d/dBx
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,1); // d/dBx
	    q141 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,0);  // d/dBx
	    q142 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,0); // d/dBx
	    q143 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,1); // d/dBx
	    q144 += beta*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q145 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBx
	    q146 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBx
	    q147 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q148 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBx
	    q149 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBx
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += beta*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBx
	    q151 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,0); // d/dBx
	    q152 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,1); // d/dBx
	    q153 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,0);  // d/dBx
	    q154 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,0); // d/dBx
	    q155 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,1); // d/dBx
	    q156 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBx
	    q157 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,0); // d/dBx
	    q158 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,1); // d/dBx
	    q159 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,0); // d/dBx
	    q161 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,1); // d/dBx
	    q162 += beta*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q163 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBx
	    q164 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBx
	    q165 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q166 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBx
	    q167 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBx
	    q168 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,0);  // d/dBx
	    q169 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,0); // d/dBx
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,1); // d/dBx
	    q171 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q172 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBx
	    q173 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBx
	    q174 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBx
	    q175 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,0); // d/dBx
	    q176 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,1); // d/dBx
	    q177 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBx
	    q178 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,0); // d/dBx
	    q179 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,1); // d/dBx
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q181 += beta*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q182 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q183 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,0); // d/dBy
	    q184 += beta*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,0);  // d/dBy
	    q185 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,1); // d/dBy
	    q186 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,0); // d/dBy
	    q187 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,0);  // d/dBy
	    q188 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,1); // d/dBy
	    q189 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += beta*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q191 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q192 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q193 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q194 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q195 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q196 += beta*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBy
	    q197 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,1); // d/dBy
	    q198 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,0); // d/dBy
	    q199 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,1); // d/dBy
	    q201 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q202 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBy
	    q203 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,1); // d/dBy
	    q204 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,0); // d/dBy
	    q205 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,0);  // d/dBy
	    q206 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,1); // d/dBy
	    q207 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q208 += beta*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q209 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q211 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q212 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q213 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,0); // d/dBy
	    q214 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,0);  // d/dBy
	    q215 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,1); // d/dBy
	    q216 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q217 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q218 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	    q219 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];
	I[216] += q216*C_[0];
	I[217] += q217*C_[0];
	I[218] += q218*C_[0];
	I[219] += q219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBy
	    q221 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,1); // d/dBy
	    q222 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q223 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBy
	    q224 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,1); // d/dBy
	    q225 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q226 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q227 += beta*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q228 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,1); // d/dBz
	    q229 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[0];
	I[222] += q222*C_[0];
	I[223] += q223*C_[0];
	I[224] += q224*C_[0];
	I[225] += q225*C_[0];
	I[226] += q226*C_[0];
	I[227] += q227*C_[0];
	I[228] += q228*C_[0];
	I[229] += q229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += beta*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,0);  // d/dBz
	    q231 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,1); // d/dBz
	    q232 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,1); // d/dBz
	    q233 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,0);  // d/dBz
	    q234 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q235 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q236 += beta*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q237 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q238 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q239 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[230] += q230*C_[0];
	I[231] += q231*C_[0];
	I[232] += q232*C_[0];
	I[233] += q233*C_[0];
	I[234] += q234*C_[0];
	I[235] += q235*C_[0];
	I[236] += q236*C_[0];
	I[237] += q237*C_[0];
	I[238] += q238*C_[0];
	I[239] += q239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q241 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,1); // d/dBz
	    q242 += beta*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBz
	    q243 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,1); // d/dBz
	    q244 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,1); // d/dBz
	    q245 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,0);  // d/dBz
	    q246 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q247 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,1); // d/dBz
	    q248 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBz
	    q249 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,1); // d/dBz
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,1); // d/dBz
	    q251 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,0);  // d/dBz
	    q252 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q253 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q254 += beta*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q255 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q256 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q257 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q258 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,1); // d/dBz
	    q259 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,1); // d/dBz
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[0];
	I[256] += q256*C_[0];
	I[257] += q257*C_[0];
	I[258] += q258*C_[0];
	I[259] += q259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,0);  // d/dBz
	    q261 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q262 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q263 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	    q264 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q265 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,1); // d/dBz
	    q266 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBz
	    q267 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q268 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,1); // d/dBz
	    q269 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[0];
	I[262] += q262*C_[0];
	I[263] += q263*C_[0];
	I[264] += q264*C_[0];
	I[265] += q265*C_[0];
	I[266] += q266*C_[0];
	I[267] += q267*C_[0];
	I[268] += q268*C_[0];
	I[269] += q269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <spp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::SP,rysq::P> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::SP,rysq::P> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1); // d/dAx
	    q3 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q5 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q6 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[1];
	I[4] += q4*C_[1];
	I[5] += q5*C_[1];
	I[6] += q6*C_[1];
	I[7] += q7*C_[1];
	I[8] += q8*C_[1];
	I[9] += q9*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAx
	    q12 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q13 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q14 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q15 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q16 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q17 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q18 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q19 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[1];
	I[11] += q11*C_[1];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[1];
	I[16] += q16*C_[1];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q21 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q22 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q23 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q24 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q25 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q26 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q27 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q28 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q29 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[20] += q20*C_[1];
	I[21] += q21*C_[1];
	I[22] += q22*C_[1];
	I[23] += q23*C_[1];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[1];
	I[28] += q28*C_[1];
	I[29] += q29*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q31 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q32 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q33 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q34 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q35 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q36 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q37 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q38 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q39 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[1];
	I[31] += q31*C_[1];
	I[32] += q32*C_[1];
	I[33] += q33*C_[1];
	I[34] += q34*C_[1];
	I[35] += q35*C_[1];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q41 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q42 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q43 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBx
	    q44 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBx
	    q45 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q46 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBx
	    q47 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBx
	    q48 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q49 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[1];
	I[41] += q41*C_[1];
	I[42] += q42*C_[1];
	I[43] += q43*C_[1];
	I[44] += q44*C_[1];
	I[45] += q45*C_[1];
	I[46] += q46*C_[1];
	I[47] += q47*C_[1];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q51 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q52 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q53 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q54 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q55 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q56 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q57 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q58 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q59 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[1];
	I[52] += q52*C_[1];
	I[53] += q53*C_[1];
	I[54] += q54*C_[1];
	I[55] += q55*C_[1];
	I[56] += q56*C_[1];
	I[57] += q57*C_[1];
	I[58] += q58*C_[1];
	I[59] += q59*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q61 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q62 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q63 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q64 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q65 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q66 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q67 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q68 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q69 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[1];
	I[64] += q64*C_[1];
	I[65] += q65*C_[1];
	I[66] += q66*C_[1];
	I[67] += q67*C_[1];
	I[68] += q68*C_[1];
	I[69] += q69*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q71 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[70] += q70*C_[1];
	I[71] += q71*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <sd| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::S,rysq::D> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::S,rysq::D> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 2;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2); // d/dAx
	    q3 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0); // d/dAx
	    q4 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1); // d/dAx
	    q5 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1); // d/dAx
	    q6 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q7 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q8 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q9 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q11 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q12 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q13 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q14 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q15 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q16 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q17 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q18 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q19 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0); // d/dBx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2); // d/dBx
	    q21 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q22 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q23 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBx
	    q24 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q25 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q26 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q27 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q28 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q29 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q31 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q32 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q33 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q34 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q35 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <pd| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::P,rysq::D> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::P,rysq::D> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q3 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	    q6 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1); // d/dAx
	    q12 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q13 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0); // d/dAx
	    q14 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2); // d/dAx
	    q15 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0); // d/dAx
	    q16 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1); // d/dAx
	    q17 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1); // d/dAx
	    q18 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q19 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q21 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q22 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q23 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q24 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q25 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	    q26 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q27 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q28 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q29 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q31 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q32 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q33 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q34 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q35 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	    q36 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q37 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q38 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q39 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q41 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q42 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q43 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q44 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q45 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q46 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q47 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	    q48 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q49 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q51 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q52 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q53 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	    q54 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q55 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0); // d/dBx
	    q56 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2); // d/dBx
	    q57 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q58 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q59 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q61 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0); // d/dBx
	    q62 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2); // d/dBx
	    q63 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q64 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q65 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBx
	    q66 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q67 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0); // d/dBx
	    q68 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2); // d/dBx
	    q69 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q71 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBx
	    q72 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q73 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q74 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q75 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q76 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q77 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q78 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q79 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q81 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q82 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q83 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	    q84 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q85 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	    q86 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q87 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q88 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q89 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q91 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q92 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q93 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q94 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q95 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q96 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q97 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	    q98 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q99 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q101 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	    q102 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q103 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q104 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q105 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q106 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q107 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <dd| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::D,rysq::D> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::D,rysq::D> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 4;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q3 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	    q6 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,0); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,2); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1); // d/dAx
	    q12 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,0); // d/dAx
	    q13 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,0); // d/dAx
	    q14 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,2); // d/dAx
	    q15 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0); // d/dAx
	    q16 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1); // d/dAx
	    q17 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1); // d/dAx
	    q18 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q19 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dAx
	    q21 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q22 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q23 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dAx
	    q24 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q25 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dAx
	    q26 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dAx
	    q27 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q28 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q29 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAx
	    q31 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAx
	    q32 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAx
	    q33 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAx
	    q34 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAx
	    q35 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAx
	    q36 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q37 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q38 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q39 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q41 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q42 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q43 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dAy
	    q44 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dAy
	    q45 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q46 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q47 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dAy
	    q48 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q49 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,0); // d/dAy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,2); // d/dAy
	    q51 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q52 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q53 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1); // d/dAy
	    q54 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q55 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	    q56 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q57 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q58 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q59 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q61 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q62 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q63 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q64 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q65 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	    q66 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q67 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dAy
	    q68 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dAy
	    q69 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	    q71 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dAy
	    q72 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q73 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q74 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q75 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q76 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q77 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q78 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q79 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,2); // d/dAz
	    q81 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q82 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	    q83 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1); // d/dAz
	    q84 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q85 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dAz
	    q86 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dAz
	    q87 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q88 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q89 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q91 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q92 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q93 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q94 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q95 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	    q96 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q97 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	    q98 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q99 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q101 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	    q102 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q103 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dAz
	    q104 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dAz
	    q105 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q106 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q107 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dAz
	    q108 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q109 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,0); // d/dBx
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,2); // d/dBx
	    q111 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q112 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q113 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBx
	    q114 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q115 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,0); // d/dBx
	    q116 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,2); // d/dBx
	    q117 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dBx
	    q118 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dBx
	    q119 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1); // d/dBx
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q121 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,0); // d/dBx
	    q122 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,2); // d/dBx
	    q123 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dBx
	    q124 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dBx
	    q125 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1); // d/dBx
	    q126 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q127 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0); // d/dBx
	    q128 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2); // d/dBx
	    q129 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q131 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBx
	    q132 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q133 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0); // d/dBx
	    q134 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2); // d/dBx
	    q135 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q136 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q137 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBx
	    q138 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q139 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0); // d/dBx
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2); // d/dBx
	    q141 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dBx
	    q142 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dBx
	    q143 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1); // d/dBx
	    q144 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q145 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q146 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q147 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q148 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q149 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q151 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dBy
	    q152 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,2); // d/dBy
	    q153 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q154 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	    q155 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dBy
	    q156 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q157 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dBy
	    q158 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,2); // d/dBy
	    q159 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q161 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dBy
	    q162 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q163 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	    q164 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q165 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q166 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q167 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	    q168 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q169 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q171 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q172 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q173 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	    q174 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q175 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dBy
	    q176 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2); // d/dBy
	    q177 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q178 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	    q179 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q181 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q182 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q183 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q184 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q185 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q186 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q187 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,1); // d/dBz
	    q188 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dBz
	    q189 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q191 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dBz
	    q192 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q193 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,1); // d/dBz
	    q194 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dBz
	    q195 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q196 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q197 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dBz
	    q198 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q199 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q201 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q202 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q203 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	    q204 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q205 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q206 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q207 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q208 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q209 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q211 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1); // d/dBz
	    q212 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dBz
	    q213 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q214 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	    q215 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <fd| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::F,rysq::D> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::F,rysq::D> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 5;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q3 += alpha*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	    q6 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,0); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,2); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,1); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,1); // d/dAx
	    q12 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,0); // d/dAx
	    q13 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,0); // d/dAx
	    q14 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,2); // d/dAx
	    q15 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,0); // d/dAx
	    q16 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,1); // d/dAx
	    q17 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,1); // d/dAx
	    q18 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q19 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dAx
	    q21 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q22 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q23 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dAx
	    q24 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q25 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dAx
	    q26 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dAx
	    q27 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q28 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q29 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q31 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dAx
	    q32 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dAx
	    q33 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dAx
	    q34 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dAx
	    q35 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dAx
	    q36 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,0); // d/dAx
	    q37 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,0); // d/dAx
	    q38 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,2); // d/dAx
	    q39 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,0); // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,1); // d/dAx
	    q41 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,1); // d/dAx
	    q42 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q43 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dAx
	    q44 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dAx
	    q45 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dAx
	    q46 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dAx
	    q47 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dAx
	    q48 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,0); // d/dAx
	    q49 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,0); // d/dAx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,2); // d/dAx
	    q51 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,0); // d/dAx
	    q52 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,1); // d/dAx
	    q53 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,1); // d/dAx
	    q54 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q55 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dAx
	    q56 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dAx
	    q57 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dAx
	    q58 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dAx
	    q59 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q61 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q62 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q63 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q64 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q65 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q66 += alpha*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q67 += alpha*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dAy
	    q68 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,2)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dAy
	    q69 += alpha*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dAy
	    q71 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dAy
	    q72 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q73 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,0); // d/dAy
	    q74 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,2); // d/dAy
	    q75 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,0); // d/dAy
	    q76 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,1); // d/dAy
	    q77 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,1); // d/dAy
	    q78 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q79 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q81 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q82 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q83 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	    q84 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q85 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q86 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q87 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q88 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q89 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q91 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dAy
	    q92 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dAy
	    q93 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q94 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q95 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dAy
	    q96 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q97 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dAy
	    q98 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,2)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dAy
	    q99 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dAy
	    q101 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,1)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dAy
	    q102 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q103 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,0); // d/dAy
	    q104 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,2); // d/dAy
	    q105 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q106 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q107 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,1); // d/dAy
	    q108 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q109 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dAy
	    q111 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dAy
	    q112 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dAy
	    q113 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dAy
	    q114 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q115 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dAy
	    q116 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dAy
	    q117 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q118 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	    q119 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q121 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q122 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q123 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q124 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q125 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q126 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q127 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,0); // d/dAz
	    q128 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,2); // d/dAz
	    q129 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,1); // d/dAz
	    q131 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,1); // d/dAz
	    q132 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q133 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dAz
	    q134 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,2)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dAz
	    q135 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dAz
	    q136 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dAz
	    q137 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dAz
	    q138 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q139 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q141 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q142 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q143 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	    q144 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q145 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	    q146 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q147 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q148 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q149 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q151 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,0); // d/dAz
	    q152 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,2); // d/dAz
	    q153 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q154 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	    q155 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,1); // d/dAz
	    q156 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q157 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dAz
	    q158 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dAz
	    q159 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dAz
	    q161 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dAz
	    q162 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q163 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dAz
	    q164 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dAz
	    q165 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q166 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q167 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dAz
	    q168 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q169 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dAz
	    q171 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dAz
	    q172 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dAz
	    q173 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dAz
	    q174 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q175 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dAz
	    q176 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dAz
	    q177 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q178 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q179 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += beta*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q181 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,0); // d/dBx
	    q182 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,2); // d/dBx
	    q183 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q184 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q185 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBx
	    q186 += beta*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dBx
	    q187 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,0); // d/dBx
	    q188 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,2); // d/dBx
	    q189 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dBx
	    q191 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,1); // d/dBx
	    q192 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dBx
	    q193 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,0); // d/dBx
	    q194 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,2); // d/dBx
	    q195 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dBx
	    q196 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dBx
	    q197 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,1); // d/dBx
	    q198 += beta*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q199 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,0); // d/dBx
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,2); // d/dBx
	    q201 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q202 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q203 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBx
	    q204 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q205 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,0); // d/dBx
	    q206 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,2); // d/dBx
	    q207 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q208 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q209 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBx
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += beta*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q211 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,0); // d/dBx
	    q212 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,2); // d/dBx
	    q213 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dBx
	    q214 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dBx
	    q215 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1); // d/dBx
	    q216 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dBx
	    q217 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,0); // d/dBx
	    q218 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,2); // d/dBx
	    q219 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];
	I[216] += q216*C_[0];
	I[217] += q217*C_[0];
	I[218] += q218*C_[0];
	I[219] += q219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dBx
	    q221 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1); // d/dBx
	    q222 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q223 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,0); // d/dBx
	    q224 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,2); // d/dBx
	    q225 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dBx
	    q226 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dBx
	    q227 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1); // d/dBx
	    q228 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dBx
	    q229 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,0); // d/dBx
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[0];
	I[222] += q222*C_[0];
	I[223] += q223*C_[0];
	I[224] += q224*C_[0];
	I[225] += q225*C_[0];
	I[226] += q226*C_[0];
	I[227] += q227*C_[0];
	I[228] += q228*C_[0];
	I[229] += q229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,2); // d/dBx
	    q231 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dBx
	    q232 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dBx
	    q233 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1); // d/dBx
	    q234 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q235 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0); // d/dBx
	    q236 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2); // d/dBx
	    q237 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dBx
	    q238 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dBx
	    q239 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1); // d/dBx
	}
	    
	//contraction coefficients
	I[230] += q230*C_[0];
	I[231] += q231*C_[0];
	I[232] += q232*C_[0];
	I[233] += q233*C_[0];
	I[234] += q234*C_[0];
	I[235] += q235*C_[0];
	I[236] += q236*C_[0];
	I[237] += q237*C_[0];
	I[238] += q238*C_[0];
	I[239] += q239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q241 += beta*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q242 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q243 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q244 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q245 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q246 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q247 += beta*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dBy
	    q248 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,2); // d/dBy
	    q249 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,1); // d/dBy
	    q251 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dBy
	    q252 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q253 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dBy
	    q254 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,2); // d/dBy
	    q255 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dBy
	    q256 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,1); // d/dBy
	    q257 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dBy
	    q258 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q259 += beta*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[0];
	I[256] += q256*C_[0];
	I[257] += q257*C_[0];
	I[258] += q258*C_[0];
	I[259] += q259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q261 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q262 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q263 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	    q264 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q265 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	    q266 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q267 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q268 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q269 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[0];
	I[262] += q262*C_[0];
	I[263] += q263*C_[0];
	I[264] += q264*C_[0];
	I[265] += q265*C_[0];
	I[266] += q266*C_[0];
	I[267] += q267*C_[0];
	I[268] += q268*C_[0];
	I[269] += q269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q270 = 0.0;
	T q271 = 0.0;
	T q272 = 0.0;
	T q273 = 0.0;
	T q274 = 0.0;
	T q275 = 0.0;
	T q276 = 0.0;
	T q277 = 0.0;
	T q278 = 0.0;
	T q279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q270 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q271 += beta*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dBy
	    q272 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,2); // d/dBy
	    q273 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q274 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	    q275 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dBy
	    q276 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q277 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dBy
	    q278 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,2); // d/dBy
	    q279 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[270] += q270*C_[0];
	I[271] += q271*C_[0];
	I[272] += q272*C_[0];
	I[273] += q273*C_[0];
	I[274] += q274*C_[0];
	I[275] += q275*C_[0];
	I[276] += q276*C_[0];
	I[277] += q277*C_[0];
	I[278] += q278*C_[0];
	I[279] += q279*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q280 = 0.0;
	T q281 = 0.0;
	T q282 = 0.0;
	T q283 = 0.0;
	T q284 = 0.0;
	T q285 = 0.0;
	T q286 = 0.0;
	T q287 = 0.0;
	T q288 = 0.0;
	T q289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q280 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1); // d/dBy
	    q281 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dBy
	    q282 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q283 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dBy
	    q284 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,2); // d/dBy
	    q285 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q286 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q287 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dBy
	    q288 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q289 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[280] += q280*C_[0];
	I[281] += q281*C_[0];
	I[282] += q282*C_[0];
	I[283] += q283*C_[0];
	I[284] += q284*C_[0];
	I[285] += q285*C_[0];
	I[286] += q286*C_[0];
	I[287] += q287*C_[0];
	I[288] += q288*C_[0];
	I[289] += q289*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q290 = 0.0;
	T q291 = 0.0;
	T q292 = 0.0;
	T q293 = 0.0;
	T q294 = 0.0;
	T q295 = 0.0;
	T q296 = 0.0;
	T q297 = 0.0;
	T q298 = 0.0;
	T q299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q290 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,2); // d/dBy
	    q291 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dBy
	    q292 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1); // d/dBy
	    q293 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dBy
	    q294 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q295 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dBy
	    q296 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2); // d/dBy
	    q297 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q298 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	    q299 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[290] += q290*C_[0];
	I[291] += q291*C_[0];
	I[292] += q292*C_[0];
	I[293] += q293*C_[0];
	I[294] += q294*C_[0];
	I[295] += q295*C_[0];
	I[296] += q296*C_[0];
	I[297] += q297*C_[0];
	I[298] += q298*C_[0];
	I[299] += q299*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q300 = 0.0;
	T q301 = 0.0;
	T q302 = 0.0;
	T q303 = 0.0;
	T q304 = 0.0;
	T q305 = 0.0;
	T q306 = 0.0;
	T q307 = 0.0;
	T q308 = 0.0;
	T q309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q300 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q301 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q302 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q303 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q304 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q305 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q306 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q307 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,1); // d/dBz
	    q308 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dBz
	    q309 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[300] += q300*C_[0];
	I[301] += q301*C_[0];
	I[302] += q302*C_[0];
	I[303] += q303*C_[0];
	I[304] += q304*C_[0];
	I[305] += q305*C_[0];
	I[306] += q306*C_[0];
	I[307] += q307*C_[0];
	I[308] += q308*C_[0];
	I[309] += q309*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q310 = 0.0;
	T q311 = 0.0;
	T q312 = 0.0;
	T q313 = 0.0;
	T q314 = 0.0;
	T q315 = 0.0;
	T q316 = 0.0;
	T q317 = 0.0;
	T q318 = 0.0;
	T q319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q310 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dBz
	    q311 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dBz
	    q312 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q313 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,1); // d/dBz
	    q314 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dBz
	    q315 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,1); // d/dBz
	    q316 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dBz
	    q317 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dBz
	    q318 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q319 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[310] += q310*C_[0];
	I[311] += q311*C_[0];
	I[312] += q312*C_[0];
	I[313] += q313*C_[0];
	I[314] += q314*C_[0];
	I[315] += q315*C_[0];
	I[316] += q316*C_[0];
	I[317] += q317*C_[0];
	I[318] += q318*C_[0];
	I[319] += q319*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q320 = 0.0;
	T q321 = 0.0;
	T q322 = 0.0;
	T q323 = 0.0;
	T q324 = 0.0;
	T q325 = 0.0;
	T q326 = 0.0;
	T q327 = 0.0;
	T q328 = 0.0;
	T q329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q320 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q321 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q322 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q323 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	    q324 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q325 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q326 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q327 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q328 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q329 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[320] += q320*C_[0];
	I[321] += q321*C_[0];
	I[322] += q322*C_[0];
	I[323] += q323*C_[0];
	I[324] += q324*C_[0];
	I[325] += q325*C_[0];
	I[326] += q326*C_[0];
	I[327] += q327*C_[0];
	I[328] += q328*C_[0];
	I[329] += q329*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q330 = 0.0;
	T q331 = 0.0;
	T q332 = 0.0;
	T q333 = 0.0;
	T q334 = 0.0;
	T q335 = 0.0;
	T q336 = 0.0;
	T q337 = 0.0;
	T q338 = 0.0;
	T q339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q330 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q331 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,1); // d/dBz
	    q332 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dBz
	    q333 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q334 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q335 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dBz
	    q336 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q337 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,1); // d/dBz
	    q338 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dBz
	    q339 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[330] += q330*C_[0];
	I[331] += q331*C_[0];
	I[332] += q332*C_[0];
	I[333] += q333*C_[0];
	I[334] += q334*C_[0];
	I[335] += q335*C_[0];
	I[336] += q336*C_[0];
	I[337] += q337*C_[0];
	I[338] += q338*C_[0];
	I[339] += q339*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q340 = 0.0;
	T q341 = 0.0;
	T q342 = 0.0;
	T q343 = 0.0;
	T q344 = 0.0;
	T q345 = 0.0;
	T q346 = 0.0;
	T q347 = 0.0;
	T q348 = 0.0;
	T q349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q340 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dBz
	    q341 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dBz
	    q342 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q343 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,1); // d/dBz
	    q344 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dBz
	    q345 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q346 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q347 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dBz
	    q348 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q349 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,1); // d/dBz
	}
	    
	//contraction coefficients
	I[340] += q340*C_[0];
	I[341] += q341*C_[0];
	I[342] += q342*C_[0];
	I[343] += q343*C_[0];
	I[344] += q344*C_[0];
	I[345] += q345*C_[0];
	I[346] += q346*C_[0];
	I[347] += q347*C_[0];
	I[348] += q348*C_[0];
	I[349] += q349*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q350 = 0.0;
	T q351 = 0.0;
	T q352 = 0.0;
	T q353 = 0.0;
	T q354 = 0.0;
	T q355 = 0.0;
	T q356 = 0.0;
	T q357 = 0.0;
	T q358 = 0.0;
	T q359 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q350 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dBz
	    q351 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1); // d/dBz
	    q352 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dBz
	    q353 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dBz
	    q354 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q355 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1); // d/dBz
	    q356 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dBz
	    q357 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q358 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	    q359 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[350] += q350*C_[0];
	I[351] += q351*C_[0];
	I[352] += q352*C_[0];
	I[353] += q353*C_[0];
	I[354] += q354*C_[0];
	I[355] += q355*C_[0];
	I[356] += q356*C_[0];
	I[357] += q357*C_[0];
	I[358] += q358*C_[0];
	I[359] += q359*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <gd| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::G,rysq::D> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::G,rysq::D> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 6;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,5,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,5,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 4*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,5,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 4*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q3 += alpha*Ix(a,5,1)*Iy(a,0,1)*Iz(a,0,0)
                     - 4*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,5,1)*Iy(a,0,0)*Iz(a,0,1)
                     - 4*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,5,0)*Iy(a,0,1)*Iz(a,0,1)
                     - 4*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	    q6 += alpha*Ix(a,1,2)*Iy(a,4,0)*Iz(a,0,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,4,2)*Iz(a,0,0); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,2); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,4,1)*Iz(a,0,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,1)*Iy(a,4,0)*Iz(a,0,1); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,4,1)*Iz(a,0,1); // d/dAx
	    q12 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,4,0); // d/dAx
	    q13 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,4,0); // d/dAx
	    q14 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,2); // d/dAx
	    q15 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,4,0); // d/dAx
	    q16 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,4,1); // d/dAx
	    q17 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,4,1); // d/dAx
	    q18 += alpha*Ix(a,4,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q19 += alpha*Ix(a,4,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 3*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dAx
	    q21 += alpha*Ix(a,4,1)*Iy(a,1,1)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q22 += alpha*Ix(a,4,1)*Iy(a,1,0)*Iz(a,0,1)
                     - 3*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q23 += alpha*Ix(a,4,0)*Iy(a,1,1)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dAx
	    q24 += alpha*Ix(a,4,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q25 += alpha*Ix(a,4,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dAx
	    q26 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dAx
	    q27 += alpha*Ix(a,4,1)*Iy(a,0,1)*Iz(a,1,0)
                     - 3*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q28 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,1,1)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q29 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,1,1)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,2,2)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,0);  // d/dAx
	    q31 += alpha*Ix(a,2,0)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,0);  // d/dAx
	    q32 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,2);  // d/dAx
	    q33 += alpha*Ix(a,2,1)*Iy(a,3,1)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0);  // d/dAx
	    q34 += alpha*Ix(a,2,1)*Iy(a,3,0)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1);  // d/dAx
	    q35 += alpha*Ix(a,2,0)*Iy(a,3,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1);  // d/dAx
	    q36 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,1,0); // d/dAx
	    q37 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,1,0); // d/dAx
	    q38 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,2); // d/dAx
	    q39 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,1,0); // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,1); // d/dAx
	    q41 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,1); // d/dAx
	    q42 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,0);  // d/dAx
	    q43 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,0);  // d/dAx
	    q44 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,2);  // d/dAx
	    q45 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0);  // d/dAx
	    q46 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,3,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1);  // d/dAx
	    q47 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1);  // d/dAx
	    q48 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,3,0); // d/dAx
	    q49 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,3,0); // d/dAx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,2); // d/dAx
	    q51 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,3,0); // d/dAx
	    q52 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,1); // d/dAx
	    q53 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,1); // d/dAx
	    q54 += alpha*Ix(a,3,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q55 += alpha*Ix(a,3,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dAx
	    q56 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dAx
	    q57 += alpha*Ix(a,3,1)*Iy(a,2,1)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dAx
	    q58 += alpha*Ix(a,3,1)*Iy(a,2,0)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dAx
	    q59 += alpha*Ix(a,3,0)*Iy(a,2,1)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q61 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dAx
	    q62 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dAx
	    q63 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dAx
	    q64 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,2,1)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dAx
	    q65 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,2,1)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dAx
	    q66 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,2,0); // d/dAx
	    q67 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,2,0); // d/dAx
	    q68 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,2); // d/dAx
	    q69 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,2,0); // d/dAx
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,1); // d/dAx
	    q71 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,1); // d/dAx
	    q72 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q73 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dAx
	    q74 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dAx
	    q75 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dAx
	    q76 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dAx
	    q77 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dAx
	    q78 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,0);  // d/dAx
	    q79 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,2);  // d/dAx
	    q81 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0);  // d/dAx
	    q82 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1);  // d/dAx
	    q83 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1);  // d/dAx
	    q84 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,0);  // d/dAx
	    q85 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,0);  // d/dAx
	    q86 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,2);  // d/dAx
	    q87 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0);  // d/dAx
	    q88 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1);  // d/dAx
	    q89 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,4,2)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q91 += alpha*Ix(a,4,0)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q92 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q93 += alpha*Ix(a,4,1)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q94 += alpha*Ix(a,4,1)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q95 += alpha*Ix(a,4,0)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q96 += alpha*Ix(a,0,2)*Iy(a,5,0)*Iz(a,0,0)
                     - 4*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,0);  // d/dAy
	    q97 += alpha*Ix(a,0,0)*Iy(a,5,2)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,0);  // d/dAy
	    q98 += alpha*Ix(a,0,0)*Iy(a,5,0)*Iz(a,0,2)
                     - 4*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,2);  // d/dAy
	    q99 += alpha*Ix(a,0,1)*Iy(a,5,1)*Iz(a,0,0)
                     - 4*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,0,1)*Iy(a,5,0)*Iz(a,0,1)
                     - 4*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1);  // d/dAy
	    q101 += alpha*Ix(a,0,0)*Iy(a,5,1)*Iz(a,0,1)
                     - 4*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1);  // d/dAy
	    q102 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,4,0); // d/dAy
	    q103 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,4,0); // d/dAy
	    q104 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,2); // d/dAy
	    q105 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,4,0); // d/dAy
	    q106 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,4,1); // d/dAy
	    q107 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,4,1); // d/dAy
	    q108 += alpha*Ix(a,3,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q109 += alpha*Ix(a,3,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q111 += alpha*Ix(a,3,1)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q112 += alpha*Ix(a,3,1)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q113 += alpha*Ix(a,3,0)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	    q114 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q115 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q116 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q117 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q118 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q119 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,1,2)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q121 += alpha*Ix(a,1,0)*Iy(a,4,2)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dAy
	    q122 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,2)
                     - 3*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dAy
	    q123 += alpha*Ix(a,1,1)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dAy
	    q124 += alpha*Ix(a,1,1)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dAy
	    q125 += alpha*Ix(a,1,0)*Iy(a,4,1)*Iz(a,0,1)
                     - 3*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dAy
	    q126 += alpha*Ix(a,0,2)*Iy(a,4,0)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,0);  // d/dAy
	    q127 += alpha*Ix(a,0,0)*Iy(a,4,2)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,0);  // d/dAy
	    q128 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,2)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,2);  // d/dAy
	    q129 += alpha*Ix(a,0,1)*Iy(a,4,1)*Iz(a,1,0)
                     - 3*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,1,1)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1);  // d/dAy
	    q131 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,1,1)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1);  // d/dAy
	    q132 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q133 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,3,0); // d/dAy
	    q134 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,2); // d/dAy
	    q135 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,3,0); // d/dAy
	    q136 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,1); // d/dAy
	    q137 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,1); // d/dAy
	    q138 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,3,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,0);  // d/dAy
	    q139 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,2);  // d/dAy
	    q141 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0);  // d/dAy
	    q142 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,3,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1);  // d/dAy
	    q143 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1);  // d/dAy
	    q144 += alpha*Ix(a,2,2)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q145 += alpha*Ix(a,2,0)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dAy
	    q146 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dAy
	    q147 += alpha*Ix(a,2,1)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q148 += alpha*Ix(a,2,1)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q149 += alpha*Ix(a,2,0)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q151 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,2,0); // d/dAy
	    q152 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,2); // d/dAy
	    q153 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q154 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q155 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,1); // d/dAy
	    q156 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,2,0)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,0);  // d/dAy
	    q157 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,2,0)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,0);  // d/dAy
	    q158 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,2)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,2);  // d/dAy
	    q159 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1);  // d/dAy
	    q161 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,2,1)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1);  // d/dAy
	    q162 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q163 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dAy
	    q164 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dAy
	    q165 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q166 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	    q167 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dAy
	    q168 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q169 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dAy
	    q171 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dAy
	    q172 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dAy
	    q173 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dAy
	    q174 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q175 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dAy
	    q176 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dAy
	    q177 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dAy
	    q178 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dAy
	    q179 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += alpha*Ix(a,4,2)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q181 += alpha*Ix(a,4,0)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q182 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q183 += alpha*Ix(a,4,1)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q184 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q185 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q186 += alpha*Ix(a,0,2)*Iy(a,4,0)*Iz(a,1,0); // d/dAz
	    q187 += alpha*Ix(a,0,0)*Iy(a,4,2)*Iz(a,1,0); // d/dAz
	    q188 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,2); // d/dAz
	    q189 += alpha*Ix(a,0,1)*Iy(a,4,1)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,1,1); // d/dAz
	    q191 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,1,1); // d/dAz
	    q192 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,5,0)
                     - 4*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,0);  // d/dAz
	    q193 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,5,0)
                     - 4*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,0);  // d/dAz
	    q194 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,5,2)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,2);  // d/dAz
	    q195 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,5,0)
                     - 4*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0);  // d/dAz
	    q196 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,5,1)
                     - 4*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1);  // d/dAz
	    q197 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,5,1)
                     - 4*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1);  // d/dAz
	    q198 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q199 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q201 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q202 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q203 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	    q204 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q205 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	    q206 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q207 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q208 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q209 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q211 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,1,0); // d/dAz
	    q212 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,2); // d/dAz
	    q213 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,1,0); // d/dAz
	    q214 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,1); // d/dAz
	    q215 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,1); // d/dAz
	    q216 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,0);  // d/dAz
	    q217 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,0);  // d/dAz
	    q218 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,2);  // d/dAz
	    q219 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];
	I[216] += q216*C_[0];
	I[217] += q217*C_[0];
	I[218] += q218*C_[0];
	I[219] += q219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1);  // d/dAz
	    q221 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1);  // d/dAz
	    q222 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q223 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,4,0)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dAz
	    q224 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,2)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dAz
	    q225 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dAz
	    q226 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dAz
	    q227 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,4,1)
                     - 3*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dAz
	    q228 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,4,0)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,0);  // d/dAz
	    q229 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[0];
	I[222] += q222*C_[0];
	I[223] += q223*C_[0];
	I[224] += q224*C_[0];
	I[225] += q225*C_[0];
	I[226] += q226*C_[0];
	I[227] += q227*C_[0];
	I[228] += q228*C_[0];
	I[229] += q229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,2)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,2);  // d/dAz
	    q231 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0);  // d/dAz
	    q232 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,4,1)
                     - 3*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1);  // d/dAz
	    q233 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1);  // d/dAz
	    q234 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q235 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,1,0); // d/dAz
	    q236 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,2); // d/dAz
	    q237 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q238 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	    q239 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[230] += q230*C_[0];
	I[231] += q231*C_[0];
	I[232] += q232*C_[0];
	I[233] += q233*C_[0];
	I[234] += q234*C_[0];
	I[235] += q235*C_[0];
	I[236] += q236*C_[0];
	I[237] += q237*C_[0];
	I[238] += q238*C_[0];
	I[239] += q239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q241 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dAz
	    q242 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dAz
	    q243 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q244 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q245 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dAz
	    q246 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,0);  // d/dAz
	    q247 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,0);  // d/dAz
	    q248 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,2);  // d/dAz
	    q249 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1);  // d/dAz
	    q251 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1);  // d/dAz
	    q252 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q253 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dAz
	    q254 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dAz
	    q255 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q256 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q257 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dAz
	    q258 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q259 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[0];
	I[256] += q256*C_[0];
	I[257] += q257*C_[0];
	I[258] += q258*C_[0];
	I[259] += q259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dAz
	    q261 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dAz
	    q262 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dAz
	    q263 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dAz
	    q264 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q265 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dAz
	    q266 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,2)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dAz
	    q267 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dAz
	    q268 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dAz
	    q269 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[0];
	I[262] += q262*C_[0];
	I[263] += q263*C_[0];
	I[264] += q264*C_[0];
	I[265] += q265*C_[0];
	I[266] += q266*C_[0];
	I[267] += q267*C_[0];
	I[268] += q268*C_[0];
	I[269] += q269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q270 = 0.0;
	T q271 = 0.0;
	T q272 = 0.0;
	T q273 = 0.0;
	T q274 = 0.0;
	T q275 = 0.0;
	T q276 = 0.0;
	T q277 = 0.0;
	T q278 = 0.0;
	T q279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q270 += beta*Ix(a,4,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q271 += beta*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,0); // d/dBx
	    q272 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,2); // d/dBx
	    q273 += beta*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q274 += beta*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q275 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBx
	    q276 += beta*Ix(a,0,3)*Iy(a,4,0)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,0);  // d/dBx
	    q277 += beta*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,0); // d/dBx
	    q278 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,2); // d/dBx
	    q279 += beta*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[270] += q270*C_[0];
	I[271] += q271*C_[0];
	I[272] += q272*C_[0];
	I[273] += q273*C_[0];
	I[274] += q274*C_[0];
	I[275] += q275*C_[0];
	I[276] += q276*C_[0];
	I[277] += q277*C_[0];
	I[278] += q278*C_[0];
	I[279] += q279*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q280 = 0.0;
	T q281 = 0.0;
	T q282 = 0.0;
	T q283 = 0.0;
	T q284 = 0.0;
	T q285 = 0.0;
	T q286 = 0.0;
	T q287 = 0.0;
	T q288 = 0.0;
	T q289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q280 += beta*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,1);  // d/dBx
	    q281 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,1); // d/dBx
	    q282 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,4,0)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,0);  // d/dBx
	    q283 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,0); // d/dBx
	    q284 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,2); // d/dBx
	    q285 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,0);  // d/dBx
	    q286 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,1);  // d/dBx
	    q287 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,1); // d/dBx
	    q288 += beta*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q289 += beta*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,0); // d/dBx
	}
	    
	//contraction coefficients
	I[280] += q280*C_[0];
	I[281] += q281*C_[0];
	I[282] += q282*C_[0];
	I[283] += q283*C_[0];
	I[284] += q284*C_[0];
	I[285] += q285*C_[0];
	I[286] += q286*C_[0];
	I[287] += q287*C_[0];
	I[288] += q288*C_[0];
	I[289] += q289*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q290 = 0.0;
	T q291 = 0.0;
	T q292 = 0.0;
	T q293 = 0.0;
	T q294 = 0.0;
	T q295 = 0.0;
	T q296 = 0.0;
	T q297 = 0.0;
	T q298 = 0.0;
	T q299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q290 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,2); // d/dBx
	    q291 += beta*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q292 += beta*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q293 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBx
	    q294 += beta*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q295 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,0); // d/dBx
	    q296 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,2); // d/dBx
	    q297 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,0)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q298 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,1)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q299 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBx
	}
	    
	//contraction coefficients
	I[290] += q290*C_[0];
	I[291] += q291*C_[0];
	I[292] += q292*C_[0];
	I[293] += q293*C_[0];
	I[294] += q294*C_[0];
	I[295] += q295*C_[0];
	I[296] += q296*C_[0];
	I[297] += q297*C_[0];
	I[298] += q298*C_[0];
	I[299] += q299*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q300 = 0.0;
	T q301 = 0.0;
	T q302 = 0.0;
	T q303 = 0.0;
	T q304 = 0.0;
	T q305 = 0.0;
	T q306 = 0.0;
	T q307 = 0.0;
	T q308 = 0.0;
	T q309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q300 += beta*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dBx
	    q301 += beta*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,0); // d/dBx
	    q302 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,2); // d/dBx
	    q303 += beta*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dBx
	    q304 += beta*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dBx
	    q305 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,1); // d/dBx
	    q306 += beta*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,0);  // d/dBx
	    q307 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,0); // d/dBx
	    q308 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,2); // d/dBx
	    q309 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[300] += q300*C_[0];
	I[301] += q301*C_[0];
	I[302] += q302*C_[0];
	I[303] += q303*C_[0];
	I[304] += q304*C_[0];
	I[305] += q305*C_[0];
	I[306] += q306*C_[0];
	I[307] += q307*C_[0];
	I[308] += q308*C_[0];
	I[309] += q309*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q310 = 0.0;
	T q311 = 0.0;
	T q312 = 0.0;
	T q313 = 0.0;
	T q314 = 0.0;
	T q315 = 0.0;
	T q316 = 0.0;
	T q317 = 0.0;
	T q318 = 0.0;
	T q319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q310 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,1);  // d/dBx
	    q311 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,1); // d/dBx
	    q312 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dBx
	    q313 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,0); // d/dBx
	    q314 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,2); // d/dBx
	    q315 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dBx
	    q316 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dBx
	    q317 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,1); // d/dBx
	    q318 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,0);  // d/dBx
	    q319 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,0); // d/dBx
	}
	    
	//contraction coefficients
	I[310] += q310*C_[0];
	I[311] += q311*C_[0];
	I[312] += q312*C_[0];
	I[313] += q313*C_[0];
	I[314] += q314*C_[0];
	I[315] += q315*C_[0];
	I[316] += q316*C_[0];
	I[317] += q317*C_[0];
	I[318] += q318*C_[0];
	I[319] += q319*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q320 = 0.0;
	T q321 = 0.0;
	T q322 = 0.0;
	T q323 = 0.0;
	T q324 = 0.0;
	T q325 = 0.0;
	T q326 = 0.0;
	T q327 = 0.0;
	T q328 = 0.0;
	T q329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q320 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,2); // d/dBx
	    q321 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,0);  // d/dBx
	    q322 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,1);  // d/dBx
	    q323 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,1); // d/dBx
	    q324 += beta*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q325 += beta*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,0); // d/dBx
	    q326 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,2); // d/dBx
	    q327 += beta*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dBx
	    q328 += beta*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dBx
	    q329 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,1); // d/dBx
	}
	    
	//contraction coefficients
	I[320] += q320*C_[0];
	I[321] += q321*C_[0];
	I[322] += q322*C_[0];
	I[323] += q323*C_[0];
	I[324] += q324*C_[0];
	I[325] += q325*C_[0];
	I[326] += q326*C_[0];
	I[327] += q327*C_[0];
	I[328] += q328*C_[0];
	I[329] += q329*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q330 = 0.0;
	T q331 = 0.0;
	T q332 = 0.0;
	T q333 = 0.0;
	T q334 = 0.0;
	T q335 = 0.0;
	T q336 = 0.0;
	T q337 = 0.0;
	T q338 = 0.0;
	T q339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q330 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,0)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q331 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,0); // d/dBx
	    q332 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,2); // d/dBx
	    q333 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dBx
	    q334 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dBx
	    q335 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,1); // d/dBx
	    q336 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,0);  // d/dBx
	    q337 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,0); // d/dBx
	    q338 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,2); // d/dBx
	    q339 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[330] += q330*C_[0];
	I[331] += q331*C_[0];
	I[332] += q332*C_[0];
	I[333] += q333*C_[0];
	I[334] += q334*C_[0];
	I[335] += q335*C_[0];
	I[336] += q336*C_[0];
	I[337] += q337*C_[0];
	I[338] += q338*C_[0];
	I[339] += q339*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q340 = 0.0;
	T q341 = 0.0;
	T q342 = 0.0;
	T q343 = 0.0;
	T q344 = 0.0;
	T q345 = 0.0;
	T q346 = 0.0;
	T q347 = 0.0;
	T q348 = 0.0;
	T q349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q340 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,1);  // d/dBx
	    q341 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,1); // d/dBx
	    q342 += beta*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,0)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q343 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,0); // d/dBx
	    q344 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,2); // d/dBx
	    q345 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dBx
	    q346 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dBx
	    q347 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,1); // d/dBx
	    q348 += beta*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dBx
	    q349 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,0); // d/dBx
	}
	    
	//contraction coefficients
	I[340] += q340*C_[0];
	I[341] += q341*C_[0];
	I[342] += q342*C_[0];
	I[343] += q343*C_[0];
	I[344] += q344*C_[0];
	I[345] += q345*C_[0];
	I[346] += q346*C_[0];
	I[347] += q347*C_[0];
	I[348] += q348*C_[0];
	I[349] += q349*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q350 = 0.0;
	T q351 = 0.0;
	T q352 = 0.0;
	T q353 = 0.0;
	T q354 = 0.0;
	T q355 = 0.0;
	T q356 = 0.0;
	T q357 = 0.0;
	T q358 = 0.0;
	T q359 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q350 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,2); // d/dBx
	    q351 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dBx
	    q352 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dBx
	    q353 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,1); // d/dBx
	    q354 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dBx
	    q355 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,0); // d/dBx
	    q356 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,2); // d/dBx
	    q357 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dBx
	    q358 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dBx
	    q359 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,1); // d/dBx
	}
	    
	//contraction coefficients
	I[350] += q350*C_[0];
	I[351] += q351*C_[0];
	I[352] += q352*C_[0];
	I[353] += q353*C_[0];
	I[354] += q354*C_[0];
	I[355] += q355*C_[0];
	I[356] += q356*C_[0];
	I[357] += q357*C_[0];
	I[358] += q358*C_[0];
	I[359] += q359*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q360 = 0.0;
	T q361 = 0.0;
	T q362 = 0.0;
	T q363 = 0.0;
	T q364 = 0.0;
	T q365 = 0.0;
	T q366 = 0.0;
	T q367 = 0.0;
	T q368 = 0.0;
	T q369 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q360 += beta*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q361 += beta*Ix(a,4,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q362 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q363 += beta*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q364 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q365 += beta*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q366 += beta*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,0); // d/dBy
	    q367 += beta*Ix(a,0,0)*Iy(a,4,3)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,0);  // d/dBy
	    q368 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,2); // d/dBy
	    q369 += beta*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[360] += q360*C_[0];
	I[361] += q361*C_[0];
	I[362] += q362*C_[0];
	I[363] += q363*C_[0];
	I[364] += q364*C_[0];
	I[365] += q365*C_[0];
	I[366] += q366*C_[0];
	I[367] += q367*C_[0];
	I[368] += q368*C_[0];
	I[369] += q369*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q370 = 0.0;
	T q371 = 0.0;
	T q372 = 0.0;
	T q373 = 0.0;
	T q374 = 0.0;
	T q375 = 0.0;
	T q376 = 0.0;
	T q377 = 0.0;
	T q378 = 0.0;
	T q379 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q370 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,1); // d/dBy
	    q371 += beta*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,1);  // d/dBy
	    q372 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,0); // d/dBy
	    q373 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,4,0)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,0);  // d/dBy
	    q374 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,2); // d/dBy
	    q375 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,0);  // d/dBy
	    q376 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,1); // d/dBy
	    q377 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,1);  // d/dBy
	    q378 += beta*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q379 += beta*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[370] += q370*C_[0];
	I[371] += q371*C_[0];
	I[372] += q372*C_[0];
	I[373] += q373*C_[0];
	I[374] += q374*C_[0];
	I[375] += q375*C_[0];
	I[376] += q376*C_[0];
	I[377] += q377*C_[0];
	I[378] += q378*C_[0];
	I[379] += q379*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q380 = 0.0;
	T q381 = 0.0;
	T q382 = 0.0;
	T q383 = 0.0;
	T q384 = 0.0;
	T q385 = 0.0;
	T q386 = 0.0;
	T q387 = 0.0;
	T q388 = 0.0;
	T q389 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q380 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q381 += beta*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q382 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q383 += beta*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	    q384 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q385 += beta*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	    q386 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q387 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q388 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q389 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[380] += q380*C_[0];
	I[381] += q381*C_[0];
	I[382] += q382*C_[0];
	I[383] += q383*C_[0];
	I[384] += q384*C_[0];
	I[385] += q385*C_[0];
	I[386] += q386*C_[0];
	I[387] += q387*C_[0];
	I[388] += q388*C_[0];
	I[389] += q389*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q390 = 0.0;
	T q391 = 0.0;
	T q392 = 0.0;
	T q393 = 0.0;
	T q394 = 0.0;
	T q395 = 0.0;
	T q396 = 0.0;
	T q397 = 0.0;
	T q398 = 0.0;
	T q399 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q390 += beta*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q391 += beta*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dBy
	    q392 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,2); // d/dBy
	    q393 += beta*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dBy
	    q394 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,1); // d/dBy
	    q395 += beta*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dBy
	    q396 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,0); // d/dBy
	    q397 += beta*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,0);  // d/dBy
	    q398 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,2); // d/dBy
	    q399 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[390] += q390*C_[0];
	I[391] += q391*C_[0];
	I[392] += q392*C_[0];
	I[393] += q393*C_[0];
	I[394] += q394*C_[0];
	I[395] += q395*C_[0];
	I[396] += q396*C_[0];
	I[397] += q397*C_[0];
	I[398] += q398*C_[0];
	I[399] += q399*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q400 = 0.0;
	T q401 = 0.0;
	T q402 = 0.0;
	T q403 = 0.0;
	T q404 = 0.0;
	T q405 = 0.0;
	T q406 = 0.0;
	T q407 = 0.0;
	T q408 = 0.0;
	T q409 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q400 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,1); // d/dBy
	    q401 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,1);  // d/dBy
	    q402 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q403 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dBy
	    q404 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,2); // d/dBy
	    q405 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dBy
	    q406 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,1); // d/dBy
	    q407 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dBy
	    q408 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,0); // d/dBy
	    q409 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[400] += q400*C_[0];
	I[401] += q401*C_[0];
	I[402] += q402*C_[0];
	I[403] += q403*C_[0];
	I[404] += q404*C_[0];
	I[405] += q405*C_[0];
	I[406] += q406*C_[0];
	I[407] += q407*C_[0];
	I[408] += q408*C_[0];
	I[409] += q409*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q410 = 0.0;
	T q411 = 0.0;
	T q412 = 0.0;
	T q413 = 0.0;
	T q414 = 0.0;
	T q415 = 0.0;
	T q416 = 0.0;
	T q417 = 0.0;
	T q418 = 0.0;
	T q419 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q410 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,2); // d/dBy
	    q411 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,0);  // d/dBy
	    q412 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,1); // d/dBy
	    q413 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,1);  // d/dBy
	    q414 += beta*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q415 += beta*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dBy
	    q416 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,2); // d/dBy
	    q417 += beta*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q418 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	    q419 += beta*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[410] += q410*C_[0];
	I[411] += q411*C_[0];
	I[412] += q412*C_[0];
	I[413] += q413*C_[0];
	I[414] += q414*C_[0];
	I[415] += q415*C_[0];
	I[416] += q416*C_[0];
	I[417] += q417*C_[0];
	I[418] += q418*C_[0];
	I[419] += q419*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q420 = 0.0;
	T q421 = 0.0;
	T q422 = 0.0;
	T q423 = 0.0;
	T q424 = 0.0;
	T q425 = 0.0;
	T q426 = 0.0;
	T q427 = 0.0;
	T q428 = 0.0;
	T q429 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q420 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q421 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dBy
	    q422 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,2); // d/dBy
	    q423 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q424 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q425 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dBy
	    q426 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,0); // d/dBy
	    q427 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,0)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,0);  // d/dBy
	    q428 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,2); // d/dBy
	    q429 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[420] += q420*C_[0];
	I[421] += q421*C_[0];
	I[422] += q422*C_[0];
	I[423] += q423*C_[0];
	I[424] += q424*C_[0];
	I[425] += q425*C_[0];
	I[426] += q426*C_[0];
	I[427] += q427*C_[0];
	I[428] += q428*C_[0];
	I[429] += q429*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q430 = 0.0;
	T q431 = 0.0;
	T q432 = 0.0;
	T q433 = 0.0;
	T q434 = 0.0;
	T q435 = 0.0;
	T q436 = 0.0;
	T q437 = 0.0;
	T q438 = 0.0;
	T q439 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q430 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,1); // d/dBy
	    q431 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,1);  // d/dBy
	    q432 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q433 += beta*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dBy
	    q434 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,2); // d/dBy
	    q435 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q436 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	    q437 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dBy
	    q438 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q439 += beta*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[430] += q430*C_[0];
	I[431] += q431*C_[0];
	I[432] += q432*C_[0];
	I[433] += q433*C_[0];
	I[434] += q434*C_[0];
	I[435] += q435*C_[0];
	I[436] += q436*C_[0];
	I[437] += q437*C_[0];
	I[438] += q438*C_[0];
	I[439] += q439*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q440 = 0.0;
	T q441 = 0.0;
	T q442 = 0.0;
	T q443 = 0.0;
	T q444 = 0.0;
	T q445 = 0.0;
	T q446 = 0.0;
	T q447 = 0.0;
	T q448 = 0.0;
	T q449 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q440 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,2); // d/dBy
	    q441 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dBy
	    q442 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,1); // d/dBy
	    q443 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dBy
	    q444 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q445 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dBy
	    q446 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,2); // d/dBy
	    q447 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dBy
	    q448 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,1); // d/dBy
	    q449 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[440] += q440*C_[0];
	I[441] += q441*C_[0];
	I[442] += q442*C_[0];
	I[443] += q443*C_[0];
	I[444] += q444*C_[0];
	I[445] += q445*C_[0];
	I[446] += q446*C_[0];
	I[447] += q447*C_[0];
	I[448] += q448*C_[0];
	I[449] += q449*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q450 = 0.0;
	T q451 = 0.0;
	T q452 = 0.0;
	T q453 = 0.0;
	T q454 = 0.0;
	T q455 = 0.0;
	T q456 = 0.0;
	T q457 = 0.0;
	T q458 = 0.0;
	T q459 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q450 += beta*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q451 += beta*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q452 += beta*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q453 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q454 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q455 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q456 += beta*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,1); // d/dBz
	    q457 += beta*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,1); // d/dBz
	    q458 += beta*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,1);  // d/dBz
	    q459 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[450] += q450*C_[0];
	I[451] += q451*C_[0];
	I[452] += q452*C_[0];
	I[453] += q453*C_[0];
	I[454] += q454*C_[0];
	I[455] += q455*C_[0];
	I[456] += q456*C_[0];
	I[457] += q457*C_[0];
	I[458] += q458*C_[0];
	I[459] += q459*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q460 = 0.0;
	T q461 = 0.0;
	T q462 = 0.0;
	T q463 = 0.0;
	T q464 = 0.0;
	T q465 = 0.0;
	T q466 = 0.0;
	T q467 = 0.0;
	T q468 = 0.0;
	T q469 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q460 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,0);  // d/dBz
	    q461 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,0);  // d/dBz
	    q462 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,1); // d/dBz
	    q463 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,1); // d/dBz
	    q464 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,3)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,1);  // d/dBz
	    q465 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,1); // d/dBz
	    q466 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,0);  // d/dBz
	    q467 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,0);  // d/dBz
	    q468 += beta*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q469 += beta*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[460] += q460*C_[0];
	I[461] += q461*C_[0];
	I[462] += q462*C_[0];
	I[463] += q463*C_[0];
	I[464] += q464*C_[0];
	I[465] += q465*C_[0];
	I[466] += q466*C_[0];
	I[467] += q467*C_[0];
	I[468] += q468*C_[0];
	I[469] += q469*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q470 = 0.0;
	T q471 = 0.0;
	T q472 = 0.0;
	T q473 = 0.0;
	T q474 = 0.0;
	T q475 = 0.0;
	T q476 = 0.0;
	T q477 = 0.0;
	T q478 = 0.0;
	T q479 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q470 += beta*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q471 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q472 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q473 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	    q474 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q475 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q476 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q477 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q478 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q479 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[470] += q470*C_[0];
	I[471] += q471*C_[0];
	I[472] += q472*C_[0];
	I[473] += q473*C_[0];
	I[474] += q474*C_[0];
	I[475] += q475*C_[0];
	I[476] += q476*C_[0];
	I[477] += q477*C_[0];
	I[478] += q478*C_[0];
	I[479] += q479*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q480 = 0.0;
	T q481 = 0.0;
	T q482 = 0.0;
	T q483 = 0.0;
	T q484 = 0.0;
	T q485 = 0.0;
	T q486 = 0.0;
	T q487 = 0.0;
	T q488 = 0.0;
	T q489 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q480 += beta*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q481 += beta*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,1); // d/dBz
	    q482 += beta*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dBz
	    q483 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,1); // d/dBz
	    q484 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dBz
	    q485 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dBz
	    q486 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,1); // d/dBz
	    q487 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,1); // d/dBz
	    q488 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,1);  // d/dBz
	    q489 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[480] += q480*C_[0];
	I[481] += q481*C_[0];
	I[482] += q482*C_[0];
	I[483] += q483*C_[0];
	I[484] += q484*C_[0];
	I[485] += q485*C_[0];
	I[486] += q486*C_[0];
	I[487] += q487*C_[0];
	I[488] += q488*C_[0];
	I[489] += q489*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q490 = 0.0;
	T q491 = 0.0;
	T q492 = 0.0;
	T q493 = 0.0;
	T q494 = 0.0;
	T q495 = 0.0;
	T q496 = 0.0;
	T q497 = 0.0;
	T q498 = 0.0;
	T q499 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q490 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,0);  // d/dBz
	    q491 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,0);  // d/dBz
	    q492 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q493 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,1); // d/dBz
	    q494 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dBz
	    q495 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,1); // d/dBz
	    q496 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dBz
	    q497 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dBz
	    q498 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,1); // d/dBz
	    q499 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,1); // d/dBz
	}
	    
	//contraction coefficients
	I[490] += q490*C_[0];
	I[491] += q491*C_[0];
	I[492] += q492*C_[0];
	I[493] += q493*C_[0];
	I[494] += q494*C_[0];
	I[495] += q495*C_[0];
	I[496] += q496*C_[0];
	I[497] += q497*C_[0];
	I[498] += q498*C_[0];
	I[499] += q499*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q500 = 0.0;
	T q501 = 0.0;
	T q502 = 0.0;
	T q503 = 0.0;
	T q504 = 0.0;
	T q505 = 0.0;
	T q506 = 0.0;
	T q507 = 0.0;
	T q508 = 0.0;
	T q509 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q500 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,1);  // d/dBz
	    q501 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,1); // d/dBz
	    q502 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,0);  // d/dBz
	    q503 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,0);  // d/dBz
	    q504 += beta*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q505 += beta*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,1); // d/dBz
	    q506 += beta*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dBz
	    q507 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q508 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q509 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[500] += q500*C_[0];
	I[501] += q501*C_[0];
	I[502] += q502*C_[0];
	I[503] += q503*C_[0];
	I[504] += q504*C_[0];
	I[505] += q505*C_[0];
	I[506] += q506*C_[0];
	I[507] += q507*C_[0];
	I[508] += q508*C_[0];
	I[509] += q509*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q510 = 0.0;
	T q511 = 0.0;
	T q512 = 0.0;
	T q513 = 0.0;
	T q514 = 0.0;
	T q515 = 0.0;
	T q516 = 0.0;
	T q517 = 0.0;
	T q518 = 0.0;
	T q519 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q510 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q511 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,1); // d/dBz
	    q512 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dBz
	    q513 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q514 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q515 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dBz
	    q516 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,1); // d/dBz
	    q517 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,1); // d/dBz
	    q518 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,1);  // d/dBz
	    q519 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,1); // d/dBz
	}
	    
	//contraction coefficients
	I[510] += q510*C_[0];
	I[511] += q511*C_[0];
	I[512] += q512*C_[0];
	I[513] += q513*C_[0];
	I[514] += q514*C_[0];
	I[515] += q515*C_[0];
	I[516] += q516*C_[0];
	I[517] += q517*C_[0];
	I[518] += q518*C_[0];
	I[519] += q519*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q520 = 0.0;
	T q521 = 0.0;
	T q522 = 0.0;
	T q523 = 0.0;
	T q524 = 0.0;
	T q525 = 0.0;
	T q526 = 0.0;
	T q527 = 0.0;
	T q528 = 0.0;
	T q529 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q520 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,0);  // d/dBz
	    q521 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,0);  // d/dBz
	    q522 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q523 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,1); // d/dBz
	    q524 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dBz
	    q525 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q526 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	    q527 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dBz
	    q528 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q529 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[520] += q520*C_[0];
	I[521] += q521*C_[0];
	I[522] += q522*C_[0];
	I[523] += q523*C_[0];
	I[524] += q524*C_[0];
	I[525] += q525*C_[0];
	I[526] += q526*C_[0];
	I[527] += q527*C_[0];
	I[528] += q528*C_[0];
	I[529] += q529*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q530 = 0.0;
	T q531 = 0.0;
	T q532 = 0.0;
	T q533 = 0.0;
	T q534 = 0.0;
	T q535 = 0.0;
	T q536 = 0.0;
	T q537 = 0.0;
	T q538 = 0.0;
	T q539 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q530 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dBz
	    q531 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,1); // d/dBz
	    q532 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dBz
	    q533 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dBz
	    q534 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q535 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,1); // d/dBz
	    q536 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,3)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dBz
	    q537 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,1); // d/dBz
	    q538 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dBz
	    q539 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[530] += q530*C_[0];
	I[531] += q531*C_[0];
	I[532] += q532*C_[0];
	I[533] += q533*C_[0];
	I[534] += q534*C_[0];
	I[535] += q535*C_[0];
	I[536] += q536*C_[0];
	I[537] += q537*C_[0];
	I[538] += q538*C_[0];
	I[539] += q539*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <spd| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::SP,rysq::D> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::SP,rysq::D> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2); // d/dAx
	    q3 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0); // d/dAx
	    q4 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1); // d/dAx
	    q5 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1); // d/dAx
	    q6 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q7 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q8 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q9 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[1];
	I[7] += q7*C_[1];
	I[8] += q8*C_[1];
	I[9] += q9*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q11 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	    q12 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q13 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0); // d/dAx
	    q14 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2); // d/dAx
	    q15 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0); // d/dAx
	    q16 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1); // d/dAx
	    q17 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1); // d/dAx
	    q18 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q19 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[1];
	I[11] += q11*C_[1];
	I[12] += q12*C_[1];
	I[13] += q13*C_[1];
	I[14] += q14*C_[1];
	I[15] += q15*C_[1];
	I[16] += q16*C_[1];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2); // d/dAx
	    q21 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0); // d/dAx
	    q22 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1); // d/dAx
	    q23 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1); // d/dAx
	    q24 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q25 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q26 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q27 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q28 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q29 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[20] += q20*C_[1];
	I[21] += q21*C_[1];
	I[22] += q22*C_[1];
	I[23] += q23*C_[1];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q31 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q32 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q33 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q34 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q35 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q36 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q37 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	    q38 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q39 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[30] += q30*C_[1];
	I[31] += q31*C_[1];
	I[32] += q32*C_[1];
	I[33] += q33*C_[1];
	I[34] += q34*C_[1];
	I[35] += q35*C_[1];
	I[36] += q36*C_[1];
	I[37] += q37*C_[1];
	I[38] += q38*C_[1];
	I[39] += q39*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q41 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	    q42 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q43 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q44 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q45 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q46 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q47 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	    q48 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q49 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[40] += q40*C_[1];
	I[41] += q41*C_[1];
	I[42] += q42*C_[1];
	I[43] += q43*C_[1];
	I[44] += q44*C_[1];
	I[45] += q45*C_[1];
	I[46] += q46*C_[1];
	I[47] += q47*C_[1];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q51 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q52 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q53 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q54 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q55 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q56 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q57 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q58 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q59 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[1];
	I[55] += q55*C_[1];
	I[56] += q56*C_[1];
	I[57] += q57*C_[1];
	I[58] += q58*C_[1];
	I[59] += q59*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q61 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q62 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q63 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q64 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q65 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	    q66 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q67 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	    q68 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q69 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[60] += q60*C_[1];
	I[61] += q61*C_[1];
	I[62] += q62*C_[1];
	I[63] += q63*C_[1];
	I[64] += q64*C_[1];
	I[65] += q65*C_[1];
	I[66] += q66*C_[1];
	I[67] += q67*C_[1];
	I[68] += q68*C_[1];
	I[69] += q69*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q71 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	    q72 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q73 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0); // d/dBx
	    q74 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2); // d/dBx
	    q75 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q76 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q77 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBx
	    q78 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q79 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0); // d/dBx
	}
	    
	//contraction coefficients
	I[70] += q70*C_[1];
	I[71] += q71*C_[1];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[1];
	I[79] += q79*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2); // d/dBx
	    q81 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q82 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q83 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBx
	    q84 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q85 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0); // d/dBx
	    q86 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2); // d/dBx
	    q87 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q88 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q89 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBx
	}
	    
	//contraction coefficients
	I[80] += q80*C_[1];
	I[81] += q81*C_[1];
	I[82] += q82*C_[1];
	I[83] += q83*C_[1];
	I[84] += q84*C_[1];
	I[85] += q85*C_[1];
	I[86] += q86*C_[1];
	I[87] += q87*C_[1];
	I[88] += q88*C_[1];
	I[89] += q89*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q91 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0); // d/dBx
	    q92 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2); // d/dBx
	    q93 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q94 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q95 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBx
	    q96 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q97 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q98 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q99 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[90] += q90*C_[1];
	I[91] += q91*C_[1];
	I[92] += q92*C_[1];
	I[93] += q93*C_[1];
	I[94] += q94*C_[1];
	I[95] += q95*C_[1];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q101 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q102 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q103 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q104 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q105 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q106 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q107 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q108 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q109 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[1];
	I[103] += q103*C_[1];
	I[104] += q104*C_[1];
	I[105] += q105*C_[1];
	I[106] += q106*C_[1];
	I[107] += q107*C_[1];
	I[108] += q108*C_[1];
	I[109] += q109*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q111 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q112 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q113 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	    q114 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q115 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	    q116 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q117 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q118 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q119 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[110] += q110*C_[1];
	I[111] += q111*C_[1];
	I[112] += q112*C_[1];
	I[113] += q113*C_[1];
	I[114] += q114*C_[1];
	I[115] += q115*C_[1];
	I[116] += q116*C_[1];
	I[117] += q117*C_[1];
	I[118] += q118*C_[1];
	I[119] += q119*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q121 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q122 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q123 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q124 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q125 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q126 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q127 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q128 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q129 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[1];
	I[127] += q127*C_[1];
	I[128] += q128*C_[1];
	I[129] += q129*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q131 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q132 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q133 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	    q134 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q135 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q136 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q137 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	    q138 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q139 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[130] += q130*C_[1];
	I[131] += q131*C_[1];
	I[132] += q132*C_[1];
	I[133] += q133*C_[1];
	I[134] += q134*C_[1];
	I[135] += q135*C_[1];
	I[136] += q136*C_[1];
	I[137] += q137*C_[1];
	I[138] += q138*C_[1];
	I[139] += q139*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q141 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q142 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q143 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[140] += q140*C_[1];
	I[141] += q141*C_[1];
	I[142] += q142*C_[1];
	I[143] += q143*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <sf| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::S,rysq::F> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::S,rysq::F> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 2;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3); // d/dAx
	    q3 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0); // d/dAx
	    q4 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1); // d/dAx
	    q5 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0); // d/dAx
	    q6 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1); // d/dAx
	    q7 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q11 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q12 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q13 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q14 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q15 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q16 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q17 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q18 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	    q19 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q21 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q22 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q23 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q24 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q25 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q26 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q27 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q28 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q29 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q31 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,0); // d/dBx
	    q32 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,3); // d/dBx
	    q33 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q34 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q35 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q36 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBx
	    q37 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q38 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBx
	    q39 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q41 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q42 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q43 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q44 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q45 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q46 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q47 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q48 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q49 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q51 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q52 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q53 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q54 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q55 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q56 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q57 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q58 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	    q59 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <pf| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::P,rysq::F> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::P,rysq::F> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAx
	    q3 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAx
	    q7 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q8 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAx
	    q9 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0); // d/dAx
	    q12 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3); // d/dAx
	    q13 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0); // d/dAx
	    q14 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1); // d/dAx
	    q15 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0); // d/dAx
	    q16 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1); // d/dAx
	    q17 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2); // d/dAx
	    q18 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2); // d/dAx
	    q19 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q21 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0); // d/dAx
	    q22 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3); // d/dAx
	    q23 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0); // d/dAx
	    q24 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1); // d/dAx
	    q25 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1); // d/dAx
	    q27 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2); // d/dAx
	    q28 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2); // d/dAx
	    q29 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1); // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q31 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q32 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q33 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q34 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q35 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q36 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q37 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q38 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	    q39 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q41 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAy
	    q42 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAy
	    q43 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q44 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q45 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	    q46 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAy
	    q47 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q48 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAy
	    q49 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q51 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAy
	    q52 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAy
	    q53 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q54 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q55 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q56 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAy
	    q57 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q58 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAy
	    q59 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q61 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q62 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q63 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q64 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q65 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q66 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q67 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q68 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q69 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q71 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAz
	    q72 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAz
	    q73 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q74 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q75 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q76 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAz
	    q77 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q78 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAz
	    q79 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q81 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAz
	    q82 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAz
	    q83 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q84 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q85 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	    q86 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAz
	    q87 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q88 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAz
	    q89 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q91 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,0); // d/dBx
	    q92 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,3); // d/dBx
	    q93 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q94 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q95 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q96 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBx
	    q97 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q98 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBx
	    q99 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q101 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,0); // d/dBx
	    q102 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,3); // d/dBx
	    q103 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q104 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q105 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBx
	    q106 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1); // d/dBx
	    q107 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBx
	    q108 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2); // d/dBx
	    q109 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q111 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,0); // d/dBx
	    q112 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,3); // d/dBx
	    q113 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q114 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q115 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBx
	    q116 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1); // d/dBx
	    q117 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBx
	    q118 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2); // d/dBx
	    q119 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q121 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q122 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q123 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q124 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q125 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q126 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q127 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q128 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q129 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q131 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBy
	    q132 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,3); // d/dBy
	    q133 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q134 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q135 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	    q136 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBy
	    q137 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q138 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBy
	    q139 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q141 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBy
	    q142 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,3); // d/dBy
	    q143 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q144 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q145 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	    q146 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBy
	    q147 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q148 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBy
	    q149 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q151 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q152 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q153 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q154 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q155 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q156 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q157 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q158 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	    q159 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q161 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,1); // d/dBz
	    q162 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBz
	    q163 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q164 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q165 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	    q166 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBz
	    q167 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q168 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBz
	    q169 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q171 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,1); // d/dBz
	    q172 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBz
	    q173 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q174 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q175 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q176 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBz
	    q177 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q178 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBz
	    q179 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <df| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::D,rysq::F> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::D,rysq::F> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 4;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAx
	    q3 += alpha*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAx
	    q7 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q8 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAx
	    q9 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,0); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,0); // d/dAx
	    q12 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,3); // d/dAx
	    q13 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,0); // d/dAx
	    q14 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,1); // d/dAx
	    q15 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,0); // d/dAx
	    q16 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,1); // d/dAx
	    q17 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,2); // d/dAx
	    q18 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,2); // d/dAx
	    q19 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,0); // d/dAx
	    q21 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,0); // d/dAx
	    q22 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,3); // d/dAx
	    q23 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,0); // d/dAx
	    q24 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,1); // d/dAx
	    q25 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,0); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,1); // d/dAx
	    q27 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,2); // d/dAx
	    q28 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,2); // d/dAx
	    q29 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1); // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q31 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dAx
	    q32 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dAx
	    q33 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q34 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q35 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dAx
	    q36 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dAx
	    q37 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dAx
	    q38 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dAx
	    q39 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q41 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dAx
	    q42 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dAx
	    q43 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q44 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q45 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dAx
	    q46 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dAx
	    q47 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dAx
	    q48 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dAx
	    q49 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAx
	    q51 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAx
	    q52 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAx
	    q53 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAx
	    q54 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAx
	    q55 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAx
	    q56 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAx
	    q57 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAx
	    q58 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAx
	    q59 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q61 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q62 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q63 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q64 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q65 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q66 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q67 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q68 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	    q69 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q71 += alpha*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dAy
	    q72 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dAy
	    q73 += alpha*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q74 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q75 += alpha*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dAy
	    q76 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dAy
	    q77 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dAy
	    q78 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,2)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dAy
	    q79 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q81 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,0); // d/dAy
	    q82 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,3); // d/dAy
	    q83 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q84 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q85 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,0); // d/dAy
	    q86 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,1); // d/dAy
	    q87 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,2); // d/dAy
	    q88 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,2); // d/dAy
	    q89 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1); // d/dAy
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q91 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAy
	    q92 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAy
	    q93 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q94 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q95 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	    q96 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAy
	    q97 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q98 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAy
	    q99 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q101 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAy
	    q102 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAy
	    q103 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q104 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q105 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q106 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAy
	    q107 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q108 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAy
	    q109 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q111 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dAy
	    q112 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dAy
	    q113 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q114 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	    q115 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dAy
	    q116 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dAy
	    q117 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dAy
	    q118 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dAy
	    q119 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q121 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q122 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q123 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q124 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q125 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q126 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q127 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q128 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q129 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q131 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,0); // d/dAz
	    q132 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,3); // d/dAz
	    q133 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q134 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	    q135 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,0); // d/dAz
	    q136 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,1); // d/dAz
	    q137 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,2); // d/dAz
	    q138 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,2); // d/dAz
	    q139 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q141 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dAz
	    q142 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dAz
	    q143 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q144 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q145 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dAz
	    q146 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dAz
	    q147 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dAz
	    q148 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dAz
	    q149 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q151 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAz
	    q152 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAz
	    q153 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q154 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q155 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q156 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAz
	    q157 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q158 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAz
	    q159 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q161 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAz
	    q162 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAz
	    q163 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q164 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q165 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	    q166 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAz
	    q167 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q168 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAz
	    q169 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q171 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dAz
	    q172 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dAz
	    q173 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q174 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q175 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dAz
	    q176 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dAz
	    q177 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dAz
	    q178 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dAz
	    q179 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += beta*Ix(a,2,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q181 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,0,0); // d/dBx
	    q182 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,3); // d/dBx
	    q183 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q184 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q185 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q186 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBx
	    q187 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q188 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBx
	    q189 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += beta*Ix(a,0,4)*Iy(a,2,0)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q191 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,0,0); // d/dBx
	    q192 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,3); // d/dBx
	    q193 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dBx
	    q194 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dBx
	    q195 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dBx
	    q196 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,1); // d/dBx
	    q197 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dBx
	    q198 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,2); // d/dBx
	    q199 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,2,0)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q201 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,2,0); // d/dBx
	    q202 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,3); // d/dBx
	    q203 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dBx
	    q204 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dBx
	    q205 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dBx
	    q206 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,1); // d/dBx
	    q207 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dBx
	    q208 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,2); // d/dBx
	    q209 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += beta*Ix(a,1,4)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q211 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,0); // d/dBx
	    q212 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,3); // d/dBx
	    q213 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q214 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q215 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBx
	    q216 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,1); // d/dBx
	    q217 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBx
	    q218 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,2); // d/dBx
	    q219 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];
	I[216] += q216*C_[0];
	I[217] += q217*C_[0];
	I[218] += q218*C_[0];
	I[219] += q219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q221 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,0); // d/dBx
	    q222 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,3); // d/dBx
	    q223 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q224 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q225 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBx
	    q226 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,1); // d/dBx
	    q227 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBx
	    q228 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,2); // d/dBx
	    q229 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[0];
	I[222] += q222*C_[0];
	I[223] += q223*C_[0];
	I[224] += q224*C_[0];
	I[225] += q225*C_[0];
	I[226] += q226*C_[0];
	I[227] += q227*C_[0];
	I[228] += q228*C_[0];
	I[229] += q229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q231 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,0); // d/dBx
	    q232 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,3); // d/dBx
	    q233 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dBx
	    q234 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dBx
	    q235 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dBx
	    q236 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,1); // d/dBx
	    q237 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dBx
	    q238 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,2); // d/dBx
	    q239 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[230] += q230*C_[0];
	I[231] += q231*C_[0];
	I[232] += q232*C_[0];
	I[233] += q233*C_[0];
	I[234] += q234*C_[0];
	I[235] += q235*C_[0];
	I[236] += q236*C_[0];
	I[237] += q237*C_[0];
	I[238] += q238*C_[0];
	I[239] += q239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q241 += beta*Ix(a,2,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q242 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q243 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q244 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q245 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q246 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q247 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q248 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q249 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q251 += beta*Ix(a,0,0)*Iy(a,2,4)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dBy
	    q252 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,3); // d/dBy
	    q253 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q254 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	    q255 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dBy
	    q256 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dBy
	    q257 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,2); // d/dBy
	    q258 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dBy
	    q259 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[0];
	I[256] += q256*C_[0];
	I[257] += q257*C_[0];
	I[258] += q258*C_[0];
	I[259] += q259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q261 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,2,0)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dBy
	    q262 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,3); // d/dBy
	    q263 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q264 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q265 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dBy
	    q266 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,1)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dBy
	    q267 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,2); // d/dBy
	    q268 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dBy
	    q269 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[0];
	I[262] += q262*C_[0];
	I[263] += q263*C_[0];
	I[264] += q264*C_[0];
	I[265] += q265*C_[0];
	I[266] += q266*C_[0];
	I[267] += q267*C_[0];
	I[268] += q268*C_[0];
	I[269] += q269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q270 = 0.0;
	T q271 = 0.0;
	T q272 = 0.0;
	T q273 = 0.0;
	T q274 = 0.0;
	T q275 = 0.0;
	T q276 = 0.0;
	T q277 = 0.0;
	T q278 = 0.0;
	T q279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q270 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q271 += beta*Ix(a,1,0)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBy
	    q272 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,3); // d/dBy
	    q273 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q274 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q275 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	    q276 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBy
	    q277 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q278 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBy
	    q279 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[270] += q270*C_[0];
	I[271] += q271*C_[0];
	I[272] += q272*C_[0];
	I[273] += q273*C_[0];
	I[274] += q274*C_[0];
	I[275] += q275*C_[0];
	I[276] += q276*C_[0];
	I[277] += q277*C_[0];
	I[278] += q278*C_[0];
	I[279] += q279*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q280 = 0.0;
	T q281 = 0.0;
	T q282 = 0.0;
	T q283 = 0.0;
	T q284 = 0.0;
	T q285 = 0.0;
	T q286 = 0.0;
	T q287 = 0.0;
	T q288 = 0.0;
	T q289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q280 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q281 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBy
	    q282 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,3); // d/dBy
	    q283 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q284 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q285 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	    q286 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBy
	    q287 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q288 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBy
	    q289 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[280] += q280*C_[0];
	I[281] += q281*C_[0];
	I[282] += q282*C_[0];
	I[283] += q283*C_[0];
	I[284] += q284*C_[0];
	I[285] += q285*C_[0];
	I[286] += q286*C_[0];
	I[287] += q287*C_[0];
	I[288] += q288*C_[0];
	I[289] += q289*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q290 = 0.0;
	T q291 = 0.0;
	T q292 = 0.0;
	T q293 = 0.0;
	T q294 = 0.0;
	T q295 = 0.0;
	T q296 = 0.0;
	T q297 = 0.0;
	T q298 = 0.0;
	T q299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q290 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q291 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dBy
	    q292 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,3); // d/dBy
	    q293 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q294 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	    q295 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dBy
	    q296 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,1)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dBy
	    q297 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,2); // d/dBy
	    q298 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dBy
	    q299 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[290] += q290*C_[0];
	I[291] += q291*C_[0];
	I[292] += q292*C_[0];
	I[293] += q293*C_[0];
	I[294] += q294*C_[0];
	I[295] += q295*C_[0];
	I[296] += q296*C_[0];
	I[297] += q297*C_[0];
	I[298] += q298*C_[0];
	I[299] += q299*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q300 = 0.0;
	T q301 = 0.0;
	T q302 = 0.0;
	T q303 = 0.0;
	T q304 = 0.0;
	T q305 = 0.0;
	T q306 = 0.0;
	T q307 = 0.0;
	T q308 = 0.0;
	T q309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q300 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q301 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q302 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q303 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q304 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q305 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q306 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q307 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q308 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	    q309 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[300] += q300*C_[0];
	I[301] += q301*C_[0];
	I[302] += q302*C_[0];
	I[303] += q303*C_[0];
	I[304] += q304*C_[0];
	I[305] += q305*C_[0];
	I[306] += q306*C_[0];
	I[307] += q307*C_[0];
	I[308] += q308*C_[0];
	I[309] += q309*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q310 = 0.0;
	T q311 = 0.0;
	T q312 = 0.0;
	T q313 = 0.0;
	T q314 = 0.0;
	T q315 = 0.0;
	T q316 = 0.0;
	T q317 = 0.0;
	T q318 = 0.0;
	T q319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q310 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q311 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,1); // d/dBz
	    q312 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dBz
	    q313 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q314 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q315 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,1); // d/dBz
	    q316 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dBz
	    q317 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dBz
	    q318 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dBz
	    q319 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[310] += q310*C_[0];
	I[311] += q311*C_[0];
	I[312] += q312*C_[0];
	I[313] += q313*C_[0];
	I[314] += q314*C_[0];
	I[315] += q315*C_[0];
	I[316] += q316*C_[0];
	I[317] += q317*C_[0];
	I[318] += q318*C_[0];
	I[319] += q319*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q320 = 0.0;
	T q321 = 0.0;
	T q322 = 0.0;
	T q323 = 0.0;
	T q324 = 0.0;
	T q325 = 0.0;
	T q326 = 0.0;
	T q327 = 0.0;
	T q328 = 0.0;
	T q329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q320 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q321 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,1); // d/dBz
	    q322 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,4)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dBz
	    q323 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q324 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q325 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,1); // d/dBz
	    q326 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dBz
	    q327 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dBz
	    q328 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dBz
	    q329 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[320] += q320*C_[0];
	I[321] += q321*C_[0];
	I[322] += q322*C_[0];
	I[323] += q323*C_[0];
	I[324] += q324*C_[0];
	I[325] += q325*C_[0];
	I[326] += q326*C_[0];
	I[327] += q327*C_[0];
	I[328] += q328*C_[0];
	I[329] += q329*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q330 = 0.0;
	T q331 = 0.0;
	T q332 = 0.0;
	T q333 = 0.0;
	T q334 = 0.0;
	T q335 = 0.0;
	T q336 = 0.0;
	T q337 = 0.0;
	T q338 = 0.0;
	T q339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q330 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q331 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,1); // d/dBz
	    q332 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBz
	    q333 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q334 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q335 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	    q336 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBz
	    q337 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q338 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBz
	    q339 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[330] += q330*C_[0];
	I[331] += q331*C_[0];
	I[332] += q332*C_[0];
	I[333] += q333*C_[0];
	I[334] += q334*C_[0];
	I[335] += q335*C_[0];
	I[336] += q336*C_[0];
	I[337] += q337*C_[0];
	I[338] += q338*C_[0];
	I[339] += q339*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q340 = 0.0;
	T q341 = 0.0;
	T q342 = 0.0;
	T q343 = 0.0;
	T q344 = 0.0;
	T q345 = 0.0;
	T q346 = 0.0;
	T q347 = 0.0;
	T q348 = 0.0;
	T q349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q340 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q341 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,1); // d/dBz
	    q342 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBz
	    q343 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q344 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q345 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q346 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBz
	    q347 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q348 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBz
	    q349 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[340] += q340*C_[0];
	I[341] += q341*C_[0];
	I[342] += q342*C_[0];
	I[343] += q343*C_[0];
	I[344] += q344*C_[0];
	I[345] += q345*C_[0];
	I[346] += q346*C_[0];
	I[347] += q347*C_[0];
	I[348] += q348*C_[0];
	I[349] += q349*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q350 = 0.0;
	T q351 = 0.0;
	T q352 = 0.0;
	T q353 = 0.0;
	T q354 = 0.0;
	T q355 = 0.0;
	T q356 = 0.0;
	T q357 = 0.0;
	T q358 = 0.0;
	T q359 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q350 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q351 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,1); // d/dBz
	    q352 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dBz
	    q353 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q354 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	    q355 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,1); // d/dBz
	    q356 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dBz
	    q357 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dBz
	    q358 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dBz
	    q359 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[350] += q350*C_[0];
	I[351] += q351*C_[0];
	I[352] += q352*C_[0];
	I[353] += q353*C_[0];
	I[354] += q354*C_[0];
	I[355] += q355*C_[0];
	I[356] += q356*C_[0];
	I[357] += q357*C_[0];
	I[358] += q358*C_[0];
	I[359] += q359*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <ff| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::F,rysq::F> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::F,rysq::F> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 5;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,4,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,4,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAx
	    q3 += alpha*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAx
	    q7 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q8 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAx
	    q9 += alpha*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,1)
                     - 3*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,0); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,0); // d/dAx
	    q12 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,3); // d/dAx
	    q13 += alpha*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,0); // d/dAx
	    q14 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,1); // d/dAx
	    q15 += alpha*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,0); // d/dAx
	    q16 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,1); // d/dAx
	    q17 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,2); // d/dAx
	    q18 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,2); // d/dAx
	    q19 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,0); // d/dAx
	    q21 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,0); // d/dAx
	    q22 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,3); // d/dAx
	    q23 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,0); // d/dAx
	    q24 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,1); // d/dAx
	    q25 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,0); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,1); // d/dAx
	    q27 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,2); // d/dAx
	    q28 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,2); // d/dAx
	    q29 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,1); // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q31 += alpha*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dAx
	    q32 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dAx
	    q33 += alpha*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q34 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,1)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q35 += alpha*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dAx
	    q36 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dAx
	    q37 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dAx
	    q38 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dAx
	    q39 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q41 += alpha*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dAx
	    q42 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dAx
	    q43 += alpha*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q44 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,1)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q45 += alpha*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dAx
	    q46 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dAx
	    q47 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,2)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dAx
	    q48 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dAx
	    q49 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q51 += alpha*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dAx
	    q52 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dAx
	    q53 += alpha*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dAx
	    q54 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dAx
	    q55 += alpha*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dAx
	    q56 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dAx
	    q57 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dAx
	    q58 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dAx
	    q59 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,0); // d/dAx
	    q61 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,0); // d/dAx
	    q62 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,3); // d/dAx
	    q63 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,0); // d/dAx
	    q64 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,1); // d/dAx
	    q65 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,0); // d/dAx
	    q66 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,1); // d/dAx
	    q67 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,2); // d/dAx
	    q68 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,2); // d/dAx
	    q69 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,1); // d/dAx
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q71 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dAx
	    q72 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dAx
	    q73 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dAx
	    q74 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dAx
	    q75 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dAx
	    q76 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dAx
	    q77 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dAx
	    q78 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dAx
	    q79 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,0); // d/dAx
	    q81 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,0); // d/dAx
	    q82 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,3); // d/dAx
	    q83 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,0); // d/dAx
	    q84 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,1); // d/dAx
	    q85 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,0); // d/dAx
	    q86 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,1); // d/dAx
	    q87 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,2); // d/dAx
	    q88 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,2); // d/dAx
	    q89 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,1); // d/dAx
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q91 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dAx
	    q92 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dAx
	    q93 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dAx
	    q94 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dAx
	    q95 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dAx
	    q96 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dAx
	    q97 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dAx
	    q98 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dAx
	    q99 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q101 += alpha*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q102 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q103 += alpha*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q104 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q105 += alpha*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q106 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q107 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q108 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	    q109 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,0,3)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q111 += alpha*Ix(a,0,0)*Iy(a,4,3)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dAy
	    q112 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,3)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dAy
	    q113 += alpha*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dAy
	    q114 += alpha*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dAy
	    q115 += alpha*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dAy
	    q116 += alpha*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dAy
	    q117 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,2)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dAy
	    q118 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,2)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dAy
	    q119 += alpha*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,1)
                     - 3*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q121 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,0); // d/dAy
	    q122 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,3); // d/dAy
	    q123 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,0); // d/dAy
	    q124 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,1); // d/dAy
	    q125 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,0); // d/dAy
	    q126 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,1); // d/dAy
	    q127 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,2); // d/dAy
	    q128 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,2); // d/dAy
	    q129 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,1); // d/dAy
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q131 += alpha*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAy
	    q132 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAy
	    q133 += alpha*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q134 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q135 += alpha*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	    q136 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAy
	    q137 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q138 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAy
	    q139 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q141 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAy
	    q142 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAy
	    q143 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q144 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q145 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q146 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAy
	    q147 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q148 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAy
	    q149 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += alpha*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q151 += alpha*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dAy
	    q152 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dAy
	    q153 += alpha*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q154 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q155 += alpha*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dAy
	    q156 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dAy
	    q157 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dAy
	    q158 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dAy
	    q159 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += alpha*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q161 += alpha*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dAy
	    q162 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dAy
	    q163 += alpha*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dAy
	    q164 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dAy
	    q165 += alpha*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dAy
	    q166 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,1)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dAy
	    q167 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,2)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dAy
	    q168 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,2)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dAy
	    q169 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q171 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,0); // d/dAy
	    q172 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,3); // d/dAy
	    q173 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q174 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q175 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,0); // d/dAy
	    q176 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,1); // d/dAy
	    q177 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,2); // d/dAy
	    q178 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,2); // d/dAy
	    q179 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,1); // d/dAy
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q181 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dAy
	    q182 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dAy
	    q183 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dAy
	    q184 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dAy
	    q185 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dAy
	    q186 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dAy
	    q187 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dAy
	    q188 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dAy
	    q189 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q191 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dAy
	    q192 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dAy
	    q193 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q194 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	    q195 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dAy
	    q196 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dAy
	    q197 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dAy
	    q198 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dAy
	    q199 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += alpha*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q201 += alpha*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q202 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q203 += alpha*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q204 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q205 += alpha*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q206 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q207 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q208 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q209 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += alpha*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q211 += alpha*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,0); // d/dAz
	    q212 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,3); // d/dAz
	    q213 += alpha*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,0); // d/dAz
	    q214 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,1); // d/dAz
	    q215 += alpha*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,0); // d/dAz
	    q216 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,1); // d/dAz
	    q217 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,2); // d/dAz
	    q218 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,2); // d/dAz
	    q219 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];
	I[216] += q216*C_[0];
	I[217] += q217*C_[0];
	I[218] += q218*C_[0];
	I[219] += q219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q221 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dAz
	    q222 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,3)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dAz
	    q223 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dAz
	    q224 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dAz
	    q225 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dAz
	    q226 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dAz
	    q227 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,2)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dAz
	    q228 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,2)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dAz
	    q229 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,1)
                     - 3*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[0];
	I[222] += q222*C_[0];
	I[223] += q223*C_[0];
	I[224] += q224*C_[0];
	I[225] += q225*C_[0];
	I[226] += q226*C_[0];
	I[227] += q227*C_[0];
	I[228] += q228*C_[0];
	I[229] += q229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q231 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAz
	    q232 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAz
	    q233 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q234 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q235 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q236 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAz
	    q237 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q238 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAz
	    q239 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[230] += q230*C_[0];
	I[231] += q231*C_[0];
	I[232] += q232*C_[0];
	I[233] += q233*C_[0];
	I[234] += q234*C_[0];
	I[235] += q235*C_[0];
	I[236] += q236*C_[0];
	I[237] += q237*C_[0];
	I[238] += q238*C_[0];
	I[239] += q239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q241 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAz
	    q242 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAz
	    q243 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q244 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q245 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	    q246 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAz
	    q247 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q248 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAz
	    q249 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q251 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,0); // d/dAz
	    q252 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,3); // d/dAz
	    q253 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q254 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	    q255 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,0); // d/dAz
	    q256 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,1); // d/dAz
	    q257 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,2); // d/dAz
	    q258 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,2); // d/dAz
	    q259 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[0];
	I[256] += q256*C_[0];
	I[257] += q257*C_[0];
	I[258] += q258*C_[0];
	I[259] += q259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q261 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dAz
	    q262 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dAz
	    q263 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dAz
	    q264 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dAz
	    q265 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dAz
	    q266 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dAz
	    q267 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dAz
	    q268 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dAz
	    q269 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[0];
	I[262] += q262*C_[0];
	I[263] += q263*C_[0];
	I[264] += q264*C_[0];
	I[265] += q265*C_[0];
	I[266] += q266*C_[0];
	I[267] += q267*C_[0];
	I[268] += q268*C_[0];
	I[269] += q269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q270 = 0.0;
	T q271 = 0.0;
	T q272 = 0.0;
	T q273 = 0.0;
	T q274 = 0.0;
	T q275 = 0.0;
	T q276 = 0.0;
	T q277 = 0.0;
	T q278 = 0.0;
	T q279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q270 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q271 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dAz
	    q272 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dAz
	    q273 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q274 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q275 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dAz
	    q276 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dAz
	    q277 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dAz
	    q278 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,2)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dAz
	    q279 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[270] += q270*C_[0];
	I[271] += q271*C_[0];
	I[272] += q272*C_[0];
	I[273] += q273*C_[0];
	I[274] += q274*C_[0];
	I[275] += q275*C_[0];
	I[276] += q276*C_[0];
	I[277] += q277*C_[0];
	I[278] += q278*C_[0];
	I[279] += q279*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q280 = 0.0;
	T q281 = 0.0;
	T q282 = 0.0;
	T q283 = 0.0;
	T q284 = 0.0;
	T q285 = 0.0;
	T q286 = 0.0;
	T q287 = 0.0;
	T q288 = 0.0;
	T q289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q280 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q281 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dAz
	    q282 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dAz
	    q283 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dAz
	    q284 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dAz
	    q285 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dAz
	    q286 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dAz
	    q287 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,2)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dAz
	    q288 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dAz
	    q289 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[280] += q280*C_[0];
	I[281] += q281*C_[0];
	I[282] += q282*C_[0];
	I[283] += q283*C_[0];
	I[284] += q284*C_[0];
	I[285] += q285*C_[0];
	I[286] += q286*C_[0];
	I[287] += q287*C_[0];
	I[288] += q288*C_[0];
	I[289] += q289*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q290 = 0.0;
	T q291 = 0.0;
	T q292 = 0.0;
	T q293 = 0.0;
	T q294 = 0.0;
	T q295 = 0.0;
	T q296 = 0.0;
	T q297 = 0.0;
	T q298 = 0.0;
	T q299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q290 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q291 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dAz
	    q292 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dAz
	    q293 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q294 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q295 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dAz
	    q296 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dAz
	    q297 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dAz
	    q298 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dAz
	    q299 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[290] += q290*C_[0];
	I[291] += q291*C_[0];
	I[292] += q292*C_[0];
	I[293] += q293*C_[0];
	I[294] += q294*C_[0];
	I[295] += q295*C_[0];
	I[296] += q296*C_[0];
	I[297] += q297*C_[0];
	I[298] += q298*C_[0];
	I[299] += q299*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q300 = 0.0;
	T q301 = 0.0;
	T q302 = 0.0;
	T q303 = 0.0;
	T q304 = 0.0;
	T q305 = 0.0;
	T q306 = 0.0;
	T q307 = 0.0;
	T q308 = 0.0;
	T q309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q300 += beta*Ix(a,3,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q301 += beta*Ix(a,3,1)*Iy(a,0,3)*Iz(a,0,0); // d/dBx
	    q302 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,3); // d/dBx
	    q303 += beta*Ix(a,3,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q304 += beta*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q305 += beta*Ix(a,3,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q306 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBx
	    q307 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q308 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBx
	    q309 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[300] += q300*C_[0];
	I[301] += q301*C_[0];
	I[302] += q302*C_[0];
	I[303] += q303*C_[0];
	I[304] += q304*C_[0];
	I[305] += q305*C_[0];
	I[306] += q306*C_[0];
	I[307] += q307*C_[0];
	I[308] += q308*C_[0];
	I[309] += q309*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q310 = 0.0;
	T q311 = 0.0;
	T q312 = 0.0;
	T q313 = 0.0;
	T q314 = 0.0;
	T q315 = 0.0;
	T q316 = 0.0;
	T q317 = 0.0;
	T q318 = 0.0;
	T q319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q310 += beta*Ix(a,0,4)*Iy(a,3,0)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,0);  // d/dBx
	    q311 += beta*Ix(a,0,1)*Iy(a,3,3)*Iz(a,0,0); // d/dBx
	    q312 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,3); // d/dBx
	    q313 += beta*Ix(a,0,3)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0);  // d/dBx
	    q314 += beta*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1);  // d/dBx
	    q315 += beta*Ix(a,0,2)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,0);  // d/dBx
	    q316 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,1); // d/dBx
	    q317 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,2);  // d/dBx
	    q318 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,2); // d/dBx
	    q319 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[310] += q310*C_[0];
	I[311] += q311*C_[0];
	I[312] += q312*C_[0];
	I[313] += q313*C_[0];
	I[314] += q314*C_[0];
	I[315] += q315*C_[0];
	I[316] += q316*C_[0];
	I[317] += q317*C_[0];
	I[318] += q318*C_[0];
	I[319] += q319*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q320 = 0.0;
	T q321 = 0.0;
	T q322 = 0.0;
	T q323 = 0.0;
	T q324 = 0.0;
	T q325 = 0.0;
	T q326 = 0.0;
	T q327 = 0.0;
	T q328 = 0.0;
	T q329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q320 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,3,0)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,0);  // d/dBx
	    q321 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,3,0); // d/dBx
	    q322 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,3); // d/dBx
	    q323 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0);  // d/dBx
	    q324 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1);  // d/dBx
	    q325 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,0);  // d/dBx
	    q326 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,1); // d/dBx
	    q327 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,2);  // d/dBx
	    q328 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,2); // d/dBx
	    q329 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[320] += q320*C_[0];
	I[321] += q321*C_[0];
	I[322] += q322*C_[0];
	I[323] += q323*C_[0];
	I[324] += q324*C_[0];
	I[325] += q325*C_[0];
	I[326] += q326*C_[0];
	I[327] += q327*C_[0];
	I[328] += q328*C_[0];
	I[329] += q329*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q330 = 0.0;
	T q331 = 0.0;
	T q332 = 0.0;
	T q333 = 0.0;
	T q334 = 0.0;
	T q335 = 0.0;
	T q336 = 0.0;
	T q337 = 0.0;
	T q338 = 0.0;
	T q339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q330 += beta*Ix(a,2,4)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q331 += beta*Ix(a,2,1)*Iy(a,1,3)*Iz(a,0,0); // d/dBx
	    q332 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,3); // d/dBx
	    q333 += beta*Ix(a,2,3)*Iy(a,1,1)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q334 += beta*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q335 += beta*Ix(a,2,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBx
	    q336 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,1); // d/dBx
	    q337 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBx
	    q338 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,2); // d/dBx
	    q339 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[330] += q330*C_[0];
	I[331] += q331*C_[0];
	I[332] += q332*C_[0];
	I[333] += q333*C_[0];
	I[334] += q334*C_[0];
	I[335] += q335*C_[0];
	I[336] += q336*C_[0];
	I[337] += q337*C_[0];
	I[338] += q338*C_[0];
	I[339] += q339*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q340 = 0.0;
	T q341 = 0.0;
	T q342 = 0.0;
	T q343 = 0.0;
	T q344 = 0.0;
	T q345 = 0.0;
	T q346 = 0.0;
	T q347 = 0.0;
	T q348 = 0.0;
	T q349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q340 += beta*Ix(a,2,4)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q341 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,1,0); // d/dBx
	    q342 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,3); // d/dBx
	    q343 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,1,0)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q344 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,1)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q345 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBx
	    q346 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,1); // d/dBx
	    q347 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBx
	    q348 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,2); // d/dBx
	    q349 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[340] += q340*C_[0];
	I[341] += q341*C_[0];
	I[342] += q342*C_[0];
	I[343] += q343*C_[0];
	I[344] += q344*C_[0];
	I[345] += q345*C_[0];
	I[346] += q346*C_[0];
	I[347] += q347*C_[0];
	I[348] += q348*C_[0];
	I[349] += q349*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q350 = 0.0;
	T q351 = 0.0;
	T q352 = 0.0;
	T q353 = 0.0;
	T q354 = 0.0;
	T q355 = 0.0;
	T q356 = 0.0;
	T q357 = 0.0;
	T q358 = 0.0;
	T q359 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q350 += beta*Ix(a,1,4)*Iy(a,2,0)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q351 += beta*Ix(a,1,1)*Iy(a,2,3)*Iz(a,0,0); // d/dBx
	    q352 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,3); // d/dBx
	    q353 += beta*Ix(a,1,3)*Iy(a,2,1)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dBx
	    q354 += beta*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dBx
	    q355 += beta*Ix(a,1,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dBx
	    q356 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,1); // d/dBx
	    q357 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dBx
	    q358 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,2); // d/dBx
	    q359 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[350] += q350*C_[0];
	I[351] += q351*C_[0];
	I[352] += q352*C_[0];
	I[353] += q353*C_[0];
	I[354] += q354*C_[0];
	I[355] += q355*C_[0];
	I[356] += q356*C_[0];
	I[357] += q357*C_[0];
	I[358] += q358*C_[0];
	I[359] += q359*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q360 = 0.0;
	T q361 = 0.0;
	T q362 = 0.0;
	T q363 = 0.0;
	T q364 = 0.0;
	T q365 = 0.0;
	T q366 = 0.0;
	T q367 = 0.0;
	T q368 = 0.0;
	T q369 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q360 += beta*Ix(a,0,4)*Iy(a,2,0)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,0);  // d/dBx
	    q361 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,1,0); // d/dBx
	    q362 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,3); // d/dBx
	    q363 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0);  // d/dBx
	    q364 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1);  // d/dBx
	    q365 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,0);  // d/dBx
	    q366 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,1); // d/dBx
	    q367 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,2);  // d/dBx
	    q368 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,2); // d/dBx
	    q369 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[360] += q360*C_[0];
	I[361] += q361*C_[0];
	I[362] += q362*C_[0];
	I[363] += q363*C_[0];
	I[364] += q364*C_[0];
	I[365] += q365*C_[0];
	I[366] += q366*C_[0];
	I[367] += q367*C_[0];
	I[368] += q368*C_[0];
	I[369] += q369*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q370 = 0.0;
	T q371 = 0.0;
	T q372 = 0.0;
	T q373 = 0.0;
	T q374 = 0.0;
	T q375 = 0.0;
	T q376 = 0.0;
	T q377 = 0.0;
	T q378 = 0.0;
	T q379 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q370 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,2,0)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q371 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,2,0); // d/dBx
	    q372 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,3); // d/dBx
	    q373 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dBx
	    q374 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,1)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dBx
	    q375 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dBx
	    q376 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,1); // d/dBx
	    q377 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dBx
	    q378 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,2); // d/dBx
	    q379 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[370] += q370*C_[0];
	I[371] += q371*C_[0];
	I[372] += q372*C_[0];
	I[373] += q373*C_[0];
	I[374] += q374*C_[0];
	I[375] += q375*C_[0];
	I[376] += q376*C_[0];
	I[377] += q377*C_[0];
	I[378] += q378*C_[0];
	I[379] += q379*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q380 = 0.0;
	T q381 = 0.0;
	T q382 = 0.0;
	T q383 = 0.0;
	T q384 = 0.0;
	T q385 = 0.0;
	T q386 = 0.0;
	T q387 = 0.0;
	T q388 = 0.0;
	T q389 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q380 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,2,0)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,0);  // d/dBx
	    q381 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,2,0); // d/dBx
	    q382 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,3); // d/dBx
	    q383 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0);  // d/dBx
	    q384 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1);  // d/dBx
	    q385 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,0);  // d/dBx
	    q386 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,1); // d/dBx
	    q387 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,2);  // d/dBx
	    q388 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,2); // d/dBx
	    q389 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[380] += q380*C_[0];
	I[381] += q381*C_[0];
	I[382] += q382*C_[0];
	I[383] += q383*C_[0];
	I[384] += q384*C_[0];
	I[385] += q385*C_[0];
	I[386] += q386*C_[0];
	I[387] += q387*C_[0];
	I[388] += q388*C_[0];
	I[389] += q389*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q390 = 0.0;
	T q391 = 0.0;
	T q392 = 0.0;
	T q393 = 0.0;
	T q394 = 0.0;
	T q395 = 0.0;
	T q396 = 0.0;
	T q397 = 0.0;
	T q398 = 0.0;
	T q399 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q390 += beta*Ix(a,1,4)*Iy(a,1,0)*Iz(a,1,0)
                     - 3*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q391 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,0); // d/dBx
	    q392 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,3); // d/dBx
	    q393 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dBx
	    q394 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dBx
	    q395 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dBx
	    q396 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,1); // d/dBx
	    q397 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dBx
	    q398 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,2); // d/dBx
	    q399 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[390] += q390*C_[0];
	I[391] += q391*C_[0];
	I[392] += q392*C_[0];
	I[393] += q393*C_[0];
	I[394] += q394*C_[0];
	I[395] += q395*C_[0];
	I[396] += q396*C_[0];
	I[397] += q397*C_[0];
	I[398] += q398*C_[0];
	I[399] += q399*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q400 = 0.0;
	T q401 = 0.0;
	T q402 = 0.0;
	T q403 = 0.0;
	T q404 = 0.0;
	T q405 = 0.0;
	T q406 = 0.0;
	T q407 = 0.0;
	T q408 = 0.0;
	T q409 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q400 += beta*Ix(a,3,3)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q401 += beta*Ix(a,3,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q402 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q403 += beta*Ix(a,3,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q404 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q405 += beta*Ix(a,3,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q406 += beta*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q407 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q408 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q409 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[400] += q400*C_[0];
	I[401] += q401*C_[0];
	I[402] += q402*C_[0];
	I[403] += q403*C_[0];
	I[404] += q404*C_[0];
	I[405] += q405*C_[0];
	I[406] += q406*C_[0];
	I[407] += q407*C_[0];
	I[408] += q408*C_[0];
	I[409] += q409*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q410 = 0.0;
	T q411 = 0.0;
	T q412 = 0.0;
	T q413 = 0.0;
	T q414 = 0.0;
	T q415 = 0.0;
	T q416 = 0.0;
	T q417 = 0.0;
	T q418 = 0.0;
	T q419 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q410 += beta*Ix(a,0,3)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q411 += beta*Ix(a,0,0)*Iy(a,3,4)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,0);  // d/dBy
	    q412 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,3); // d/dBy
	    q413 += beta*Ix(a,0,2)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,0);  // d/dBy
	    q414 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,1); // d/dBy
	    q415 += beta*Ix(a,0,1)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0);  // d/dBy
	    q416 += beta*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1);  // d/dBy
	    q417 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,2); // d/dBy
	    q418 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,2);  // d/dBy
	    q419 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[410] += q410*C_[0];
	I[411] += q411*C_[0];
	I[412] += q412*C_[0];
	I[413] += q413*C_[0];
	I[414] += q414*C_[0];
	I[415] += q415*C_[0];
	I[416] += q416*C_[0];
	I[417] += q417*C_[0];
	I[418] += q418*C_[0];
	I[419] += q419*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q420 = 0.0;
	T q421 = 0.0;
	T q422 = 0.0;
	T q423 = 0.0;
	T q424 = 0.0;
	T q425 = 0.0;
	T q426 = 0.0;
	T q427 = 0.0;
	T q428 = 0.0;
	T q429 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q420 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q421 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,3,0)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,0);  // d/dBy
	    q422 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,3); // d/dBy
	    q423 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,0);  // d/dBy
	    q424 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,1); // d/dBy
	    q425 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0);  // d/dBy
	    q426 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1);  // d/dBy
	    q427 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,2); // d/dBy
	    q428 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,2);  // d/dBy
	    q429 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[420] += q420*C_[0];
	I[421] += q421*C_[0];
	I[422] += q422*C_[0];
	I[423] += q423*C_[0];
	I[424] += q424*C_[0];
	I[425] += q425*C_[0];
	I[426] += q426*C_[0];
	I[427] += q427*C_[0];
	I[428] += q428*C_[0];
	I[429] += q429*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q430 = 0.0;
	T q431 = 0.0;
	T q432 = 0.0;
	T q433 = 0.0;
	T q434 = 0.0;
	T q435 = 0.0;
	T q436 = 0.0;
	T q437 = 0.0;
	T q438 = 0.0;
	T q439 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q430 += beta*Ix(a,2,3)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q431 += beta*Ix(a,2,0)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBy
	    q432 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,3); // d/dBy
	    q433 += beta*Ix(a,2,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q434 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q435 += beta*Ix(a,2,1)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	    q436 += beta*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBy
	    q437 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q438 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBy
	    q439 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[430] += q430*C_[0];
	I[431] += q431*C_[0];
	I[432] += q432*C_[0];
	I[433] += q433*C_[0];
	I[434] += q434*C_[0];
	I[435] += q435*C_[0];
	I[436] += q436*C_[0];
	I[437] += q437*C_[0];
	I[438] += q438*C_[0];
	I[439] += q439*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q440 = 0.0;
	T q441 = 0.0;
	T q442 = 0.0;
	T q443 = 0.0;
	T q444 = 0.0;
	T q445 = 0.0;
	T q446 = 0.0;
	T q447 = 0.0;
	T q448 = 0.0;
	T q449 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q440 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q441 += beta*Ix(a,2,0)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBy
	    q442 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,3); // d/dBy
	    q443 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q444 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q445 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	    q446 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBy
	    q447 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q448 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBy
	    q449 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[440] += q440*C_[0];
	I[441] += q441*C_[0];
	I[442] += q442*C_[0];
	I[443] += q443*C_[0];
	I[444] += q444*C_[0];
	I[445] += q445*C_[0];
	I[446] += q446*C_[0];
	I[447] += q447*C_[0];
	I[448] += q448*C_[0];
	I[449] += q449*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q450 = 0.0;
	T q451 = 0.0;
	T q452 = 0.0;
	T q453 = 0.0;
	T q454 = 0.0;
	T q455 = 0.0;
	T q456 = 0.0;
	T q457 = 0.0;
	T q458 = 0.0;
	T q459 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q450 += beta*Ix(a,1,3)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q451 += beta*Ix(a,1,0)*Iy(a,2,4)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dBy
	    q452 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,3); // d/dBy
	    q453 += beta*Ix(a,1,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q454 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	    q455 += beta*Ix(a,1,1)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dBy
	    q456 += beta*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dBy
	    q457 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,2); // d/dBy
	    q458 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dBy
	    q459 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[450] += q450*C_[0];
	I[451] += q451*C_[0];
	I[452] += q452*C_[0];
	I[453] += q453*C_[0];
	I[454] += q454*C_[0];
	I[455] += q455*C_[0];
	I[456] += q456*C_[0];
	I[457] += q457*C_[0];
	I[458] += q458*C_[0];
	I[459] += q459*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q460 = 0.0;
	T q461 = 0.0;
	T q462 = 0.0;
	T q463 = 0.0;
	T q464 = 0.0;
	T q465 = 0.0;
	T q466 = 0.0;
	T q467 = 0.0;
	T q468 = 0.0;
	T q469 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q460 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q461 += beta*Ix(a,0,0)*Iy(a,2,4)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,0);  // d/dBy
	    q462 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,3); // d/dBy
	    q463 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,0);  // d/dBy
	    q464 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,1); // d/dBy
	    q465 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0);  // d/dBy
	    q466 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,1)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1);  // d/dBy
	    q467 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,2); // d/dBy
	    q468 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,2);  // d/dBy
	    q469 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[460] += q460*C_[0];
	I[461] += q461*C_[0];
	I[462] += q462*C_[0];
	I[463] += q463*C_[0];
	I[464] += q464*C_[0];
	I[465] += q465*C_[0];
	I[466] += q466*C_[0];
	I[467] += q467*C_[0];
	I[468] += q468*C_[0];
	I[469] += q469*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q470 = 0.0;
	T q471 = 0.0;
	T q472 = 0.0;
	T q473 = 0.0;
	T q474 = 0.0;
	T q475 = 0.0;
	T q476 = 0.0;
	T q477 = 0.0;
	T q478 = 0.0;
	T q479 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q470 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q471 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,2,0)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dBy
	    q472 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,3); // d/dBy
	    q473 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q474 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q475 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dBy
	    q476 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,1)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dBy
	    q477 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,2); // d/dBy
	    q478 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dBy
	    q479 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[470] += q470*C_[0];
	I[471] += q471*C_[0];
	I[472] += q472*C_[0];
	I[473] += q473*C_[0];
	I[474] += q474*C_[0];
	I[475] += q475*C_[0];
	I[476] += q476*C_[0];
	I[477] += q477*C_[0];
	I[478] += q478*C_[0];
	I[479] += q479*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q480 = 0.0;
	T q481 = 0.0;
	T q482 = 0.0;
	T q483 = 0.0;
	T q484 = 0.0;
	T q485 = 0.0;
	T q486 = 0.0;
	T q487 = 0.0;
	T q488 = 0.0;
	T q489 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q480 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q481 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,2,0)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,0);  // d/dBy
	    q482 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,3); // d/dBy
	    q483 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,0);  // d/dBy
	    q484 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,1); // d/dBy
	    q485 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0);  // d/dBy
	    q486 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,1)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1);  // d/dBy
	    q487 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,2); // d/dBy
	    q488 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,2);  // d/dBy
	    q489 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[480] += q480*C_[0];
	I[481] += q481*C_[0];
	I[482] += q482*C_[0];
	I[483] += q483*C_[0];
	I[484] += q484*C_[0];
	I[485] += q485*C_[0];
	I[486] += q486*C_[0];
	I[487] += q487*C_[0];
	I[488] += q488*C_[0];
	I[489] += q489*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q490 = 0.0;
	T q491 = 0.0;
	T q492 = 0.0;
	T q493 = 0.0;
	T q494 = 0.0;
	T q495 = 0.0;
	T q496 = 0.0;
	T q497 = 0.0;
	T q498 = 0.0;
	T q499 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q490 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q491 += beta*Ix(a,1,0)*Iy(a,1,4)*Iz(a,1,0)
                     - 3*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dBy
	    q492 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,3); // d/dBy
	    q493 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q494 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	    q495 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dBy
	    q496 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dBy
	    q497 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,2); // d/dBy
	    q498 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dBy
	    q499 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[490] += q490*C_[0];
	I[491] += q491*C_[0];
	I[492] += q492*C_[0];
	I[493] += q493*C_[0];
	I[494] += q494*C_[0];
	I[495] += q495*C_[0];
	I[496] += q496*C_[0];
	I[497] += q497*C_[0];
	I[498] += q498*C_[0];
	I[499] += q499*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q500 = 0.0;
	T q501 = 0.0;
	T q502 = 0.0;
	T q503 = 0.0;
	T q504 = 0.0;
	T q505 = 0.0;
	T q506 = 0.0;
	T q507 = 0.0;
	T q508 = 0.0;
	T q509 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q500 += beta*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q501 += beta*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q502 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q503 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q504 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q505 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q506 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q507 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q508 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	    q509 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[500] += q500*C_[0];
	I[501] += q501*C_[0];
	I[502] += q502*C_[0];
	I[503] += q503*C_[0];
	I[504] += q504*C_[0];
	I[505] += q505*C_[0];
	I[506] += q506*C_[0];
	I[507] += q507*C_[0];
	I[508] += q508*C_[0];
	I[509] += q509*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q510 = 0.0;
	T q511 = 0.0;
	T q512 = 0.0;
	T q513 = 0.0;
	T q514 = 0.0;
	T q515 = 0.0;
	T q516 = 0.0;
	T q517 = 0.0;
	T q518 = 0.0;
	T q519 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q510 += beta*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q511 += beta*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,1); // d/dBz
	    q512 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,2);  // d/dBz
	    q513 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,1); // d/dBz
	    q514 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,0);  // d/dBz
	    q515 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,1); // d/dBz
	    q516 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,0);  // d/dBz
	    q517 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1);  // d/dBz
	    q518 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1);  // d/dBz
	    q519 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[510] += q510*C_[0];
	I[511] += q511*C_[0];
	I[512] += q512*C_[0];
	I[513] += q513*C_[0];
	I[514] += q514*C_[0];
	I[515] += q515*C_[0];
	I[516] += q516*C_[0];
	I[517] += q517*C_[0];
	I[518] += q518*C_[0];
	I[519] += q519*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q520 = 0.0;
	T q521 = 0.0;
	T q522 = 0.0;
	T q523 = 0.0;
	T q524 = 0.0;
	T q525 = 0.0;
	T q526 = 0.0;
	T q527 = 0.0;
	T q528 = 0.0;
	T q529 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q520 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q521 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,1); // d/dBz
	    q522 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,4)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,2);  // d/dBz
	    q523 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,1); // d/dBz
	    q524 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,0);  // d/dBz
	    q525 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,1); // d/dBz
	    q526 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,0);  // d/dBz
	    q527 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1);  // d/dBz
	    q528 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1);  // d/dBz
	    q529 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[520] += q520*C_[0];
	I[521] += q521*C_[0];
	I[522] += q522*C_[0];
	I[523] += q523*C_[0];
	I[524] += q524*C_[0];
	I[525] += q525*C_[0];
	I[526] += q526*C_[0];
	I[527] += q527*C_[0];
	I[528] += q528*C_[0];
	I[529] += q529*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q530 = 0.0;
	T q531 = 0.0;
	T q532 = 0.0;
	T q533 = 0.0;
	T q534 = 0.0;
	T q535 = 0.0;
	T q536 = 0.0;
	T q537 = 0.0;
	T q538 = 0.0;
	T q539 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q530 += beta*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q531 += beta*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,1); // d/dBz
	    q532 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBz
	    q533 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q534 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q535 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	    q536 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBz
	    q537 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q538 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBz
	    q539 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[530] += q530*C_[0];
	I[531] += q531*C_[0];
	I[532] += q532*C_[0];
	I[533] += q533*C_[0];
	I[534] += q534*C_[0];
	I[535] += q535*C_[0];
	I[536] += q536*C_[0];
	I[537] += q537*C_[0];
	I[538] += q538*C_[0];
	I[539] += q539*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q540 = 0.0;
	T q541 = 0.0;
	T q542 = 0.0;
	T q543 = 0.0;
	T q544 = 0.0;
	T q545 = 0.0;
	T q546 = 0.0;
	T q547 = 0.0;
	T q548 = 0.0;
	T q549 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q540 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q541 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,1); // d/dBz
	    q542 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBz
	    q543 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q544 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q545 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q546 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBz
	    q547 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q548 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBz
	    q549 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[540] += q540*C_[0];
	I[541] += q541*C_[0];
	I[542] += q542*C_[0];
	I[543] += q543*C_[0];
	I[544] += q544*C_[0];
	I[545] += q545*C_[0];
	I[546] += q546*C_[0];
	I[547] += q547*C_[0];
	I[548] += q548*C_[0];
	I[549] += q549*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q550 = 0.0;
	T q551 = 0.0;
	T q552 = 0.0;
	T q553 = 0.0;
	T q554 = 0.0;
	T q555 = 0.0;
	T q556 = 0.0;
	T q557 = 0.0;
	T q558 = 0.0;
	T q559 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q550 += beta*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q551 += beta*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,1); // d/dBz
	    q552 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dBz
	    q553 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q554 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q555 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,1); // d/dBz
	    q556 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dBz
	    q557 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dBz
	    q558 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dBz
	    q559 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[550] += q550*C_[0];
	I[551] += q551*C_[0];
	I[552] += q552*C_[0];
	I[553] += q553*C_[0];
	I[554] += q554*C_[0];
	I[555] += q555*C_[0];
	I[556] += q556*C_[0];
	I[557] += q557*C_[0];
	I[558] += q558*C_[0];
	I[559] += q559*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q560 = 0.0;
	T q561 = 0.0;
	T q562 = 0.0;
	T q563 = 0.0;
	T q564 = 0.0;
	T q565 = 0.0;
	T q566 = 0.0;
	T q567 = 0.0;
	T q568 = 0.0;
	T q569 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q560 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q561 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,1); // d/dBz
	    q562 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,2);  // d/dBz
	    q563 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,1); // d/dBz
	    q564 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,0);  // d/dBz
	    q565 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,1); // d/dBz
	    q566 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,0);  // d/dBz
	    q567 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1);  // d/dBz
	    q568 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1);  // d/dBz
	    q569 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[560] += q560*C_[0];
	I[561] += q561*C_[0];
	I[562] += q562*C_[0];
	I[563] += q563*C_[0];
	I[564] += q564*C_[0];
	I[565] += q565*C_[0];
	I[566] += q566*C_[0];
	I[567] += q567*C_[0];
	I[568] += q568*C_[0];
	I[569] += q569*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q570 = 0.0;
	T q571 = 0.0;
	T q572 = 0.0;
	T q573 = 0.0;
	T q574 = 0.0;
	T q575 = 0.0;
	T q576 = 0.0;
	T q577 = 0.0;
	T q578 = 0.0;
	T q579 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q570 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q571 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,1); // d/dBz
	    q572 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,4)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dBz
	    q573 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q574 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q575 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,1); // d/dBz
	    q576 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dBz
	    q577 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dBz
	    q578 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,3)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dBz
	    q579 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[570] += q570*C_[0];
	I[571] += q571*C_[0];
	I[572] += q572*C_[0];
	I[573] += q573*C_[0];
	I[574] += q574*C_[0];
	I[575] += q575*C_[0];
	I[576] += q576*C_[0];
	I[577] += q577*C_[0];
	I[578] += q578*C_[0];
	I[579] += q579*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q580 = 0.0;
	T q581 = 0.0;
	T q582 = 0.0;
	T q583 = 0.0;
	T q584 = 0.0;
	T q585 = 0.0;
	T q586 = 0.0;
	T q587 = 0.0;
	T q588 = 0.0;
	T q589 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q580 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q581 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,1); // d/dBz
	    q582 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,4)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,2);  // d/dBz
	    q583 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,1); // d/dBz
	    q584 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,0);  // d/dBz
	    q585 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,1); // d/dBz
	    q586 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,0);  // d/dBz
	    q587 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,3)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1);  // d/dBz
	    q588 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1);  // d/dBz
	    q589 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[580] += q580*C_[0];
	I[581] += q581*C_[0];
	I[582] += q582*C_[0];
	I[583] += q583*C_[0];
	I[584] += q584*C_[0];
	I[585] += q585*C_[0];
	I[586] += q586*C_[0];
	I[587] += q587*C_[0];
	I[588] += q588*C_[0];
	I[589] += q589*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q590 = 0.0;
	T q591 = 0.0;
	T q592 = 0.0;
	T q593 = 0.0;
	T q594 = 0.0;
	T q595 = 0.0;
	T q596 = 0.0;
	T q597 = 0.0;
	T q598 = 0.0;
	T q599 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q590 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q591 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,1); // d/dBz
	    q592 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,4)
                     - 3*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dBz
	    q593 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q594 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	    q595 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,1); // d/dBz
	    q596 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dBz
	    q597 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dBz
	    q598 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dBz
	    q599 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[590] += q590*C_[0];
	I[591] += q591*C_[0];
	I[592] += q592*C_[0];
	I[593] += q593*C_[0];
	I[594] += q594*C_[0];
	I[595] += q595*C_[0];
	I[596] += q596*C_[0];
	I[597] += q597*C_[0];
	I[598] += q598*C_[0];
	I[599] += q599*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <gf| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::G,rysq::F> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::G,rysq::F> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 6;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,5,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,5,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 4*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,5,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 4*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAx
	    q3 += alpha*Ix(a,5,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 4*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,5,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 4*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,5,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 4*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,5,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 4*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAx
	    q7 += alpha*Ix(a,5,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 4*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q8 += alpha*Ix(a,5,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 4*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAx
	    q9 += alpha*Ix(a,5,1)*Iy(a,0,1)*Iz(a,0,1)
                     - 4*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,3)*Iy(a,4,0)*Iz(a,0,0); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,4,3)*Iz(a,0,0); // d/dAx
	    q12 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,3); // d/dAx
	    q13 += alpha*Ix(a,1,2)*Iy(a,4,1)*Iz(a,0,0); // d/dAx
	    q14 += alpha*Ix(a,1,2)*Iy(a,4,0)*Iz(a,0,1); // d/dAx
	    q15 += alpha*Ix(a,1,1)*Iy(a,4,2)*Iz(a,0,0); // d/dAx
	    q16 += alpha*Ix(a,1,0)*Iy(a,4,2)*Iz(a,0,1); // d/dAx
	    q17 += alpha*Ix(a,1,1)*Iy(a,4,0)*Iz(a,0,2); // d/dAx
	    q18 += alpha*Ix(a,1,0)*Iy(a,4,1)*Iz(a,0,2); // d/dAx
	    q19 += alpha*Ix(a,1,1)*Iy(a,4,1)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,4,0); // d/dAx
	    q21 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,4,0); // d/dAx
	    q22 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,3); // d/dAx
	    q23 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,4,0); // d/dAx
	    q24 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,4,1); // d/dAx
	    q25 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,4,0); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,4,1); // d/dAx
	    q27 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,4,2); // d/dAx
	    q28 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,4,2); // d/dAx
	    q29 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,4,1); // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,4,3)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q31 += alpha*Ix(a,4,0)*Iy(a,1,3)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dAx
	    q32 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,3)
                     - 3*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dAx
	    q33 += alpha*Ix(a,4,2)*Iy(a,1,1)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q34 += alpha*Ix(a,4,2)*Iy(a,1,0)*Iz(a,0,1)
                     - 3*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q35 += alpha*Ix(a,4,1)*Iy(a,1,2)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dAx
	    q36 += alpha*Ix(a,4,0)*Iy(a,1,2)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dAx
	    q37 += alpha*Ix(a,4,1)*Iy(a,1,0)*Iz(a,0,2)
                     - 3*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dAx
	    q38 += alpha*Ix(a,4,0)*Iy(a,1,1)*Iz(a,0,2)
                     - 3*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dAx
	    q39 += alpha*Ix(a,4,1)*Iy(a,1,1)*Iz(a,0,1)
                     - 3*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,4,3)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q41 += alpha*Ix(a,4,0)*Iy(a,0,3)*Iz(a,1,0)
                     - 3*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dAx
	    q42 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,3)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dAx
	    q43 += alpha*Ix(a,4,2)*Iy(a,0,1)*Iz(a,1,0)
                     - 3*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q44 += alpha*Ix(a,4,2)*Iy(a,0,0)*Iz(a,1,1)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q45 += alpha*Ix(a,4,1)*Iy(a,0,2)*Iz(a,1,0)
                     - 3*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dAx
	    q46 += alpha*Ix(a,4,0)*Iy(a,0,2)*Iz(a,1,1)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dAx
	    q47 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,1,2)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dAx
	    q48 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,1,2)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dAx
	    q49 += alpha*Ix(a,4,1)*Iy(a,0,1)*Iz(a,1,1)
                     - 3*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,2,3)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,0);  // d/dAx
	    q51 += alpha*Ix(a,2,0)*Iy(a,3,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,0);  // d/dAx
	    q52 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,3);  // d/dAx
	    q53 += alpha*Ix(a,2,2)*Iy(a,3,1)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,0);  // d/dAx
	    q54 += alpha*Ix(a,2,2)*Iy(a,3,0)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,1);  // d/dAx
	    q55 += alpha*Ix(a,2,1)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,0);  // d/dAx
	    q56 += alpha*Ix(a,2,0)*Iy(a,3,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,1);  // d/dAx
	    q57 += alpha*Ix(a,2,1)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,2);  // d/dAx
	    q58 += alpha*Ix(a,2,0)*Iy(a,3,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,2);  // d/dAx
	    q59 += alpha*Ix(a,2,1)*Iy(a,3,1)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,1,3)*Iy(a,3,0)*Iz(a,1,0); // d/dAx
	    q61 += alpha*Ix(a,1,0)*Iy(a,3,3)*Iz(a,1,0); // d/dAx
	    q62 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,3); // d/dAx
	    q63 += alpha*Ix(a,1,2)*Iy(a,3,1)*Iz(a,1,0); // d/dAx
	    q64 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,1,1); // d/dAx
	    q65 += alpha*Ix(a,1,1)*Iy(a,3,2)*Iz(a,1,0); // d/dAx
	    q66 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,1,1); // d/dAx
	    q67 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,2); // d/dAx
	    q68 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,2); // d/dAx
	    q69 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,1,1); // d/dAx
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,0);  // d/dAx
	    q71 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,0);  // d/dAx
	    q72 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,3);  // d/dAx
	    q73 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,3,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,0);  // d/dAx
	    q74 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,3,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,1);  // d/dAx
	    q75 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,0);  // d/dAx
	    q76 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,1);  // d/dAx
	    q77 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,2);  // d/dAx
	    q78 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,2);  // d/dAx
	    q79 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,3,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,3,0); // d/dAx
	    q81 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,3,0); // d/dAx
	    q82 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,3); // d/dAx
	    q83 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,3,0); // d/dAx
	    q84 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,3,1); // d/dAx
	    q85 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,3,0); // d/dAx
	    q86 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,3,1); // d/dAx
	    q87 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,2); // d/dAx
	    q88 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,2); // d/dAx
	    q89 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,3,1); // d/dAx
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,3,3)*Iy(a,2,0)*Iz(a,0,0)
                     - 2*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q91 += alpha*Ix(a,3,0)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dAx
	    q92 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dAx
	    q93 += alpha*Ix(a,3,2)*Iy(a,2,1)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dAx
	    q94 += alpha*Ix(a,3,2)*Iy(a,2,0)*Iz(a,0,1)
                     - 2*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dAx
	    q95 += alpha*Ix(a,3,1)*Iy(a,2,2)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dAx
	    q96 += alpha*Ix(a,3,0)*Iy(a,2,2)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dAx
	    q97 += alpha*Ix(a,3,1)*Iy(a,2,0)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dAx
	    q98 += alpha*Ix(a,3,0)*Iy(a,2,1)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dAx
	    q99 += alpha*Ix(a,3,1)*Iy(a,2,1)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,3,3)*Iy(a,0,0)*Iz(a,2,0)
                     - 2*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q101 += alpha*Ix(a,3,0)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dAx
	    q102 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dAx
	    q103 += alpha*Ix(a,3,2)*Iy(a,0,1)*Iz(a,2,0)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dAx
	    q104 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,2,1)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dAx
	    q105 += alpha*Ix(a,3,1)*Iy(a,0,2)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dAx
	    q106 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,2,1)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dAx
	    q107 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,2,2)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dAx
	    q108 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,2,2)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dAx
	    q109 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,2,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,2,0); // d/dAx
	    q111 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,2,0); // d/dAx
	    q112 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,3); // d/dAx
	    q113 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,2,0); // d/dAx
	    q114 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,2,1); // d/dAx
	    q115 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,2,0); // d/dAx
	    q116 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,2,1); // d/dAx
	    q117 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,2); // d/dAx
	    q118 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,2); // d/dAx
	    q119 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,2,1); // d/dAx
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,3,3)*Iy(a,1,0)*Iz(a,1,0)
                     - 2*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q121 += alpha*Ix(a,3,0)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dAx
	    q122 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dAx
	    q123 += alpha*Ix(a,3,2)*Iy(a,1,1)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dAx
	    q124 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,1,1)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dAx
	    q125 += alpha*Ix(a,3,1)*Iy(a,1,2)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dAx
	    q126 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dAx
	    q127 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,2)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dAx
	    q128 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dAx
	    q129 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,2,3)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,0);  // d/dAx
	    q131 += alpha*Ix(a,2,0)*Iy(a,2,3)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,0);  // d/dAx
	    q132 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,3);  // d/dAx
	    q133 += alpha*Ix(a,2,2)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,0);  // d/dAx
	    q134 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,1);  // d/dAx
	    q135 += alpha*Ix(a,2,1)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,0);  // d/dAx
	    q136 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,1);  // d/dAx
	    q137 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,2);  // d/dAx
	    q138 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,2);  // d/dAx
	    q139 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,0);  // d/dAx
	    q141 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,0);  // d/dAx
	    q142 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,3);  // d/dAx
	    q143 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,0);  // d/dAx
	    q144 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,1);  // d/dAx
	    q145 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,0);  // d/dAx
	    q146 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,1);  // d/dAx
	    q147 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,2);  // d/dAx
	    q148 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,2);  // d/dAx
	    q149 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += alpha*Ix(a,4,3)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q151 += alpha*Ix(a,4,0)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q152 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q153 += alpha*Ix(a,4,2)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q154 += alpha*Ix(a,4,2)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q155 += alpha*Ix(a,4,1)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q156 += alpha*Ix(a,4,0)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q157 += alpha*Ix(a,4,1)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q158 += alpha*Ix(a,4,0)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	    q159 += alpha*Ix(a,4,1)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += alpha*Ix(a,0,3)*Iy(a,5,0)*Iz(a,0,0)
                     - 4*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,0);  // d/dAy
	    q161 += alpha*Ix(a,0,0)*Iy(a,5,3)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,0);  // d/dAy
	    q162 += alpha*Ix(a,0,0)*Iy(a,5,0)*Iz(a,0,3)
                     - 4*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,3);  // d/dAy
	    q163 += alpha*Ix(a,0,2)*Iy(a,5,1)*Iz(a,0,0)
                     - 4*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,0);  // d/dAy
	    q164 += alpha*Ix(a,0,2)*Iy(a,5,0)*Iz(a,0,1)
                     - 4*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,1);  // d/dAy
	    q165 += alpha*Ix(a,0,1)*Iy(a,5,2)*Iz(a,0,0)
                     - 4*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,0);  // d/dAy
	    q166 += alpha*Ix(a,0,0)*Iy(a,5,2)*Iz(a,0,1)
                     - 4*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,1);  // d/dAy
	    q167 += alpha*Ix(a,0,1)*Iy(a,5,0)*Iz(a,0,2)
                     - 4*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,2);  // d/dAy
	    q168 += alpha*Ix(a,0,0)*Iy(a,5,1)*Iz(a,0,2)
                     - 4*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,2);  // d/dAy
	    q169 += alpha*Ix(a,0,1)*Iy(a,5,1)*Iz(a,0,1)
                     - 4*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,4,0); // d/dAy
	    q171 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,4,0); // d/dAy
	    q172 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,3); // d/dAy
	    q173 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,4,0); // d/dAy
	    q174 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,4,1); // d/dAy
	    q175 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,4,0); // d/dAy
	    q176 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,4,1); // d/dAy
	    q177 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,4,2); // d/dAy
	    q178 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,4,2); // d/dAy
	    q179 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,4,1); // d/dAy
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += alpha*Ix(a,3,3)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q181 += alpha*Ix(a,3,0)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAy
	    q182 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAy
	    q183 += alpha*Ix(a,3,2)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q184 += alpha*Ix(a,3,2)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q185 += alpha*Ix(a,3,1)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	    q186 += alpha*Ix(a,3,0)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAy
	    q187 += alpha*Ix(a,3,1)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q188 += alpha*Ix(a,3,0)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAy
	    q189 += alpha*Ix(a,3,1)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += alpha*Ix(a,3,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q191 += alpha*Ix(a,3,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAy
	    q192 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAy
	    q193 += alpha*Ix(a,3,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q194 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q195 += alpha*Ix(a,3,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q196 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAy
	    q197 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q198 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAy
	    q199 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += alpha*Ix(a,1,3)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q201 += alpha*Ix(a,1,0)*Iy(a,4,3)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dAy
	    q202 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,3)
                     - 3*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dAy
	    q203 += alpha*Ix(a,1,2)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dAy
	    q204 += alpha*Ix(a,1,2)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dAy
	    q205 += alpha*Ix(a,1,1)*Iy(a,4,2)*Iz(a,0,0)
                     - 3*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dAy
	    q206 += alpha*Ix(a,1,0)*Iy(a,4,2)*Iz(a,0,1)
                     - 3*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dAy
	    q207 += alpha*Ix(a,1,1)*Iy(a,4,0)*Iz(a,0,2)
                     - 3*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dAy
	    q208 += alpha*Ix(a,1,0)*Iy(a,4,1)*Iz(a,0,2)
                     - 3*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dAy
	    q209 += alpha*Ix(a,1,1)*Iy(a,4,1)*Iz(a,0,1)
                     - 3*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += alpha*Ix(a,0,3)*Iy(a,4,0)*Iz(a,1,0)
                     - 3*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,0);  // d/dAy
	    q211 += alpha*Ix(a,0,0)*Iy(a,4,3)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,0);  // d/dAy
	    q212 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,3)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,3);  // d/dAy
	    q213 += alpha*Ix(a,0,2)*Iy(a,4,1)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,0);  // d/dAy
	    q214 += alpha*Ix(a,0,2)*Iy(a,4,0)*Iz(a,1,1)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,1);  // d/dAy
	    q215 += alpha*Ix(a,0,1)*Iy(a,4,2)*Iz(a,1,0)
                     - 3*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,0);  // d/dAy
	    q216 += alpha*Ix(a,0,0)*Iy(a,4,2)*Iz(a,1,1)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,1);  // d/dAy
	    q217 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,1,2)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,2);  // d/dAy
	    q218 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,1,2)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,2);  // d/dAy
	    q219 += alpha*Ix(a,0,1)*Iy(a,4,1)*Iz(a,1,1)
                     - 3*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];
	I[216] += q216*C_[0];
	I[217] += q217*C_[0];
	I[218] += q218*C_[0];
	I[219] += q219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q221 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,3,0); // d/dAy
	    q222 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,3); // d/dAy
	    q223 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,3,0); // d/dAy
	    q224 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,3,1); // d/dAy
	    q225 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,3,0); // d/dAy
	    q226 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,3,1); // d/dAy
	    q227 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,2); // d/dAy
	    q228 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,2); // d/dAy
	    q229 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,3,1); // d/dAy
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[0];
	I[222] += q222*C_[0];
	I[223] += q223*C_[0];
	I[224] += q224*C_[0];
	I[225] += q225*C_[0];
	I[226] += q226*C_[0];
	I[227] += q227*C_[0];
	I[228] += q228*C_[0];
	I[229] += q229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,3,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,0);  // d/dAy
	    q231 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,0);  // d/dAy
	    q232 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,3);  // d/dAy
	    q233 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,3,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,0);  // d/dAy
	    q234 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,3,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,1);  // d/dAy
	    q235 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,0);  // d/dAy
	    q236 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,1);  // d/dAy
	    q237 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,2);  // d/dAy
	    q238 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,2);  // d/dAy
	    q239 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,3,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[230] += q230*C_[0];
	I[231] += q231*C_[0];
	I[232] += q232*C_[0];
	I[233] += q233*C_[0];
	I[234] += q234*C_[0];
	I[235] += q235*C_[0];
	I[236] += q236*C_[0];
	I[237] += q237*C_[0];
	I[238] += q238*C_[0];
	I[239] += q239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += alpha*Ix(a,2,3)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q241 += alpha*Ix(a,2,0)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dAy
	    q242 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dAy
	    q243 += alpha*Ix(a,2,2)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q244 += alpha*Ix(a,2,2)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q245 += alpha*Ix(a,2,1)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dAy
	    q246 += alpha*Ix(a,2,0)*Iy(a,3,2)*Iz(a,0,1)
                     - 2*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dAy
	    q247 += alpha*Ix(a,2,1)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dAy
	    q248 += alpha*Ix(a,2,0)*Iy(a,3,1)*Iz(a,0,2)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dAy
	    q249 += alpha*Ix(a,2,1)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q251 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,2,0); // d/dAy
	    q252 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,3); // d/dAy
	    q253 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q254 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q255 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,2,0); // d/dAy
	    q256 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,2,1); // d/dAy
	    q257 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,2); // d/dAy
	    q258 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,2); // d/dAy
	    q259 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,2,1); // d/dAy
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[0];
	I[256] += q256*C_[0];
	I[257] += q257*C_[0];
	I[258] += q258*C_[0];
	I[259] += q259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += alpha*Ix(a,0,3)*Iy(a,3,0)*Iz(a,2,0)
                     - 2*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,0);  // d/dAy
	    q261 += alpha*Ix(a,0,0)*Iy(a,3,3)*Iz(a,2,0)
                     - 2*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,0);  // d/dAy
	    q262 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,3);  // d/dAy
	    q263 += alpha*Ix(a,0,2)*Iy(a,3,1)*Iz(a,2,0)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,0);  // d/dAy
	    q264 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,2,1)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,1);  // d/dAy
	    q265 += alpha*Ix(a,0,1)*Iy(a,3,2)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,0);  // d/dAy
	    q266 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,2,1)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,1);  // d/dAy
	    q267 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,2,2)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,2);  // d/dAy
	    q268 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,2,2)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,2);  // d/dAy
	    q269 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[0];
	I[262] += q262*C_[0];
	I[263] += q263*C_[0];
	I[264] += q264*C_[0];
	I[265] += q265*C_[0];
	I[266] += q266*C_[0];
	I[267] += q267*C_[0];
	I[268] += q268*C_[0];
	I[269] += q269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q270 = 0.0;
	T q271 = 0.0;
	T q272 = 0.0;
	T q273 = 0.0;
	T q274 = 0.0;
	T q275 = 0.0;
	T q276 = 0.0;
	T q277 = 0.0;
	T q278 = 0.0;
	T q279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q270 += alpha*Ix(a,2,3)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q271 += alpha*Ix(a,2,0)*Iy(a,2,3)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dAy
	    q272 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,3)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dAy
	    q273 += alpha*Ix(a,2,2)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q274 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	    q275 += alpha*Ix(a,2,1)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dAy
	    q276 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dAy
	    q277 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dAy
	    q278 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dAy
	    q279 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[270] += q270*C_[0];
	I[271] += q271*C_[0];
	I[272] += q272*C_[0];
	I[273] += q273*C_[0];
	I[274] += q274*C_[0];
	I[275] += q275*C_[0];
	I[276] += q276*C_[0];
	I[277] += q277*C_[0];
	I[278] += q278*C_[0];
	I[279] += q279*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q280 = 0.0;
	T q281 = 0.0;
	T q282 = 0.0;
	T q283 = 0.0;
	T q284 = 0.0;
	T q285 = 0.0;
	T q286 = 0.0;
	T q287 = 0.0;
	T q288 = 0.0;
	T q289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q280 += alpha*Ix(a,1,3)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q281 += alpha*Ix(a,1,0)*Iy(a,3,3)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dAy
	    q282 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dAy
	    q283 += alpha*Ix(a,1,2)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dAy
	    q284 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dAy
	    q285 += alpha*Ix(a,1,1)*Iy(a,3,2)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dAy
	    q286 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dAy
	    q287 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,2)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dAy
	    q288 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dAy
	    q289 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[280] += q280*C_[0];
	I[281] += q281*C_[0];
	I[282] += q282*C_[0];
	I[283] += q283*C_[0];
	I[284] += q284*C_[0];
	I[285] += q285*C_[0];
	I[286] += q286*C_[0];
	I[287] += q287*C_[0];
	I[288] += q288*C_[0];
	I[289] += q289*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q290 = 0.0;
	T q291 = 0.0;
	T q292 = 0.0;
	T q293 = 0.0;
	T q294 = 0.0;
	T q295 = 0.0;
	T q296 = 0.0;
	T q297 = 0.0;
	T q298 = 0.0;
	T q299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q290 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q291 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dAy
	    q292 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dAy
	    q293 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dAy
	    q294 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dAy
	    q295 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dAy
	    q296 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dAy
	    q297 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dAy
	    q298 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dAy
	    q299 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[290] += q290*C_[0];
	I[291] += q291*C_[0];
	I[292] += q292*C_[0];
	I[293] += q293*C_[0];
	I[294] += q294*C_[0];
	I[295] += q295*C_[0];
	I[296] += q296*C_[0];
	I[297] += q297*C_[0];
	I[298] += q298*C_[0];
	I[299] += q299*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q300 = 0.0;
	T q301 = 0.0;
	T q302 = 0.0;
	T q303 = 0.0;
	T q304 = 0.0;
	T q305 = 0.0;
	T q306 = 0.0;
	T q307 = 0.0;
	T q308 = 0.0;
	T q309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q300 += alpha*Ix(a,4,3)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q301 += alpha*Ix(a,4,0)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q302 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q303 += alpha*Ix(a,4,2)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q304 += alpha*Ix(a,4,2)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q305 += alpha*Ix(a,4,1)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q306 += alpha*Ix(a,4,0)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q307 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q308 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q309 += alpha*Ix(a,4,1)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[300] += q300*C_[0];
	I[301] += q301*C_[0];
	I[302] += q302*C_[0];
	I[303] += q303*C_[0];
	I[304] += q304*C_[0];
	I[305] += q305*C_[0];
	I[306] += q306*C_[0];
	I[307] += q307*C_[0];
	I[308] += q308*C_[0];
	I[309] += q309*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q310 = 0.0;
	T q311 = 0.0;
	T q312 = 0.0;
	T q313 = 0.0;
	T q314 = 0.0;
	T q315 = 0.0;
	T q316 = 0.0;
	T q317 = 0.0;
	T q318 = 0.0;
	T q319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q310 += alpha*Ix(a,0,3)*Iy(a,4,0)*Iz(a,1,0); // d/dAz
	    q311 += alpha*Ix(a,0,0)*Iy(a,4,3)*Iz(a,1,0); // d/dAz
	    q312 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,3); // d/dAz
	    q313 += alpha*Ix(a,0,2)*Iy(a,4,1)*Iz(a,1,0); // d/dAz
	    q314 += alpha*Ix(a,0,2)*Iy(a,4,0)*Iz(a,1,1); // d/dAz
	    q315 += alpha*Ix(a,0,1)*Iy(a,4,2)*Iz(a,1,0); // d/dAz
	    q316 += alpha*Ix(a,0,0)*Iy(a,4,2)*Iz(a,1,1); // d/dAz
	    q317 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,1,2); // d/dAz
	    q318 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,1,2); // d/dAz
	    q319 += alpha*Ix(a,0,1)*Iy(a,4,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[310] += q310*C_[0];
	I[311] += q311*C_[0];
	I[312] += q312*C_[0];
	I[313] += q313*C_[0];
	I[314] += q314*C_[0];
	I[315] += q315*C_[0];
	I[316] += q316*C_[0];
	I[317] += q317*C_[0];
	I[318] += q318*C_[0];
	I[319] += q319*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q320 = 0.0;
	T q321 = 0.0;
	T q322 = 0.0;
	T q323 = 0.0;
	T q324 = 0.0;
	T q325 = 0.0;
	T q326 = 0.0;
	T q327 = 0.0;
	T q328 = 0.0;
	T q329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q320 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,5,0)
                     - 4*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,0);  // d/dAz
	    q321 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,5,0)
                     - 4*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,0);  // d/dAz
	    q322 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,5,3)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,3);  // d/dAz
	    q323 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,5,0)
                     - 4*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,0);  // d/dAz
	    q324 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,5,1)
                     - 4*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,1);  // d/dAz
	    q325 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,5,0)
                     - 4*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,0);  // d/dAz
	    q326 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,5,1)
                     - 4*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,1);  // d/dAz
	    q327 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,5,2)
                     - 4*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,2);  // d/dAz
	    q328 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,5,2)
                     - 4*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,2);  // d/dAz
	    q329 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,5,1)
                     - 4*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[320] += q320*C_[0];
	I[321] += q321*C_[0];
	I[322] += q322*C_[0];
	I[323] += q323*C_[0];
	I[324] += q324*C_[0];
	I[325] += q325*C_[0];
	I[326] += q326*C_[0];
	I[327] += q327*C_[0];
	I[328] += q328*C_[0];
	I[329] += q329*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q330 = 0.0;
	T q331 = 0.0;
	T q332 = 0.0;
	T q333 = 0.0;
	T q334 = 0.0;
	T q335 = 0.0;
	T q336 = 0.0;
	T q337 = 0.0;
	T q338 = 0.0;
	T q339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q330 += alpha*Ix(a,3,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q331 += alpha*Ix(a,3,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAz
	    q332 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAz
	    q333 += alpha*Ix(a,3,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q334 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q335 += alpha*Ix(a,3,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q336 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAz
	    q337 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q338 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAz
	    q339 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[330] += q330*C_[0];
	I[331] += q331*C_[0];
	I[332] += q332*C_[0];
	I[333] += q333*C_[0];
	I[334] += q334*C_[0];
	I[335] += q335*C_[0];
	I[336] += q336*C_[0];
	I[337] += q337*C_[0];
	I[338] += q338*C_[0];
	I[339] += q339*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q340 = 0.0;
	T q341 = 0.0;
	T q342 = 0.0;
	T q343 = 0.0;
	T q344 = 0.0;
	T q345 = 0.0;
	T q346 = 0.0;
	T q347 = 0.0;
	T q348 = 0.0;
	T q349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q340 += alpha*Ix(a,3,3)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q341 += alpha*Ix(a,3,0)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAz
	    q342 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAz
	    q343 += alpha*Ix(a,3,2)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q344 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q345 += alpha*Ix(a,3,1)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	    q346 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAz
	    q347 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q348 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAz
	    q349 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[340] += q340*C_[0];
	I[341] += q341*C_[0];
	I[342] += q342*C_[0];
	I[343] += q343*C_[0];
	I[344] += q344*C_[0];
	I[345] += q345*C_[0];
	I[346] += q346*C_[0];
	I[347] += q347*C_[0];
	I[348] += q348*C_[0];
	I[349] += q349*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q350 = 0.0;
	T q351 = 0.0;
	T q352 = 0.0;
	T q353 = 0.0;
	T q354 = 0.0;
	T q355 = 0.0;
	T q356 = 0.0;
	T q357 = 0.0;
	T q358 = 0.0;
	T q359 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q350 += alpha*Ix(a,1,3)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q351 += alpha*Ix(a,1,0)*Iy(a,3,3)*Iz(a,1,0); // d/dAz
	    q352 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,3); // d/dAz
	    q353 += alpha*Ix(a,1,2)*Iy(a,3,1)*Iz(a,1,0); // d/dAz
	    q354 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,1,1); // d/dAz
	    q355 += alpha*Ix(a,1,1)*Iy(a,3,2)*Iz(a,1,0); // d/dAz
	    q356 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,1,1); // d/dAz
	    q357 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,2); // d/dAz
	    q358 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,2); // d/dAz
	    q359 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[350] += q350*C_[0];
	I[351] += q351*C_[0];
	I[352] += q352*C_[0];
	I[353] += q353*C_[0];
	I[354] += q354*C_[0];
	I[355] += q355*C_[0];
	I[356] += q356*C_[0];
	I[357] += q357*C_[0];
	I[358] += q358*C_[0];
	I[359] += q359*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q360 = 0.0;
	T q361 = 0.0;
	T q362 = 0.0;
	T q363 = 0.0;
	T q364 = 0.0;
	T q365 = 0.0;
	T q366 = 0.0;
	T q367 = 0.0;
	T q368 = 0.0;
	T q369 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q360 += alpha*Ix(a,0,3)*Iy(a,3,0)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,0);  // d/dAz
	    q361 += alpha*Ix(a,0,0)*Iy(a,3,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,0);  // d/dAz
	    q362 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,3);  // d/dAz
	    q363 += alpha*Ix(a,0,2)*Iy(a,3,1)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,0);  // d/dAz
	    q364 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,1);  // d/dAz
	    q365 += alpha*Ix(a,0,1)*Iy(a,3,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,0);  // d/dAz
	    q366 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,1);  // d/dAz
	    q367 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,2);  // d/dAz
	    q368 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,2);  // d/dAz
	    q369 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[360] += q360*C_[0];
	I[361] += q361*C_[0];
	I[362] += q362*C_[0];
	I[363] += q363*C_[0];
	I[364] += q364*C_[0];
	I[365] += q365*C_[0];
	I[366] += q366*C_[0];
	I[367] += q367*C_[0];
	I[368] += q368*C_[0];
	I[369] += q369*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q370 = 0.0;
	T q371 = 0.0;
	T q372 = 0.0;
	T q373 = 0.0;
	T q374 = 0.0;
	T q375 = 0.0;
	T q376 = 0.0;
	T q377 = 0.0;
	T q378 = 0.0;
	T q379 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q370 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q371 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,4,0)
                     - 3*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dAz
	    q372 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,3)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dAz
	    q373 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dAz
	    q374 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dAz
	    q375 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,4,0)
                     - 3*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dAz
	    q376 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,4,1)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dAz
	    q377 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,4,2)
                     - 3*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dAz
	    q378 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,4,2)
                     - 3*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dAz
	    q379 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,4,1)
                     - 3*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[370] += q370*C_[0];
	I[371] += q371*C_[0];
	I[372] += q372*C_[0];
	I[373] += q373*C_[0];
	I[374] += q374*C_[0];
	I[375] += q375*C_[0];
	I[376] += q376*C_[0];
	I[377] += q377*C_[0];
	I[378] += q378*C_[0];
	I[379] += q379*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q380 = 0.0;
	T q381 = 0.0;
	T q382 = 0.0;
	T q383 = 0.0;
	T q384 = 0.0;
	T q385 = 0.0;
	T q386 = 0.0;
	T q387 = 0.0;
	T q388 = 0.0;
	T q389 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q380 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,4,0)
                     - 3*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,0);  // d/dAz
	    q381 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,0);  // d/dAz
	    q382 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,3)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,3);  // d/dAz
	    q383 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,4,0)
                     - 3*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,0);  // d/dAz
	    q384 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,4,1)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,1);  // d/dAz
	    q385 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,0);  // d/dAz
	    q386 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,1);  // d/dAz
	    q387 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,4,2)
                     - 3*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,2);  // d/dAz
	    q388 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,4,2)
                     - 3*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,2);  // d/dAz
	    q389 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,4,1)
                     - 3*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[380] += q380*C_[0];
	I[381] += q381*C_[0];
	I[382] += q382*C_[0];
	I[383] += q383*C_[0];
	I[384] += q384*C_[0];
	I[385] += q385*C_[0];
	I[386] += q386*C_[0];
	I[387] += q387*C_[0];
	I[388] += q388*C_[0];
	I[389] += q389*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q390 = 0.0;
	T q391 = 0.0;
	T q392 = 0.0;
	T q393 = 0.0;
	T q394 = 0.0;
	T q395 = 0.0;
	T q396 = 0.0;
	T q397 = 0.0;
	T q398 = 0.0;
	T q399 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q390 += alpha*Ix(a,2,3)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q391 += alpha*Ix(a,2,0)*Iy(a,2,3)*Iz(a,1,0); // d/dAz
	    q392 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,3); // d/dAz
	    q393 += alpha*Ix(a,2,2)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q394 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	    q395 += alpha*Ix(a,2,1)*Iy(a,2,2)*Iz(a,1,0); // d/dAz
	    q396 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,1,1); // d/dAz
	    q397 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,2); // d/dAz
	    q398 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,2); // d/dAz
	    q399 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[390] += q390*C_[0];
	I[391] += q391*C_[0];
	I[392] += q392*C_[0];
	I[393] += q393*C_[0];
	I[394] += q394*C_[0];
	I[395] += q395*C_[0];
	I[396] += q396*C_[0];
	I[397] += q397*C_[0];
	I[398] += q398*C_[0];
	I[399] += q399*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q400 = 0.0;
	T q401 = 0.0;
	T q402 = 0.0;
	T q403 = 0.0;
	T q404 = 0.0;
	T q405 = 0.0;
	T q406 = 0.0;
	T q407 = 0.0;
	T q408 = 0.0;
	T q409 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q400 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q401 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dAz
	    q402 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dAz
	    q403 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q404 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q405 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dAz
	    q406 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,3,1)
                     - 2*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dAz
	    q407 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dAz
	    q408 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,3,2)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dAz
	    q409 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[400] += q400*C_[0];
	I[401] += q401*C_[0];
	I[402] += q402*C_[0];
	I[403] += q403*C_[0];
	I[404] += q404*C_[0];
	I[405] += q405*C_[0];
	I[406] += q406*C_[0];
	I[407] += q407*C_[0];
	I[408] += q408*C_[0];
	I[409] += q409*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q410 = 0.0;
	T q411 = 0.0;
	T q412 = 0.0;
	T q413 = 0.0;
	T q414 = 0.0;
	T q415 = 0.0;
	T q416 = 0.0;
	T q417 = 0.0;
	T q418 = 0.0;
	T q419 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q410 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,3,0)
                     - 2*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,0);  // d/dAz
	    q411 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,0);  // d/dAz
	    q412 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,3);  // d/dAz
	    q413 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,0);  // d/dAz
	    q414 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,3,1)
                     - 2*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,1);  // d/dAz
	    q415 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,0);  // d/dAz
	    q416 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,1);  // d/dAz
	    q417 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,3,2)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,2);  // d/dAz
	    q418 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,2);  // d/dAz
	    q419 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[410] += q410*C_[0];
	I[411] += q411*C_[0];
	I[412] += q412*C_[0];
	I[413] += q413*C_[0];
	I[414] += q414*C_[0];
	I[415] += q415*C_[0];
	I[416] += q416*C_[0];
	I[417] += q417*C_[0];
	I[418] += q418*C_[0];
	I[419] += q419*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q420 = 0.0;
	T q421 = 0.0;
	T q422 = 0.0;
	T q423 = 0.0;
	T q424 = 0.0;
	T q425 = 0.0;
	T q426 = 0.0;
	T q427 = 0.0;
	T q428 = 0.0;
	T q429 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q420 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q421 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dAz
	    q422 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,3)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dAz
	    q423 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q424 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q425 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dAz
	    q426 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dAz
	    q427 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dAz
	    q428 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dAz
	    q429 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[420] += q420*C_[0];
	I[421] += q421*C_[0];
	I[422] += q422*C_[0];
	I[423] += q423*C_[0];
	I[424] += q424*C_[0];
	I[425] += q425*C_[0];
	I[426] += q426*C_[0];
	I[427] += q427*C_[0];
	I[428] += q428*C_[0];
	I[429] += q429*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q430 = 0.0;
	T q431 = 0.0;
	T q432 = 0.0;
	T q433 = 0.0;
	T q434 = 0.0;
	T q435 = 0.0;
	T q436 = 0.0;
	T q437 = 0.0;
	T q438 = 0.0;
	T q439 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q430 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q431 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dAz
	    q432 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dAz
	    q433 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dAz
	    q434 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dAz
	    q435 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dAz
	    q436 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dAz
	    q437 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dAz
	    q438 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dAz
	    q439 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[430] += q430*C_[0];
	I[431] += q431*C_[0];
	I[432] += q432*C_[0];
	I[433] += q433*C_[0];
	I[434] += q434*C_[0];
	I[435] += q435*C_[0];
	I[436] += q436*C_[0];
	I[437] += q437*C_[0];
	I[438] += q438*C_[0];
	I[439] += q439*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q440 = 0.0;
	T q441 = 0.0;
	T q442 = 0.0;
	T q443 = 0.0;
	T q444 = 0.0;
	T q445 = 0.0;
	T q446 = 0.0;
	T q447 = 0.0;
	T q448 = 0.0;
	T q449 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q440 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q441 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dAz
	    q442 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,3)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dAz
	    q443 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dAz
	    q444 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dAz
	    q445 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dAz
	    q446 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dAz
	    q447 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,2)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dAz
	    q448 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,2)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dAz
	    q449 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,3,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[440] += q440*C_[0];
	I[441] += q441*C_[0];
	I[442] += q442*C_[0];
	I[443] += q443*C_[0];
	I[444] += q444*C_[0];
	I[445] += q445*C_[0];
	I[446] += q446*C_[0];
	I[447] += q447*C_[0];
	I[448] += q448*C_[0];
	I[449] += q449*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q450 = 0.0;
	T q451 = 0.0;
	T q452 = 0.0;
	T q453 = 0.0;
	T q454 = 0.0;
	T q455 = 0.0;
	T q456 = 0.0;
	T q457 = 0.0;
	T q458 = 0.0;
	T q459 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q450 += beta*Ix(a,4,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q451 += beta*Ix(a,4,1)*Iy(a,0,3)*Iz(a,0,0); // d/dBx
	    q452 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,3); // d/dBx
	    q453 += beta*Ix(a,4,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q454 += beta*Ix(a,4,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q455 += beta*Ix(a,4,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q456 += beta*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBx
	    q457 += beta*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q458 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBx
	    q459 += beta*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[450] += q450*C_[0];
	I[451] += q451*C_[0];
	I[452] += q452*C_[0];
	I[453] += q453*C_[0];
	I[454] += q454*C_[0];
	I[455] += q455*C_[0];
	I[456] += q456*C_[0];
	I[457] += q457*C_[0];
	I[458] += q458*C_[0];
	I[459] += q459*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q460 = 0.0;
	T q461 = 0.0;
	T q462 = 0.0;
	T q463 = 0.0;
	T q464 = 0.0;
	T q465 = 0.0;
	T q466 = 0.0;
	T q467 = 0.0;
	T q468 = 0.0;
	T q469 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q460 += beta*Ix(a,0,4)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,0);  // d/dBx
	    q461 += beta*Ix(a,0,1)*Iy(a,4,3)*Iz(a,0,0); // d/dBx
	    q462 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,3); // d/dBx
	    q463 += beta*Ix(a,0,3)*Iy(a,4,1)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,0);  // d/dBx
	    q464 += beta*Ix(a,0,3)*Iy(a,4,0)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,1);  // d/dBx
	    q465 += beta*Ix(a,0,2)*Iy(a,4,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,0);  // d/dBx
	    q466 += beta*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,1); // d/dBx
	    q467 += beta*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,2);  // d/dBx
	    q468 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,2); // d/dBx
	    q469 += beta*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[460] += q460*C_[0];
	I[461] += q461*C_[0];
	I[462] += q462*C_[0];
	I[463] += q463*C_[0];
	I[464] += q464*C_[0];
	I[465] += q465*C_[0];
	I[466] += q466*C_[0];
	I[467] += q467*C_[0];
	I[468] += q468*C_[0];
	I[469] += q469*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q470 = 0.0;
	T q471 = 0.0;
	T q472 = 0.0;
	T q473 = 0.0;
	T q474 = 0.0;
	T q475 = 0.0;
	T q476 = 0.0;
	T q477 = 0.0;
	T q478 = 0.0;
	T q479 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q470 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,0);  // d/dBx
	    q471 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,4,0); // d/dBx
	    q472 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,3); // d/dBx
	    q473 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,4,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,0);  // d/dBx
	    q474 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,4,1)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,1);  // d/dBx
	    q475 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,4,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,0);  // d/dBx
	    q476 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,1); // d/dBx
	    q477 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,2);  // d/dBx
	    q478 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,2); // d/dBx
	    q479 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[470] += q470*C_[0];
	I[471] += q471*C_[0];
	I[472] += q472*C_[0];
	I[473] += q473*C_[0];
	I[474] += q474*C_[0];
	I[475] += q475*C_[0];
	I[476] += q476*C_[0];
	I[477] += q477*C_[0];
	I[478] += q478*C_[0];
	I[479] += q479*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q480 = 0.0;
	T q481 = 0.0;
	T q482 = 0.0;
	T q483 = 0.0;
	T q484 = 0.0;
	T q485 = 0.0;
	T q486 = 0.0;
	T q487 = 0.0;
	T q488 = 0.0;
	T q489 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q480 += beta*Ix(a,3,4)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q481 += beta*Ix(a,3,1)*Iy(a,1,3)*Iz(a,0,0); // d/dBx
	    q482 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,3); // d/dBx
	    q483 += beta*Ix(a,3,3)*Iy(a,1,1)*Iz(a,0,0)
                     - 2*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q484 += beta*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,1)
                     - 2*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q485 += beta*Ix(a,3,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBx
	    q486 += beta*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,1); // d/dBx
	    q487 += beta*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBx
	    q488 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,2); // d/dBx
	    q489 += beta*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[480] += q480*C_[0];
	I[481] += q481*C_[0];
	I[482] += q482*C_[0];
	I[483] += q483*C_[0];
	I[484] += q484*C_[0];
	I[485] += q485*C_[0];
	I[486] += q486*C_[0];
	I[487] += q487*C_[0];
	I[488] += q488*C_[0];
	I[489] += q489*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q490 = 0.0;
	T q491 = 0.0;
	T q492 = 0.0;
	T q493 = 0.0;
	T q494 = 0.0;
	T q495 = 0.0;
	T q496 = 0.0;
	T q497 = 0.0;
	T q498 = 0.0;
	T q499 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q490 += beta*Ix(a,3,4)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q491 += beta*Ix(a,3,1)*Iy(a,0,3)*Iz(a,1,0); // d/dBx
	    q492 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,3); // d/dBx
	    q493 += beta*Ix(a,3,3)*Iy(a,0,1)*Iz(a,1,0)
                     - 2*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q494 += beta*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,1)
                     - 2*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q495 += beta*Ix(a,3,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBx
	    q496 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,1); // d/dBx
	    q497 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBx
	    q498 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,2); // d/dBx
	    q499 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,1)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[490] += q490*C_[0];
	I[491] += q491*C_[0];
	I[492] += q492*C_[0];
	I[493] += q493*C_[0];
	I[494] += q494*C_[0];
	I[495] += q495*C_[0];
	I[496] += q496*C_[0];
	I[497] += q497*C_[0];
	I[498] += q498*C_[0];
	I[499] += q499*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q500 = 0.0;
	T q501 = 0.0;
	T q502 = 0.0;
	T q503 = 0.0;
	T q504 = 0.0;
	T q505 = 0.0;
	T q506 = 0.0;
	T q507 = 0.0;
	T q508 = 0.0;
	T q509 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q500 += beta*Ix(a,1,4)*Iy(a,3,0)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,0);  // d/dBx
	    q501 += beta*Ix(a,1,1)*Iy(a,3,3)*Iz(a,0,0); // d/dBx
	    q502 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,3); // d/dBx
	    q503 += beta*Ix(a,1,3)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,0);  // d/dBx
	    q504 += beta*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,1);  // d/dBx
	    q505 += beta*Ix(a,1,2)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,0);  // d/dBx
	    q506 += beta*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,1); // d/dBx
	    q507 += beta*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,2);  // d/dBx
	    q508 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,2); // d/dBx
	    q509 += beta*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[500] += q500*C_[0];
	I[501] += q501*C_[0];
	I[502] += q502*C_[0];
	I[503] += q503*C_[0];
	I[504] += q504*C_[0];
	I[505] += q505*C_[0];
	I[506] += q506*C_[0];
	I[507] += q507*C_[0];
	I[508] += q508*C_[0];
	I[509] += q509*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q510 = 0.0;
	T q511 = 0.0;
	T q512 = 0.0;
	T q513 = 0.0;
	T q514 = 0.0;
	T q515 = 0.0;
	T q516 = 0.0;
	T q517 = 0.0;
	T q518 = 0.0;
	T q519 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q510 += beta*Ix(a,0,4)*Iy(a,3,0)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,0);  // d/dBx
	    q511 += beta*Ix(a,0,1)*Iy(a,3,3)*Iz(a,1,0); // d/dBx
	    q512 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,3); // d/dBx
	    q513 += beta*Ix(a,0,3)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,0);  // d/dBx
	    q514 += beta*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,1);  // d/dBx
	    q515 += beta*Ix(a,0,2)*Iy(a,3,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,0);  // d/dBx
	    q516 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,1); // d/dBx
	    q517 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,2);  // d/dBx
	    q518 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,2); // d/dBx
	    q519 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[510] += q510*C_[0];
	I[511] += q511*C_[0];
	I[512] += q512*C_[0];
	I[513] += q513*C_[0];
	I[514] += q514*C_[0];
	I[515] += q515*C_[0];
	I[516] += q516*C_[0];
	I[517] += q517*C_[0];
	I[518] += q518*C_[0];
	I[519] += q519*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q520 = 0.0;
	T q521 = 0.0;
	T q522 = 0.0;
	T q523 = 0.0;
	T q524 = 0.0;
	T q525 = 0.0;
	T q526 = 0.0;
	T q527 = 0.0;
	T q528 = 0.0;
	T q529 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q520 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,3,0)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,0);  // d/dBx
	    q521 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,3,0); // d/dBx
	    q522 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,3); // d/dBx
	    q523 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,0);  // d/dBx
	    q524 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,1);  // d/dBx
	    q525 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,0);  // d/dBx
	    q526 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,1); // d/dBx
	    q527 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,2);  // d/dBx
	    q528 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,2); // d/dBx
	    q529 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,1)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[520] += q520*C_[0];
	I[521] += q521*C_[0];
	I[522] += q522*C_[0];
	I[523] += q523*C_[0];
	I[524] += q524*C_[0];
	I[525] += q525*C_[0];
	I[526] += q526*C_[0];
	I[527] += q527*C_[0];
	I[528] += q528*C_[0];
	I[529] += q529*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q530 = 0.0;
	T q531 = 0.0;
	T q532 = 0.0;
	T q533 = 0.0;
	T q534 = 0.0;
	T q535 = 0.0;
	T q536 = 0.0;
	T q537 = 0.0;
	T q538 = 0.0;
	T q539 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q530 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,3,0)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,0);  // d/dBx
	    q531 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,3,0); // d/dBx
	    q532 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,3); // d/dBx
	    q533 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,0);  // d/dBx
	    q534 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,1);  // d/dBx
	    q535 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,0);  // d/dBx
	    q536 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,1); // d/dBx
	    q537 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,2);  // d/dBx
	    q538 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,2); // d/dBx
	    q539 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[530] += q530*C_[0];
	I[531] += q531*C_[0];
	I[532] += q532*C_[0];
	I[533] += q533*C_[0];
	I[534] += q534*C_[0];
	I[535] += q535*C_[0];
	I[536] += q536*C_[0];
	I[537] += q537*C_[0];
	I[538] += q538*C_[0];
	I[539] += q539*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q540 = 0.0;
	T q541 = 0.0;
	T q542 = 0.0;
	T q543 = 0.0;
	T q544 = 0.0;
	T q545 = 0.0;
	T q546 = 0.0;
	T q547 = 0.0;
	T q548 = 0.0;
	T q549 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q540 += beta*Ix(a,2,4)*Iy(a,2,0)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q541 += beta*Ix(a,2,1)*Iy(a,2,3)*Iz(a,0,0); // d/dBx
	    q542 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,3); // d/dBx
	    q543 += beta*Ix(a,2,3)*Iy(a,2,1)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dBx
	    q544 += beta*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dBx
	    q545 += beta*Ix(a,2,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dBx
	    q546 += beta*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,1); // d/dBx
	    q547 += beta*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dBx
	    q548 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,2); // d/dBx
	    q549 += beta*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[540] += q540*C_[0];
	I[541] += q541*C_[0];
	I[542] += q542*C_[0];
	I[543] += q543*C_[0];
	I[544] += q544*C_[0];
	I[545] += q545*C_[0];
	I[546] += q546*C_[0];
	I[547] += q547*C_[0];
	I[548] += q548*C_[0];
	I[549] += q549*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q550 = 0.0;
	T q551 = 0.0;
	T q552 = 0.0;
	T q553 = 0.0;
	T q554 = 0.0;
	T q555 = 0.0;
	T q556 = 0.0;
	T q557 = 0.0;
	T q558 = 0.0;
	T q559 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q550 += beta*Ix(a,2,4)*Iy(a,0,0)*Iz(a,2,0)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q551 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,2,0); // d/dBx
	    q552 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,3); // d/dBx
	    q553 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,2,0)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dBx
	    q554 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,1)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dBx
	    q555 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dBx
	    q556 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,1); // d/dBx
	    q557 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dBx
	    q558 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,2); // d/dBx
	    q559 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[550] += q550*C_[0];
	I[551] += q551*C_[0];
	I[552] += q552*C_[0];
	I[553] += q553*C_[0];
	I[554] += q554*C_[0];
	I[555] += q555*C_[0];
	I[556] += q556*C_[0];
	I[557] += q557*C_[0];
	I[558] += q558*C_[0];
	I[559] += q559*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q560 = 0.0;
	T q561 = 0.0;
	T q562 = 0.0;
	T q563 = 0.0;
	T q564 = 0.0;
	T q565 = 0.0;
	T q566 = 0.0;
	T q567 = 0.0;
	T q568 = 0.0;
	T q569 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q560 += beta*Ix(a,0,4)*Iy(a,2,0)*Iz(a,2,0)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,0);  // d/dBx
	    q561 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,2,0); // d/dBx
	    q562 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,3); // d/dBx
	    q563 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,0);  // d/dBx
	    q564 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,1);  // d/dBx
	    q565 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,0);  // d/dBx
	    q566 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,1); // d/dBx
	    q567 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,2);  // d/dBx
	    q568 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,2); // d/dBx
	    q569 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[560] += q560*C_[0];
	I[561] += q561*C_[0];
	I[562] += q562*C_[0];
	I[563] += q563*C_[0];
	I[564] += q564*C_[0];
	I[565] += q565*C_[0];
	I[566] += q566*C_[0];
	I[567] += q567*C_[0];
	I[568] += q568*C_[0];
	I[569] += q569*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q570 = 0.0;
	T q571 = 0.0;
	T q572 = 0.0;
	T q573 = 0.0;
	T q574 = 0.0;
	T q575 = 0.0;
	T q576 = 0.0;
	T q577 = 0.0;
	T q578 = 0.0;
	T q579 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q570 += beta*Ix(a,2,4)*Iy(a,1,0)*Iz(a,1,0)
                     - 3*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q571 += beta*Ix(a,2,1)*Iy(a,1,3)*Iz(a,1,0); // d/dBx
	    q572 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,3); // d/dBx
	    q573 += beta*Ix(a,2,3)*Iy(a,1,1)*Iz(a,1,0)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dBx
	    q574 += beta*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,1)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dBx
	    q575 += beta*Ix(a,2,2)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dBx
	    q576 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,1); // d/dBx
	    q577 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dBx
	    q578 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,2); // d/dBx
	    q579 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[570] += q570*C_[0];
	I[571] += q571*C_[0];
	I[572] += q572*C_[0];
	I[573] += q573*C_[0];
	I[574] += q574*C_[0];
	I[575] += q575*C_[0];
	I[576] += q576*C_[0];
	I[577] += q577*C_[0];
	I[578] += q578*C_[0];
	I[579] += q579*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q580 = 0.0;
	T q581 = 0.0;
	T q582 = 0.0;
	T q583 = 0.0;
	T q584 = 0.0;
	T q585 = 0.0;
	T q586 = 0.0;
	T q587 = 0.0;
	T q588 = 0.0;
	T q589 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q580 += beta*Ix(a,1,4)*Iy(a,2,0)*Iz(a,1,0)
                     - 3*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,0);  // d/dBx
	    q581 += beta*Ix(a,1,1)*Iy(a,2,3)*Iz(a,1,0); // d/dBx
	    q582 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,3); // d/dBx
	    q583 += beta*Ix(a,1,3)*Iy(a,2,1)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,0);  // d/dBx
	    q584 += beta*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,1);  // d/dBx
	    q585 += beta*Ix(a,1,2)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,0);  // d/dBx
	    q586 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,1); // d/dBx
	    q587 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,2);  // d/dBx
	    q588 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,2); // d/dBx
	    q589 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[580] += q580*C_[0];
	I[581] += q581*C_[0];
	I[582] += q582*C_[0];
	I[583] += q583*C_[0];
	I[584] += q584*C_[0];
	I[585] += q585*C_[0];
	I[586] += q586*C_[0];
	I[587] += q587*C_[0];
	I[588] += q588*C_[0];
	I[589] += q589*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q590 = 0.0;
	T q591 = 0.0;
	T q592 = 0.0;
	T q593 = 0.0;
	T q594 = 0.0;
	T q595 = 0.0;
	T q596 = 0.0;
	T q597 = 0.0;
	T q598 = 0.0;
	T q599 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q590 += beta*Ix(a,1,4)*Iy(a,1,0)*Iz(a,2,0)
                     - 3*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,0);  // d/dBx
	    q591 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,2,0); // d/dBx
	    q592 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,3); // d/dBx
	    q593 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,0);  // d/dBx
	    q594 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,1)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,1);  // d/dBx
	    q595 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,0);  // d/dBx
	    q596 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,1); // d/dBx
	    q597 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,2);  // d/dBx
	    q598 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,2); // d/dBx
	    q599 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[590] += q590*C_[0];
	I[591] += q591*C_[0];
	I[592] += q592*C_[0];
	I[593] += q593*C_[0];
	I[594] += q594*C_[0];
	I[595] += q595*C_[0];
	I[596] += q596*C_[0];
	I[597] += q597*C_[0];
	I[598] += q598*C_[0];
	I[599] += q599*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q600 = 0.0;
	T q601 = 0.0;
	T q602 = 0.0;
	T q603 = 0.0;
	T q604 = 0.0;
	T q605 = 0.0;
	T q606 = 0.0;
	T q607 = 0.0;
	T q608 = 0.0;
	T q609 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q600 += beta*Ix(a,4,3)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q601 += beta*Ix(a,4,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q602 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q603 += beta*Ix(a,4,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q604 += beta*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q605 += beta*Ix(a,4,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q606 += beta*Ix(a,4,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q607 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q608 += beta*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q609 += beta*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[600] += q600*C_[0];
	I[601] += q601*C_[0];
	I[602] += q602*C_[0];
	I[603] += q603*C_[0];
	I[604] += q604*C_[0];
	I[605] += q605*C_[0];
	I[606] += q606*C_[0];
	I[607] += q607*C_[0];
	I[608] += q608*C_[0];
	I[609] += q609*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q610 = 0.0;
	T q611 = 0.0;
	T q612 = 0.0;
	T q613 = 0.0;
	T q614 = 0.0;
	T q615 = 0.0;
	T q616 = 0.0;
	T q617 = 0.0;
	T q618 = 0.0;
	T q619 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q610 += beta*Ix(a,0,3)*Iy(a,4,1)*Iz(a,0,0); // d/dBy
	    q611 += beta*Ix(a,0,0)*Iy(a,4,4)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,0);  // d/dBy
	    q612 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,3); // d/dBy
	    q613 += beta*Ix(a,0,2)*Iy(a,4,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,0);  // d/dBy
	    q614 += beta*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,1); // d/dBy
	    q615 += beta*Ix(a,0,1)*Iy(a,4,3)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,0);  // d/dBy
	    q616 += beta*Ix(a,0,0)*Iy(a,4,3)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,1);  // d/dBy
	    q617 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,2); // d/dBy
	    q618 += beta*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,2);  // d/dBy
	    q619 += beta*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[610] += q610*C_[0];
	I[611] += q611*C_[0];
	I[612] += q612*C_[0];
	I[613] += q613*C_[0];
	I[614] += q614*C_[0];
	I[615] += q615*C_[0];
	I[616] += q616*C_[0];
	I[617] += q617*C_[0];
	I[618] += q618*C_[0];
	I[619] += q619*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q620 = 0.0;
	T q621 = 0.0;
	T q622 = 0.0;
	T q623 = 0.0;
	T q624 = 0.0;
	T q625 = 0.0;
	T q626 = 0.0;
	T q627 = 0.0;
	T q628 = 0.0;
	T q629 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q620 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,4,0); // d/dBy
	    q621 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,0);  // d/dBy
	    q622 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,3); // d/dBy
	    q623 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,4,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,0);  // d/dBy
	    q624 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,1); // d/dBy
	    q625 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,4,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,0);  // d/dBy
	    q626 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,4,1)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,1);  // d/dBy
	    q627 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,2); // d/dBy
	    q628 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,2);  // d/dBy
	    q629 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[620] += q620*C_[0];
	I[621] += q621*C_[0];
	I[622] += q622*C_[0];
	I[623] += q623*C_[0];
	I[624] += q624*C_[0];
	I[625] += q625*C_[0];
	I[626] += q626*C_[0];
	I[627] += q627*C_[0];
	I[628] += q628*C_[0];
	I[629] += q629*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q630 = 0.0;
	T q631 = 0.0;
	T q632 = 0.0;
	T q633 = 0.0;
	T q634 = 0.0;
	T q635 = 0.0;
	T q636 = 0.0;
	T q637 = 0.0;
	T q638 = 0.0;
	T q639 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q630 += beta*Ix(a,3,3)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q631 += beta*Ix(a,3,0)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBy
	    q632 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,3); // d/dBy
	    q633 += beta*Ix(a,3,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q634 += beta*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q635 += beta*Ix(a,3,1)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	    q636 += beta*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBy
	    q637 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q638 += beta*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBy
	    q639 += beta*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[630] += q630*C_[0];
	I[631] += q631*C_[0];
	I[632] += q632*C_[0];
	I[633] += q633*C_[0];
	I[634] += q634*C_[0];
	I[635] += q635*C_[0];
	I[636] += q636*C_[0];
	I[637] += q637*C_[0];
	I[638] += q638*C_[0];
	I[639] += q639*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q640 = 0.0;
	T q641 = 0.0;
	T q642 = 0.0;
	T q643 = 0.0;
	T q644 = 0.0;
	T q645 = 0.0;
	T q646 = 0.0;
	T q647 = 0.0;
	T q648 = 0.0;
	T q649 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q640 += beta*Ix(a,3,3)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q641 += beta*Ix(a,3,0)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBy
	    q642 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,3); // d/dBy
	    q643 += beta*Ix(a,3,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q644 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q645 += beta*Ix(a,3,1)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	    q646 += beta*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBy
	    q647 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q648 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBy
	    q649 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[640] += q640*C_[0];
	I[641] += q641*C_[0];
	I[642] += q642*C_[0];
	I[643] += q643*C_[0];
	I[644] += q644*C_[0];
	I[645] += q645*C_[0];
	I[646] += q646*C_[0];
	I[647] += q647*C_[0];
	I[648] += q648*C_[0];
	I[649] += q649*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q650 = 0.0;
	T q651 = 0.0;
	T q652 = 0.0;
	T q653 = 0.0;
	T q654 = 0.0;
	T q655 = 0.0;
	T q656 = 0.0;
	T q657 = 0.0;
	T q658 = 0.0;
	T q659 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q650 += beta*Ix(a,1,3)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q651 += beta*Ix(a,1,0)*Iy(a,3,4)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,0);  // d/dBy
	    q652 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,3); // d/dBy
	    q653 += beta*Ix(a,1,2)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,0);  // d/dBy
	    q654 += beta*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,1); // d/dBy
	    q655 += beta*Ix(a,1,1)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,0);  // d/dBy
	    q656 += beta*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,1);  // d/dBy
	    q657 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,2); // d/dBy
	    q658 += beta*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,2);  // d/dBy
	    q659 += beta*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,1)
                     - 1*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[650] += q650*C_[0];
	I[651] += q651*C_[0];
	I[652] += q652*C_[0];
	I[653] += q653*C_[0];
	I[654] += q654*C_[0];
	I[655] += q655*C_[0];
	I[656] += q656*C_[0];
	I[657] += q657*C_[0];
	I[658] += q658*C_[0];
	I[659] += q659*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q660 = 0.0;
	T q661 = 0.0;
	T q662 = 0.0;
	T q663 = 0.0;
	T q664 = 0.0;
	T q665 = 0.0;
	T q666 = 0.0;
	T q667 = 0.0;
	T q668 = 0.0;
	T q669 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q660 += beta*Ix(a,0,3)*Iy(a,3,1)*Iz(a,1,0); // d/dBy
	    q661 += beta*Ix(a,0,0)*Iy(a,3,4)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,0);  // d/dBy
	    q662 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,3); // d/dBy
	    q663 += beta*Ix(a,0,2)*Iy(a,3,2)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,0);  // d/dBy
	    q664 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,1); // d/dBy
	    q665 += beta*Ix(a,0,1)*Iy(a,3,3)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,0);  // d/dBy
	    q666 += beta*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,1)
                     - 2*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,1);  // d/dBy
	    q667 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,2); // d/dBy
	    q668 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,2);  // d/dBy
	    q669 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[660] += q660*C_[0];
	I[661] += q661*C_[0];
	I[662] += q662*C_[0];
	I[663] += q663*C_[0];
	I[664] += q664*C_[0];
	I[665] += q665*C_[0];
	I[666] += q666*C_[0];
	I[667] += q667*C_[0];
	I[668] += q668*C_[0];
	I[669] += q669*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q670 = 0.0;
	T q671 = 0.0;
	T q672 = 0.0;
	T q673 = 0.0;
	T q674 = 0.0;
	T q675 = 0.0;
	T q676 = 0.0;
	T q677 = 0.0;
	T q678 = 0.0;
	T q679 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q670 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q671 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,3,0)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,0);  // d/dBy
	    q672 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,3); // d/dBy
	    q673 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,0);  // d/dBy
	    q674 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,1); // d/dBy
	    q675 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,0);  // d/dBy
	    q676 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,1);  // d/dBy
	    q677 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,2); // d/dBy
	    q678 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,2);  // d/dBy
	    q679 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,1)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[670] += q670*C_[0];
	I[671] += q671*C_[0];
	I[672] += q672*C_[0];
	I[673] += q673*C_[0];
	I[674] += q674*C_[0];
	I[675] += q675*C_[0];
	I[676] += q676*C_[0];
	I[677] += q677*C_[0];
	I[678] += q678*C_[0];
	I[679] += q679*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q680 = 0.0;
	T q681 = 0.0;
	T q682 = 0.0;
	T q683 = 0.0;
	T q684 = 0.0;
	T q685 = 0.0;
	T q686 = 0.0;
	T q687 = 0.0;
	T q688 = 0.0;
	T q689 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q680 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,3,0); // d/dBy
	    q681 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,3,0)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,0);  // d/dBy
	    q682 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,3); // d/dBy
	    q683 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,3,0)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,0);  // d/dBy
	    q684 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,1); // d/dBy
	    q685 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,0);  // d/dBy
	    q686 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,1);  // d/dBy
	    q687 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,2); // d/dBy
	    q688 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,2);  // d/dBy
	    q689 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,1)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[680] += q680*C_[0];
	I[681] += q681*C_[0];
	I[682] += q682*C_[0];
	I[683] += q683*C_[0];
	I[684] += q684*C_[0];
	I[685] += q685*C_[0];
	I[686] += q686*C_[0];
	I[687] += q687*C_[0];
	I[688] += q688*C_[0];
	I[689] += q689*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q690 = 0.0;
	T q691 = 0.0;
	T q692 = 0.0;
	T q693 = 0.0;
	T q694 = 0.0;
	T q695 = 0.0;
	T q696 = 0.0;
	T q697 = 0.0;
	T q698 = 0.0;
	T q699 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q690 += beta*Ix(a,2,3)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q691 += beta*Ix(a,2,0)*Iy(a,2,4)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dBy
	    q692 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,3); // d/dBy
	    q693 += beta*Ix(a,2,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q694 += beta*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	    q695 += beta*Ix(a,2,1)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dBy
	    q696 += beta*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,1)
                     - 2*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dBy
	    q697 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,2); // d/dBy
	    q698 += beta*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dBy
	    q699 += beta*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[690] += q690*C_[0];
	I[691] += q691*C_[0];
	I[692] += q692*C_[0];
	I[693] += q693*C_[0];
	I[694] += q694*C_[0];
	I[695] += q695*C_[0];
	I[696] += q696*C_[0];
	I[697] += q697*C_[0];
	I[698] += q698*C_[0];
	I[699] += q699*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q700 = 0.0;
	T q701 = 0.0;
	T q702 = 0.0;
	T q703 = 0.0;
	T q704 = 0.0;
	T q705 = 0.0;
	T q706 = 0.0;
	T q707 = 0.0;
	T q708 = 0.0;
	T q709 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q700 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q701 += beta*Ix(a,2,0)*Iy(a,0,4)*Iz(a,2,0)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dBy
	    q702 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,3); // d/dBy
	    q703 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q704 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q705 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dBy
	    q706 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,1)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dBy
	    q707 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,2); // d/dBy
	    q708 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dBy
	    q709 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[700] += q700*C_[0];
	I[701] += q701*C_[0];
	I[702] += q702*C_[0];
	I[703] += q703*C_[0];
	I[704] += q704*C_[0];
	I[705] += q705*C_[0];
	I[706] += q706*C_[0];
	I[707] += q707*C_[0];
	I[708] += q708*C_[0];
	I[709] += q709*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q710 = 0.0;
	T q711 = 0.0;
	T q712 = 0.0;
	T q713 = 0.0;
	T q714 = 0.0;
	T q715 = 0.0;
	T q716 = 0.0;
	T q717 = 0.0;
	T q718 = 0.0;
	T q719 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q710 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,2,0); // d/dBy
	    q711 += beta*Ix(a,0,0)*Iy(a,2,4)*Iz(a,2,0)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,0);  // d/dBy
	    q712 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,3); // d/dBy
	    q713 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,0);  // d/dBy
	    q714 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,1); // d/dBy
	    q715 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,0);  // d/dBy
	    q716 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,1)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,1);  // d/dBy
	    q717 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,2); // d/dBy
	    q718 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,2);  // d/dBy
	    q719 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[710] += q710*C_[0];
	I[711] += q711*C_[0];
	I[712] += q712*C_[0];
	I[713] += q713*C_[0];
	I[714] += q714*C_[0];
	I[715] += q715*C_[0];
	I[716] += q716*C_[0];
	I[717] += q717*C_[0];
	I[718] += q718*C_[0];
	I[719] += q719*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q720 = 0.0;
	T q721 = 0.0;
	T q722 = 0.0;
	T q723 = 0.0;
	T q724 = 0.0;
	T q725 = 0.0;
	T q726 = 0.0;
	T q727 = 0.0;
	T q728 = 0.0;
	T q729 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q720 += beta*Ix(a,2,3)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q721 += beta*Ix(a,2,0)*Iy(a,1,4)*Iz(a,1,0)
                     - 3*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dBy
	    q722 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,3); // d/dBy
	    q723 += beta*Ix(a,2,2)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q724 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	    q725 += beta*Ix(a,2,1)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dBy
	    q726 += beta*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,1)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dBy
	    q727 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,2); // d/dBy
	    q728 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dBy
	    q729 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[720] += q720*C_[0];
	I[721] += q721*C_[0];
	I[722] += q722*C_[0];
	I[723] += q723*C_[0];
	I[724] += q724*C_[0];
	I[725] += q725*C_[0];
	I[726] += q726*C_[0];
	I[727] += q727*C_[0];
	I[728] += q728*C_[0];
	I[729] += q729*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q730 = 0.0;
	T q731 = 0.0;
	T q732 = 0.0;
	T q733 = 0.0;
	T q734 = 0.0;
	T q735 = 0.0;
	T q736 = 0.0;
	T q737 = 0.0;
	T q738 = 0.0;
	T q739 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q730 += beta*Ix(a,1,3)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q731 += beta*Ix(a,1,0)*Iy(a,2,4)*Iz(a,1,0)
                     - 3*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,0);  // d/dBy
	    q732 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,3); // d/dBy
	    q733 += beta*Ix(a,1,2)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,0);  // d/dBy
	    q734 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,1); // d/dBy
	    q735 += beta*Ix(a,1,1)*Iy(a,2,3)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,0);  // d/dBy
	    q736 += beta*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,1);  // d/dBy
	    q737 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,2); // d/dBy
	    q738 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,2);  // d/dBy
	    q739 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[730] += q730*C_[0];
	I[731] += q731*C_[0];
	I[732] += q732*C_[0];
	I[733] += q733*C_[0];
	I[734] += q734*C_[0];
	I[735] += q735*C_[0];
	I[736] += q736*C_[0];
	I[737] += q737*C_[0];
	I[738] += q738*C_[0];
	I[739] += q739*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q740 = 0.0;
	T q741 = 0.0;
	T q742 = 0.0;
	T q743 = 0.0;
	T q744 = 0.0;
	T q745 = 0.0;
	T q746 = 0.0;
	T q747 = 0.0;
	T q748 = 0.0;
	T q749 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q740 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q741 += beta*Ix(a,1,0)*Iy(a,1,4)*Iz(a,2,0)
                     - 3*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,0);  // d/dBy
	    q742 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,3); // d/dBy
	    q743 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,0);  // d/dBy
	    q744 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,1); // d/dBy
	    q745 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,0);  // d/dBy
	    q746 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,1)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,1);  // d/dBy
	    q747 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,2); // d/dBy
	    q748 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,2);  // d/dBy
	    q749 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[740] += q740*C_[0];
	I[741] += q741*C_[0];
	I[742] += q742*C_[0];
	I[743] += q743*C_[0];
	I[744] += q744*C_[0];
	I[745] += q745*C_[0];
	I[746] += q746*C_[0];
	I[747] += q747*C_[0];
	I[748] += q748*C_[0];
	I[749] += q749*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q750 = 0.0;
	T q751 = 0.0;
	T q752 = 0.0;
	T q753 = 0.0;
	T q754 = 0.0;
	T q755 = 0.0;
	T q756 = 0.0;
	T q757 = 0.0;
	T q758 = 0.0;
	T q759 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q750 += beta*Ix(a,4,3)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q751 += beta*Ix(a,4,0)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q752 += beta*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q753 += beta*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q754 += beta*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q755 += beta*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q756 += beta*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q757 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q758 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	    q759 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[750] += q750*C_[0];
	I[751] += q751*C_[0];
	I[752] += q752*C_[0];
	I[753] += q753*C_[0];
	I[754] += q754*C_[0];
	I[755] += q755*C_[0];
	I[756] += q756*C_[0];
	I[757] += q757*C_[0];
	I[758] += q758*C_[0];
	I[759] += q759*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q760 = 0.0;
	T q761 = 0.0;
	T q762 = 0.0;
	T q763 = 0.0;
	T q764 = 0.0;
	T q765 = 0.0;
	T q766 = 0.0;
	T q767 = 0.0;
	T q768 = 0.0;
	T q769 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q760 += beta*Ix(a,0,3)*Iy(a,4,0)*Iz(a,0,1); // d/dBz
	    q761 += beta*Ix(a,0,0)*Iy(a,4,3)*Iz(a,0,1); // d/dBz
	    q762 += beta*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,2);  // d/dBz
	    q763 += beta*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,1); // d/dBz
	    q764 += beta*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,0);  // d/dBz
	    q765 += beta*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,1); // d/dBz
	    q766 += beta*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,0);  // d/dBz
	    q767 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,1);  // d/dBz
	    q768 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,1);  // d/dBz
	    q769 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[760] += q760*C_[0];
	I[761] += q761*C_[0];
	I[762] += q762*C_[0];
	I[763] += q763*C_[0];
	I[764] += q764*C_[0];
	I[765] += q765*C_[0];
	I[766] += q766*C_[0];
	I[767] += q767*C_[0];
	I[768] += q768*C_[0];
	I[769] += q769*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q770 = 0.0;
	T q771 = 0.0;
	T q772 = 0.0;
	T q773 = 0.0;
	T q774 = 0.0;
	T q775 = 0.0;
	T q776 = 0.0;
	T q777 = 0.0;
	T q778 = 0.0;
	T q779 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q770 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,4,1); // d/dBz
	    q771 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,4,1); // d/dBz
	    q772 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,4)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,2);  // d/dBz
	    q773 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,1); // d/dBz
	    q774 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,0);  // d/dBz
	    q775 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,1); // d/dBz
	    q776 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,0);  // d/dBz
	    q777 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,3)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,1);  // d/dBz
	    q778 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,3)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,1);  // d/dBz
	    q779 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[770] += q770*C_[0];
	I[771] += q771*C_[0];
	I[772] += q772*C_[0];
	I[773] += q773*C_[0];
	I[774] += q774*C_[0];
	I[775] += q775*C_[0];
	I[776] += q776*C_[0];
	I[777] += q777*C_[0];
	I[778] += q778*C_[0];
	I[779] += q779*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q780 = 0.0;
	T q781 = 0.0;
	T q782 = 0.0;
	T q783 = 0.0;
	T q784 = 0.0;
	T q785 = 0.0;
	T q786 = 0.0;
	T q787 = 0.0;
	T q788 = 0.0;
	T q789 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q780 += beta*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q781 += beta*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,1); // d/dBz
	    q782 += beta*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBz
	    q783 += beta*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q784 += beta*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q785 += beta*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	    q786 += beta*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBz
	    q787 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q788 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBz
	    q789 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[780] += q780*C_[0];
	I[781] += q781*C_[0];
	I[782] += q782*C_[0];
	I[783] += q783*C_[0];
	I[784] += q784*C_[0];
	I[785] += q785*C_[0];
	I[786] += q786*C_[0];
	I[787] += q787*C_[0];
	I[788] += q788*C_[0];
	I[789] += q789*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q790 = 0.0;
	T q791 = 0.0;
	T q792 = 0.0;
	T q793 = 0.0;
	T q794 = 0.0;
	T q795 = 0.0;
	T q796 = 0.0;
	T q797 = 0.0;
	T q798 = 0.0;
	T q799 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q790 += beta*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q791 += beta*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,1); // d/dBz
	    q792 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBz
	    q793 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q794 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q795 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q796 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBz
	    q797 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q798 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBz
	    q799 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[790] += q790*C_[0];
	I[791] += q791*C_[0];
	I[792] += q792*C_[0];
	I[793] += q793*C_[0];
	I[794] += q794*C_[0];
	I[795] += q795*C_[0];
	I[796] += q796*C_[0];
	I[797] += q797*C_[0];
	I[798] += q798*C_[0];
	I[799] += q799*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q800 = 0.0;
	T q801 = 0.0;
	T q802 = 0.0;
	T q803 = 0.0;
	T q804 = 0.0;
	T q805 = 0.0;
	T q806 = 0.0;
	T q807 = 0.0;
	T q808 = 0.0;
	T q809 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q800 += beta*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q801 += beta*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,1); // d/dBz
	    q802 += beta*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,2);  // d/dBz
	    q803 += beta*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,1); // d/dBz
	    q804 += beta*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,0);  // d/dBz
	    q805 += beta*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,1); // d/dBz
	    q806 += beta*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,0);  // d/dBz
	    q807 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,1);  // d/dBz
	    q808 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,1);  // d/dBz
	    q809 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[800] += q800*C_[0];
	I[801] += q801*C_[0];
	I[802] += q802*C_[0];
	I[803] += q803*C_[0];
	I[804] += q804*C_[0];
	I[805] += q805*C_[0];
	I[806] += q806*C_[0];
	I[807] += q807*C_[0];
	I[808] += q808*C_[0];
	I[809] += q809*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q810 = 0.0;
	T q811 = 0.0;
	T q812 = 0.0;
	T q813 = 0.0;
	T q814 = 0.0;
	T q815 = 0.0;
	T q816 = 0.0;
	T q817 = 0.0;
	T q818 = 0.0;
	T q819 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q810 += beta*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,1); // d/dBz
	    q811 += beta*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,1); // d/dBz
	    q812 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,2);  // d/dBz
	    q813 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,1); // d/dBz
	    q814 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,0);  // d/dBz
	    q815 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,1); // d/dBz
	    q816 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,0);  // d/dBz
	    q817 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,1);  // d/dBz
	    q818 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,1);  // d/dBz
	    q819 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[810] += q810*C_[0];
	I[811] += q811*C_[0];
	I[812] += q812*C_[0];
	I[813] += q813*C_[0];
	I[814] += q814*C_[0];
	I[815] += q815*C_[0];
	I[816] += q816*C_[0];
	I[817] += q817*C_[0];
	I[818] += q818*C_[0];
	I[819] += q819*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q820 = 0.0;
	T q821 = 0.0;
	T q822 = 0.0;
	T q823 = 0.0;
	T q824 = 0.0;
	T q825 = 0.0;
	T q826 = 0.0;
	T q827 = 0.0;
	T q828 = 0.0;
	T q829 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q820 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q821 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,1); // d/dBz
	    q822 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,4)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,2);  // d/dBz
	    q823 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,1); // d/dBz
	    q824 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,0);  // d/dBz
	    q825 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,1); // d/dBz
	    q826 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,2)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,0);  // d/dBz
	    q827 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,1);  // d/dBz
	    q828 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,3)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,1);  // d/dBz
	    q829 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,2)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[820] += q820*C_[0];
	I[821] += q821*C_[0];
	I[822] += q822*C_[0];
	I[823] += q823*C_[0];
	I[824] += q824*C_[0];
	I[825] += q825*C_[0];
	I[826] += q826*C_[0];
	I[827] += q827*C_[0];
	I[828] += q828*C_[0];
	I[829] += q829*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q830 = 0.0;
	T q831 = 0.0;
	T q832 = 0.0;
	T q833 = 0.0;
	T q834 = 0.0;
	T q835 = 0.0;
	T q836 = 0.0;
	T q837 = 0.0;
	T q838 = 0.0;
	T q839 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q830 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,1); // d/dBz
	    q831 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,1); // d/dBz
	    q832 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,4)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,2);  // d/dBz
	    q833 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,1); // d/dBz
	    q834 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,2)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,0);  // d/dBz
	    q835 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,1); // d/dBz
	    q836 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,0);  // d/dBz
	    q837 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,3)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,1);  // d/dBz
	    q838 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,1);  // d/dBz
	    q839 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[830] += q830*C_[0];
	I[831] += q831*C_[0];
	I[832] += q832*C_[0];
	I[833] += q833*C_[0];
	I[834] += q834*C_[0];
	I[835] += q835*C_[0];
	I[836] += q836*C_[0];
	I[837] += q837*C_[0];
	I[838] += q838*C_[0];
	I[839] += q839*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q840 = 0.0;
	T q841 = 0.0;
	T q842 = 0.0;
	T q843 = 0.0;
	T q844 = 0.0;
	T q845 = 0.0;
	T q846 = 0.0;
	T q847 = 0.0;
	T q848 = 0.0;
	T q849 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q840 += beta*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q841 += beta*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,1); // d/dBz
	    q842 += beta*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,4)
                     - 3*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,2);  // d/dBz
	    q843 += beta*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q844 += beta*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q845 += beta*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,1); // d/dBz
	    q846 += beta*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,0);  // d/dBz
	    q847 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,1);  // d/dBz
	    q848 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,1);  // d/dBz
	    q849 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[840] += q840*C_[0];
	I[841] += q841*C_[0];
	I[842] += q842*C_[0];
	I[843] += q843*C_[0];
	I[844] += q844*C_[0];
	I[845] += q845*C_[0];
	I[846] += q846*C_[0];
	I[847] += q847*C_[0];
	I[848] += q848*C_[0];
	I[849] += q849*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q850 = 0.0;
	T q851 = 0.0;
	T q852 = 0.0;
	T q853 = 0.0;
	T q854 = 0.0;
	T q855 = 0.0;
	T q856 = 0.0;
	T q857 = 0.0;
	T q858 = 0.0;
	T q859 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q850 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q851 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,1); // d/dBz
	    q852 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,4)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,2);  // d/dBz
	    q853 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q854 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q855 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,1); // d/dBz
	    q856 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,0);  // d/dBz
	    q857 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,1);  // d/dBz
	    q858 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,3)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,1);  // d/dBz
	    q859 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[850] += q850*C_[0];
	I[851] += q851*C_[0];
	I[852] += q852*C_[0];
	I[853] += q853*C_[0];
	I[854] += q854*C_[0];
	I[855] += q855*C_[0];
	I[856] += q856*C_[0];
	I[857] += q857*C_[0];
	I[858] += q858*C_[0];
	I[859] += q859*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q860 = 0.0;
	T q861 = 0.0;
	T q862 = 0.0;
	T q863 = 0.0;
	T q864 = 0.0;
	T q865 = 0.0;
	T q866 = 0.0;
	T q867 = 0.0;
	T q868 = 0.0;
	T q869 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q860 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,1); // d/dBz
	    q861 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,1); // d/dBz
	    q862 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,4)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,2);  // d/dBz
	    q863 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,1); // d/dBz
	    q864 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,0);  // d/dBz
	    q865 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,1); // d/dBz
	    q866 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,0);  // d/dBz
	    q867 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,3)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,1);  // d/dBz
	    q868 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,1);  // d/dBz
	    q869 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[860] += q860*C_[0];
	I[861] += q861*C_[0];
	I[862] += q862*C_[0];
	I[863] += q863*C_[0];
	I[864] += q864*C_[0];
	I[865] += q865*C_[0];
	I[866] += q866*C_[0];
	I[867] += q867*C_[0];
	I[868] += q868*C_[0];
	I[869] += q869*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q870 = 0.0;
	T q871 = 0.0;
	T q872 = 0.0;
	T q873 = 0.0;
	T q874 = 0.0;
	T q875 = 0.0;
	T q876 = 0.0;
	T q877 = 0.0;
	T q878 = 0.0;
	T q879 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q870 += beta*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q871 += beta*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,1); // d/dBz
	    q872 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,4)
                     - 3*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,2);  // d/dBz
	    q873 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q874 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	    q875 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,1); // d/dBz
	    q876 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,0);  // d/dBz
	    q877 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,1);  // d/dBz
	    q878 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,3)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,1);  // d/dBz
	    q879 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[870] += q870*C_[0];
	I[871] += q871*C_[0];
	I[872] += q872*C_[0];
	I[873] += q873*C_[0];
	I[874] += q874*C_[0];
	I[875] += q875*C_[0];
	I[876] += q876*C_[0];
	I[877] += q877*C_[0];
	I[878] += q878*C_[0];
	I[879] += q879*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q880 = 0.0;
	T q881 = 0.0;
	T q882 = 0.0;
	T q883 = 0.0;
	T q884 = 0.0;
	T q885 = 0.0;
	T q886 = 0.0;
	T q887 = 0.0;
	T q888 = 0.0;
	T q889 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q880 += beta*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q881 += beta*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,1); // d/dBz
	    q882 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,4)
                     - 3*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,2);  // d/dBz
	    q883 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,1); // d/dBz
	    q884 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,0);  // d/dBz
	    q885 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,1); // d/dBz
	    q886 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,0);  // d/dBz
	    q887 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,3)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,1);  // d/dBz
	    q888 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,1);  // d/dBz
	    q889 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[880] += q880*C_[0];
	I[881] += q881*C_[0];
	I[882] += q882*C_[0];
	I[883] += q883*C_[0];
	I[884] += q884*C_[0];
	I[885] += q885*C_[0];
	I[886] += q886*C_[0];
	I[887] += q887*C_[0];
	I[888] += q888*C_[0];
	I[889] += q889*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q890 = 0.0;
	T q891 = 0.0;
	T q892 = 0.0;
	T q893 = 0.0;
	T q894 = 0.0;
	T q895 = 0.0;
	T q896 = 0.0;
	T q897 = 0.0;
	T q898 = 0.0;
	T q899 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q890 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q891 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,1); // d/dBz
	    q892 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,4)
                     - 3*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,2);  // d/dBz
	    q893 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,1); // d/dBz
	    q894 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,0);  // d/dBz
	    q895 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,1); // d/dBz
	    q896 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,0);  // d/dBz
	    q897 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,3)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,1);  // d/dBz
	    q898 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,3)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,1);  // d/dBz
	    q899 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[890] += q890*C_[0];
	I[891] += q891*C_[0];
	I[892] += q892*C_[0];
	I[893] += q893*C_[0];
	I[894] += q894*C_[0];
	I[895] += q895*C_[0];
	I[896] += q896*C_[0];
	I[897] += q897*C_[0];
	I[898] += q898*C_[0];
	I[899] += q899*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <spf| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::SP,rysq::F> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::SP,rysq::F> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3); // d/dAx
	    q3 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0); // d/dAx
	    q4 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1); // d/dAx
	    q5 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0); // d/dAx
	    q6 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1); // d/dAx
	    q7 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q11 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAx
	    q12 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAx
	    q13 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q14 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q15 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q16 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAx
	    q17 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q18 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAx
	    q19 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[1];
	I[11] += q11*C_[1];
	I[12] += q12*C_[1];
	I[13] += q13*C_[1];
	I[14] += q14*C_[1];
	I[15] += q15*C_[1];
	I[16] += q16*C_[1];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q21 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0); // d/dAx
	    q22 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3); // d/dAx
	    q23 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0); // d/dAx
	    q24 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1); // d/dAx
	    q25 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1); // d/dAx
	    q27 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2); // d/dAx
	    q28 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2); // d/dAx
	    q29 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[1];
	I[21] += q21*C_[1];
	I[22] += q22*C_[1];
	I[23] += q23*C_[1];
	I[24] += q24*C_[1];
	I[25] += q25*C_[1];
	I[26] += q26*C_[1];
	I[27] += q27*C_[1];
	I[28] += q28*C_[1];
	I[29] += q29*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q31 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0); // d/dAx
	    q32 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3); // d/dAx
	    q33 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0); // d/dAx
	    q34 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1); // d/dAx
	    q35 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0); // d/dAx
	    q36 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1); // d/dAx
	    q37 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2); // d/dAx
	    q38 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2); // d/dAx
	    q39 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1); // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[1];
	I[31] += q31*C_[1];
	I[32] += q32*C_[1];
	I[33] += q33*C_[1];
	I[34] += q34*C_[1];
	I[35] += q35*C_[1];
	I[36] += q36*C_[1];
	I[37] += q37*C_[1];
	I[38] += q38*C_[1];
	I[39] += q39*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q41 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q42 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q43 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q44 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q45 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q46 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q47 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q48 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	    q49 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q51 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q52 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q53 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q54 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q55 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q56 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q57 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q58 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	    q59 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[50] += q50*C_[1];
	I[51] += q51*C_[1];
	I[52] += q52*C_[1];
	I[53] += q53*C_[1];
	I[54] += q54*C_[1];
	I[55] += q55*C_[1];
	I[56] += q56*C_[1];
	I[57] += q57*C_[1];
	I[58] += q58*C_[1];
	I[59] += q59*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q61 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAy
	    q62 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAy
	    q63 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q64 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q65 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	    q66 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAy
	    q67 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q68 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAy
	    q69 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[1];
	I[61] += q61*C_[1];
	I[62] += q62*C_[1];
	I[63] += q63*C_[1];
	I[64] += q64*C_[1];
	I[65] += q65*C_[1];
	I[66] += q66*C_[1];
	I[67] += q67*C_[1];
	I[68] += q68*C_[1];
	I[69] += q69*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q71 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAy
	    q72 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAy
	    q73 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q74 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q75 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q76 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAy
	    q77 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q78 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAy
	    q79 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[1];
	I[71] += q71*C_[1];
	I[72] += q72*C_[1];
	I[73] += q73*C_[1];
	I[74] += q74*C_[1];
	I[75] += q75*C_[1];
	I[76] += q76*C_[1];
	I[77] += q77*C_[1];
	I[78] += q78*C_[1];
	I[79] += q79*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q81 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q82 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q83 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q84 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q85 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q86 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q87 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q88 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q89 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q91 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q92 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q93 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q94 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q95 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q96 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q97 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q98 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q99 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[90] += q90*C_[1];
	I[91] += q91*C_[1];
	I[92] += q92*C_[1];
	I[93] += q93*C_[1];
	I[94] += q94*C_[1];
	I[95] += q95*C_[1];
	I[96] += q96*C_[1];
	I[97] += q97*C_[1];
	I[98] += q98*C_[1];
	I[99] += q99*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q101 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0); // d/dAz
	    q102 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3); // d/dAz
	    q103 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q104 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q105 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q106 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1); // d/dAz
	    q107 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q108 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2); // d/dAz
	    q109 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[100] += q100*C_[1];
	I[101] += q101*C_[1];
	I[102] += q102*C_[1];
	I[103] += q103*C_[1];
	I[104] += q104*C_[1];
	I[105] += q105*C_[1];
	I[106] += q106*C_[1];
	I[107] += q107*C_[1];
	I[108] += q108*C_[1];
	I[109] += q109*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q111 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dAz
	    q112 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dAz
	    q113 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q114 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q115 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	    q116 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dAz
	    q117 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q118 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dAz
	    q119 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[110] += q110*C_[1];
	I[111] += q111*C_[1];
	I[112] += q112*C_[1];
	I[113] += q113*C_[1];
	I[114] += q114*C_[1];
	I[115] += q115*C_[1];
	I[116] += q116*C_[1];
	I[117] += q117*C_[1];
	I[118] += q118*C_[1];
	I[119] += q119*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q121 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,0); // d/dBx
	    q122 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,3); // d/dBx
	    q123 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q124 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q125 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q126 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBx
	    q127 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q128 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBx
	    q129 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q131 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,0); // d/dBx
	    q132 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,3); // d/dBx
	    q133 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q134 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q135 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q136 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBx
	    q137 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q138 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBx
	    q139 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[130] += q130*C_[1];
	I[131] += q131*C_[1];
	I[132] += q132*C_[1];
	I[133] += q133*C_[1];
	I[134] += q134*C_[1];
	I[135] += q135*C_[1];
	I[136] += q136*C_[1];
	I[137] += q137*C_[1];
	I[138] += q138*C_[1];
	I[139] += q139*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q141 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,0); // d/dBx
	    q142 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,3); // d/dBx
	    q143 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q144 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q145 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBx
	    q146 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1); // d/dBx
	    q147 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBx
	    q148 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2); // d/dBx
	    q149 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[140] += q140*C_[1];
	I[141] += q141*C_[1];
	I[142] += q142*C_[1];
	I[143] += q143*C_[1];
	I[144] += q144*C_[1];
	I[145] += q145*C_[1];
	I[146] += q146*C_[1];
	I[147] += q147*C_[1];
	I[148] += q148*C_[1];
	I[149] += q149*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q151 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,0); // d/dBx
	    q152 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,3); // d/dBx
	    q153 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q154 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q155 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBx
	    q156 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1); // d/dBx
	    q157 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBx
	    q158 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2); // d/dBx
	    q159 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[150] += q150*C_[1];
	I[151] += q151*C_[1];
	I[152] += q152*C_[1];
	I[153] += q153*C_[1];
	I[154] += q154*C_[1];
	I[155] += q155*C_[1];
	I[156] += q156*C_[1];
	I[157] += q157*C_[1];
	I[158] += q158*C_[1];
	I[159] += q159*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q161 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q162 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q163 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q164 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q165 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q166 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q167 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q168 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q169 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q171 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q172 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q173 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q174 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q175 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q176 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q177 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q178 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q179 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[170] += q170*C_[1];
	I[171] += q171*C_[1];
	I[172] += q172*C_[1];
	I[173] += q173*C_[1];
	I[174] += q174*C_[1];
	I[175] += q175*C_[1];
	I[176] += q176*C_[1];
	I[177] += q177*C_[1];
	I[178] += q178*C_[1];
	I[179] += q179*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q181 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBy
	    q182 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,3); // d/dBy
	    q183 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q184 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q185 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	    q186 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBy
	    q187 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q188 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBy
	    q189 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[180] += q180*C_[1];
	I[181] += q181*C_[1];
	I[182] += q182*C_[1];
	I[183] += q183*C_[1];
	I[184] += q184*C_[1];
	I[185] += q185*C_[1];
	I[186] += q186*C_[1];
	I[187] += q187*C_[1];
	I[188] += q188*C_[1];
	I[189] += q189*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q191 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBy
	    q192 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,3); // d/dBy
	    q193 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q194 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q195 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	    q196 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBy
	    q197 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q198 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBy
	    q199 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	}
	    
	//contraction coefficients
	I[190] += q190*C_[1];
	I[191] += q191*C_[1];
	I[192] += q192*C_[1];
	I[193] += q193*C_[1];
	I[194] += q194*C_[1];
	I[195] += q195*C_[1];
	I[196] += q196*C_[1];
	I[197] += q197*C_[1];
	I[198] += q198*C_[1];
	I[199] += q199*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q201 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q202 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q203 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q204 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q205 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q206 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q207 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q208 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	    q209 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q211 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q212 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q213 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q214 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q215 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q216 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q217 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q218 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	    q219 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[210] += q210*C_[1];
	I[211] += q211*C_[1];
	I[212] += q212*C_[1];
	I[213] += q213*C_[1];
	I[214] += q214*C_[1];
	I[215] += q215*C_[1];
	I[216] += q216*C_[1];
	I[217] += q217*C_[1];
	I[218] += q218*C_[1];
	I[219] += q219*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q221 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,1); // d/dBz
	    q222 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2);  // d/dBz
	    q223 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q224 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q225 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	    q226 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0);  // d/dBz
	    q227 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q228 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1);  // d/dBz
	    q229 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[220] += q220*C_[1];
	I[221] += q221*C_[1];
	I[222] += q222*C_[1];
	I[223] += q223*C_[1];
	I[224] += q224*C_[1];
	I[225] += q225*C_[1];
	I[226] += q226*C_[1];
	I[227] += q227*C_[1];
	I[228] += q228*C_[1];
	I[229] += q229*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q231 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,1); // d/dBz
	    q232 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2);  // d/dBz
	    q233 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q234 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q235 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q236 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0);  // d/dBz
	    q237 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q238 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1);  // d/dBz
	    q239 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[230] += q230*C_[1];
	I[231] += q231*C_[1];
	I[232] += q232*C_[1];
	I[233] += q233*C_[1];
	I[234] += q234*C_[1];
	I[235] += q235*C_[1];
	I[236] += q236*C_[1];
	I[237] += q237*C_[1];
	I[238] += q238*C_[1];
	I[239] += q239*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <sg| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::S,rysq::G> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::S,rysq::G> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 2;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,4); // d/dAx
	    q3 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,0); // d/dAx
	    q4 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,1); // d/dAx
	    q5 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,0); // d/dAx
	    q6 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,1); // d/dAx
	    q7 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,3); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,3); // d/dAx
	    q9 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,2); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,2); // d/dAx
	    q12 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1); // d/dAx
	    q13 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1); // d/dAx
	    q14 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2); // d/dAx
	    q15 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q16 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,0); // d/dAy
	    q17 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,4); // d/dAy
	    q18 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q19 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q21 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,1); // d/dAy
	    q22 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q23 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,3); // d/dAy
	    q24 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q25 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q26 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,2); // d/dAy
	    q27 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q28 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q29 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q31 += alpha*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,0); // d/dAz
	    q32 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,4); // d/dAz
	    q33 += alpha*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q34 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q35 += alpha*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q36 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,1); // d/dAz
	    q37 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q38 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,3); // d/dAz
	    q39 += alpha*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q41 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,2); // d/dAz
	    q42 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q43 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q44 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q45 += beta*Ix(a,0,5)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q46 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,0,0); // d/dBx
	    q47 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,4); // d/dBx
	    q48 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q49 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBx
	    q51 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBx
	    q52 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBx
	    q53 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBx
	    q54 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q55 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q56 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,2); // d/dBx
	    q57 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	    q58 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBx
	    q59 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q61 += beta*Ix(a,0,0)*Iy(a,0,5)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBy
	    q62 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,4); // d/dBy
	    q63 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q64 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q65 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q66 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBy
	    q67 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q68 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBy
	    q69 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q71 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBy
	    q72 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q73 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q74 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q75 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q76 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,1); // d/dBz
	    q77 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,5)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBz
	    q78 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q79 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q81 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBz
	    q82 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q83 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBz
	    q84 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q85 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q86 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBz
	    q87 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q88 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q89 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <pg| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::P,rysq::G> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::P,rysq::G> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,2,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,2,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAx
	    q3 += alpha*Ix(a,2,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,2,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAx
	    q7 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAx
	    q8 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAx
	    q9 += alpha*Ix(a,2,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q11 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAx
	    q12 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	    q13 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAx
	    q14 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAx
	    q15 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q16 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,0,0); // d/dAx
	    q17 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,4); // d/dAx
	    q18 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,0); // d/dAx
	    q19 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,0); // d/dAx
	    q21 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,1); // d/dAx
	    q22 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,3); // d/dAx
	    q23 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,3); // d/dAx
	    q24 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,0); // d/dAx
	    q25 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,2); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,2); // d/dAx
	    q27 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,1); // d/dAx
	    q28 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,1); // d/dAx
	    q29 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,2); // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q31 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,1,0); // d/dAx
	    q32 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,4); // d/dAx
	    q33 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,0); // d/dAx
	    q34 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,1); // d/dAx
	    q35 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,0); // d/dAx
	    q36 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,1); // d/dAx
	    q37 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,3); // d/dAx
	    q38 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,3); // d/dAx
	    q39 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,0); // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,2); // d/dAx
	    q41 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,2); // d/dAx
	    q42 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,1); // d/dAx
	    q43 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,1); // d/dAx
	    q44 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,2); // d/dAx
	    q45 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q46 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,0,0); // d/dAy
	    q47 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,4); // d/dAy
	    q48 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q49 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q51 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,1); // d/dAy
	    q52 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q53 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,3); // d/dAy
	    q54 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q55 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q56 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,2); // d/dAy
	    q57 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q58 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q59 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,0,4)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q61 += alpha*Ix(a,0,0)*Iy(a,2,4)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAy
	    q62 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAy
	    q63 += alpha*Ix(a,0,3)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q64 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q65 += alpha*Ix(a,0,1)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAy
	    q66 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAy
	    q67 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAy
	    q68 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAy
	    q69 += alpha*Ix(a,0,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q71 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAy
	    q72 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	    q73 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAy
	    q74 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAy
	    q75 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q76 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAy
	    q77 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAy
	    q78 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q79 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAy
	    q81 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAy
	    q82 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAy
	    q83 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAy
	    q84 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q85 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q86 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAy
	    q87 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	    q88 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAy
	    q89 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAy
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q91 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,1,0); // d/dAz
	    q92 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,4); // d/dAz
	    q93 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q94 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q95 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q96 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,1); // d/dAz
	    q97 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q98 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,3); // d/dAz
	    q99 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q101 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,2); // d/dAz
	    q102 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q103 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q104 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q105 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q106 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAz
	    q107 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAz
	    q108 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q109 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAz
	    q111 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAz
	    q112 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAz
	    q113 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAz
	    q114 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q115 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q116 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAz
	    q117 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	    q118 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAz
	    q119 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,0,4)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q121 += alpha*Ix(a,0,0)*Iy(a,0,4)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAz
	    q122 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAz
	    q123 += alpha*Ix(a,0,3)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q124 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q125 += alpha*Ix(a,0,1)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAz
	    q126 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAz
	    q127 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAz
	    q128 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAz
	    q129 += alpha*Ix(a,0,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q131 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAz
	    q132 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	    q133 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAz
	    q134 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAz
	    q135 += beta*Ix(a,1,5)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q136 += beta*Ix(a,1,1)*Iy(a,0,4)*Iz(a,0,0); // d/dBx
	    q137 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,4); // d/dBx
	    q138 += beta*Ix(a,1,4)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q139 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += beta*Ix(a,1,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBx
	    q141 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBx
	    q142 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBx
	    q143 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBx
	    q144 += beta*Ix(a,1,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q145 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q146 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,2); // d/dBx
	    q147 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	    q148 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBx
	    q149 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += beta*Ix(a,0,5)*Iy(a,1,0)*Iz(a,0,0)
                     - 4*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q151 += beta*Ix(a,0,1)*Iy(a,1,4)*Iz(a,0,0); // d/dBx
	    q152 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,4); // d/dBx
	    q153 += beta*Ix(a,0,4)*Iy(a,1,1)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q154 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,1)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q155 += beta*Ix(a,0,2)*Iy(a,1,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBx
	    q156 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,1); // d/dBx
	    q157 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBx
	    q158 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,3); // d/dBx
	    q159 += beta*Ix(a,0,3)*Iy(a,1,2)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,2)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBx
	    q161 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,2); // d/dBx
	    q162 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBx
	    q163 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBx
	    q164 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBx
	    q165 += beta*Ix(a,0,5)*Iy(a,0,0)*Iz(a,1,0)
                     - 4*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q166 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,1,0); // d/dBx
	    q167 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,4); // d/dBx
	    q168 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q169 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,1)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBx
	    q171 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,1); // d/dBx
	    q172 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBx
	    q173 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,3); // d/dBx
	    q174 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBx
	    q175 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,2)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBx
	    q176 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,2); // d/dBx
	    q177 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBx
	    q178 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBx
	    q179 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += beta*Ix(a,1,4)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q181 += beta*Ix(a,1,0)*Iy(a,0,5)*Iz(a,0,0)
                     - 4*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBy
	    q182 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,4); // d/dBy
	    q183 += beta*Ix(a,1,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q184 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q185 += beta*Ix(a,1,1)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q186 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,1)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBy
	    q187 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q188 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBy
	    q189 += beta*Ix(a,1,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q191 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBy
	    q192 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q193 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q194 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q195 += beta*Ix(a,0,4)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q196 += beta*Ix(a,0,0)*Iy(a,1,5)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBy
	    q197 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,4); // d/dBy
	    q198 += beta*Ix(a,0,3)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q199 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += beta*Ix(a,0,1)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBy
	    q201 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBy
	    q202 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,3); // d/dBy
	    q203 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBy
	    q204 += beta*Ix(a,0,2)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	    q205 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q206 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,2)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBy
	    q207 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	    q208 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBy
	    q209 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q211 += beta*Ix(a,0,0)*Iy(a,0,5)*Iz(a,1,0)
                     - 4*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBy
	    q212 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,4); // d/dBy
	    q213 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q214 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q215 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBy
	    q216 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,1)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBy
	    q217 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,3); // d/dBy
	    q218 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBy
	    q219 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];
	I[216] += q216*C_[0];
	I[217] += q217*C_[0];
	I[218] += q218*C_[0];
	I[219] += q219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q221 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,2)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBy
	    q222 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	    q223 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBy
	    q224 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBy
	    q225 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q226 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,1); // d/dBz
	    q227 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,5)
                     - 4*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBz
	    q228 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q229 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[0];
	I[222] += q222*C_[0];
	I[223] += q223*C_[0];
	I[224] += q224*C_[0];
	I[225] += q225*C_[0];
	I[226] += q226*C_[0];
	I[227] += q227*C_[0];
	I[228] += q228*C_[0];
	I[229] += q229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q231 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBz
	    q232 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q233 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBz
	    q234 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q235 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q236 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBz
	    q237 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q238 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q239 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[230] += q230*C_[0];
	I[231] += q231*C_[0];
	I[232] += q232*C_[0];
	I[233] += q233*C_[0];
	I[234] += q234*C_[0];
	I[235] += q235*C_[0];
	I[236] += q236*C_[0];
	I[237] += q237*C_[0];
	I[238] += q238*C_[0];
	I[239] += q239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q241 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,1); // d/dBz
	    q242 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,5)
                     - 4*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBz
	    q243 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q244 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q245 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,1); // d/dBz
	    q246 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBz
	    q247 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBz
	    q248 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBz
	    q249 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q251 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBz
	    q252 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	    q253 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBz
	    q254 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBz
	    q255 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q256 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,1); // d/dBz
	    q257 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,5)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBz
	    q258 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q259 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[0];
	I[256] += q256*C_[0];
	I[257] += q257*C_[0];
	I[258] += q258*C_[0];
	I[259] += q259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,1); // d/dBz
	    q261 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBz
	    q262 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBz
	    q263 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBz
	    q264 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q265 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q266 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBz
	    q267 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	    q268 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBz
	    q269 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[0];
	I[262] += q262*C_[0];
	I[263] += q263*C_[0];
	I[264] += q264*C_[0];
	I[265] += q265*C_[0];
	I[266] += q266*C_[0];
	I[267] += q267*C_[0];
	I[268] += q268*C_[0];
	I[269] += q269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <dg| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::D,rysq::G> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::D,rysq::G> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 4;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,3,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,3,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAx
	    q3 += alpha*Ix(a,3,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,3,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAx
	    q7 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAx
	    q8 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAx
	    q9 += alpha*Ix(a,3,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q11 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAx
	    q12 += alpha*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	    q13 += alpha*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAx
	    q14 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAx
	    q15 += alpha*Ix(a,1,4)*Iy(a,2,0)*Iz(a,0,0); // d/dAx
	    q16 += alpha*Ix(a,1,0)*Iy(a,2,4)*Iz(a,0,0); // d/dAx
	    q17 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,4); // d/dAx
	    q18 += alpha*Ix(a,1,3)*Iy(a,2,1)*Iz(a,0,0); // d/dAx
	    q19 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,1)*Iy(a,2,3)*Iz(a,0,0); // d/dAx
	    q21 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,1); // d/dAx
	    q22 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,3); // d/dAx
	    q23 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,3); // d/dAx
	    q24 += alpha*Ix(a,1,2)*Iy(a,2,2)*Iz(a,0,0); // d/dAx
	    q25 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,2); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,2); // d/dAx
	    q27 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,1); // d/dAx
	    q28 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,1); // d/dAx
	    q29 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,2); // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,2,0); // d/dAx
	    q31 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,2,0); // d/dAx
	    q32 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,4); // d/dAx
	    q33 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,2,0); // d/dAx
	    q34 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,1); // d/dAx
	    q35 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,2,0); // d/dAx
	    q36 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,1); // d/dAx
	    q37 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,3); // d/dAx
	    q38 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,3); // d/dAx
	    q39 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,2,0); // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,2); // d/dAx
	    q41 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,2); // d/dAx
	    q42 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,1); // d/dAx
	    q43 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,1); // d/dAx
	    q44 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,2); // d/dAx
	    q45 += alpha*Ix(a,2,4)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q46 += alpha*Ix(a,2,0)*Iy(a,1,4)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,0);  // d/dAx
	    q47 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,4)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,4);  // d/dAx
	    q48 += alpha*Ix(a,2,3)*Iy(a,1,1)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q49 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,1)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,2,1)*Iy(a,1,3)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,0);  // d/dAx
	    q51 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,1);  // d/dAx
	    q52 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,3)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,3);  // d/dAx
	    q53 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,3);  // d/dAx
	    q54 += alpha*Ix(a,2,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,0);  // d/dAx
	    q55 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,2);  // d/dAx
	    q56 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,2);  // d/dAx
	    q57 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1);  // d/dAx
	    q58 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1);  // d/dAx
	    q59 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,2,4)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q61 += alpha*Ix(a,2,0)*Iy(a,0,4)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,0);  // d/dAx
	    q62 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,4);  // d/dAx
	    q63 += alpha*Ix(a,2,3)*Iy(a,0,1)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q64 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q65 += alpha*Ix(a,2,1)*Iy(a,0,3)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,0);  // d/dAx
	    q66 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,1);  // d/dAx
	    q67 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,3);  // d/dAx
	    q68 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,3);  // d/dAx
	    q69 += alpha*Ix(a,2,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,2);  // d/dAx
	    q71 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,2);  // d/dAx
	    q72 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1);  // d/dAx
	    q73 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1);  // d/dAx
	    q74 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2);  // d/dAx
	    q75 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAx
	    q76 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAx
	    q77 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAx
	    q78 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAx
	    q79 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAx
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAx
	    q81 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAx
	    q82 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAx
	    q83 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAx
	    q84 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAx
	    q85 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAx
	    q86 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAx
	    q87 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAx
	    q88 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAx
	    q89 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAx
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,2,4)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q91 += alpha*Ix(a,2,0)*Iy(a,1,4)*Iz(a,0,0); // d/dAy
	    q92 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,4); // d/dAy
	    q93 += alpha*Ix(a,2,3)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q94 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q95 += alpha*Ix(a,2,1)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q96 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,1); // d/dAy
	    q97 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q98 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,3); // d/dAy
	    q99 += alpha*Ix(a,2,2)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q101 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,2); // d/dAy
	    q102 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q103 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q104 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	    q105 += alpha*Ix(a,0,4)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q106 += alpha*Ix(a,0,0)*Iy(a,3,4)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,0);  // d/dAy
	    q107 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,4)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,4);  // d/dAy
	    q108 += alpha*Ix(a,0,3)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q109 += alpha*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,0,1)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,0);  // d/dAy
	    q111 += alpha*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,1);  // d/dAy
	    q112 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,3);  // d/dAy
	    q113 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,3);  // d/dAy
	    q114 += alpha*Ix(a,0,2)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,0);  // d/dAy
	    q115 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,2);  // d/dAy
	    q116 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,2)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,2);  // d/dAy
	    q117 += alpha*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1);  // d/dAy
	    q118 += alpha*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1);  // d/dAy
	    q119 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,2)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q121 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,2,0); // d/dAy
	    q122 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,4); // d/dAy
	    q123 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q124 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q125 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,2,0); // d/dAy
	    q126 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,1); // d/dAy
	    q127 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,3); // d/dAy
	    q128 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,3); // d/dAy
	    q129 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,2,0); // d/dAy
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,2); // d/dAy
	    q131 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,2); // d/dAy
	    q132 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,1); // d/dAy
	    q133 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,1); // d/dAy
	    q134 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,2); // d/dAy
	    q135 += alpha*Ix(a,1,4)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q136 += alpha*Ix(a,1,0)*Iy(a,2,4)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAy
	    q137 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,4)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAy
	    q138 += alpha*Ix(a,1,3)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q139 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += alpha*Ix(a,1,1)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAy
	    q141 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAy
	    q142 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAy
	    q143 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAy
	    q144 += alpha*Ix(a,1,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	    q145 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q146 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAy
	    q147 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	    q148 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAy
	    q149 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q151 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAy
	    q152 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAy
	    q153 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q154 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q155 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAy
	    q156 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAy
	    q157 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAy
	    q158 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAy
	    q159 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q161 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAy
	    q162 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	    q163 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAy
	    q164 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAy
	    q165 += alpha*Ix(a,0,4)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q166 += alpha*Ix(a,0,0)*Iy(a,2,4)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,0);  // d/dAy
	    q167 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,4);  // d/dAy
	    q168 += alpha*Ix(a,0,3)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q169 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += alpha*Ix(a,0,1)*Iy(a,2,3)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,0);  // d/dAy
	    q171 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,1);  // d/dAy
	    q172 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,3);  // d/dAy
	    q173 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,3);  // d/dAy
	    q174 += alpha*Ix(a,0,2)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,0);  // d/dAy
	    q175 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,2);  // d/dAy
	    q176 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,2);  // d/dAy
	    q177 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1);  // d/dAy
	    q178 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1);  // d/dAy
	    q179 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += alpha*Ix(a,2,4)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q181 += alpha*Ix(a,2,0)*Iy(a,0,4)*Iz(a,1,0); // d/dAz
	    q182 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,4); // d/dAz
	    q183 += alpha*Ix(a,2,3)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q184 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q185 += alpha*Ix(a,2,1)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q186 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,1); // d/dAz
	    q187 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q188 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,3); // d/dAz
	    q189 += alpha*Ix(a,2,2)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q191 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,2); // d/dAz
	    q192 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q193 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q194 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q195 += alpha*Ix(a,0,4)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q196 += alpha*Ix(a,0,0)*Iy(a,2,4)*Iz(a,1,0); // d/dAz
	    q197 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,4); // d/dAz
	    q198 += alpha*Ix(a,0,3)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q199 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += alpha*Ix(a,0,1)*Iy(a,2,3)*Iz(a,1,0); // d/dAz
	    q201 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,1); // d/dAz
	    q202 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,3); // d/dAz
	    q203 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,3); // d/dAz
	    q204 += alpha*Ix(a,0,2)*Iy(a,2,2)*Iz(a,1,0); // d/dAz
	    q205 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,2); // d/dAz
	    q206 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,2); // d/dAz
	    q207 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,1); // d/dAz
	    q208 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,1); // d/dAz
	    q209 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += alpha*Ix(a,0,4)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q211 += alpha*Ix(a,0,0)*Iy(a,0,4)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,0);  // d/dAz
	    q212 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,4)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,4);  // d/dAz
	    q213 += alpha*Ix(a,0,3)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q214 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q215 += alpha*Ix(a,0,1)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,0);  // d/dAz
	    q216 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,1);  // d/dAz
	    q217 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,3);  // d/dAz
	    q218 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,3);  // d/dAz
	    q219 += alpha*Ix(a,0,2)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];
	I[216] += q216*C_[0];
	I[217] += q217*C_[0];
	I[218] += q218*C_[0];
	I[219] += q219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,2);  // d/dAz
	    q221 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,2);  // d/dAz
	    q222 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1);  // d/dAz
	    q223 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1);  // d/dAz
	    q224 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,2)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2);  // d/dAz
	    q225 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q226 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAz
	    q227 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAz
	    q228 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q229 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[0];
	I[222] += q222*C_[0];
	I[223] += q223*C_[0];
	I[224] += q224*C_[0];
	I[225] += q225*C_[0];
	I[226] += q226*C_[0];
	I[227] += q227*C_[0];
	I[228] += q228*C_[0];
	I[229] += q229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAz
	    q231 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAz
	    q232 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAz
	    q233 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAz
	    q234 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q235 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q236 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAz
	    q237 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	    q238 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAz
	    q239 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[230] += q230*C_[0];
	I[231] += q231*C_[0];
	I[232] += q232*C_[0];
	I[233] += q233*C_[0];
	I[234] += q234*C_[0];
	I[235] += q235*C_[0];
	I[236] += q236*C_[0];
	I[237] += q237*C_[0];
	I[238] += q238*C_[0];
	I[239] += q239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q241 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAz
	    q242 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,4)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAz
	    q243 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q244 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q245 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAz
	    q246 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAz
	    q247 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAz
	    q248 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAz
	    q249 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q251 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAz
	    q252 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	    q253 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAz
	    q254 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAz
	    q255 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q256 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,0);  // d/dAz
	    q257 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,4)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,4);  // d/dAz
	    q258 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q259 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[0];
	I[256] += q256*C_[0];
	I[257] += q257*C_[0];
	I[258] += q258*C_[0];
	I[259] += q259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,0);  // d/dAz
	    q261 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,1);  // d/dAz
	    q262 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,3)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,3);  // d/dAz
	    q263 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,3);  // d/dAz
	    q264 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,0);  // d/dAz
	    q265 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,2);  // d/dAz
	    q266 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,2);  // d/dAz
	    q267 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1);  // d/dAz
	    q268 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1);  // d/dAz
	    q269 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2);  // d/dAz
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[0];
	I[262] += q262*C_[0];
	I[263] += q263*C_[0];
	I[264] += q264*C_[0];
	I[265] += q265*C_[0];
	I[266] += q266*C_[0];
	I[267] += q267*C_[0];
	I[268] += q268*C_[0];
	I[269] += q269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q270 = 0.0;
	T q271 = 0.0;
	T q272 = 0.0;
	T q273 = 0.0;
	T q274 = 0.0;
	T q275 = 0.0;
	T q276 = 0.0;
	T q277 = 0.0;
	T q278 = 0.0;
	T q279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q270 += beta*Ix(a,2,5)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q271 += beta*Ix(a,2,1)*Iy(a,0,4)*Iz(a,0,0); // d/dBx
	    q272 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,4); // d/dBx
	    q273 += beta*Ix(a,2,4)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q274 += beta*Ix(a,2,4)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q275 += beta*Ix(a,2,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBx
	    q276 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBx
	    q277 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBx
	    q278 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBx
	    q279 += beta*Ix(a,2,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[270] += q270*C_[0];
	I[271] += q271*C_[0];
	I[272] += q272*C_[0];
	I[273] += q273*C_[0];
	I[274] += q274*C_[0];
	I[275] += q275*C_[0];
	I[276] += q276*C_[0];
	I[277] += q277*C_[0];
	I[278] += q278*C_[0];
	I[279] += q279*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q280 = 0.0;
	T q281 = 0.0;
	T q282 = 0.0;
	T q283 = 0.0;
	T q284 = 0.0;
	T q285 = 0.0;
	T q286 = 0.0;
	T q287 = 0.0;
	T q288 = 0.0;
	T q289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q280 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q281 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,2); // d/dBx
	    q282 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	    q283 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBx
	    q284 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBx
	    q285 += beta*Ix(a,0,5)*Iy(a,2,0)*Iz(a,0,0)
                     - 4*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q286 += beta*Ix(a,0,1)*Iy(a,2,4)*Iz(a,0,0); // d/dBx
	    q287 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,4); // d/dBx
	    q288 += beta*Ix(a,0,4)*Iy(a,2,1)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dBx
	    q289 += beta*Ix(a,0,4)*Iy(a,2,0)*Iz(a,0,1)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[280] += q280*C_[0];
	I[281] += q281*C_[0];
	I[282] += q282*C_[0];
	I[283] += q283*C_[0];
	I[284] += q284*C_[0];
	I[285] += q285*C_[0];
	I[286] += q286*C_[0];
	I[287] += q287*C_[0];
	I[288] += q288*C_[0];
	I[289] += q289*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q290 = 0.0;
	T q291 = 0.0;
	T q292 = 0.0;
	T q293 = 0.0;
	T q294 = 0.0;
	T q295 = 0.0;
	T q296 = 0.0;
	T q297 = 0.0;
	T q298 = 0.0;
	T q299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q290 += beta*Ix(a,0,2)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dBx
	    q291 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,0,1); // d/dBx
	    q292 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dBx
	    q293 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,3); // d/dBx
	    q294 += beta*Ix(a,0,3)*Iy(a,2,2)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dBx
	    q295 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,2)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dBx
	    q296 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,2); // d/dBx
	    q297 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dBx
	    q298 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dBx
	    q299 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[290] += q290*C_[0];
	I[291] += q291*C_[0];
	I[292] += q292*C_[0];
	I[293] += q293*C_[0];
	I[294] += q294*C_[0];
	I[295] += q295*C_[0];
	I[296] += q296*C_[0];
	I[297] += q297*C_[0];
	I[298] += q298*C_[0];
	I[299] += q299*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q300 = 0.0;
	T q301 = 0.0;
	T q302 = 0.0;
	T q303 = 0.0;
	T q304 = 0.0;
	T q305 = 0.0;
	T q306 = 0.0;
	T q307 = 0.0;
	T q308 = 0.0;
	T q309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q300 += beta*Ix(a,0,5)*Iy(a,0,0)*Iz(a,2,0)
                     - 4*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q301 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,2,0); // d/dBx
	    q302 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,4); // d/dBx
	    q303 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,2,0)
                     - 3*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dBx
	    q304 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,2,1)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dBx
	    q305 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dBx
	    q306 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,2,1); // d/dBx
	    q307 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dBx
	    q308 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,3); // d/dBx
	    q309 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[300] += q300*C_[0];
	I[301] += q301*C_[0];
	I[302] += q302*C_[0];
	I[303] += q303*C_[0];
	I[304] += q304*C_[0];
	I[305] += q305*C_[0];
	I[306] += q306*C_[0];
	I[307] += q307*C_[0];
	I[308] += q308*C_[0];
	I[309] += q309*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q310 = 0.0;
	T q311 = 0.0;
	T q312 = 0.0;
	T q313 = 0.0;
	T q314 = 0.0;
	T q315 = 0.0;
	T q316 = 0.0;
	T q317 = 0.0;
	T q318 = 0.0;
	T q319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q310 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,2)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dBx
	    q311 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,2); // d/dBx
	    q312 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dBx
	    q313 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dBx
	    q314 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dBx
	    q315 += beta*Ix(a,1,5)*Iy(a,1,0)*Iz(a,0,0)
                     - 4*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q316 += beta*Ix(a,1,1)*Iy(a,1,4)*Iz(a,0,0); // d/dBx
	    q317 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,4); // d/dBx
	    q318 += beta*Ix(a,1,4)*Iy(a,1,1)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q319 += beta*Ix(a,1,4)*Iy(a,1,0)*Iz(a,0,1)
                     - 3*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[310] += q310*C_[0];
	I[311] += q311*C_[0];
	I[312] += q312*C_[0];
	I[313] += q313*C_[0];
	I[314] += q314*C_[0];
	I[315] += q315*C_[0];
	I[316] += q316*C_[0];
	I[317] += q317*C_[0];
	I[318] += q318*C_[0];
	I[319] += q319*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q320 = 0.0;
	T q321 = 0.0;
	T q322 = 0.0;
	T q323 = 0.0;
	T q324 = 0.0;
	T q325 = 0.0;
	T q326 = 0.0;
	T q327 = 0.0;
	T q328 = 0.0;
	T q329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q320 += beta*Ix(a,1,2)*Iy(a,1,3)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBx
	    q321 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,1); // d/dBx
	    q322 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBx
	    q323 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,3); // d/dBx
	    q324 += beta*Ix(a,1,3)*Iy(a,1,2)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBx
	    q325 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBx
	    q326 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,2); // d/dBx
	    q327 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBx
	    q328 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBx
	    q329 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[320] += q320*C_[0];
	I[321] += q321*C_[0];
	I[322] += q322*C_[0];
	I[323] += q323*C_[0];
	I[324] += q324*C_[0];
	I[325] += q325*C_[0];
	I[326] += q326*C_[0];
	I[327] += q327*C_[0];
	I[328] += q328*C_[0];
	I[329] += q329*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q330 = 0.0;
	T q331 = 0.0;
	T q332 = 0.0;
	T q333 = 0.0;
	T q334 = 0.0;
	T q335 = 0.0;
	T q336 = 0.0;
	T q337 = 0.0;
	T q338 = 0.0;
	T q339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q330 += beta*Ix(a,1,5)*Iy(a,0,0)*Iz(a,1,0)
                     - 4*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q331 += beta*Ix(a,1,1)*Iy(a,0,4)*Iz(a,1,0); // d/dBx
	    q332 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,4); // d/dBx
	    q333 += beta*Ix(a,1,4)*Iy(a,0,1)*Iz(a,1,0)
                     - 3*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q334 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,1,1)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q335 += beta*Ix(a,1,2)*Iy(a,0,3)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBx
	    q336 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,1); // d/dBx
	    q337 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBx
	    q338 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,3); // d/dBx
	    q339 += beta*Ix(a,1,3)*Iy(a,0,2)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[330] += q330*C_[0];
	I[331] += q331*C_[0];
	I[332] += q332*C_[0];
	I[333] += q333*C_[0];
	I[334] += q334*C_[0];
	I[335] += q335*C_[0];
	I[336] += q336*C_[0];
	I[337] += q337*C_[0];
	I[338] += q338*C_[0];
	I[339] += q339*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q340 = 0.0;
	T q341 = 0.0;
	T q342 = 0.0;
	T q343 = 0.0;
	T q344 = 0.0;
	T q345 = 0.0;
	T q346 = 0.0;
	T q347 = 0.0;
	T q348 = 0.0;
	T q349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q340 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,2)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBx
	    q341 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,2); // d/dBx
	    q342 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBx
	    q343 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBx
	    q344 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBx
	    q345 += beta*Ix(a,0,5)*Iy(a,1,0)*Iz(a,1,0)
                     - 4*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q346 += beta*Ix(a,0,1)*Iy(a,1,4)*Iz(a,1,0); // d/dBx
	    q347 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,4); // d/dBx
	    q348 += beta*Ix(a,0,4)*Iy(a,1,1)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dBx
	    q349 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,1,1)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[340] += q340*C_[0];
	I[341] += q341*C_[0];
	I[342] += q342*C_[0];
	I[343] += q343*C_[0];
	I[344] += q344*C_[0];
	I[345] += q345*C_[0];
	I[346] += q346*C_[0];
	I[347] += q347*C_[0];
	I[348] += q348*C_[0];
	I[349] += q349*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q350 = 0.0;
	T q351 = 0.0;
	T q352 = 0.0;
	T q353 = 0.0;
	T q354 = 0.0;
	T q355 = 0.0;
	T q356 = 0.0;
	T q357 = 0.0;
	T q358 = 0.0;
	T q359 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q350 += beta*Ix(a,0,2)*Iy(a,1,3)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dBx
	    q351 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,1); // d/dBx
	    q352 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dBx
	    q353 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,3); // d/dBx
	    q354 += beta*Ix(a,0,3)*Iy(a,1,2)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dBx
	    q355 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,2)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dBx
	    q356 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,2); // d/dBx
	    q357 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dBx
	    q358 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dBx
	    q359 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[350] += q350*C_[0];
	I[351] += q351*C_[0];
	I[352] += q352*C_[0];
	I[353] += q353*C_[0];
	I[354] += q354*C_[0];
	I[355] += q355*C_[0];
	I[356] += q356*C_[0];
	I[357] += q357*C_[0];
	I[358] += q358*C_[0];
	I[359] += q359*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q360 = 0.0;
	T q361 = 0.0;
	T q362 = 0.0;
	T q363 = 0.0;
	T q364 = 0.0;
	T q365 = 0.0;
	T q366 = 0.0;
	T q367 = 0.0;
	T q368 = 0.0;
	T q369 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q360 += beta*Ix(a,2,4)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q361 += beta*Ix(a,2,0)*Iy(a,0,5)*Iz(a,0,0)
                     - 4*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBy
	    q362 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,4); // d/dBy
	    q363 += beta*Ix(a,2,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q364 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q365 += beta*Ix(a,2,1)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q366 += beta*Ix(a,2,0)*Iy(a,0,4)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBy
	    q367 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q368 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBy
	    q369 += beta*Ix(a,2,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[360] += q360*C_[0];
	I[361] += q361*C_[0];
	I[362] += q362*C_[0];
	I[363] += q363*C_[0];
	I[364] += q364*C_[0];
	I[365] += q365*C_[0];
	I[366] += q366*C_[0];
	I[367] += q367*C_[0];
	I[368] += q368*C_[0];
	I[369] += q369*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q370 = 0.0;
	T q371 = 0.0;
	T q372 = 0.0;
	T q373 = 0.0;
	T q374 = 0.0;
	T q375 = 0.0;
	T q376 = 0.0;
	T q377 = 0.0;
	T q378 = 0.0;
	T q379 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q370 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q371 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBy
	    q372 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q373 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q374 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q375 += beta*Ix(a,0,4)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q376 += beta*Ix(a,0,0)*Iy(a,2,5)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dBy
	    q377 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,4); // d/dBy
	    q378 += beta*Ix(a,0,3)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q379 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[370] += q370*C_[0];
	I[371] += q371*C_[0];
	I[372] += q372*C_[0];
	I[373] += q373*C_[0];
	I[374] += q374*C_[0];
	I[375] += q375*C_[0];
	I[376] += q376*C_[0];
	I[377] += q377*C_[0];
	I[378] += q378*C_[0];
	I[379] += q379*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q380 = 0.0;
	T q381 = 0.0;
	T q382 = 0.0;
	T q383 = 0.0;
	T q384 = 0.0;
	T q385 = 0.0;
	T q386 = 0.0;
	T q387 = 0.0;
	T q388 = 0.0;
	T q389 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q380 += beta*Ix(a,0,1)*Iy(a,2,4)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dBy
	    q381 += beta*Ix(a,0,0)*Iy(a,2,4)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dBy
	    q382 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,3); // d/dBy
	    q383 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dBy
	    q384 += beta*Ix(a,0,2)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dBy
	    q385 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,2); // d/dBy
	    q386 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,2)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dBy
	    q387 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dBy
	    q388 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dBy
	    q389 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[380] += q380*C_[0];
	I[381] += q381*C_[0];
	I[382] += q382*C_[0];
	I[383] += q383*C_[0];
	I[384] += q384*C_[0];
	I[385] += q385*C_[0];
	I[386] += q386*C_[0];
	I[387] += q387*C_[0];
	I[388] += q388*C_[0];
	I[389] += q389*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q390 = 0.0;
	T q391 = 0.0;
	T q392 = 0.0;
	T q393 = 0.0;
	T q394 = 0.0;
	T q395 = 0.0;
	T q396 = 0.0;
	T q397 = 0.0;
	T q398 = 0.0;
	T q399 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q390 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q391 += beta*Ix(a,0,0)*Iy(a,0,5)*Iz(a,2,0)
                     - 4*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dBy
	    q392 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,4); // d/dBy
	    q393 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q394 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q395 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,2,0)
                     - 3*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dBy
	    q396 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,2,1)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dBy
	    q397 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,3); // d/dBy
	    q398 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dBy
	    q399 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[390] += q390*C_[0];
	I[391] += q391*C_[0];
	I[392] += q392*C_[0];
	I[393] += q393*C_[0];
	I[394] += q394*C_[0];
	I[395] += q395*C_[0];
	I[396] += q396*C_[0];
	I[397] += q397*C_[0];
	I[398] += q398*C_[0];
	I[399] += q399*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q400 = 0.0;
	T q401 = 0.0;
	T q402 = 0.0;
	T q403 = 0.0;
	T q404 = 0.0;
	T q405 = 0.0;
	T q406 = 0.0;
	T q407 = 0.0;
	T q408 = 0.0;
	T q409 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q400 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,2); // d/dBy
	    q401 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,2)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dBy
	    q402 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dBy
	    q403 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dBy
	    q404 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dBy
	    q405 += beta*Ix(a,1,4)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q406 += beta*Ix(a,1,0)*Iy(a,1,5)*Iz(a,0,0)
                     - 4*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBy
	    q407 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,4); // d/dBy
	    q408 += beta*Ix(a,1,3)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q409 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[400] += q400*C_[0];
	I[401] += q401*C_[0];
	I[402] += q402*C_[0];
	I[403] += q403*C_[0];
	I[404] += q404*C_[0];
	I[405] += q405*C_[0];
	I[406] += q406*C_[0];
	I[407] += q407*C_[0];
	I[408] += q408*C_[0];
	I[409] += q409*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q410 = 0.0;
	T q411 = 0.0;
	T q412 = 0.0;
	T q413 = 0.0;
	T q414 = 0.0;
	T q415 = 0.0;
	T q416 = 0.0;
	T q417 = 0.0;
	T q418 = 0.0;
	T q419 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q410 += beta*Ix(a,1,1)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBy
	    q411 += beta*Ix(a,1,0)*Iy(a,1,4)*Iz(a,0,1)
                     - 3*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBy
	    q412 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,3); // d/dBy
	    q413 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBy
	    q414 += beta*Ix(a,1,2)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	    q415 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q416 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBy
	    q417 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	    q418 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBy
	    q419 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[410] += q410*C_[0];
	I[411] += q411*C_[0];
	I[412] += q412*C_[0];
	I[413] += q413*C_[0];
	I[414] += q414*C_[0];
	I[415] += q415*C_[0];
	I[416] += q416*C_[0];
	I[417] += q417*C_[0];
	I[418] += q418*C_[0];
	I[419] += q419*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q420 = 0.0;
	T q421 = 0.0;
	T q422 = 0.0;
	T q423 = 0.0;
	T q424 = 0.0;
	T q425 = 0.0;
	T q426 = 0.0;
	T q427 = 0.0;
	T q428 = 0.0;
	T q429 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q420 += beta*Ix(a,1,4)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q421 += beta*Ix(a,1,0)*Iy(a,0,5)*Iz(a,1,0)
                     - 4*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBy
	    q422 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,4); // d/dBy
	    q423 += beta*Ix(a,1,3)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q424 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q425 += beta*Ix(a,1,1)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBy
	    q426 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,1,1)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBy
	    q427 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,3); // d/dBy
	    q428 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBy
	    q429 += beta*Ix(a,1,2)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[420] += q420*C_[0];
	I[421] += q421*C_[0];
	I[422] += q422*C_[0];
	I[423] += q423*C_[0];
	I[424] += q424*C_[0];
	I[425] += q425*C_[0];
	I[426] += q426*C_[0];
	I[427] += q427*C_[0];
	I[428] += q428*C_[0];
	I[429] += q429*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q430 = 0.0;
	T q431 = 0.0;
	T q432 = 0.0;
	T q433 = 0.0;
	T q434 = 0.0;
	T q435 = 0.0;
	T q436 = 0.0;
	T q437 = 0.0;
	T q438 = 0.0;
	T q439 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q430 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q431 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBy
	    q432 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	    q433 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBy
	    q434 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBy
	    q435 += beta*Ix(a,0,4)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q436 += beta*Ix(a,0,0)*Iy(a,1,5)*Iz(a,1,0)
                     - 4*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dBy
	    q437 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,4); // d/dBy
	    q438 += beta*Ix(a,0,3)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q439 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[430] += q430*C_[0];
	I[431] += q431*C_[0];
	I[432] += q432*C_[0];
	I[433] += q433*C_[0];
	I[434] += q434*C_[0];
	I[435] += q435*C_[0];
	I[436] += q436*C_[0];
	I[437] += q437*C_[0];
	I[438] += q438*C_[0];
	I[439] += q439*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q440 = 0.0;
	T q441 = 0.0;
	T q442 = 0.0;
	T q443 = 0.0;
	T q444 = 0.0;
	T q445 = 0.0;
	T q446 = 0.0;
	T q447 = 0.0;
	T q448 = 0.0;
	T q449 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q440 += beta*Ix(a,0,1)*Iy(a,1,4)*Iz(a,1,0)
                     - 3*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dBy
	    q441 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,1,1)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dBy
	    q442 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,3); // d/dBy
	    q443 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dBy
	    q444 += beta*Ix(a,0,2)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dBy
	    q445 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,2); // d/dBy
	    q446 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,2)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dBy
	    q447 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dBy
	    q448 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dBy
	    q449 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[440] += q440*C_[0];
	I[441] += q441*C_[0];
	I[442] += q442*C_[0];
	I[443] += q443*C_[0];
	I[444] += q444*C_[0];
	I[445] += q445*C_[0];
	I[446] += q446*C_[0];
	I[447] += q447*C_[0];
	I[448] += q448*C_[0];
	I[449] += q449*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q450 = 0.0;
	T q451 = 0.0;
	T q452 = 0.0;
	T q453 = 0.0;
	T q454 = 0.0;
	T q455 = 0.0;
	T q456 = 0.0;
	T q457 = 0.0;
	T q458 = 0.0;
	T q459 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q450 += beta*Ix(a,2,4)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q451 += beta*Ix(a,2,0)*Iy(a,0,4)*Iz(a,0,1); // d/dBz
	    q452 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,5)
                     - 4*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBz
	    q453 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q454 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q455 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q456 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBz
	    q457 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q458 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,4)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBz
	    q459 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[450] += q450*C_[0];
	I[451] += q451*C_[0];
	I[452] += q452*C_[0];
	I[453] += q453*C_[0];
	I[454] += q454*C_[0];
	I[455] += q455*C_[0];
	I[456] += q456*C_[0];
	I[457] += q457*C_[0];
	I[458] += q458*C_[0];
	I[459] += q459*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q460 = 0.0;
	T q461 = 0.0;
	T q462 = 0.0;
	T q463 = 0.0;
	T q464 = 0.0;
	T q465 = 0.0;
	T q466 = 0.0;
	T q467 = 0.0;
	T q468 = 0.0;
	T q469 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q460 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q461 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBz
	    q462 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q463 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q464 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	    q465 += beta*Ix(a,0,4)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q466 += beta*Ix(a,0,0)*Iy(a,2,4)*Iz(a,0,1); // d/dBz
	    q467 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,5)
                     - 4*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dBz
	    q468 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q469 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[460] += q460*C_[0];
	I[461] += q461*C_[0];
	I[462] += q462*C_[0];
	I[463] += q463*C_[0];
	I[464] += q464*C_[0];
	I[465] += q465*C_[0];
	I[466] += q466*C_[0];
	I[467] += q467*C_[0];
	I[468] += q468*C_[0];
	I[469] += q469*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q470 = 0.0;
	T q471 = 0.0;
	T q472 = 0.0;
	T q473 = 0.0;
	T q474 = 0.0;
	T q475 = 0.0;
	T q476 = 0.0;
	T q477 = 0.0;
	T q478 = 0.0;
	T q479 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q470 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,0,1); // d/dBz
	    q471 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dBz
	    q472 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,4)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dBz
	    q473 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dBz
	    q474 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,0,1); // d/dBz
	    q475 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dBz
	    q476 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dBz
	    q477 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dBz
	    q478 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dBz
	    q479 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[470] += q470*C_[0];
	I[471] += q471*C_[0];
	I[472] += q472*C_[0];
	I[473] += q473*C_[0];
	I[474] += q474*C_[0];
	I[475] += q475*C_[0];
	I[476] += q476*C_[0];
	I[477] += q477*C_[0];
	I[478] += q478*C_[0];
	I[479] += q479*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q480 = 0.0;
	T q481 = 0.0;
	T q482 = 0.0;
	T q483 = 0.0;
	T q484 = 0.0;
	T q485 = 0.0;
	T q486 = 0.0;
	T q487 = 0.0;
	T q488 = 0.0;
	T q489 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q480 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q481 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,2,1); // d/dBz
	    q482 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,5)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dBz
	    q483 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q484 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q485 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,2,1); // d/dBz
	    q486 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dBz
	    q487 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,4)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dBz
	    q488 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,4)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dBz
	    q489 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,2,1); // d/dBz
	}
	    
	//contraction coefficients
	I[480] += q480*C_[0];
	I[481] += q481*C_[0];
	I[482] += q482*C_[0];
	I[483] += q483*C_[0];
	I[484] += q484*C_[0];
	I[485] += q485*C_[0];
	I[486] += q486*C_[0];
	I[487] += q487*C_[0];
	I[488] += q488*C_[0];
	I[489] += q489*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q490 = 0.0;
	T q491 = 0.0;
	T q492 = 0.0;
	T q493 = 0.0;
	T q494 = 0.0;
	T q495 = 0.0;
	T q496 = 0.0;
	T q497 = 0.0;
	T q498 = 0.0;
	T q499 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q490 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dBz
	    q491 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dBz
	    q492 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dBz
	    q493 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dBz
	    q494 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,3)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dBz
	    q495 += beta*Ix(a,1,4)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q496 += beta*Ix(a,1,0)*Iy(a,1,4)*Iz(a,0,1); // d/dBz
	    q497 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,5)
                     - 4*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBz
	    q498 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q499 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[490] += q490*C_[0];
	I[491] += q491*C_[0];
	I[492] += q492*C_[0];
	I[493] += q493*C_[0];
	I[494] += q494*C_[0];
	I[495] += q495*C_[0];
	I[496] += q496*C_[0];
	I[497] += q497*C_[0];
	I[498] += q498*C_[0];
	I[499] += q499*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q500 = 0.0;
	T q501 = 0.0;
	T q502 = 0.0;
	T q503 = 0.0;
	T q504 = 0.0;
	T q505 = 0.0;
	T q506 = 0.0;
	T q507 = 0.0;
	T q508 = 0.0;
	T q509 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q500 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,1); // d/dBz
	    q501 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBz
	    q502 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBz
	    q503 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBz
	    q504 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	    q505 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q506 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBz
	    q507 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	    q508 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBz
	    q509 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[500] += q500*C_[0];
	I[501] += q501*C_[0];
	I[502] += q502*C_[0];
	I[503] += q503*C_[0];
	I[504] += q504*C_[0];
	I[505] += q505*C_[0];
	I[506] += q506*C_[0];
	I[507] += q507*C_[0];
	I[508] += q508*C_[0];
	I[509] += q509*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q510 = 0.0;
	T q511 = 0.0;
	T q512 = 0.0;
	T q513 = 0.0;
	T q514 = 0.0;
	T q515 = 0.0;
	T q516 = 0.0;
	T q517 = 0.0;
	T q518 = 0.0;
	T q519 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q510 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q511 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,1,1); // d/dBz
	    q512 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,5)
                     - 4*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBz
	    q513 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q514 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q515 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,1); // d/dBz
	    q516 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBz
	    q517 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBz
	    q518 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,4)
                     - 3*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBz
	    q519 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[510] += q510*C_[0];
	I[511] += q511*C_[0];
	I[512] += q512*C_[0];
	I[513] += q513*C_[0];
	I[514] += q514*C_[0];
	I[515] += q515*C_[0];
	I[516] += q516*C_[0];
	I[517] += q517*C_[0];
	I[518] += q518*C_[0];
	I[519] += q519*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q520 = 0.0;
	T q521 = 0.0;
	T q522 = 0.0;
	T q523 = 0.0;
	T q524 = 0.0;
	T q525 = 0.0;
	T q526 = 0.0;
	T q527 = 0.0;
	T q528 = 0.0;
	T q529 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q520 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q521 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBz
	    q522 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	    q523 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBz
	    q524 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBz
	    q525 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q526 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,1,1); // d/dBz
	    q527 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,5)
                     - 4*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dBz
	    q528 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q529 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[520] += q520*C_[0];
	I[521] += q521*C_[0];
	I[522] += q522*C_[0];
	I[523] += q523*C_[0];
	I[524] += q524*C_[0];
	I[525] += q525*C_[0];
	I[526] += q526*C_[0];
	I[527] += q527*C_[0];
	I[528] += q528*C_[0];
	I[529] += q529*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q530 = 0.0;
	T q531 = 0.0;
	T q532 = 0.0;
	T q533 = 0.0;
	T q534 = 0.0;
	T q535 = 0.0;
	T q536 = 0.0;
	T q537 = 0.0;
	T q538 = 0.0;
	T q539 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q530 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,1); // d/dBz
	    q531 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dBz
	    q532 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,4)
                     - 3*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dBz
	    q533 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dBz
	    q534 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,1); // d/dBz
	    q535 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dBz
	    q536 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dBz
	    q537 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dBz
	    q538 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dBz
	    q539 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[530] += q530*C_[0];
	I[531] += q531*C_[0];
	I[532] += q532*C_[0];
	I[533] += q533*C_[0];
	I[534] += q534*C_[0];
	I[535] += q535*C_[0];
	I[536] += q536*C_[0];
	I[537] += q537*C_[0];
	I[538] += q538*C_[0];
	I[539] += q539*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <fg| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::F,rysq::G> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::F,rysq::G> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 5;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,4,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,2,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,4,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAx
	    q3 += alpha*Ix(a,4,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,2,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,4,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,4,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,4,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAx
	    q7 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAx
	    q8 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAx
	    q9 += alpha*Ix(a,4,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q11 += alpha*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAx
	    q12 += alpha*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 3*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	    q13 += alpha*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 3*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAx
	    q14 += alpha*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 3*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAx
	    q15 += alpha*Ix(a,1,4)*Iy(a,3,0)*Iz(a,0,0); // d/dAx
	    q16 += alpha*Ix(a,1,0)*Iy(a,3,4)*Iz(a,0,0); // d/dAx
	    q17 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,4); // d/dAx
	    q18 += alpha*Ix(a,1,3)*Iy(a,3,1)*Iz(a,0,0); // d/dAx
	    q19 += alpha*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,1)*Iy(a,3,3)*Iz(a,0,0); // d/dAx
	    q21 += alpha*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,1); // d/dAx
	    q22 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,3); // d/dAx
	    q23 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,3); // d/dAx
	    q24 += alpha*Ix(a,1,2)*Iy(a,3,2)*Iz(a,0,0); // d/dAx
	    q25 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,2); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,2); // d/dAx
	    q27 += alpha*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,1); // d/dAx
	    q28 += alpha*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,1); // d/dAx
	    q29 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,2); // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,3,0); // d/dAx
	    q31 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,3,0); // d/dAx
	    q32 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,4); // d/dAx
	    q33 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,3,0); // d/dAx
	    q34 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,1); // d/dAx
	    q35 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,3,0); // d/dAx
	    q36 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,1); // d/dAx
	    q37 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,3); // d/dAx
	    q38 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,3); // d/dAx
	    q39 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,3,0); // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,2); // d/dAx
	    q41 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,2); // d/dAx
	    q42 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,1); // d/dAx
	    q43 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,1); // d/dAx
	    q44 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,2); // d/dAx
	    q45 += alpha*Ix(a,3,4)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,1,4)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q46 += alpha*Ix(a,3,0)*Iy(a,1,4)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,4)*Iz(a,0,0);  // d/dAx
	    q47 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,4)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,4);  // d/dAx
	    q48 += alpha*Ix(a,3,3)*Iy(a,1,1)*Iz(a,0,0)
                     - 2*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q49 += alpha*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,1)
                     - 2*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,3,1)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,0);  // d/dAx
	    q51 += alpha*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,1);  // d/dAx
	    q52 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,3);  // d/dAx
	    q53 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,3);  // d/dAx
	    q54 += alpha*Ix(a,3,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,0);  // d/dAx
	    q55 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,2);  // d/dAx
	    q56 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,2);  // d/dAx
	    q57 += alpha*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,1)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,1);  // d/dAx
	    q58 += alpha*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,1);  // d/dAx
	    q59 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,3,4)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,1,4)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q61 += alpha*Ix(a,3,0)*Iy(a,0,4)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,0,4)*Iz(a,1,0);  // d/dAx
	    q62 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,4)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,4);  // d/dAx
	    q63 += alpha*Ix(a,3,3)*Iy(a,0,1)*Iz(a,1,0)
                     - 2*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q64 += alpha*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,1)
                     - 2*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q65 += alpha*Ix(a,3,1)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,0);  // d/dAx
	    q66 += alpha*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,1);  // d/dAx
	    q67 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,3);  // d/dAx
	    q68 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,3);  // d/dAx
	    q69 += alpha*Ix(a,3,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,2);  // d/dAx
	    q71 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,2);  // d/dAx
	    q72 += alpha*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,1)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,1);  // d/dAx
	    q73 += alpha*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,1);  // d/dAx
	    q74 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,2)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,2);  // d/dAx
	    q75 += alpha*Ix(a,2,4)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,4)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q76 += alpha*Ix(a,2,0)*Iy(a,2,4)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,4)*Iz(a,0,0);  // d/dAx
	    q77 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,4)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,4);  // d/dAx
	    q78 += alpha*Ix(a,2,3)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,2,1)*Iz(a,0,0);  // d/dAx
	    q79 += alpha*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,2,1)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,2,3)*Iz(a,0,0);  // d/dAx
	    q81 += alpha*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,1);  // d/dAx
	    q82 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,3);  // d/dAx
	    q83 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,3);  // d/dAx
	    q84 += alpha*Ix(a,2,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,2,2)*Iz(a,0,0);  // d/dAx
	    q85 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,2);  // d/dAx
	    q86 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,2);  // d/dAx
	    q87 += alpha*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,1);  // d/dAx
	    q88 += alpha*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,1);  // d/dAx
	    q89 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,1,4)*Iy(a,2,0)*Iz(a,1,0); // d/dAx
	    q91 += alpha*Ix(a,1,0)*Iy(a,2,4)*Iz(a,1,0); // d/dAx
	    q92 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,4); // d/dAx
	    q93 += alpha*Ix(a,1,3)*Iy(a,2,1)*Iz(a,1,0); // d/dAx
	    q94 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,1); // d/dAx
	    q95 += alpha*Ix(a,1,1)*Iy(a,2,3)*Iz(a,1,0); // d/dAx
	    q96 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,1); // d/dAx
	    q97 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,3); // d/dAx
	    q98 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,3); // d/dAx
	    q99 += alpha*Ix(a,1,2)*Iy(a,2,2)*Iz(a,1,0); // d/dAx
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,2); // d/dAx
	    q101 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,2); // d/dAx
	    q102 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,1); // d/dAx
	    q103 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,1); // d/dAx
	    q104 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,2); // d/dAx
	    q105 += alpha*Ix(a,2,4)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q106 += alpha*Ix(a,2,0)*Iy(a,0,4)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,2,0);  // d/dAx
	    q107 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,4);  // d/dAx
	    q108 += alpha*Ix(a,2,3)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,2,0);  // d/dAx
	    q109 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,2,1)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,2,0);  // d/dAx
	    q111 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,1);  // d/dAx
	    q112 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,3);  // d/dAx
	    q113 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,3);  // d/dAx
	    q114 += alpha*Ix(a,2,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,2,0);  // d/dAx
	    q115 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,2);  // d/dAx
	    q116 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,2);  // d/dAx
	    q117 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,1);  // d/dAx
	    q118 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,1);  // d/dAx
	    q119 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,2,0); // d/dAx
	    q121 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,2,0); // d/dAx
	    q122 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,4); // d/dAx
	    q123 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,2,0); // d/dAx
	    q124 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,1); // d/dAx
	    q125 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,2,0); // d/dAx
	    q126 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,1); // d/dAx
	    q127 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,3); // d/dAx
	    q128 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,3); // d/dAx
	    q129 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,2,0); // d/dAx
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,2); // d/dAx
	    q131 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,2); // d/dAx
	    q132 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,1); // d/dAx
	    q133 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,1); // d/dAx
	    q134 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,2); // d/dAx
	    q135 += alpha*Ix(a,2,4)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,0,4)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q136 += alpha*Ix(a,2,0)*Iy(a,1,4)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,4)*Iz(a,1,0);  // d/dAx
	    q137 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,4)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,4);  // d/dAx
	    q138 += alpha*Ix(a,2,3)*Iy(a,1,1)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,0);  // d/dAx
	    q139 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,1)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += alpha*Ix(a,2,1)*Iy(a,1,3)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,0);  // d/dAx
	    q141 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,1);  // d/dAx
	    q142 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,3)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,3);  // d/dAx
	    q143 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,3);  // d/dAx
	    q144 += alpha*Ix(a,2,2)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,0);  // d/dAx
	    q145 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,2);  // d/dAx
	    q146 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,2);  // d/dAx
	    q147 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,1);  // d/dAx
	    q148 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,1);  // d/dAx
	    q149 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += alpha*Ix(a,3,4)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q151 += alpha*Ix(a,3,0)*Iy(a,1,4)*Iz(a,0,0); // d/dAy
	    q152 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,4); // d/dAy
	    q153 += alpha*Ix(a,3,3)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q154 += alpha*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q155 += alpha*Ix(a,3,1)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q156 += alpha*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,1); // d/dAy
	    q157 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q158 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,3); // d/dAy
	    q159 += alpha*Ix(a,3,2)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q161 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,2); // d/dAy
	    q162 += alpha*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q163 += alpha*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q164 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	    q165 += alpha*Ix(a,0,4)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,0,4)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q166 += alpha*Ix(a,0,0)*Iy(a,4,4)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,2,4)*Iz(a,0,0);  // d/dAy
	    q167 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,4);  // d/dAy
	    q168 += alpha*Ix(a,0,3)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,0,3)*Iy(a,2,1)*Iz(a,0,0);  // d/dAy
	    q169 += alpha*Ix(a,0,3)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += alpha*Ix(a,0,1)*Iy(a,4,3)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,2,3)*Iz(a,0,0);  // d/dAy
	    q171 += alpha*Ix(a,0,0)*Iy(a,4,3)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,1);  // d/dAy
	    q172 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,3)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,3);  // d/dAy
	    q173 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,3)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,3);  // d/dAy
	    q174 += alpha*Ix(a,0,2)*Iy(a,4,2)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,2,2)*Iz(a,0,0);  // d/dAy
	    q175 += alpha*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,2)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,2);  // d/dAy
	    q176 += alpha*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,2)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,2);  // d/dAy
	    q177 += alpha*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,1)
                     - 3*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,1);  // d/dAy
	    q178 += alpha*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,1)
                     - 3*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,1);  // d/dAy
	    q179 += alpha*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,2)
                     - 3*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q181 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,3,0); // d/dAy
	    q182 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,4); // d/dAy
	    q183 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,3,0); // d/dAy
	    q184 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,1); // d/dAy
	    q185 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,3,0); // d/dAy
	    q186 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,1); // d/dAy
	    q187 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,3); // d/dAy
	    q188 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,3); // d/dAy
	    q189 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,3,0); // d/dAy
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,2); // d/dAy
	    q191 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,2); // d/dAy
	    q192 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,1); // d/dAy
	    q193 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,1); // d/dAy
	    q194 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,2); // d/dAy
	    q195 += alpha*Ix(a,2,4)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,2,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q196 += alpha*Ix(a,2,0)*Iy(a,2,4)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAy
	    q197 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,4)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAy
	    q198 += alpha*Ix(a,2,3)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,2,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q199 += alpha*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += alpha*Ix(a,2,1)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,2,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAy
	    q201 += alpha*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAy
	    q202 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAy
	    q203 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,3)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAy
	    q204 += alpha*Ix(a,2,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,2,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	    q205 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q206 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAy
	    q207 += alpha*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	    q208 += alpha*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAy
	    q209 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += alpha*Ix(a,2,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q211 += alpha*Ix(a,2,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAy
	    q212 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAy
	    q213 += alpha*Ix(a,2,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q214 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q215 += alpha*Ix(a,2,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAy
	    q216 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAy
	    q217 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAy
	    q218 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAy
	    q219 += alpha*Ix(a,2,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];
	I[216] += q216*C_[0];
	I[217] += q217*C_[0];
	I[218] += q218*C_[0];
	I[219] += q219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q221 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAy
	    q222 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	    q223 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAy
	    q224 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAy
	    q225 += alpha*Ix(a,1,4)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,1,4)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q226 += alpha*Ix(a,1,0)*Iy(a,3,4)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,4)*Iz(a,0,0);  // d/dAy
	    q227 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,4)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,4);  // d/dAy
	    q228 += alpha*Ix(a,1,3)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q229 += alpha*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[0];
	I[222] += q222*C_[0];
	I[223] += q223*C_[0];
	I[224] += q224*C_[0];
	I[225] += q225*C_[0];
	I[226] += q226*C_[0];
	I[227] += q227*C_[0];
	I[228] += q228*C_[0];
	I[229] += q229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += alpha*Ix(a,1,1)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,0);  // d/dAy
	    q231 += alpha*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,1);  // d/dAy
	    q232 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,3);  // d/dAy
	    q233 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,3);  // d/dAy
	    q234 += alpha*Ix(a,1,2)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,0);  // d/dAy
	    q235 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,2);  // d/dAy
	    q236 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,2);  // d/dAy
	    q237 += alpha*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,1);  // d/dAy
	    q238 += alpha*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,1);  // d/dAy
	    q239 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[230] += q230*C_[0];
	I[231] += q231*C_[0];
	I[232] += q232*C_[0];
	I[233] += q233*C_[0];
	I[234] += q234*C_[0];
	I[235] += q235*C_[0];
	I[236] += q236*C_[0];
	I[237] += q237*C_[0];
	I[238] += q238*C_[0];
	I[239] += q239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += alpha*Ix(a,0,4)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,0,4)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q241 += alpha*Ix(a,0,0)*Iy(a,3,4)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,1,4)*Iz(a,1,0);  // d/dAy
	    q242 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,4)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,4);  // d/dAy
	    q243 += alpha*Ix(a,0,3)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,0);  // d/dAy
	    q244 += alpha*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,1);  // d/dAy
	    q245 += alpha*Ix(a,0,1)*Iy(a,3,3)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,0);  // d/dAy
	    q246 += alpha*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,1)
                     - 2*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,1);  // d/dAy
	    q247 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,3);  // d/dAy
	    q248 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,3);  // d/dAy
	    q249 += alpha*Ix(a,0,2)*Iy(a,3,2)*Iz(a,1,0)
                     - 2*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,2)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,2);  // d/dAy
	    q251 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,2)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,2);  // d/dAy
	    q252 += alpha*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,1)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,1);  // d/dAy
	    q253 += alpha*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,1);  // d/dAy
	    q254 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,2)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,2);  // d/dAy
	    q255 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q256 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,2,0); // d/dAy
	    q257 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,4); // d/dAy
	    q258 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q259 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[0];
	I[256] += q256*C_[0];
	I[257] += q257*C_[0];
	I[258] += q258*C_[0];
	I[259] += q259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,2,0); // d/dAy
	    q261 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,1); // d/dAy
	    q262 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,3); // d/dAy
	    q263 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,3); // d/dAy
	    q264 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,2,0); // d/dAy
	    q265 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,2); // d/dAy
	    q266 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,2); // d/dAy
	    q267 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,1); // d/dAy
	    q268 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,1); // d/dAy
	    q269 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,2); // d/dAy
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[0];
	I[262] += q262*C_[0];
	I[263] += q263*C_[0];
	I[264] += q264*C_[0];
	I[265] += q265*C_[0];
	I[266] += q266*C_[0];
	I[267] += q267*C_[0];
	I[268] += q268*C_[0];
	I[269] += q269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q270 = 0.0;
	T q271 = 0.0;
	T q272 = 0.0;
	T q273 = 0.0;
	T q274 = 0.0;
	T q275 = 0.0;
	T q276 = 0.0;
	T q277 = 0.0;
	T q278 = 0.0;
	T q279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q270 += alpha*Ix(a,0,4)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q271 += alpha*Ix(a,0,0)*Iy(a,2,4)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,2,0);  // d/dAy
	    q272 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,4);  // d/dAy
	    q273 += alpha*Ix(a,0,3)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,2,0);  // d/dAy
	    q274 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,1);  // d/dAy
	    q275 += alpha*Ix(a,0,1)*Iy(a,2,3)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,2,0);  // d/dAy
	    q276 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,1);  // d/dAy
	    q277 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,3);  // d/dAy
	    q278 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,3);  // d/dAy
	    q279 += alpha*Ix(a,0,2)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,2,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[270] += q270*C_[0];
	I[271] += q271*C_[0];
	I[272] += q272*C_[0];
	I[273] += q273*C_[0];
	I[274] += q274*C_[0];
	I[275] += q275*C_[0];
	I[276] += q276*C_[0];
	I[277] += q277*C_[0];
	I[278] += q278*C_[0];
	I[279] += q279*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q280 = 0.0;
	T q281 = 0.0;
	T q282 = 0.0;
	T q283 = 0.0;
	T q284 = 0.0;
	T q285 = 0.0;
	T q286 = 0.0;
	T q287 = 0.0;
	T q288 = 0.0;
	T q289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q280 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,2);  // d/dAy
	    q281 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,2);  // d/dAy
	    q282 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,1);  // d/dAy
	    q283 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,1);  // d/dAy
	    q284 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,2);  // d/dAy
	    q285 += alpha*Ix(a,1,4)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,1,4)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q286 += alpha*Ix(a,1,0)*Iy(a,2,4)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,4)*Iz(a,1,0);  // d/dAy
	    q287 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,4)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,4);  // d/dAy
	    q288 += alpha*Ix(a,1,3)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q289 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[280] += q280*C_[0];
	I[281] += q281*C_[0];
	I[282] += q282*C_[0];
	I[283] += q283*C_[0];
	I[284] += q284*C_[0];
	I[285] += q285*C_[0];
	I[286] += q286*C_[0];
	I[287] += q287*C_[0];
	I[288] += q288*C_[0];
	I[289] += q289*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q290 = 0.0;
	T q291 = 0.0;
	T q292 = 0.0;
	T q293 = 0.0;
	T q294 = 0.0;
	T q295 = 0.0;
	T q296 = 0.0;
	T q297 = 0.0;
	T q298 = 0.0;
	T q299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q290 += alpha*Ix(a,1,1)*Iy(a,2,3)*Iz(a,1,0)
                     - 1*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,0);  // d/dAy
	    q291 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,1);  // d/dAy
	    q292 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,3)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,3);  // d/dAy
	    q293 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,3)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,3);  // d/dAy
	    q294 += alpha*Ix(a,1,2)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,0);  // d/dAy
	    q295 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,2);  // d/dAy
	    q296 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,2);  // d/dAy
	    q297 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,1);  // d/dAy
	    q298 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,1);  // d/dAy
	    q299 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[290] += q290*C_[0];
	I[291] += q291*C_[0];
	I[292] += q292*C_[0];
	I[293] += q293*C_[0];
	I[294] += q294*C_[0];
	I[295] += q295*C_[0];
	I[296] += q296*C_[0];
	I[297] += q297*C_[0];
	I[298] += q298*C_[0];
	I[299] += q299*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q300 = 0.0;
	T q301 = 0.0;
	T q302 = 0.0;
	T q303 = 0.0;
	T q304 = 0.0;
	T q305 = 0.0;
	T q306 = 0.0;
	T q307 = 0.0;
	T q308 = 0.0;
	T q309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q300 += alpha*Ix(a,3,4)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q301 += alpha*Ix(a,3,0)*Iy(a,0,4)*Iz(a,1,0); // d/dAz
	    q302 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,4); // d/dAz
	    q303 += alpha*Ix(a,3,3)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q304 += alpha*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q305 += alpha*Ix(a,3,1)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q306 += alpha*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,1); // d/dAz
	    q307 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q308 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,3); // d/dAz
	    q309 += alpha*Ix(a,3,2)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[300] += q300*C_[0];
	I[301] += q301*C_[0];
	I[302] += q302*C_[0];
	I[303] += q303*C_[0];
	I[304] += q304*C_[0];
	I[305] += q305*C_[0];
	I[306] += q306*C_[0];
	I[307] += q307*C_[0];
	I[308] += q308*C_[0];
	I[309] += q309*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q310 = 0.0;
	T q311 = 0.0;
	T q312 = 0.0;
	T q313 = 0.0;
	T q314 = 0.0;
	T q315 = 0.0;
	T q316 = 0.0;
	T q317 = 0.0;
	T q318 = 0.0;
	T q319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q310 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q311 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,2); // d/dAz
	    q312 += alpha*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q313 += alpha*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q314 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q315 += alpha*Ix(a,0,4)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q316 += alpha*Ix(a,0,0)*Iy(a,3,4)*Iz(a,1,0); // d/dAz
	    q317 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,4); // d/dAz
	    q318 += alpha*Ix(a,0,3)*Iy(a,3,1)*Iz(a,1,0); // d/dAz
	    q319 += alpha*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[310] += q310*C_[0];
	I[311] += q311*C_[0];
	I[312] += q312*C_[0];
	I[313] += q313*C_[0];
	I[314] += q314*C_[0];
	I[315] += q315*C_[0];
	I[316] += q316*C_[0];
	I[317] += q317*C_[0];
	I[318] += q318*C_[0];
	I[319] += q319*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q320 = 0.0;
	T q321 = 0.0;
	T q322 = 0.0;
	T q323 = 0.0;
	T q324 = 0.0;
	T q325 = 0.0;
	T q326 = 0.0;
	T q327 = 0.0;
	T q328 = 0.0;
	T q329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q320 += alpha*Ix(a,0,1)*Iy(a,3,3)*Iz(a,1,0); // d/dAz
	    q321 += alpha*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,1); // d/dAz
	    q322 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,3); // d/dAz
	    q323 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,3); // d/dAz
	    q324 += alpha*Ix(a,0,2)*Iy(a,3,2)*Iz(a,1,0); // d/dAz
	    q325 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,2); // d/dAz
	    q326 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,2); // d/dAz
	    q327 += alpha*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,1); // d/dAz
	    q328 += alpha*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,1); // d/dAz
	    q329 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[320] += q320*C_[0];
	I[321] += q321*C_[0];
	I[322] += q322*C_[0];
	I[323] += q323*C_[0];
	I[324] += q324*C_[0];
	I[325] += q325*C_[0];
	I[326] += q326*C_[0];
	I[327] += q327*C_[0];
	I[328] += q328*C_[0];
	I[329] += q329*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q330 = 0.0;
	T q331 = 0.0;
	T q332 = 0.0;
	T q333 = 0.0;
	T q334 = 0.0;
	T q335 = 0.0;
	T q336 = 0.0;
	T q337 = 0.0;
	T q338 = 0.0;
	T q339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q330 += alpha*Ix(a,0,4)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,0,4)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q331 += alpha*Ix(a,0,0)*Iy(a,0,4)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,0,4)*Iz(a,2,0);  // d/dAz
	    q332 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,4)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,4);  // d/dAz
	    q333 += alpha*Ix(a,0,3)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,0,3)*Iy(a,0,1)*Iz(a,2,0);  // d/dAz
	    q334 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,1);  // d/dAz
	    q335 += alpha*Ix(a,0,1)*Iy(a,0,3)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,0,3)*Iz(a,2,0);  // d/dAz
	    q336 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,1);  // d/dAz
	    q337 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,3)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,3);  // d/dAz
	    q338 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,3)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,3);  // d/dAz
	    q339 += alpha*Ix(a,0,2)*Iy(a,0,2)*Iz(a,4,0)
                     - 3*Ix(a,0,2)*Iy(a,0,2)*Iz(a,2,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[330] += q330*C_[0];
	I[331] += q331*C_[0];
	I[332] += q332*C_[0];
	I[333] += q333*C_[0];
	I[334] += q334*C_[0];
	I[335] += q335*C_[0];
	I[336] += q336*C_[0];
	I[337] += q337*C_[0];
	I[338] += q338*C_[0];
	I[339] += q339*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q340 = 0.0;
	T q341 = 0.0;
	T q342 = 0.0;
	T q343 = 0.0;
	T q344 = 0.0;
	T q345 = 0.0;
	T q346 = 0.0;
	T q347 = 0.0;
	T q348 = 0.0;
	T q349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q340 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,2)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,2);  // d/dAz
	    q341 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,2)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,2);  // d/dAz
	    q342 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,1)
                     - 3*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,1);  // d/dAz
	    q343 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,1)
                     - 3*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,1);  // d/dAz
	    q344 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,2)
                     - 3*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,2);  // d/dAz
	    q345 += alpha*Ix(a,2,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q346 += alpha*Ix(a,2,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAz
	    q347 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAz
	    q348 += alpha*Ix(a,2,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q349 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[340] += q340*C_[0];
	I[341] += q341*C_[0];
	I[342] += q342*C_[0];
	I[343] += q343*C_[0];
	I[344] += q344*C_[0];
	I[345] += q345*C_[0];
	I[346] += q346*C_[0];
	I[347] += q347*C_[0];
	I[348] += q348*C_[0];
	I[349] += q349*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q350 = 0.0;
	T q351 = 0.0;
	T q352 = 0.0;
	T q353 = 0.0;
	T q354 = 0.0;
	T q355 = 0.0;
	T q356 = 0.0;
	T q357 = 0.0;
	T q358 = 0.0;
	T q359 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q350 += alpha*Ix(a,2,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAz
	    q351 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAz
	    q352 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAz
	    q353 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAz
	    q354 += alpha*Ix(a,2,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q355 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q356 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAz
	    q357 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	    q358 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAz
	    q359 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[350] += q350*C_[0];
	I[351] += q351*C_[0];
	I[352] += q352*C_[0];
	I[353] += q353*C_[0];
	I[354] += q354*C_[0];
	I[355] += q355*C_[0];
	I[356] += q356*C_[0];
	I[357] += q357*C_[0];
	I[358] += q358*C_[0];
	I[359] += q359*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q360 = 0.0;
	T q361 = 0.0;
	T q362 = 0.0;
	T q363 = 0.0;
	T q364 = 0.0;
	T q365 = 0.0;
	T q366 = 0.0;
	T q367 = 0.0;
	T q368 = 0.0;
	T q369 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q360 += alpha*Ix(a,2,4)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,2,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q361 += alpha*Ix(a,2,0)*Iy(a,0,4)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAz
	    q362 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,4)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAz
	    q363 += alpha*Ix(a,2,3)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,2,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q364 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q365 += alpha*Ix(a,2,1)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAz
	    q366 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAz
	    q367 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAz
	    q368 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,3)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAz
	    q369 += alpha*Ix(a,2,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,2,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[360] += q360*C_[0];
	I[361] += q361*C_[0];
	I[362] += q362*C_[0];
	I[363] += q363*C_[0];
	I[364] += q364*C_[0];
	I[365] += q365*C_[0];
	I[366] += q366*C_[0];
	I[367] += q367*C_[0];
	I[368] += q368*C_[0];
	I[369] += q369*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q370 = 0.0;
	T q371 = 0.0;
	T q372 = 0.0;
	T q373 = 0.0;
	T q374 = 0.0;
	T q375 = 0.0;
	T q376 = 0.0;
	T q377 = 0.0;
	T q378 = 0.0;
	T q379 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q370 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q371 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAz
	    q372 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	    q373 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAz
	    q374 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAz
	    q375 += alpha*Ix(a,1,4)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q376 += alpha*Ix(a,1,0)*Iy(a,2,4)*Iz(a,1,0); // d/dAz
	    q377 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,4); // d/dAz
	    q378 += alpha*Ix(a,1,3)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q379 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[370] += q370*C_[0];
	I[371] += q371*C_[0];
	I[372] += q372*C_[0];
	I[373] += q373*C_[0];
	I[374] += q374*C_[0];
	I[375] += q375*C_[0];
	I[376] += q376*C_[0];
	I[377] += q377*C_[0];
	I[378] += q378*C_[0];
	I[379] += q379*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q380 = 0.0;
	T q381 = 0.0;
	T q382 = 0.0;
	T q383 = 0.0;
	T q384 = 0.0;
	T q385 = 0.0;
	T q386 = 0.0;
	T q387 = 0.0;
	T q388 = 0.0;
	T q389 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q380 += alpha*Ix(a,1,1)*Iy(a,2,3)*Iz(a,1,0); // d/dAz
	    q381 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,1); // d/dAz
	    q382 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,3); // d/dAz
	    q383 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,3); // d/dAz
	    q384 += alpha*Ix(a,1,2)*Iy(a,2,2)*Iz(a,1,0); // d/dAz
	    q385 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,2); // d/dAz
	    q386 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,2); // d/dAz
	    q387 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,1); // d/dAz
	    q388 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,1); // d/dAz
	    q389 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[380] += q380*C_[0];
	I[381] += q381*C_[0];
	I[382] += q382*C_[0];
	I[383] += q383*C_[0];
	I[384] += q384*C_[0];
	I[385] += q385*C_[0];
	I[386] += q386*C_[0];
	I[387] += q387*C_[0];
	I[388] += q388*C_[0];
	I[389] += q389*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q390 = 0.0;
	T q391 = 0.0;
	T q392 = 0.0;
	T q393 = 0.0;
	T q394 = 0.0;
	T q395 = 0.0;
	T q396 = 0.0;
	T q397 = 0.0;
	T q398 = 0.0;
	T q399 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q390 += alpha*Ix(a,0,4)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,4)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q391 += alpha*Ix(a,0,0)*Iy(a,2,4)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,4)*Iz(a,0,0);  // d/dAz
	    q392 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,4)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,4);  // d/dAz
	    q393 += alpha*Ix(a,0,3)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,2,1)*Iz(a,0,0);  // d/dAz
	    q394 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,1);  // d/dAz
	    q395 += alpha*Ix(a,0,1)*Iy(a,2,3)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,2,3)*Iz(a,0,0);  // d/dAz
	    q396 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,1);  // d/dAz
	    q397 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,3)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,3);  // d/dAz
	    q398 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,3);  // d/dAz
	    q399 += alpha*Ix(a,0,2)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,2,2)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[390] += q390*C_[0];
	I[391] += q391*C_[0];
	I[392] += q392*C_[0];
	I[393] += q393*C_[0];
	I[394] += q394*C_[0];
	I[395] += q395*C_[0];
	I[396] += q396*C_[0];
	I[397] += q397*C_[0];
	I[398] += q398*C_[0];
	I[399] += q399*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q400 = 0.0;
	T q401 = 0.0;
	T q402 = 0.0;
	T q403 = 0.0;
	T q404 = 0.0;
	T q405 = 0.0;
	T q406 = 0.0;
	T q407 = 0.0;
	T q408 = 0.0;
	T q409 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q400 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,2);  // d/dAz
	    q401 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,2);  // d/dAz
	    q402 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,1);  // d/dAz
	    q403 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,1);  // d/dAz
	    q404 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,2);  // d/dAz
	    q405 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,1,4)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q406 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,0,4)*Iz(a,1,0);  // d/dAz
	    q407 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,4)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,4);  // d/dAz
	    q408 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q409 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[400] += q400*C_[0];
	I[401] += q401*C_[0];
	I[402] += q402*C_[0];
	I[403] += q403*C_[0];
	I[404] += q404*C_[0];
	I[405] += q405*C_[0];
	I[406] += q406*C_[0];
	I[407] += q407*C_[0];
	I[408] += q408*C_[0];
	I[409] += q409*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q410 = 0.0;
	T q411 = 0.0;
	T q412 = 0.0;
	T q413 = 0.0;
	T q414 = 0.0;
	T q415 = 0.0;
	T q416 = 0.0;
	T q417 = 0.0;
	T q418 = 0.0;
	T q419 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q410 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,0);  // d/dAz
	    q411 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,1);  // d/dAz
	    q412 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,3);  // d/dAz
	    q413 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,3)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,3);  // d/dAz
	    q414 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,0);  // d/dAz
	    q415 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,2);  // d/dAz
	    q416 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,2)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,2);  // d/dAz
	    q417 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,1);  // d/dAz
	    q418 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,1)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,1);  // d/dAz
	    q419 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,2)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,2);  // d/dAz
	}
	    
	//contraction coefficients
	I[410] += q410*C_[0];
	I[411] += q411*C_[0];
	I[412] += q412*C_[0];
	I[413] += q413*C_[0];
	I[414] += q414*C_[0];
	I[415] += q415*C_[0];
	I[416] += q416*C_[0];
	I[417] += q417*C_[0];
	I[418] += q418*C_[0];
	I[419] += q419*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q420 = 0.0;
	T q421 = 0.0;
	T q422 = 0.0;
	T q423 = 0.0;
	T q424 = 0.0;
	T q425 = 0.0;
	T q426 = 0.0;
	T q427 = 0.0;
	T q428 = 0.0;
	T q429 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q420 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,0,4)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q421 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,1,4)*Iz(a,1,0);  // d/dAz
	    q422 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,4)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,4);  // d/dAz
	    q423 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,0);  // d/dAz
	    q424 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,1);  // d/dAz
	    q425 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,0);  // d/dAz
	    q426 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,1);  // d/dAz
	    q427 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,3)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,3);  // d/dAz
	    q428 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,3);  // d/dAz
	    q429 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[420] += q420*C_[0];
	I[421] += q421*C_[0];
	I[422] += q422*C_[0];
	I[423] += q423*C_[0];
	I[424] += q424*C_[0];
	I[425] += q425*C_[0];
	I[426] += q426*C_[0];
	I[427] += q427*C_[0];
	I[428] += q428*C_[0];
	I[429] += q429*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q430 = 0.0;
	T q431 = 0.0;
	T q432 = 0.0;
	T q433 = 0.0;
	T q434 = 0.0;
	T q435 = 0.0;
	T q436 = 0.0;
	T q437 = 0.0;
	T q438 = 0.0;
	T q439 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q430 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,2)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,2);  // d/dAz
	    q431 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,2);  // d/dAz
	    q432 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,1)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,1);  // d/dAz
	    q433 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,1);  // d/dAz
	    q434 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,2)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,2);  // d/dAz
	    q435 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,1,4)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q436 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,4)*Iz(a,0,0);  // d/dAz
	    q437 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,4)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,4);  // d/dAz
	    q438 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q439 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[430] += q430*C_[0];
	I[431] += q431*C_[0];
	I[432] += q432*C_[0];
	I[433] += q433*C_[0];
	I[434] += q434*C_[0];
	I[435] += q435*C_[0];
	I[436] += q436*C_[0];
	I[437] += q437*C_[0];
	I[438] += q438*C_[0];
	I[439] += q439*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q440 = 0.0;
	T q441 = 0.0;
	T q442 = 0.0;
	T q443 = 0.0;
	T q444 = 0.0;
	T q445 = 0.0;
	T q446 = 0.0;
	T q447 = 0.0;
	T q448 = 0.0;
	T q449 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q440 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,0);  // d/dAz
	    q441 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,1);  // d/dAz
	    q442 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,3)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,3);  // d/dAz
	    q443 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,3);  // d/dAz
	    q444 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,0);  // d/dAz
	    q445 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,2);  // d/dAz
	    q446 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,2);  // d/dAz
	    q447 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,1);  // d/dAz
	    q448 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,1);  // d/dAz
	    q449 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,2);  // d/dAz
	}
	    
	//contraction coefficients
	I[440] += q440*C_[0];
	I[441] += q441*C_[0];
	I[442] += q442*C_[0];
	I[443] += q443*C_[0];
	I[444] += q444*C_[0];
	I[445] += q445*C_[0];
	I[446] += q446*C_[0];
	I[447] += q447*C_[0];
	I[448] += q448*C_[0];
	I[449] += q449*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q450 = 0.0;
	T q451 = 0.0;
	T q452 = 0.0;
	T q453 = 0.0;
	T q454 = 0.0;
	T q455 = 0.0;
	T q456 = 0.0;
	T q457 = 0.0;
	T q458 = 0.0;
	T q459 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q450 += beta*Ix(a,3,5)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q451 += beta*Ix(a,3,1)*Iy(a,0,4)*Iz(a,0,0); // d/dBx
	    q452 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,4); // d/dBx
	    q453 += beta*Ix(a,3,4)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q454 += beta*Ix(a,3,4)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q455 += beta*Ix(a,3,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBx
	    q456 += beta*Ix(a,3,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBx
	    q457 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBx
	    q458 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBx
	    q459 += beta*Ix(a,3,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 2*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[450] += q450*C_[0];
	I[451] += q451*C_[0];
	I[452] += q452*C_[0];
	I[453] += q453*C_[0];
	I[454] += q454*C_[0];
	I[455] += q455*C_[0];
	I[456] += q456*C_[0];
	I[457] += q457*C_[0];
	I[458] += q458*C_[0];
	I[459] += q459*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q460 = 0.0;
	T q461 = 0.0;
	T q462 = 0.0;
	T q463 = 0.0;
	T q464 = 0.0;
	T q465 = 0.0;
	T q466 = 0.0;
	T q467 = 0.0;
	T q468 = 0.0;
	T q469 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q460 += beta*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 2*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q461 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,2); // d/dBx
	    q462 += beta*Ix(a,3,3)*Iy(a,0,1)*Iz(a,0,1)
                     - 2*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	    q463 += beta*Ix(a,3,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBx
	    q464 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBx
	    q465 += beta*Ix(a,0,5)*Iy(a,3,0)*Iz(a,0,0)
                     - 4*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,0);  // d/dBx
	    q466 += beta*Ix(a,0,1)*Iy(a,3,4)*Iz(a,0,0); // d/dBx
	    q467 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,4); // d/dBx
	    q468 += beta*Ix(a,0,4)*Iy(a,3,1)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,0);  // d/dBx
	    q469 += beta*Ix(a,0,4)*Iy(a,3,0)*Iz(a,0,1)
                     - 3*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[460] += q460*C_[0];
	I[461] += q461*C_[0];
	I[462] += q462*C_[0];
	I[463] += q463*C_[0];
	I[464] += q464*C_[0];
	I[465] += q465*C_[0];
	I[466] += q466*C_[0];
	I[467] += q467*C_[0];
	I[468] += q468*C_[0];
	I[469] += q469*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q470 = 0.0;
	T q471 = 0.0;
	T q472 = 0.0;
	T q473 = 0.0;
	T q474 = 0.0;
	T q475 = 0.0;
	T q476 = 0.0;
	T q477 = 0.0;
	T q478 = 0.0;
	T q479 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q470 += beta*Ix(a,0,2)*Iy(a,3,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,0);  // d/dBx
	    q471 += beta*Ix(a,0,1)*Iy(a,3,3)*Iz(a,0,1); // d/dBx
	    q472 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,3);  // d/dBx
	    q473 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,3); // d/dBx
	    q474 += beta*Ix(a,0,3)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,0);  // d/dBx
	    q475 += beta*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,2);  // d/dBx
	    q476 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,2); // d/dBx
	    q477 += beta*Ix(a,0,3)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,1);  // d/dBx
	    q478 += beta*Ix(a,0,2)*Iy(a,3,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,1);  // d/dBx
	    q479 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[470] += q470*C_[0];
	I[471] += q471*C_[0];
	I[472] += q472*C_[0];
	I[473] += q473*C_[0];
	I[474] += q474*C_[0];
	I[475] += q475*C_[0];
	I[476] += q476*C_[0];
	I[477] += q477*C_[0];
	I[478] += q478*C_[0];
	I[479] += q479*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q480 = 0.0;
	T q481 = 0.0;
	T q482 = 0.0;
	T q483 = 0.0;
	T q484 = 0.0;
	T q485 = 0.0;
	T q486 = 0.0;
	T q487 = 0.0;
	T q488 = 0.0;
	T q489 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q480 += beta*Ix(a,0,5)*Iy(a,0,0)*Iz(a,3,0)
                     - 4*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,0);  // d/dBx
	    q481 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,3,0); // d/dBx
	    q482 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,4); // d/dBx
	    q483 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,3,0)
                     - 3*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,0);  // d/dBx
	    q484 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,3,1)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,1);  // d/dBx
	    q485 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,0);  // d/dBx
	    q486 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,3,1); // d/dBx
	    q487 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,3);  // d/dBx
	    q488 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,3); // d/dBx
	    q489 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[480] += q480*C_[0];
	I[481] += q481*C_[0];
	I[482] += q482*C_[0];
	I[483] += q483*C_[0];
	I[484] += q484*C_[0];
	I[485] += q485*C_[0];
	I[486] += q486*C_[0];
	I[487] += q487*C_[0];
	I[488] += q488*C_[0];
	I[489] += q489*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q490 = 0.0;
	T q491 = 0.0;
	T q492 = 0.0;
	T q493 = 0.0;
	T q494 = 0.0;
	T q495 = 0.0;
	T q496 = 0.0;
	T q497 = 0.0;
	T q498 = 0.0;
	T q499 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q490 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,2);  // d/dBx
	    q491 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,2); // d/dBx
	    q492 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,1);  // d/dBx
	    q493 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,1);  // d/dBx
	    q494 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,2);  // d/dBx
	    q495 += beta*Ix(a,2,5)*Iy(a,1,0)*Iz(a,0,0)
                     - 4*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q496 += beta*Ix(a,2,1)*Iy(a,1,4)*Iz(a,0,0); // d/dBx
	    q497 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,4); // d/dBx
	    q498 += beta*Ix(a,2,4)*Iy(a,1,1)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q499 += beta*Ix(a,2,4)*Iy(a,1,0)*Iz(a,0,1)
                     - 3*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[490] += q490*C_[0];
	I[491] += q491*C_[0];
	I[492] += q492*C_[0];
	I[493] += q493*C_[0];
	I[494] += q494*C_[0];
	I[495] += q495*C_[0];
	I[496] += q496*C_[0];
	I[497] += q497*C_[0];
	I[498] += q498*C_[0];
	I[499] += q499*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q500 = 0.0;
	T q501 = 0.0;
	T q502 = 0.0;
	T q503 = 0.0;
	T q504 = 0.0;
	T q505 = 0.0;
	T q506 = 0.0;
	T q507 = 0.0;
	T q508 = 0.0;
	T q509 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q500 += beta*Ix(a,2,2)*Iy(a,1,3)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBx
	    q501 += beta*Ix(a,2,1)*Iy(a,1,3)*Iz(a,0,1); // d/dBx
	    q502 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,3)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBx
	    q503 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,3); // d/dBx
	    q504 += beta*Ix(a,2,3)*Iy(a,1,2)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBx
	    q505 += beta*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,2)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBx
	    q506 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,2); // d/dBx
	    q507 += beta*Ix(a,2,3)*Iy(a,1,1)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBx
	    q508 += beta*Ix(a,2,2)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBx
	    q509 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[500] += q500*C_[0];
	I[501] += q501*C_[0];
	I[502] += q502*C_[0];
	I[503] += q503*C_[0];
	I[504] += q504*C_[0];
	I[505] += q505*C_[0];
	I[506] += q506*C_[0];
	I[507] += q507*C_[0];
	I[508] += q508*C_[0];
	I[509] += q509*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q510 = 0.0;
	T q511 = 0.0;
	T q512 = 0.0;
	T q513 = 0.0;
	T q514 = 0.0;
	T q515 = 0.0;
	T q516 = 0.0;
	T q517 = 0.0;
	T q518 = 0.0;
	T q519 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q510 += beta*Ix(a,2,5)*Iy(a,0,0)*Iz(a,1,0)
                     - 4*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q511 += beta*Ix(a,2,1)*Iy(a,0,4)*Iz(a,1,0); // d/dBx
	    q512 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,4); // d/dBx
	    q513 += beta*Ix(a,2,4)*Iy(a,0,1)*Iz(a,1,0)
                     - 3*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q514 += beta*Ix(a,2,4)*Iy(a,0,0)*Iz(a,1,1)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	    q515 += beta*Ix(a,2,2)*Iy(a,0,3)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBx
	    q516 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,1,1); // d/dBx
	    q517 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,3)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBx
	    q518 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,3); // d/dBx
	    q519 += beta*Ix(a,2,3)*Iy(a,0,2)*Iz(a,1,0)
                     - 2*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[510] += q510*C_[0];
	I[511] += q511*C_[0];
	I[512] += q512*C_[0];
	I[513] += q513*C_[0];
	I[514] += q514*C_[0];
	I[515] += q515*C_[0];
	I[516] += q516*C_[0];
	I[517] += q517*C_[0];
	I[518] += q518*C_[0];
	I[519] += q519*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q520 = 0.0;
	T q521 = 0.0;
	T q522 = 0.0;
	T q523 = 0.0;
	T q524 = 0.0;
	T q525 = 0.0;
	T q526 = 0.0;
	T q527 = 0.0;
	T q528 = 0.0;
	T q529 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q520 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,2)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBx
	    q521 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,2); // d/dBx
	    q522 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,1,1)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBx
	    q523 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBx
	    q524 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBx
	    q525 += beta*Ix(a,1,5)*Iy(a,2,0)*Iz(a,0,0)
                     - 4*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q526 += beta*Ix(a,1,1)*Iy(a,2,4)*Iz(a,0,0); // d/dBx
	    q527 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,4); // d/dBx
	    q528 += beta*Ix(a,1,4)*Iy(a,2,1)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dBx
	    q529 += beta*Ix(a,1,4)*Iy(a,2,0)*Iz(a,0,1)
                     - 3*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[520] += q520*C_[0];
	I[521] += q521*C_[0];
	I[522] += q522*C_[0];
	I[523] += q523*C_[0];
	I[524] += q524*C_[0];
	I[525] += q525*C_[0];
	I[526] += q526*C_[0];
	I[527] += q527*C_[0];
	I[528] += q528*C_[0];
	I[529] += q529*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q530 = 0.0;
	T q531 = 0.0;
	T q532 = 0.0;
	T q533 = 0.0;
	T q534 = 0.0;
	T q535 = 0.0;
	T q536 = 0.0;
	T q537 = 0.0;
	T q538 = 0.0;
	T q539 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q530 += beta*Ix(a,1,2)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dBx
	    q531 += beta*Ix(a,1,1)*Iy(a,2,3)*Iz(a,0,1); // d/dBx
	    q532 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dBx
	    q533 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,3); // d/dBx
	    q534 += beta*Ix(a,1,3)*Iy(a,2,2)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dBx
	    q535 += beta*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dBx
	    q536 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,2); // d/dBx
	    q537 += beta*Ix(a,1,3)*Iy(a,2,1)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dBx
	    q538 += beta*Ix(a,1,2)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dBx
	    q539 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[530] += q530*C_[0];
	I[531] += q531*C_[0];
	I[532] += q532*C_[0];
	I[533] += q533*C_[0];
	I[534] += q534*C_[0];
	I[535] += q535*C_[0];
	I[536] += q536*C_[0];
	I[537] += q537*C_[0];
	I[538] += q538*C_[0];
	I[539] += q539*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q540 = 0.0;
	T q541 = 0.0;
	T q542 = 0.0;
	T q543 = 0.0;
	T q544 = 0.0;
	T q545 = 0.0;
	T q546 = 0.0;
	T q547 = 0.0;
	T q548 = 0.0;
	T q549 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q540 += beta*Ix(a,0,5)*Iy(a,2,0)*Iz(a,1,0)
                     - 4*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,0);  // d/dBx
	    q541 += beta*Ix(a,0,1)*Iy(a,2,4)*Iz(a,1,0); // d/dBx
	    q542 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,4); // d/dBx
	    q543 += beta*Ix(a,0,4)*Iy(a,2,1)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,0);  // d/dBx
	    q544 += beta*Ix(a,0,4)*Iy(a,2,0)*Iz(a,1,1)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,1);  // d/dBx
	    q545 += beta*Ix(a,0,2)*Iy(a,2,3)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,0);  // d/dBx
	    q546 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,1,1); // d/dBx
	    q547 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,3);  // d/dBx
	    q548 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,3); // d/dBx
	    q549 += beta*Ix(a,0,3)*Iy(a,2,2)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[540] += q540*C_[0];
	I[541] += q541*C_[0];
	I[542] += q542*C_[0];
	I[543] += q543*C_[0];
	I[544] += q544*C_[0];
	I[545] += q545*C_[0];
	I[546] += q546*C_[0];
	I[547] += q547*C_[0];
	I[548] += q548*C_[0];
	I[549] += q549*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q550 = 0.0;
	T q551 = 0.0;
	T q552 = 0.0;
	T q553 = 0.0;
	T q554 = 0.0;
	T q555 = 0.0;
	T q556 = 0.0;
	T q557 = 0.0;
	T q558 = 0.0;
	T q559 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q550 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,2)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,2);  // d/dBx
	    q551 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,2); // d/dBx
	    q552 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1);  // d/dBx
	    q553 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,1);  // d/dBx
	    q554 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,2);  // d/dBx
	    q555 += beta*Ix(a,1,5)*Iy(a,0,0)*Iz(a,2,0)
                     - 4*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q556 += beta*Ix(a,1,1)*Iy(a,0,4)*Iz(a,2,0); // d/dBx
	    q557 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,4); // d/dBx
	    q558 += beta*Ix(a,1,4)*Iy(a,0,1)*Iz(a,2,0)
                     - 3*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dBx
	    q559 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,2,1)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[550] += q550*C_[0];
	I[551] += q551*C_[0];
	I[552] += q552*C_[0];
	I[553] += q553*C_[0];
	I[554] += q554*C_[0];
	I[555] += q555*C_[0];
	I[556] += q556*C_[0];
	I[557] += q557*C_[0];
	I[558] += q558*C_[0];
	I[559] += q559*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q560 = 0.0;
	T q561 = 0.0;
	T q562 = 0.0;
	T q563 = 0.0;
	T q564 = 0.0;
	T q565 = 0.0;
	T q566 = 0.0;
	T q567 = 0.0;
	T q568 = 0.0;
	T q569 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q560 += beta*Ix(a,1,2)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dBx
	    q561 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,2,1); // d/dBx
	    q562 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dBx
	    q563 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,3); // d/dBx
	    q564 += beta*Ix(a,1,3)*Iy(a,0,2)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dBx
	    q565 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,2)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dBx
	    q566 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,2); // d/dBx
	    q567 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,2,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dBx
	    q568 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dBx
	    q569 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[560] += q560*C_[0];
	I[561] += q561*C_[0];
	I[562] += q562*C_[0];
	I[563] += q563*C_[0];
	I[564] += q564*C_[0];
	I[565] += q565*C_[0];
	I[566] += q566*C_[0];
	I[567] += q567*C_[0];
	I[568] += q568*C_[0];
	I[569] += q569*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q570 = 0.0;
	T q571 = 0.0;
	T q572 = 0.0;
	T q573 = 0.0;
	T q574 = 0.0;
	T q575 = 0.0;
	T q576 = 0.0;
	T q577 = 0.0;
	T q578 = 0.0;
	T q579 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q570 += beta*Ix(a,0,5)*Iy(a,1,0)*Iz(a,2,0)
                     - 4*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,0);  // d/dBx
	    q571 += beta*Ix(a,0,1)*Iy(a,1,4)*Iz(a,2,0); // d/dBx
	    q572 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,4); // d/dBx
	    q573 += beta*Ix(a,0,4)*Iy(a,1,1)*Iz(a,2,0)
                     - 3*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,0);  // d/dBx
	    q574 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,2,1)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,1);  // d/dBx
	    q575 += beta*Ix(a,0,2)*Iy(a,1,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,0);  // d/dBx
	    q576 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,2,1); // d/dBx
	    q577 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,3);  // d/dBx
	    q578 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,3); // d/dBx
	    q579 += beta*Ix(a,0,3)*Iy(a,1,2)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[570] += q570*C_[0];
	I[571] += q571*C_[0];
	I[572] += q572*C_[0];
	I[573] += q573*C_[0];
	I[574] += q574*C_[0];
	I[575] += q575*C_[0];
	I[576] += q576*C_[0];
	I[577] += q577*C_[0];
	I[578] += q578*C_[0];
	I[579] += q579*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q580 = 0.0;
	T q581 = 0.0;
	T q582 = 0.0;
	T q583 = 0.0;
	T q584 = 0.0;
	T q585 = 0.0;
	T q586 = 0.0;
	T q587 = 0.0;
	T q588 = 0.0;
	T q589 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q580 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,2)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,2);  // d/dBx
	    q581 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,2); // d/dBx
	    q582 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1);  // d/dBx
	    q583 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,1);  // d/dBx
	    q584 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,2);  // d/dBx
	    q585 += beta*Ix(a,1,5)*Iy(a,1,0)*Iz(a,1,0)
                     - 4*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q586 += beta*Ix(a,1,1)*Iy(a,1,4)*Iz(a,1,0); // d/dBx
	    q587 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,4); // d/dBx
	    q588 += beta*Ix(a,1,4)*Iy(a,1,1)*Iz(a,1,0)
                     - 3*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dBx
	    q589 += beta*Ix(a,1,4)*Iy(a,1,0)*Iz(a,1,1)
                     - 3*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[580] += q580*C_[0];
	I[581] += q581*C_[0];
	I[582] += q582*C_[0];
	I[583] += q583*C_[0];
	I[584] += q584*C_[0];
	I[585] += q585*C_[0];
	I[586] += q586*C_[0];
	I[587] += q587*C_[0];
	I[588] += q588*C_[0];
	I[589] += q589*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q590 = 0.0;
	T q591 = 0.0;
	T q592 = 0.0;
	T q593 = 0.0;
	T q594 = 0.0;
	T q595 = 0.0;
	T q596 = 0.0;
	T q597 = 0.0;
	T q598 = 0.0;
	T q599 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q590 += beta*Ix(a,1,2)*Iy(a,1,3)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dBx
	    q591 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,1); // d/dBx
	    q592 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,3)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dBx
	    q593 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,3); // d/dBx
	    q594 += beta*Ix(a,1,3)*Iy(a,1,2)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dBx
	    q595 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,2)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dBx
	    q596 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,2); // d/dBx
	    q597 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dBx
	    q598 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dBx
	    q599 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[590] += q590*C_[0];
	I[591] += q591*C_[0];
	I[592] += q592*C_[0];
	I[593] += q593*C_[0];
	I[594] += q594*C_[0];
	I[595] += q595*C_[0];
	I[596] += q596*C_[0];
	I[597] += q597*C_[0];
	I[598] += q598*C_[0];
	I[599] += q599*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q600 = 0.0;
	T q601 = 0.0;
	T q602 = 0.0;
	T q603 = 0.0;
	T q604 = 0.0;
	T q605 = 0.0;
	T q606 = 0.0;
	T q607 = 0.0;
	T q608 = 0.0;
	T q609 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q600 += beta*Ix(a,3,4)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q601 += beta*Ix(a,3,0)*Iy(a,0,5)*Iz(a,0,0)
                     - 4*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBy
	    q602 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,4); // d/dBy
	    q603 += beta*Ix(a,3,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q604 += beta*Ix(a,3,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q605 += beta*Ix(a,3,1)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q606 += beta*Ix(a,3,0)*Iy(a,0,4)*Iz(a,0,1)
                     - 3*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBy
	    q607 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q608 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBy
	    q609 += beta*Ix(a,3,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[600] += q600*C_[0];
	I[601] += q601*C_[0];
	I[602] += q602*C_[0];
	I[603] += q603*C_[0];
	I[604] += q604*C_[0];
	I[605] += q605*C_[0];
	I[606] += q606*C_[0];
	I[607] += q607*C_[0];
	I[608] += q608*C_[0];
	I[609] += q609*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q610 = 0.0;
	T q611 = 0.0;
	T q612 = 0.0;
	T q613 = 0.0;
	T q614 = 0.0;
	T q615 = 0.0;
	T q616 = 0.0;
	T q617 = 0.0;
	T q618 = 0.0;
	T q619 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q610 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q611 += beta*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 2*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBy
	    q612 += beta*Ix(a,3,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q613 += beta*Ix(a,3,1)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q614 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q615 += beta*Ix(a,0,4)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q616 += beta*Ix(a,0,0)*Iy(a,3,5)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,0);  // d/dBy
	    q617 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,4); // d/dBy
	    q618 += beta*Ix(a,0,3)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,0);  // d/dBy
	    q619 += beta*Ix(a,0,3)*Iy(a,3,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[610] += q610*C_[0];
	I[611] += q611*C_[0];
	I[612] += q612*C_[0];
	I[613] += q613*C_[0];
	I[614] += q614*C_[0];
	I[615] += q615*C_[0];
	I[616] += q616*C_[0];
	I[617] += q617*C_[0];
	I[618] += q618*C_[0];
	I[619] += q619*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q620 = 0.0;
	T q621 = 0.0;
	T q622 = 0.0;
	T q623 = 0.0;
	T q624 = 0.0;
	T q625 = 0.0;
	T q626 = 0.0;
	T q627 = 0.0;
	T q628 = 0.0;
	T q629 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q620 += beta*Ix(a,0,1)*Iy(a,3,4)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,0);  // d/dBy
	    q621 += beta*Ix(a,0,0)*Iy(a,3,4)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,1);  // d/dBy
	    q622 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,3); // d/dBy
	    q623 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,3);  // d/dBy
	    q624 += beta*Ix(a,0,2)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,0);  // d/dBy
	    q625 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,2); // d/dBy
	    q626 += beta*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,2)
                     - 2*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,2);  // d/dBy
	    q627 += beta*Ix(a,0,2)*Iy(a,3,2)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,1);  // d/dBy
	    q628 += beta*Ix(a,0,1)*Iy(a,3,3)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,1);  // d/dBy
	    q629 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[620] += q620*C_[0];
	I[621] += q621*C_[0];
	I[622] += q622*C_[0];
	I[623] += q623*C_[0];
	I[624] += q624*C_[0];
	I[625] += q625*C_[0];
	I[626] += q626*C_[0];
	I[627] += q627*C_[0];
	I[628] += q628*C_[0];
	I[629] += q629*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q630 = 0.0;
	T q631 = 0.0;
	T q632 = 0.0;
	T q633 = 0.0;
	T q634 = 0.0;
	T q635 = 0.0;
	T q636 = 0.0;
	T q637 = 0.0;
	T q638 = 0.0;
	T q639 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q630 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q631 += beta*Ix(a,0,0)*Iy(a,0,5)*Iz(a,3,0)
                     - 4*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,0);  // d/dBy
	    q632 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,4); // d/dBy
	    q633 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,0);  // d/dBy
	    q634 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,3,1); // d/dBy
	    q635 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,3,0)
                     - 3*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,0);  // d/dBy
	    q636 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,3,1)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,1);  // d/dBy
	    q637 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,3); // d/dBy
	    q638 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,3);  // d/dBy
	    q639 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[630] += q630*C_[0];
	I[631] += q631*C_[0];
	I[632] += q632*C_[0];
	I[633] += q633*C_[0];
	I[634] += q634*C_[0];
	I[635] += q635*C_[0];
	I[636] += q636*C_[0];
	I[637] += q637*C_[0];
	I[638] += q638*C_[0];
	I[639] += q639*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q640 = 0.0;
	T q641 = 0.0;
	T q642 = 0.0;
	T q643 = 0.0;
	T q644 = 0.0;
	T q645 = 0.0;
	T q646 = 0.0;
	T q647 = 0.0;
	T q648 = 0.0;
	T q649 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q640 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,2); // d/dBy
	    q641 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,2);  // d/dBy
	    q642 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,3,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,1);  // d/dBy
	    q643 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,1);  // d/dBy
	    q644 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,2);  // d/dBy
	    q645 += beta*Ix(a,2,4)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q646 += beta*Ix(a,2,0)*Iy(a,1,5)*Iz(a,0,0)
                     - 4*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBy
	    q647 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,4); // d/dBy
	    q648 += beta*Ix(a,2,3)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q649 += beta*Ix(a,2,3)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[640] += q640*C_[0];
	I[641] += q641*C_[0];
	I[642] += q642*C_[0];
	I[643] += q643*C_[0];
	I[644] += q644*C_[0];
	I[645] += q645*C_[0];
	I[646] += q646*C_[0];
	I[647] += q647*C_[0];
	I[648] += q648*C_[0];
	I[649] += q649*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q650 = 0.0;
	T q651 = 0.0;
	T q652 = 0.0;
	T q653 = 0.0;
	T q654 = 0.0;
	T q655 = 0.0;
	T q656 = 0.0;
	T q657 = 0.0;
	T q658 = 0.0;
	T q659 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q650 += beta*Ix(a,2,1)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBy
	    q651 += beta*Ix(a,2,0)*Iy(a,1,4)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBy
	    q652 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,3); // d/dBy
	    q653 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,3)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBy
	    q654 += beta*Ix(a,2,2)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	    q655 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q656 += beta*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,2)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBy
	    q657 += beta*Ix(a,2,2)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	    q658 += beta*Ix(a,2,1)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBy
	    q659 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[650] += q650*C_[0];
	I[651] += q651*C_[0];
	I[652] += q652*C_[0];
	I[653] += q653*C_[0];
	I[654] += q654*C_[0];
	I[655] += q655*C_[0];
	I[656] += q656*C_[0];
	I[657] += q657*C_[0];
	I[658] += q658*C_[0];
	I[659] += q659*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q660 = 0.0;
	T q661 = 0.0;
	T q662 = 0.0;
	T q663 = 0.0;
	T q664 = 0.0;
	T q665 = 0.0;
	T q666 = 0.0;
	T q667 = 0.0;
	T q668 = 0.0;
	T q669 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q660 += beta*Ix(a,2,4)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q661 += beta*Ix(a,2,0)*Iy(a,0,5)*Iz(a,1,0)
                     - 4*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBy
	    q662 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,4); // d/dBy
	    q663 += beta*Ix(a,2,3)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q664 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q665 += beta*Ix(a,2,1)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBy
	    q666 += beta*Ix(a,2,0)*Iy(a,0,4)*Iz(a,1,1)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBy
	    q667 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,3); // d/dBy
	    q668 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,3)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBy
	    q669 += beta*Ix(a,2,2)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[660] += q660*C_[0];
	I[661] += q661*C_[0];
	I[662] += q662*C_[0];
	I[663] += q663*C_[0];
	I[664] += q664*C_[0];
	I[665] += q665*C_[0];
	I[666] += q666*C_[0];
	I[667] += q667*C_[0];
	I[668] += q668*C_[0];
	I[669] += q669*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q670 = 0.0;
	T q671 = 0.0;
	T q672 = 0.0;
	T q673 = 0.0;
	T q674 = 0.0;
	T q675 = 0.0;
	T q676 = 0.0;
	T q677 = 0.0;
	T q678 = 0.0;
	T q679 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q670 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q671 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,2)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBy
	    q672 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	    q673 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBy
	    q674 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBy
	    q675 += beta*Ix(a,1,4)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q676 += beta*Ix(a,1,0)*Iy(a,2,5)*Iz(a,0,0)
                     - 4*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dBy
	    q677 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,4); // d/dBy
	    q678 += beta*Ix(a,1,3)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q679 += beta*Ix(a,1,3)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[670] += q670*C_[0];
	I[671] += q671*C_[0];
	I[672] += q672*C_[0];
	I[673] += q673*C_[0];
	I[674] += q674*C_[0];
	I[675] += q675*C_[0];
	I[676] += q676*C_[0];
	I[677] += q677*C_[0];
	I[678] += q678*C_[0];
	I[679] += q679*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q680 = 0.0;
	T q681 = 0.0;
	T q682 = 0.0;
	T q683 = 0.0;
	T q684 = 0.0;
	T q685 = 0.0;
	T q686 = 0.0;
	T q687 = 0.0;
	T q688 = 0.0;
	T q689 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q680 += beta*Ix(a,1,1)*Iy(a,2,4)*Iz(a,0,0)
                     - 3*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dBy
	    q681 += beta*Ix(a,1,0)*Iy(a,2,4)*Iz(a,0,1)
                     - 3*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dBy
	    q682 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,3); // d/dBy
	    q683 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dBy
	    q684 += beta*Ix(a,1,2)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dBy
	    q685 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,2); // d/dBy
	    q686 += beta*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dBy
	    q687 += beta*Ix(a,1,2)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dBy
	    q688 += beta*Ix(a,1,1)*Iy(a,2,3)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dBy
	    q689 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[680] += q680*C_[0];
	I[681] += q681*C_[0];
	I[682] += q682*C_[0];
	I[683] += q683*C_[0];
	I[684] += q684*C_[0];
	I[685] += q685*C_[0];
	I[686] += q686*C_[0];
	I[687] += q687*C_[0];
	I[688] += q688*C_[0];
	I[689] += q689*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q690 = 0.0;
	T q691 = 0.0;
	T q692 = 0.0;
	T q693 = 0.0;
	T q694 = 0.0;
	T q695 = 0.0;
	T q696 = 0.0;
	T q697 = 0.0;
	T q698 = 0.0;
	T q699 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q690 += beta*Ix(a,0,4)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q691 += beta*Ix(a,0,0)*Iy(a,2,5)*Iz(a,1,0)
                     - 4*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,0);  // d/dBy
	    q692 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,4); // d/dBy
	    q693 += beta*Ix(a,0,3)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,0);  // d/dBy
	    q694 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,1,1); // d/dBy
	    q695 += beta*Ix(a,0,1)*Iy(a,2,4)*Iz(a,1,0)
                     - 3*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,0);  // d/dBy
	    q696 += beta*Ix(a,0,0)*Iy(a,2,4)*Iz(a,1,1)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,1);  // d/dBy
	    q697 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,3); // d/dBy
	    q698 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,3);  // d/dBy
	    q699 += beta*Ix(a,0,2)*Iy(a,2,3)*Iz(a,1,0)
                     - 2*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[690] += q690*C_[0];
	I[691] += q691*C_[0];
	I[692] += q692*C_[0];
	I[693] += q693*C_[0];
	I[694] += q694*C_[0];
	I[695] += q695*C_[0];
	I[696] += q696*C_[0];
	I[697] += q697*C_[0];
	I[698] += q698*C_[0];
	I[699] += q699*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q700 = 0.0;
	T q701 = 0.0;
	T q702 = 0.0;
	T q703 = 0.0;
	T q704 = 0.0;
	T q705 = 0.0;
	T q706 = 0.0;
	T q707 = 0.0;
	T q708 = 0.0;
	T q709 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q700 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,2); // d/dBy
	    q701 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,2)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,2);  // d/dBy
	    q702 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,1);  // d/dBy
	    q703 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1);  // d/dBy
	    q704 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,2);  // d/dBy
	    q705 += beta*Ix(a,1,4)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q706 += beta*Ix(a,1,0)*Iy(a,0,5)*Iz(a,2,0)
                     - 4*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dBy
	    q707 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,4); // d/dBy
	    q708 += beta*Ix(a,1,3)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q709 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	}
	    
	//contraction coefficients
	I[700] += q700*C_[0];
	I[701] += q701*C_[0];
	I[702] += q702*C_[0];
	I[703] += q703*C_[0];
	I[704] += q704*C_[0];
	I[705] += q705*C_[0];
	I[706] += q706*C_[0];
	I[707] += q707*C_[0];
	I[708] += q708*C_[0];
	I[709] += q709*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q710 = 0.0;
	T q711 = 0.0;
	T q712 = 0.0;
	T q713 = 0.0;
	T q714 = 0.0;
	T q715 = 0.0;
	T q716 = 0.0;
	T q717 = 0.0;
	T q718 = 0.0;
	T q719 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q710 += beta*Ix(a,1,1)*Iy(a,0,4)*Iz(a,2,0)
                     - 3*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dBy
	    q711 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,2,1)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dBy
	    q712 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,3); // d/dBy
	    q713 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dBy
	    q714 += beta*Ix(a,1,2)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dBy
	    q715 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,2); // d/dBy
	    q716 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,2)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dBy
	    q717 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dBy
	    q718 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,2,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dBy
	    q719 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[710] += q710*C_[0];
	I[711] += q711*C_[0];
	I[712] += q712*C_[0];
	I[713] += q713*C_[0];
	I[714] += q714*C_[0];
	I[715] += q715*C_[0];
	I[716] += q716*C_[0];
	I[717] += q717*C_[0];
	I[718] += q718*C_[0];
	I[719] += q719*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q720 = 0.0;
	T q721 = 0.0;
	T q722 = 0.0;
	T q723 = 0.0;
	T q724 = 0.0;
	T q725 = 0.0;
	T q726 = 0.0;
	T q727 = 0.0;
	T q728 = 0.0;
	T q729 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q720 += beta*Ix(a,0,4)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q721 += beta*Ix(a,0,0)*Iy(a,1,5)*Iz(a,2,0)
                     - 4*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,0);  // d/dBy
	    q722 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,4); // d/dBy
	    q723 += beta*Ix(a,0,3)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,0);  // d/dBy
	    q724 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,2,1); // d/dBy
	    q725 += beta*Ix(a,0,1)*Iy(a,1,4)*Iz(a,2,0)
                     - 3*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,0);  // d/dBy
	    q726 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,2,1)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,1);  // d/dBy
	    q727 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,3); // d/dBy
	    q728 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,3);  // d/dBy
	    q729 += beta*Ix(a,0,2)*Iy(a,1,3)*Iz(a,2,0)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[720] += q720*C_[0];
	I[721] += q721*C_[0];
	I[722] += q722*C_[0];
	I[723] += q723*C_[0];
	I[724] += q724*C_[0];
	I[725] += q725*C_[0];
	I[726] += q726*C_[0];
	I[727] += q727*C_[0];
	I[728] += q728*C_[0];
	I[729] += q729*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q730 = 0.0;
	T q731 = 0.0;
	T q732 = 0.0;
	T q733 = 0.0;
	T q734 = 0.0;
	T q735 = 0.0;
	T q736 = 0.0;
	T q737 = 0.0;
	T q738 = 0.0;
	T q739 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q730 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,2); // d/dBy
	    q731 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,2)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,2);  // d/dBy
	    q732 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,1);  // d/dBy
	    q733 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1);  // d/dBy
	    q734 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,2);  // d/dBy
	    q735 += beta*Ix(a,1,4)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q736 += beta*Ix(a,1,0)*Iy(a,1,5)*Iz(a,1,0)
                     - 4*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dBy
	    q737 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,4); // d/dBy
	    q738 += beta*Ix(a,1,3)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q739 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[730] += q730*C_[0];
	I[731] += q731*C_[0];
	I[732] += q732*C_[0];
	I[733] += q733*C_[0];
	I[734] += q734*C_[0];
	I[735] += q735*C_[0];
	I[736] += q736*C_[0];
	I[737] += q737*C_[0];
	I[738] += q738*C_[0];
	I[739] += q739*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q740 = 0.0;
	T q741 = 0.0;
	T q742 = 0.0;
	T q743 = 0.0;
	T q744 = 0.0;
	T q745 = 0.0;
	T q746 = 0.0;
	T q747 = 0.0;
	T q748 = 0.0;
	T q749 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q740 += beta*Ix(a,1,1)*Iy(a,1,4)*Iz(a,1,0)
                     - 3*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dBy
	    q741 += beta*Ix(a,1,0)*Iy(a,1,4)*Iz(a,1,1)
                     - 3*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dBy
	    q742 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,3); // d/dBy
	    q743 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,3)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dBy
	    q744 += beta*Ix(a,1,2)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dBy
	    q745 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,2); // d/dBy
	    q746 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dBy
	    q747 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dBy
	    q748 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dBy
	    q749 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[740] += q740*C_[0];
	I[741] += q741*C_[0];
	I[742] += q742*C_[0];
	I[743] += q743*C_[0];
	I[744] += q744*C_[0];
	I[745] += q745*C_[0];
	I[746] += q746*C_[0];
	I[747] += q747*C_[0];
	I[748] += q748*C_[0];
	I[749] += q749*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q750 = 0.0;
	T q751 = 0.0;
	T q752 = 0.0;
	T q753 = 0.0;
	T q754 = 0.0;
	T q755 = 0.0;
	T q756 = 0.0;
	T q757 = 0.0;
	T q758 = 0.0;
	T q759 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q750 += beta*Ix(a,3,4)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q751 += beta*Ix(a,3,0)*Iy(a,0,4)*Iz(a,0,1); // d/dBz
	    q752 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,5)
                     - 4*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBz
	    q753 += beta*Ix(a,3,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q754 += beta*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q755 += beta*Ix(a,3,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q756 += beta*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBz
	    q757 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q758 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,4)
                     - 3*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBz
	    q759 += beta*Ix(a,3,2)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[750] += q750*C_[0];
	I[751] += q751*C_[0];
	I[752] += q752*C_[0];
	I[753] += q753*C_[0];
	I[754] += q754*C_[0];
	I[755] += q755*C_[0];
	I[756] += q756*C_[0];
	I[757] += q757*C_[0];
	I[758] += q758*C_[0];
	I[759] += q759*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q760 = 0.0;
	T q761 = 0.0;
	T q762 = 0.0;
	T q763 = 0.0;
	T q764 = 0.0;
	T q765 = 0.0;
	T q766 = 0.0;
	T q767 = 0.0;
	T q768 = 0.0;
	T q769 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q760 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q761 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 2*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBz
	    q762 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q763 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q764 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	    q765 += beta*Ix(a,0,4)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q766 += beta*Ix(a,0,0)*Iy(a,3,4)*Iz(a,0,1); // d/dBz
	    q767 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,5)
                     - 4*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,3);  // d/dBz
	    q768 += beta*Ix(a,0,3)*Iy(a,3,1)*Iz(a,0,1); // d/dBz
	    q769 += beta*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[760] += q760*C_[0];
	I[761] += q761*C_[0];
	I[762] += q762*C_[0];
	I[763] += q763*C_[0];
	I[764] += q764*C_[0];
	I[765] += q765*C_[0];
	I[766] += q766*C_[0];
	I[767] += q767*C_[0];
	I[768] += q768*C_[0];
	I[769] += q769*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q770 = 0.0;
	T q771 = 0.0;
	T q772 = 0.0;
	T q773 = 0.0;
	T q774 = 0.0;
	T q775 = 0.0;
	T q776 = 0.0;
	T q777 = 0.0;
	T q778 = 0.0;
	T q779 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q770 += beta*Ix(a,0,1)*Iy(a,3,3)*Iz(a,0,1); // d/dBz
	    q771 += beta*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,0);  // d/dBz
	    q772 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,4)
                     - 3*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,2);  // d/dBz
	    q773 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,2);  // d/dBz
	    q774 += beta*Ix(a,0,2)*Iy(a,3,2)*Iz(a,0,1); // d/dBz
	    q775 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,1);  // d/dBz
	    q776 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,1);  // d/dBz
	    q777 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,0);  // d/dBz
	    q778 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,0);  // d/dBz
	    q779 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[770] += q770*C_[0];
	I[771] += q771*C_[0];
	I[772] += q772*C_[0];
	I[773] += q773*C_[0];
	I[774] += q774*C_[0];
	I[775] += q775*C_[0];
	I[776] += q776*C_[0];
	I[777] += q777*C_[0];
	I[778] += q778*C_[0];
	I[779] += q779*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q780 = 0.0;
	T q781 = 0.0;
	T q782 = 0.0;
	T q783 = 0.0;
	T q784 = 0.0;
	T q785 = 0.0;
	T q786 = 0.0;
	T q787 = 0.0;
	T q788 = 0.0;
	T q789 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q780 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q781 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,3,1); // d/dBz
	    q782 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,5)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,3);  // d/dBz
	    q783 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,3,1); // d/dBz
	    q784 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,0);  // d/dBz
	    q785 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,3,1); // d/dBz
	    q786 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,0);  // d/dBz
	    q787 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,4)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,2);  // d/dBz
	    q788 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,4)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,2);  // d/dBz
	    q789 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,3,1); // d/dBz
	}
	    
	//contraction coefficients
	I[780] += q780*C_[0];
	I[781] += q781*C_[0];
	I[782] += q782*C_[0];
	I[783] += q783*C_[0];
	I[784] += q784*C_[0];
	I[785] += q785*C_[0];
	I[786] += q786*C_[0];
	I[787] += q787*C_[0];
	I[788] += q788*C_[0];
	I[789] += q789*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q790 = 0.0;
	T q791 = 0.0;
	T q792 = 0.0;
	T q793 = 0.0;
	T q794 = 0.0;
	T q795 = 0.0;
	T q796 = 0.0;
	T q797 = 0.0;
	T q798 = 0.0;
	T q799 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q790 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,1);  // d/dBz
	    q791 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,1);  // d/dBz
	    q792 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,2)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,0);  // d/dBz
	    q793 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,0);  // d/dBz
	    q794 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,3)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,1);  // d/dBz
	    q795 += beta*Ix(a,2,4)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q796 += beta*Ix(a,2,0)*Iy(a,1,4)*Iz(a,0,1); // d/dBz
	    q797 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,5)
                     - 4*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBz
	    q798 += beta*Ix(a,2,3)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q799 += beta*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[790] += q790*C_[0];
	I[791] += q791*C_[0];
	I[792] += q792*C_[0];
	I[793] += q793*C_[0];
	I[794] += q794*C_[0];
	I[795] += q795*C_[0];
	I[796] += q796*C_[0];
	I[797] += q797*C_[0];
	I[798] += q798*C_[0];
	I[799] += q799*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q800 = 0.0;
	T q801 = 0.0;
	T q802 = 0.0;
	T q803 = 0.0;
	T q804 = 0.0;
	T q805 = 0.0;
	T q806 = 0.0;
	T q807 = 0.0;
	T q808 = 0.0;
	T q809 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q800 += beta*Ix(a,2,1)*Iy(a,1,3)*Iz(a,0,1); // d/dBz
	    q801 += beta*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBz
	    q802 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBz
	    q803 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,4)
                     - 3*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBz
	    q804 += beta*Ix(a,2,2)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	    q805 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q806 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBz
	    q807 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	    q808 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBz
	    q809 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[800] += q800*C_[0];
	I[801] += q801*C_[0];
	I[802] += q802*C_[0];
	I[803] += q803*C_[0];
	I[804] += q804*C_[0];
	I[805] += q805*C_[0];
	I[806] += q806*C_[0];
	I[807] += q807*C_[0];
	I[808] += q808*C_[0];
	I[809] += q809*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q810 = 0.0;
	T q811 = 0.0;
	T q812 = 0.0;
	T q813 = 0.0;
	T q814 = 0.0;
	T q815 = 0.0;
	T q816 = 0.0;
	T q817 = 0.0;
	T q818 = 0.0;
	T q819 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q810 += beta*Ix(a,2,4)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q811 += beta*Ix(a,2,0)*Iy(a,0,4)*Iz(a,1,1); // d/dBz
	    q812 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,5)
                     - 4*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBz
	    q813 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q814 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	    q815 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,1,1); // d/dBz
	    q816 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBz
	    q817 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBz
	    q818 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,4)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBz
	    q819 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[810] += q810*C_[0];
	I[811] += q811*C_[0];
	I[812] += q812*C_[0];
	I[813] += q813*C_[0];
	I[814] += q814*C_[0];
	I[815] += q815*C_[0];
	I[816] += q816*C_[0];
	I[817] += q817*C_[0];
	I[818] += q818*C_[0];
	I[819] += q819*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q820 = 0.0;
	T q821 = 0.0;
	T q822 = 0.0;
	T q823 = 0.0;
	T q824 = 0.0;
	T q825 = 0.0;
	T q826 = 0.0;
	T q827 = 0.0;
	T q828 = 0.0;
	T q829 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q820 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q821 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,3)
                     - 2*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBz
	    q822 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	    q823 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBz
	    q824 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBz
	    q825 += beta*Ix(a,1,4)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q826 += beta*Ix(a,1,0)*Iy(a,2,4)*Iz(a,0,1); // d/dBz
	    q827 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,5)
                     - 4*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dBz
	    q828 += beta*Ix(a,1,3)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q829 += beta*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[820] += q820*C_[0];
	I[821] += q821*C_[0];
	I[822] += q822*C_[0];
	I[823] += q823*C_[0];
	I[824] += q824*C_[0];
	I[825] += q825*C_[0];
	I[826] += q826*C_[0];
	I[827] += q827*C_[0];
	I[828] += q828*C_[0];
	I[829] += q829*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q830 = 0.0;
	T q831 = 0.0;
	T q832 = 0.0;
	T q833 = 0.0;
	T q834 = 0.0;
	T q835 = 0.0;
	T q836 = 0.0;
	T q837 = 0.0;
	T q838 = 0.0;
	T q839 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q830 += beta*Ix(a,1,1)*Iy(a,2,3)*Iz(a,0,1); // d/dBz
	    q831 += beta*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dBz
	    q832 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,4)
                     - 3*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dBz
	    q833 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dBz
	    q834 += beta*Ix(a,1,2)*Iy(a,2,2)*Iz(a,0,1); // d/dBz
	    q835 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dBz
	    q836 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dBz
	    q837 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dBz
	    q838 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dBz
	    q839 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[830] += q830*C_[0];
	I[831] += q831*C_[0];
	I[832] += q832*C_[0];
	I[833] += q833*C_[0];
	I[834] += q834*C_[0];
	I[835] += q835*C_[0];
	I[836] += q836*C_[0];
	I[837] += q837*C_[0];
	I[838] += q838*C_[0];
	I[839] += q839*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q840 = 0.0;
	T q841 = 0.0;
	T q842 = 0.0;
	T q843 = 0.0;
	T q844 = 0.0;
	T q845 = 0.0;
	T q846 = 0.0;
	T q847 = 0.0;
	T q848 = 0.0;
	T q849 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q840 += beta*Ix(a,0,4)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q841 += beta*Ix(a,0,0)*Iy(a,2,4)*Iz(a,1,1); // d/dBz
	    q842 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,5)
                     - 4*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,3);  // d/dBz
	    q843 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,1,1); // d/dBz
	    q844 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,0);  // d/dBz
	    q845 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,1,1); // d/dBz
	    q846 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,0);  // d/dBz
	    q847 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,4)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,2);  // d/dBz
	    q848 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,2);  // d/dBz
	    q849 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[840] += q840*C_[0];
	I[841] += q841*C_[0];
	I[842] += q842*C_[0];
	I[843] += q843*C_[0];
	I[844] += q844*C_[0];
	I[845] += q845*C_[0];
	I[846] += q846*C_[0];
	I[847] += q847*C_[0];
	I[848] += q848*C_[0];
	I[849] += q849*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q850 = 0.0;
	T q851 = 0.0;
	T q852 = 0.0;
	T q853 = 0.0;
	T q854 = 0.0;
	T q855 = 0.0;
	T q856 = 0.0;
	T q857 = 0.0;
	T q858 = 0.0;
	T q859 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q850 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,3)
                     - 2*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,1);  // d/dBz
	    q851 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,1);  // d/dBz
	    q852 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,0);  // d/dBz
	    q853 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,0);  // d/dBz
	    q854 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,1);  // d/dBz
	    q855 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q856 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,2,1); // d/dBz
	    q857 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,5)
                     - 4*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dBz
	    q858 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q859 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[850] += q850*C_[0];
	I[851] += q851*C_[0];
	I[852] += q852*C_[0];
	I[853] += q853*C_[0];
	I[854] += q854*C_[0];
	I[855] += q855*C_[0];
	I[856] += q856*C_[0];
	I[857] += q857*C_[0];
	I[858] += q858*C_[0];
	I[859] += q859*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q860 = 0.0;
	T q861 = 0.0;
	T q862 = 0.0;
	T q863 = 0.0;
	T q864 = 0.0;
	T q865 = 0.0;
	T q866 = 0.0;
	T q867 = 0.0;
	T q868 = 0.0;
	T q869 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q860 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,2,1); // d/dBz
	    q861 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dBz
	    q862 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,4)
                     - 3*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dBz
	    q863 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,4)
                     - 3*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dBz
	    q864 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,2,1); // d/dBz
	    q865 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dBz
	    q866 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,3)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dBz
	    q867 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dBz
	    q868 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dBz
	    q869 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,3)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[860] += q860*C_[0];
	I[861] += q861*C_[0];
	I[862] += q862*C_[0];
	I[863] += q863*C_[0];
	I[864] += q864*C_[0];
	I[865] += q865*C_[0];
	I[866] += q866*C_[0];
	I[867] += q867*C_[0];
	I[868] += q868*C_[0];
	I[869] += q869*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q870 = 0.0;
	T q871 = 0.0;
	T q872 = 0.0;
	T q873 = 0.0;
	T q874 = 0.0;
	T q875 = 0.0;
	T q876 = 0.0;
	T q877 = 0.0;
	T q878 = 0.0;
	T q879 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q870 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q871 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,2,1); // d/dBz
	    q872 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,5)
                     - 4*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,3);  // d/dBz
	    q873 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,2,1); // d/dBz
	    q874 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,0);  // d/dBz
	    q875 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,2,1); // d/dBz
	    q876 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,0);  // d/dBz
	    q877 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,4)
                     - 3*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,2);  // d/dBz
	    q878 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,4)
                     - 3*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,2);  // d/dBz
	    q879 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,2,1); // d/dBz
	}
	    
	//contraction coefficients
	I[870] += q870*C_[0];
	I[871] += q871*C_[0];
	I[872] += q872*C_[0];
	I[873] += q873*C_[0];
	I[874] += q874*C_[0];
	I[875] += q875*C_[0];
	I[876] += q876*C_[0];
	I[877] += q877*C_[0];
	I[878] += q878*C_[0];
	I[879] += q879*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q880 = 0.0;
	T q881 = 0.0;
	T q882 = 0.0;
	T q883 = 0.0;
	T q884 = 0.0;
	T q885 = 0.0;
	T q886 = 0.0;
	T q887 = 0.0;
	T q888 = 0.0;
	T q889 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q880 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,3)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,1);  // d/dBz
	    q881 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,1);  // d/dBz
	    q882 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,0);  // d/dBz
	    q883 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,0);  // d/dBz
	    q884 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,3)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,1);  // d/dBz
	    q885 += beta*Ix(a,1,4)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q886 += beta*Ix(a,1,0)*Iy(a,1,4)*Iz(a,1,1); // d/dBz
	    q887 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,5)
                     - 4*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dBz
	    q888 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q889 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[880] += q880*C_[0];
	I[881] += q881*C_[0];
	I[882] += q882*C_[0];
	I[883] += q883*C_[0];
	I[884] += q884*C_[0];
	I[885] += q885*C_[0];
	I[886] += q886*C_[0];
	I[887] += q887*C_[0];
	I[888] += q888*C_[0];
	I[889] += q889*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q890 = 0.0;
	T q891 = 0.0;
	T q892 = 0.0;
	T q893 = 0.0;
	T q894 = 0.0;
	T q895 = 0.0;
	T q896 = 0.0;
	T q897 = 0.0;
	T q898 = 0.0;
	T q899 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q890 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,1); // d/dBz
	    q891 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dBz
	    q892 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,4)
                     - 3*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dBz
	    q893 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,4)
                     - 3*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dBz
	    q894 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,1); // d/dBz
	    q895 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dBz
	    q896 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dBz
	    q897 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dBz
	    q898 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dBz
	    q899 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,3)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[890] += q890*C_[0];
	I[891] += q891*C_[0];
	I[892] += q892*C_[0];
	I[893] += q893*C_[0];
	I[894] += q894*C_[0];
	I[895] += q895*C_[0];
	I[896] += q896*C_[0];
	I[897] += q897*C_[0];
	I[898] += q898*C_[0];
	I[899] += q899*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <gg| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::G,rysq::G> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::G,rysq::G> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 6;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,5,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,3,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,5,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 4*Ix(a,3,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,5,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 4*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAx
	    q3 += alpha*Ix(a,5,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 4*Ix(a,3,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q4 += alpha*Ix(a,5,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 4*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q5 += alpha*Ix(a,5,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 4*Ix(a,3,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,5,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 4*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAx
	    q7 += alpha*Ix(a,5,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 4*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAx
	    q8 += alpha*Ix(a,5,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 4*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAx
	    q9 += alpha*Ix(a,5,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 4*Ix(a,3,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,5,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 4*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q11 += alpha*Ix(a,5,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 4*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAx
	    q12 += alpha*Ix(a,5,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 4*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	    q13 += alpha*Ix(a,5,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 4*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAx
	    q14 += alpha*Ix(a,5,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 4*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAx
	    q15 += alpha*Ix(a,1,4)*Iy(a,4,0)*Iz(a,0,0); // d/dAx
	    q16 += alpha*Ix(a,1,0)*Iy(a,4,4)*Iz(a,0,0); // d/dAx
	    q17 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,4); // d/dAx
	    q18 += alpha*Ix(a,1,3)*Iy(a,4,1)*Iz(a,0,0); // d/dAx
	    q19 += alpha*Ix(a,1,3)*Iy(a,4,0)*Iz(a,0,1); // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[0];
	I[16] += q16*C_[0];
	I[17] += q17*C_[0];
	I[18] += q18*C_[0];
	I[19] += q19*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,1)*Iy(a,4,3)*Iz(a,0,0); // d/dAx
	    q21 += alpha*Ix(a,1,0)*Iy(a,4,3)*Iz(a,0,1); // d/dAx
	    q22 += alpha*Ix(a,1,1)*Iy(a,4,0)*Iz(a,0,3); // d/dAx
	    q23 += alpha*Ix(a,1,0)*Iy(a,4,1)*Iz(a,0,3); // d/dAx
	    q24 += alpha*Ix(a,1,2)*Iy(a,4,2)*Iz(a,0,0); // d/dAx
	    q25 += alpha*Ix(a,1,2)*Iy(a,4,0)*Iz(a,0,2); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,4,2)*Iz(a,0,2); // d/dAx
	    q27 += alpha*Ix(a,1,2)*Iy(a,4,1)*Iz(a,0,1); // d/dAx
	    q28 += alpha*Ix(a,1,1)*Iy(a,4,2)*Iz(a,0,1); // d/dAx
	    q29 += alpha*Ix(a,1,1)*Iy(a,4,1)*Iz(a,0,2); // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[0];
	I[22] += q22*C_[0];
	I[23] += q23*C_[0];
	I[24] += q24*C_[0];
	I[25] += q25*C_[0];
	I[26] += q26*C_[0];
	I[27] += q27*C_[0];
	I[28] += q28*C_[0];
	I[29] += q29*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,4,0); // d/dAx
	    q31 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,4,0); // d/dAx
	    q32 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,4); // d/dAx
	    q33 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,4,0); // d/dAx
	    q34 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,4,1); // d/dAx
	    q35 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,4,0); // d/dAx
	    q36 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,4,1); // d/dAx
	    q37 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,4,3); // d/dAx
	    q38 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,4,3); // d/dAx
	    q39 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,4,0); // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[0];
	I[31] += q31*C_[0];
	I[32] += q32*C_[0];
	I[33] += q33*C_[0];
	I[34] += q34*C_[0];
	I[35] += q35*C_[0];
	I[36] += q36*C_[0];
	I[37] += q37*C_[0];
	I[38] += q38*C_[0];
	I[39] += q39*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,4,2); // d/dAx
	    q41 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,4,2); // d/dAx
	    q42 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,4,1); // d/dAx
	    q43 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,4,1); // d/dAx
	    q44 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,4,2); // d/dAx
	    q45 += alpha*Ix(a,4,4)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,2,4)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q46 += alpha*Ix(a,4,0)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,1,4)*Iz(a,0,0);  // d/dAx
	    q47 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,4);  // d/dAx
	    q48 += alpha*Ix(a,4,3)*Iy(a,1,1)*Iz(a,0,0)
                     - 3*Ix(a,2,3)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q49 += alpha*Ix(a,4,3)*Iy(a,1,0)*Iz(a,0,1)
                     - 3*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[0];
	I[42] += q42*C_[0];
	I[43] += q43*C_[0];
	I[44] += q44*C_[0];
	I[45] += q45*C_[0];
	I[46] += q46*C_[0];
	I[47] += q47*C_[0];
	I[48] += q48*C_[0];
	I[49] += q49*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,4,1)*Iy(a,1,3)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,1,3)*Iz(a,0,0);  // d/dAx
	    q51 += alpha*Ix(a,4,0)*Iy(a,1,3)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,1);  // d/dAx
	    q52 += alpha*Ix(a,4,1)*Iy(a,1,0)*Iz(a,0,3)
                     - 3*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,3);  // d/dAx
	    q53 += alpha*Ix(a,4,0)*Iy(a,1,1)*Iz(a,0,3)
                     - 3*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,3);  // d/dAx
	    q54 += alpha*Ix(a,4,2)*Iy(a,1,2)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,1,2)*Iz(a,0,0);  // d/dAx
	    q55 += alpha*Ix(a,4,2)*Iy(a,1,0)*Iz(a,0,2)
                     - 3*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,2);  // d/dAx
	    q56 += alpha*Ix(a,4,0)*Iy(a,1,2)*Iz(a,0,2)
                     - 3*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,2);  // d/dAx
	    q57 += alpha*Ix(a,4,2)*Iy(a,1,1)*Iz(a,0,1)
                     - 3*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,1);  // d/dAx
	    q58 += alpha*Ix(a,4,1)*Iy(a,1,2)*Iz(a,0,1)
                     - 3*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,1);  // d/dAx
	    q59 += alpha*Ix(a,4,1)*Iy(a,1,1)*Iz(a,0,2)
                     - 3*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[0];
	I[51] += q51*C_[0];
	I[52] += q52*C_[0];
	I[53] += q53*C_[0];
	I[54] += q54*C_[0];
	I[55] += q55*C_[0];
	I[56] += q56*C_[0];
	I[57] += q57*C_[0];
	I[58] += q58*C_[0];
	I[59] += q59*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,4,4)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,2,4)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q61 += alpha*Ix(a,4,0)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,2,0)*Iy(a,0,4)*Iz(a,1,0);  // d/dAx
	    q62 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,4);  // d/dAx
	    q63 += alpha*Ix(a,4,3)*Iy(a,0,1)*Iz(a,1,0)
                     - 3*Ix(a,2,3)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q64 += alpha*Ix(a,4,3)*Iy(a,0,0)*Iz(a,1,1)
                     - 3*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	    q65 += alpha*Ix(a,4,1)*Iy(a,0,3)*Iz(a,1,0)
                     - 3*Ix(a,2,1)*Iy(a,0,3)*Iz(a,1,0);  // d/dAx
	    q66 += alpha*Ix(a,4,0)*Iy(a,0,3)*Iz(a,1,1)
                     - 3*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,1);  // d/dAx
	    q67 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,1,3)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,3);  // d/dAx
	    q68 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,1,3)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,3);  // d/dAx
	    q69 += alpha*Ix(a,4,2)*Iy(a,0,2)*Iz(a,1,0)
                     - 3*Ix(a,2,2)*Iy(a,0,2)*Iz(a,1,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,4,2)*Iy(a,0,0)*Iz(a,1,2)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,2);  // d/dAx
	    q71 += alpha*Ix(a,4,0)*Iy(a,0,2)*Iz(a,1,2)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,2);  // d/dAx
	    q72 += alpha*Ix(a,4,2)*Iy(a,0,1)*Iz(a,1,1)
                     - 3*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,1);  // d/dAx
	    q73 += alpha*Ix(a,4,1)*Iy(a,0,2)*Iz(a,1,1)
                     - 3*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,1);  // d/dAx
	    q74 += alpha*Ix(a,4,1)*Iy(a,0,1)*Iz(a,1,2)
                     - 3*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,2);  // d/dAx
	    q75 += alpha*Ix(a,2,4)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,0,4)*Iy(a,3,0)*Iz(a,0,0);  // d/dAx
	    q76 += alpha*Ix(a,2,0)*Iy(a,3,4)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,4)*Iz(a,0,0);  // d/dAx
	    q77 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,4)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,4);  // d/dAx
	    q78 += alpha*Ix(a,2,3)*Iy(a,3,1)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,3,1)*Iz(a,0,0);  // d/dAx
	    q79 += alpha*Ix(a,2,3)*Iy(a,3,0)*Iz(a,0,1)
                     - 1*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[0];
	I[76] += q76*C_[0];
	I[77] += q77*C_[0];
	I[78] += q78*C_[0];
	I[79] += q79*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,2,1)*Iy(a,3,3)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,3,3)*Iz(a,0,0);  // d/dAx
	    q81 += alpha*Ix(a,2,0)*Iy(a,3,3)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,1);  // d/dAx
	    q82 += alpha*Ix(a,2,1)*Iy(a,3,0)*Iz(a,0,3)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,3);  // d/dAx
	    q83 += alpha*Ix(a,2,0)*Iy(a,3,1)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,3);  // d/dAx
	    q84 += alpha*Ix(a,2,2)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,3,2)*Iz(a,0,0);  // d/dAx
	    q85 += alpha*Ix(a,2,2)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,2);  // d/dAx
	    q86 += alpha*Ix(a,2,0)*Iy(a,3,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,2);  // d/dAx
	    q87 += alpha*Ix(a,2,2)*Iy(a,3,1)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,1);  // d/dAx
	    q88 += alpha*Ix(a,2,1)*Iy(a,3,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,1);  // d/dAx
	    q89 += alpha*Ix(a,2,1)*Iy(a,3,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[0];
	I[82] += q82*C_[0];
	I[83] += q83*C_[0];
	I[84] += q84*C_[0];
	I[85] += q85*C_[0];
	I[86] += q86*C_[0];
	I[87] += q87*C_[0];
	I[88] += q88*C_[0];
	I[89] += q89*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,1,4)*Iy(a,3,0)*Iz(a,1,0); // d/dAx
	    q91 += alpha*Ix(a,1,0)*Iy(a,3,4)*Iz(a,1,0); // d/dAx
	    q92 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,4); // d/dAx
	    q93 += alpha*Ix(a,1,3)*Iy(a,3,1)*Iz(a,1,0); // d/dAx
	    q94 += alpha*Ix(a,1,3)*Iy(a,3,0)*Iz(a,1,1); // d/dAx
	    q95 += alpha*Ix(a,1,1)*Iy(a,3,3)*Iz(a,1,0); // d/dAx
	    q96 += alpha*Ix(a,1,0)*Iy(a,3,3)*Iz(a,1,1); // d/dAx
	    q97 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,3); // d/dAx
	    q98 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,3); // d/dAx
	    q99 += alpha*Ix(a,1,2)*Iy(a,3,2)*Iz(a,1,0); // d/dAx
	}
	    
	//contraction coefficients
	I[90] += q90*C_[0];
	I[91] += q91*C_[0];
	I[92] += q92*C_[0];
	I[93] += q93*C_[0];
	I[94] += q94*C_[0];
	I[95] += q95*C_[0];
	I[96] += q96*C_[0];
	I[97] += q97*C_[0];
	I[98] += q98*C_[0];
	I[99] += q99*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,1,2); // d/dAx
	    q101 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,1,2); // d/dAx
	    q102 += alpha*Ix(a,1,2)*Iy(a,3,1)*Iz(a,1,1); // d/dAx
	    q103 += alpha*Ix(a,1,1)*Iy(a,3,2)*Iz(a,1,1); // d/dAx
	    q104 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,1,2); // d/dAx
	    q105 += alpha*Ix(a,2,4)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,3,0);  // d/dAx
	    q106 += alpha*Ix(a,2,0)*Iy(a,0,4)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,3,0);  // d/dAx
	    q107 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,4);  // d/dAx
	    q108 += alpha*Ix(a,2,3)*Iy(a,0,1)*Iz(a,3,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,3,0);  // d/dAx
	    q109 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,3,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[0];
	I[102] += q102*C_[0];
	I[103] += q103*C_[0];
	I[104] += q104*C_[0];
	I[105] += q105*C_[0];
	I[106] += q106*C_[0];
	I[107] += q107*C_[0];
	I[108] += q108*C_[0];
	I[109] += q109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,2,1)*Iy(a,0,3)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,3,0);  // d/dAx
	    q111 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,1);  // d/dAx
	    q112 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,3,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,3);  // d/dAx
	    q113 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,3,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,3);  // d/dAx
	    q114 += alpha*Ix(a,2,2)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,3,0);  // d/dAx
	    q115 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,2);  // d/dAx
	    q116 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,2);  // d/dAx
	    q117 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,3,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,1);  // d/dAx
	    q118 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,3,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,1);  // d/dAx
	    q119 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[110] += q110*C_[0];
	I[111] += q111*C_[0];
	I[112] += q112*C_[0];
	I[113] += q113*C_[0];
	I[114] += q114*C_[0];
	I[115] += q115*C_[0];
	I[116] += q116*C_[0];
	I[117] += q117*C_[0];
	I[118] += q118*C_[0];
	I[119] += q119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,3,0); // d/dAx
	    q121 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,3,0); // d/dAx
	    q122 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,4); // d/dAx
	    q123 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,3,0); // d/dAx
	    q124 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,3,1); // d/dAx
	    q125 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,3,0); // d/dAx
	    q126 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,3,1); // d/dAx
	    q127 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,3); // d/dAx
	    q128 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,3); // d/dAx
	    q129 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,3,0); // d/dAx
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,3,2); // d/dAx
	    q131 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,3,2); // d/dAx
	    q132 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,3,1); // d/dAx
	    q133 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,3,1); // d/dAx
	    q134 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,3,2); // d/dAx
	    q135 += alpha*Ix(a,3,4)*Iy(a,2,0)*Iz(a,0,0)
                     - 2*Ix(a,1,4)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q136 += alpha*Ix(a,3,0)*Iy(a,2,4)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,2,4)*Iz(a,0,0);  // d/dAx
	    q137 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,4)
                     - 2*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,4);  // d/dAx
	    q138 += alpha*Ix(a,3,3)*Iy(a,2,1)*Iz(a,0,0)
                     - 2*Ix(a,1,3)*Iy(a,2,1)*Iz(a,0,0);  // d/dAx
	    q139 += alpha*Ix(a,3,3)*Iy(a,2,0)*Iz(a,0,1)
                     - 2*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[0];
	I[136] += q136*C_[0];
	I[137] += q137*C_[0];
	I[138] += q138*C_[0];
	I[139] += q139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += alpha*Ix(a,3,1)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,2,3)*Iz(a,0,0);  // d/dAx
	    q141 += alpha*Ix(a,3,0)*Iy(a,2,3)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,1);  // d/dAx
	    q142 += alpha*Ix(a,3,1)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,3);  // d/dAx
	    q143 += alpha*Ix(a,3,0)*Iy(a,2,1)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,3);  // d/dAx
	    q144 += alpha*Ix(a,3,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,2,2)*Iz(a,0,0);  // d/dAx
	    q145 += alpha*Ix(a,3,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 2*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,2);  // d/dAx
	    q146 += alpha*Ix(a,3,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,2);  // d/dAx
	    q147 += alpha*Ix(a,3,2)*Iy(a,2,1)*Iz(a,0,1)
                     - 2*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,1);  // d/dAx
	    q148 += alpha*Ix(a,3,1)*Iy(a,2,2)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,1);  // d/dAx
	    q149 += alpha*Ix(a,3,1)*Iy(a,2,1)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[0];
	I[142] += q142*C_[0];
	I[143] += q143*C_[0];
	I[144] += q144*C_[0];
	I[145] += q145*C_[0];
	I[146] += q146*C_[0];
	I[147] += q147*C_[0];
	I[148] += q148*C_[0];
	I[149] += q149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += alpha*Ix(a,3,4)*Iy(a,0,0)*Iz(a,2,0)
                     - 2*Ix(a,1,4)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q151 += alpha*Ix(a,3,0)*Iy(a,0,4)*Iz(a,2,0)
                     - 2*Ix(a,1,0)*Iy(a,0,4)*Iz(a,2,0);  // d/dAx
	    q152 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,4)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,4);  // d/dAx
	    q153 += alpha*Ix(a,3,3)*Iy(a,0,1)*Iz(a,2,0)
                     - 2*Ix(a,1,3)*Iy(a,0,1)*Iz(a,2,0);  // d/dAx
	    q154 += alpha*Ix(a,3,3)*Iy(a,0,0)*Iz(a,2,1)
                     - 2*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,1);  // d/dAx
	    q155 += alpha*Ix(a,3,1)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,0,3)*Iz(a,2,0);  // d/dAx
	    q156 += alpha*Ix(a,3,0)*Iy(a,0,3)*Iz(a,2,1)
                     - 2*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,1);  // d/dAx
	    q157 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,3);  // d/dAx
	    q158 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,2,3)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,3);  // d/dAx
	    q159 += alpha*Ix(a,3,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 2*Ix(a,1,2)*Iy(a,0,2)*Iz(a,2,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[150] += q150*C_[0];
	I[151] += q151*C_[0];
	I[152] += q152*C_[0];
	I[153] += q153*C_[0];
	I[154] += q154*C_[0];
	I[155] += q155*C_[0];
	I[156] += q156*C_[0];
	I[157] += q157*C_[0];
	I[158] += q158*C_[0];
	I[159] += q159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,2);  // d/dAx
	    q161 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,2);  // d/dAx
	    q162 += alpha*Ix(a,3,2)*Iy(a,0,1)*Iz(a,2,1)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,1);  // d/dAx
	    q163 += alpha*Ix(a,3,1)*Iy(a,0,2)*Iz(a,2,1)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,1);  // d/dAx
	    q164 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,2,2)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,2);  // d/dAx
	    q165 += alpha*Ix(a,1,4)*Iy(a,2,0)*Iz(a,2,0); // d/dAx
	    q166 += alpha*Ix(a,1,0)*Iy(a,2,4)*Iz(a,2,0); // d/dAx
	    q167 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,4); // d/dAx
	    q168 += alpha*Ix(a,1,3)*Iy(a,2,1)*Iz(a,2,0); // d/dAx
	    q169 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,2,1); // d/dAx
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[0];
	I[162] += q162*C_[0];
	I[163] += q163*C_[0];
	I[164] += q164*C_[0];
	I[165] += q165*C_[0];
	I[166] += q166*C_[0];
	I[167] += q167*C_[0];
	I[168] += q168*C_[0];
	I[169] += q169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += alpha*Ix(a,1,1)*Iy(a,2,3)*Iz(a,2,0); // d/dAx
	    q171 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,2,1); // d/dAx
	    q172 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,3); // d/dAx
	    q173 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,3); // d/dAx
	    q174 += alpha*Ix(a,1,2)*Iy(a,2,2)*Iz(a,2,0); // d/dAx
	    q175 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,2,2); // d/dAx
	    q176 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,2,2); // d/dAx
	    q177 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,2,1); // d/dAx
	    q178 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,2,1); // d/dAx
	    q179 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,2,2); // d/dAx
	}
	    
	//contraction coefficients
	I[170] += q170*C_[0];
	I[171] += q171*C_[0];
	I[172] += q172*C_[0];
	I[173] += q173*C_[0];
	I[174] += q174*C_[0];
	I[175] += q175*C_[0];
	I[176] += q176*C_[0];
	I[177] += q177*C_[0];
	I[178] += q178*C_[0];
	I[179] += q179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += alpha*Ix(a,3,4)*Iy(a,1,0)*Iz(a,1,0)
                     - 2*Ix(a,1,4)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q181 += alpha*Ix(a,3,0)*Iy(a,1,4)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,4)*Iz(a,1,0);  // d/dAx
	    q182 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,4)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,4);  // d/dAx
	    q183 += alpha*Ix(a,3,3)*Iy(a,1,1)*Iz(a,1,0)
                     - 2*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,0);  // d/dAx
	    q184 += alpha*Ix(a,3,3)*Iy(a,1,0)*Iz(a,1,1)
                     - 2*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,1);  // d/dAx
	    q185 += alpha*Ix(a,3,1)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,0);  // d/dAx
	    q186 += alpha*Ix(a,3,0)*Iy(a,1,3)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,1);  // d/dAx
	    q187 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,3);  // d/dAx
	    q188 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,3);  // d/dAx
	    q189 += alpha*Ix(a,3,2)*Iy(a,1,2)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,1,2)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,2);  // d/dAx
	    q191 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,2);  // d/dAx
	    q192 += alpha*Ix(a,3,2)*Iy(a,1,1)*Iz(a,1,1)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,1);  // d/dAx
	    q193 += alpha*Ix(a,3,1)*Iy(a,1,2)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,1);  // d/dAx
	    q194 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,1,2)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,2);  // d/dAx
	    q195 += alpha*Ix(a,2,4)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,4)*Iy(a,2,0)*Iz(a,1,0);  // d/dAx
	    q196 += alpha*Ix(a,2,0)*Iy(a,2,4)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,4)*Iz(a,1,0);  // d/dAx
	    q197 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,4)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,4);  // d/dAx
	    q198 += alpha*Ix(a,2,3)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,2,1)*Iz(a,1,0);  // d/dAx
	    q199 += alpha*Ix(a,2,3)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[0];
	I[196] += q196*C_[0];
	I[197] += q197*C_[0];
	I[198] += q198*C_[0];
	I[199] += q199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += alpha*Ix(a,2,1)*Iy(a,2,3)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,2,3)*Iz(a,1,0);  // d/dAx
	    q201 += alpha*Ix(a,2,0)*Iy(a,2,3)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,1);  // d/dAx
	    q202 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,3)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,3);  // d/dAx
	    q203 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,3);  // d/dAx
	    q204 += alpha*Ix(a,2,2)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,2)*Iy(a,2,2)*Iz(a,1,0);  // d/dAx
	    q205 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,2);  // d/dAx
	    q206 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,2);  // d/dAx
	    q207 += alpha*Ix(a,2,2)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,1);  // d/dAx
	    q208 += alpha*Ix(a,2,1)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,1);  // d/dAx
	    q209 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[0];
	I[202] += q202*C_[0];
	I[203] += q203*C_[0];
	I[204] += q204*C_[0];
	I[205] += q205*C_[0];
	I[206] += q206*C_[0];
	I[207] += q207*C_[0];
	I[208] += q208*C_[0];
	I[209] += q209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += alpha*Ix(a,2,4)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,4)*Iy(a,1,0)*Iz(a,2,0);  // d/dAx
	    q211 += alpha*Ix(a,2,0)*Iy(a,1,4)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,4)*Iz(a,2,0);  // d/dAx
	    q212 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,4)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,4);  // d/dAx
	    q213 += alpha*Ix(a,2,3)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,1,1)*Iz(a,2,0);  // d/dAx
	    q214 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,1);  // d/dAx
	    q215 += alpha*Ix(a,2,1)*Iy(a,1,3)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,3)*Iz(a,2,0);  // d/dAx
	    q216 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,1);  // d/dAx
	    q217 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,3)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,3);  // d/dAx
	    q218 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,3);  // d/dAx
	    q219 += alpha*Ix(a,2,2)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,1,2)*Iz(a,2,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[210] += q210*C_[0];
	I[211] += q211*C_[0];
	I[212] += q212*C_[0];
	I[213] += q213*C_[0];
	I[214] += q214*C_[0];
	I[215] += q215*C_[0];
	I[216] += q216*C_[0];
	I[217] += q217*C_[0];
	I[218] += q218*C_[0];
	I[219] += q219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,2);  // d/dAx
	    q221 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,2);  // d/dAx
	    q222 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,1);  // d/dAx
	    q223 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,1);  // d/dAx
	    q224 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,2);  // d/dAx
	    q225 += alpha*Ix(a,4,4)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q226 += alpha*Ix(a,4,0)*Iy(a,1,4)*Iz(a,0,0); // d/dAy
	    q227 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,4); // d/dAy
	    q228 += alpha*Ix(a,4,3)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q229 += alpha*Ix(a,4,3)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[0];
	I[222] += q222*C_[0];
	I[223] += q223*C_[0];
	I[224] += q224*C_[0];
	I[225] += q225*C_[0];
	I[226] += q226*C_[0];
	I[227] += q227*C_[0];
	I[228] += q228*C_[0];
	I[229] += q229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += alpha*Ix(a,4,1)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q231 += alpha*Ix(a,4,0)*Iy(a,1,3)*Iz(a,0,1); // d/dAy
	    q232 += alpha*Ix(a,4,1)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q233 += alpha*Ix(a,4,0)*Iy(a,1,1)*Iz(a,0,3); // d/dAy
	    q234 += alpha*Ix(a,4,2)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q235 += alpha*Ix(a,4,2)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q236 += alpha*Ix(a,4,0)*Iy(a,1,2)*Iz(a,0,2); // d/dAy
	    q237 += alpha*Ix(a,4,2)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q238 += alpha*Ix(a,4,1)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q239 += alpha*Ix(a,4,1)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	}
	    
	//contraction coefficients
	I[230] += q230*C_[0];
	I[231] += q231*C_[0];
	I[232] += q232*C_[0];
	I[233] += q233*C_[0];
	I[234] += q234*C_[0];
	I[235] += q235*C_[0];
	I[236] += q236*C_[0];
	I[237] += q237*C_[0];
	I[238] += q238*C_[0];
	I[239] += q239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += alpha*Ix(a,0,4)*Iy(a,5,0)*Iz(a,0,0)
                     - 4*Ix(a,0,4)*Iy(a,3,0)*Iz(a,0,0);  // d/dAy
	    q241 += alpha*Ix(a,0,0)*Iy(a,5,4)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,3,4)*Iz(a,0,0);  // d/dAy
	    q242 += alpha*Ix(a,0,0)*Iy(a,5,0)*Iz(a,0,4)
                     - 4*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,4);  // d/dAy
	    q243 += alpha*Ix(a,0,3)*Iy(a,5,1)*Iz(a,0,0)
                     - 4*Ix(a,0,3)*Iy(a,3,1)*Iz(a,0,0);  // d/dAy
	    q244 += alpha*Ix(a,0,3)*Iy(a,5,0)*Iz(a,0,1)
                     - 4*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,1);  // d/dAy
	    q245 += alpha*Ix(a,0,1)*Iy(a,5,3)*Iz(a,0,0)
                     - 4*Ix(a,0,1)*Iy(a,3,3)*Iz(a,0,0);  // d/dAy
	    q246 += alpha*Ix(a,0,0)*Iy(a,5,3)*Iz(a,0,1)
                     - 4*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,1);  // d/dAy
	    q247 += alpha*Ix(a,0,1)*Iy(a,5,0)*Iz(a,0,3)
                     - 4*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,3);  // d/dAy
	    q248 += alpha*Ix(a,0,0)*Iy(a,5,1)*Iz(a,0,3)
                     - 4*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,3);  // d/dAy
	    q249 += alpha*Ix(a,0,2)*Iy(a,5,2)*Iz(a,0,0)
                     - 4*Ix(a,0,2)*Iy(a,3,2)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += alpha*Ix(a,0,2)*Iy(a,5,0)*Iz(a,0,2)
                     - 4*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,2);  // d/dAy
	    q251 += alpha*Ix(a,0,0)*Iy(a,5,2)*Iz(a,0,2)
                     - 4*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,2);  // d/dAy
	    q252 += alpha*Ix(a,0,2)*Iy(a,5,1)*Iz(a,0,1)
                     - 4*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,1);  // d/dAy
	    q253 += alpha*Ix(a,0,1)*Iy(a,5,2)*Iz(a,0,1)
                     - 4*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,1);  // d/dAy
	    q254 += alpha*Ix(a,0,1)*Iy(a,5,1)*Iz(a,0,2)
                     - 4*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,2);  // d/dAy
	    q255 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,4,0); // d/dAy
	    q256 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,4,0); // d/dAy
	    q257 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,4); // d/dAy
	    q258 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,4,0); // d/dAy
	    q259 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,4,1); // d/dAy
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[0];
	I[256] += q256*C_[0];
	I[257] += q257*C_[0];
	I[258] += q258*C_[0];
	I[259] += q259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,4,0); // d/dAy
	    q261 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,4,1); // d/dAy
	    q262 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,4,3); // d/dAy
	    q263 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,4,3); // d/dAy
	    q264 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,4,0); // d/dAy
	    q265 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,4,2); // d/dAy
	    q266 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,4,2); // d/dAy
	    q267 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,4,1); // d/dAy
	    q268 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,4,1); // d/dAy
	    q269 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,4,2); // d/dAy
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[0];
	I[262] += q262*C_[0];
	I[263] += q263*C_[0];
	I[264] += q264*C_[0];
	I[265] += q265*C_[0];
	I[266] += q266*C_[0];
	I[267] += q267*C_[0];
	I[268] += q268*C_[0];
	I[269] += q269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q270 = 0.0;
	T q271 = 0.0;
	T q272 = 0.0;
	T q273 = 0.0;
	T q274 = 0.0;
	T q275 = 0.0;
	T q276 = 0.0;
	T q277 = 0.0;
	T q278 = 0.0;
	T q279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q270 += alpha*Ix(a,3,4)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,3,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q271 += alpha*Ix(a,3,0)*Iy(a,2,4)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAy
	    q272 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,4)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAy
	    q273 += alpha*Ix(a,3,3)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,3,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q274 += alpha*Ix(a,3,3)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q275 += alpha*Ix(a,3,1)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,3,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAy
	    q276 += alpha*Ix(a,3,0)*Iy(a,2,3)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAy
	    q277 += alpha*Ix(a,3,1)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAy
	    q278 += alpha*Ix(a,3,0)*Iy(a,2,1)*Iz(a,0,3)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAy
	    q279 += alpha*Ix(a,3,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,3,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[270] += q270*C_[0];
	I[271] += q271*C_[0];
	I[272] += q272*C_[0];
	I[273] += q273*C_[0];
	I[274] += q274*C_[0];
	I[275] += q275*C_[0];
	I[276] += q276*C_[0];
	I[277] += q277*C_[0];
	I[278] += q278*C_[0];
	I[279] += q279*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q280 = 0.0;
	T q281 = 0.0;
	T q282 = 0.0;
	T q283 = 0.0;
	T q284 = 0.0;
	T q285 = 0.0;
	T q286 = 0.0;
	T q287 = 0.0;
	T q288 = 0.0;
	T q289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q280 += alpha*Ix(a,3,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q281 += alpha*Ix(a,3,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAy
	    q282 += alpha*Ix(a,3,2)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	    q283 += alpha*Ix(a,3,1)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAy
	    q284 += alpha*Ix(a,3,1)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAy
	    q285 += alpha*Ix(a,3,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q286 += alpha*Ix(a,3,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAy
	    q287 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAy
	    q288 += alpha*Ix(a,3,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q289 += alpha*Ix(a,3,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[280] += q280*C_[0];
	I[281] += q281*C_[0];
	I[282] += q282*C_[0];
	I[283] += q283*C_[0];
	I[284] += q284*C_[0];
	I[285] += q285*C_[0];
	I[286] += q286*C_[0];
	I[287] += q287*C_[0];
	I[288] += q288*C_[0];
	I[289] += q289*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q290 = 0.0;
	T q291 = 0.0;
	T q292 = 0.0;
	T q293 = 0.0;
	T q294 = 0.0;
	T q295 = 0.0;
	T q296 = 0.0;
	T q297 = 0.0;
	T q298 = 0.0;
	T q299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q290 += alpha*Ix(a,3,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAy
	    q291 += alpha*Ix(a,3,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAy
	    q292 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAy
	    q293 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAy
	    q294 += alpha*Ix(a,3,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q295 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q296 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAy
	    q297 += alpha*Ix(a,3,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	    q298 += alpha*Ix(a,3,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAy
	    q299 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAy
	}
	    
	//contraction coefficients
	I[290] += q290*C_[0];
	I[291] += q291*C_[0];
	I[292] += q292*C_[0];
	I[293] += q293*C_[0];
	I[294] += q294*C_[0];
	I[295] += q295*C_[0];
	I[296] += q296*C_[0];
	I[297] += q297*C_[0];
	I[298] += q298*C_[0];
	I[299] += q299*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q300 = 0.0;
	T q301 = 0.0;
	T q302 = 0.0;
	T q303 = 0.0;
	T q304 = 0.0;
	T q305 = 0.0;
	T q306 = 0.0;
	T q307 = 0.0;
	T q308 = 0.0;
	T q309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q300 += alpha*Ix(a,1,4)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,1,4)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q301 += alpha*Ix(a,1,0)*Iy(a,4,4)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,2,4)*Iz(a,0,0);  // d/dAy
	    q302 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,4);  // d/dAy
	    q303 += alpha*Ix(a,1,3)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,1,3)*Iy(a,2,1)*Iz(a,0,0);  // d/dAy
	    q304 += alpha*Ix(a,1,3)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,1);  // d/dAy
	    q305 += alpha*Ix(a,1,1)*Iy(a,4,3)*Iz(a,0,0)
                     - 3*Ix(a,1,1)*Iy(a,2,3)*Iz(a,0,0);  // d/dAy
	    q306 += alpha*Ix(a,1,0)*Iy(a,4,3)*Iz(a,0,1)
                     - 3*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,1);  // d/dAy
	    q307 += alpha*Ix(a,1,1)*Iy(a,4,0)*Iz(a,0,3)
                     - 3*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,3);  // d/dAy
	    q308 += alpha*Ix(a,1,0)*Iy(a,4,1)*Iz(a,0,3)
                     - 3*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,3);  // d/dAy
	    q309 += alpha*Ix(a,1,2)*Iy(a,4,2)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,2,2)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[300] += q300*C_[0];
	I[301] += q301*C_[0];
	I[302] += q302*C_[0];
	I[303] += q303*C_[0];
	I[304] += q304*C_[0];
	I[305] += q305*C_[0];
	I[306] += q306*C_[0];
	I[307] += q307*C_[0];
	I[308] += q308*C_[0];
	I[309] += q309*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q310 = 0.0;
	T q311 = 0.0;
	T q312 = 0.0;
	T q313 = 0.0;
	T q314 = 0.0;
	T q315 = 0.0;
	T q316 = 0.0;
	T q317 = 0.0;
	T q318 = 0.0;
	T q319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q310 += alpha*Ix(a,1,2)*Iy(a,4,0)*Iz(a,0,2)
                     - 3*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,2);  // d/dAy
	    q311 += alpha*Ix(a,1,0)*Iy(a,4,2)*Iz(a,0,2)
                     - 3*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,2);  // d/dAy
	    q312 += alpha*Ix(a,1,2)*Iy(a,4,1)*Iz(a,0,1)
                     - 3*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,1);  // d/dAy
	    q313 += alpha*Ix(a,1,1)*Iy(a,4,2)*Iz(a,0,1)
                     - 3*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,1);  // d/dAy
	    q314 += alpha*Ix(a,1,1)*Iy(a,4,1)*Iz(a,0,2)
                     - 3*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,2);  // d/dAy
	    q315 += alpha*Ix(a,0,4)*Iy(a,4,0)*Iz(a,1,0)
                     - 3*Ix(a,0,4)*Iy(a,2,0)*Iz(a,1,0);  // d/dAy
	    q316 += alpha*Ix(a,0,0)*Iy(a,4,4)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,2,4)*Iz(a,1,0);  // d/dAy
	    q317 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,4);  // d/dAy
	    q318 += alpha*Ix(a,0,3)*Iy(a,4,1)*Iz(a,1,0)
                     - 3*Ix(a,0,3)*Iy(a,2,1)*Iz(a,1,0);  // d/dAy
	    q319 += alpha*Ix(a,0,3)*Iy(a,4,0)*Iz(a,1,1)
                     - 3*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[310] += q310*C_[0];
	I[311] += q311*C_[0];
	I[312] += q312*C_[0];
	I[313] += q313*C_[0];
	I[314] += q314*C_[0];
	I[315] += q315*C_[0];
	I[316] += q316*C_[0];
	I[317] += q317*C_[0];
	I[318] += q318*C_[0];
	I[319] += q319*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q320 = 0.0;
	T q321 = 0.0;
	T q322 = 0.0;
	T q323 = 0.0;
	T q324 = 0.0;
	T q325 = 0.0;
	T q326 = 0.0;
	T q327 = 0.0;
	T q328 = 0.0;
	T q329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q320 += alpha*Ix(a,0,1)*Iy(a,4,3)*Iz(a,1,0)
                     - 3*Ix(a,0,1)*Iy(a,2,3)*Iz(a,1,0);  // d/dAy
	    q321 += alpha*Ix(a,0,0)*Iy(a,4,3)*Iz(a,1,1)
                     - 3*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,1);  // d/dAy
	    q322 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,1,3)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,3);  // d/dAy
	    q323 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,1,3)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,3);  // d/dAy
	    q324 += alpha*Ix(a,0,2)*Iy(a,4,2)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,2,2)*Iz(a,1,0);  // d/dAy
	    q325 += alpha*Ix(a,0,2)*Iy(a,4,0)*Iz(a,1,2)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,2);  // d/dAy
	    q326 += alpha*Ix(a,0,0)*Iy(a,4,2)*Iz(a,1,2)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,2);  // d/dAy
	    q327 += alpha*Ix(a,0,2)*Iy(a,4,1)*Iz(a,1,1)
                     - 3*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,1);  // d/dAy
	    q328 += alpha*Ix(a,0,1)*Iy(a,4,2)*Iz(a,1,1)
                     - 3*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,1);  // d/dAy
	    q329 += alpha*Ix(a,0,1)*Iy(a,4,1)*Iz(a,1,2)
                     - 3*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[320] += q320*C_[0];
	I[321] += q321*C_[0];
	I[322] += q322*C_[0];
	I[323] += q323*C_[0];
	I[324] += q324*C_[0];
	I[325] += q325*C_[0];
	I[326] += q326*C_[0];
	I[327] += q327*C_[0];
	I[328] += q328*C_[0];
	I[329] += q329*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q330 = 0.0;
	T q331 = 0.0;
	T q332 = 0.0;
	T q333 = 0.0;
	T q334 = 0.0;
	T q335 = 0.0;
	T q336 = 0.0;
	T q337 = 0.0;
	T q338 = 0.0;
	T q339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q330 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q331 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,3,0); // d/dAy
	    q332 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,4); // d/dAy
	    q333 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,3,0); // d/dAy
	    q334 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,3,1); // d/dAy
	    q335 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,3,0); // d/dAy
	    q336 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,3,1); // d/dAy
	    q337 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,3); // d/dAy
	    q338 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,3); // d/dAy
	    q339 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,3,0); // d/dAy
	}
	    
	//contraction coefficients
	I[330] += q330*C_[0];
	I[331] += q331*C_[0];
	I[332] += q332*C_[0];
	I[333] += q333*C_[0];
	I[334] += q334*C_[0];
	I[335] += q335*C_[0];
	I[336] += q336*C_[0];
	I[337] += q337*C_[0];
	I[338] += q338*C_[0];
	I[339] += q339*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q340 = 0.0;
	T q341 = 0.0;
	T q342 = 0.0;
	T q343 = 0.0;
	T q344 = 0.0;
	T q345 = 0.0;
	T q346 = 0.0;
	T q347 = 0.0;
	T q348 = 0.0;
	T q349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q340 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,3,2); // d/dAy
	    q341 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,3,2); // d/dAy
	    q342 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,3,1); // d/dAy
	    q343 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,3,1); // d/dAy
	    q344 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,3,2); // d/dAy
	    q345 += alpha*Ix(a,0,4)*Iy(a,2,0)*Iz(a,3,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,3,0);  // d/dAy
	    q346 += alpha*Ix(a,0,0)*Iy(a,2,4)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,3,0);  // d/dAy
	    q347 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,4);  // d/dAy
	    q348 += alpha*Ix(a,0,3)*Iy(a,2,1)*Iz(a,3,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,3,0);  // d/dAy
	    q349 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,3,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[340] += q340*C_[0];
	I[341] += q341*C_[0];
	I[342] += q342*C_[0];
	I[343] += q343*C_[0];
	I[344] += q344*C_[0];
	I[345] += q345*C_[0];
	I[346] += q346*C_[0];
	I[347] += q347*C_[0];
	I[348] += q348*C_[0];
	I[349] += q349*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q350 = 0.0;
	T q351 = 0.0;
	T q352 = 0.0;
	T q353 = 0.0;
	T q354 = 0.0;
	T q355 = 0.0;
	T q356 = 0.0;
	T q357 = 0.0;
	T q358 = 0.0;
	T q359 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q350 += alpha*Ix(a,0,1)*Iy(a,2,3)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,3,0);  // d/dAy
	    q351 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,1);  // d/dAy
	    q352 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,3,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,3);  // d/dAy
	    q353 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,3,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,3);  // d/dAy
	    q354 += alpha*Ix(a,0,2)*Iy(a,2,2)*Iz(a,3,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,3,0);  // d/dAy
	    q355 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,3,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,2);  // d/dAy
	    q356 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,2);  // d/dAy
	    q357 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,3,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,1);  // d/dAy
	    q358 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,3,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,1);  // d/dAy
	    q359 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[350] += q350*C_[0];
	I[351] += q351*C_[0];
	I[352] += q352*C_[0];
	I[353] += q353*C_[0];
	I[354] += q354*C_[0];
	I[355] += q355*C_[0];
	I[356] += q356*C_[0];
	I[357] += q357*C_[0];
	I[358] += q358*C_[0];
	I[359] += q359*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q360 = 0.0;
	T q361 = 0.0;
	T q362 = 0.0;
	T q363 = 0.0;
	T q364 = 0.0;
	T q365 = 0.0;
	T q366 = 0.0;
	T q367 = 0.0;
	T q368 = 0.0;
	T q369 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q360 += alpha*Ix(a,2,4)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,2,4)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q361 += alpha*Ix(a,2,0)*Iy(a,3,4)*Iz(a,0,0)
                     - 2*Ix(a,2,0)*Iy(a,1,4)*Iz(a,0,0);  // d/dAy
	    q362 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,4)
                     - 2*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,4);  // d/dAy
	    q363 += alpha*Ix(a,2,3)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,2,3)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q364 += alpha*Ix(a,2,3)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q365 += alpha*Ix(a,2,1)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,1,3)*Iz(a,0,0);  // d/dAy
	    q366 += alpha*Ix(a,2,0)*Iy(a,3,3)*Iz(a,0,1)
                     - 2*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,1);  // d/dAy
	    q367 += alpha*Ix(a,2,1)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,3);  // d/dAy
	    q368 += alpha*Ix(a,2,0)*Iy(a,3,1)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,3);  // d/dAy
	    q369 += alpha*Ix(a,2,2)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,2,2)*Iy(a,1,2)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[360] += q360*C_[0];
	I[361] += q361*C_[0];
	I[362] += q362*C_[0];
	I[363] += q363*C_[0];
	I[364] += q364*C_[0];
	I[365] += q365*C_[0];
	I[366] += q366*C_[0];
	I[367] += q367*C_[0];
	I[368] += q368*C_[0];
	I[369] += q369*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q370 = 0.0;
	T q371 = 0.0;
	T q372 = 0.0;
	T q373 = 0.0;
	T q374 = 0.0;
	T q375 = 0.0;
	T q376 = 0.0;
	T q377 = 0.0;
	T q378 = 0.0;
	T q379 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q370 += alpha*Ix(a,2,2)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,2);  // d/dAy
	    q371 += alpha*Ix(a,2,0)*Iy(a,3,2)*Iz(a,0,2)
                     - 2*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,2);  // d/dAy
	    q372 += alpha*Ix(a,2,2)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,1);  // d/dAy
	    q373 += alpha*Ix(a,2,1)*Iy(a,3,2)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,1);  // d/dAy
	    q374 += alpha*Ix(a,2,1)*Iy(a,3,1)*Iz(a,0,2)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,2);  // d/dAy
	    q375 += alpha*Ix(a,2,4)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q376 += alpha*Ix(a,2,0)*Iy(a,1,4)*Iz(a,2,0); // d/dAy
	    q377 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,4); // d/dAy
	    q378 += alpha*Ix(a,2,3)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q379 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	}
	    
	//contraction coefficients
	I[370] += q370*C_[0];
	I[371] += q371*C_[0];
	I[372] += q372*C_[0];
	I[373] += q373*C_[0];
	I[374] += q374*C_[0];
	I[375] += q375*C_[0];
	I[376] += q376*C_[0];
	I[377] += q377*C_[0];
	I[378] += q378*C_[0];
	I[379] += q379*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q380 = 0.0;
	T q381 = 0.0;
	T q382 = 0.0;
	T q383 = 0.0;
	T q384 = 0.0;
	T q385 = 0.0;
	T q386 = 0.0;
	T q387 = 0.0;
	T q388 = 0.0;
	T q389 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q380 += alpha*Ix(a,2,1)*Iy(a,1,3)*Iz(a,2,0); // d/dAy
	    q381 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,2,1); // d/dAy
	    q382 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,3); // d/dAy
	    q383 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,3); // d/dAy
	    q384 += alpha*Ix(a,2,2)*Iy(a,1,2)*Iz(a,2,0); // d/dAy
	    q385 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,2,2); // d/dAy
	    q386 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,2,2); // d/dAy
	    q387 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,2,1); // d/dAy
	    q388 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,2,1); // d/dAy
	    q389 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,2,2); // d/dAy
	}
	    
	//contraction coefficients
	I[380] += q380*C_[0];
	I[381] += q381*C_[0];
	I[382] += q382*C_[0];
	I[383] += q383*C_[0];
	I[384] += q384*C_[0];
	I[385] += q385*C_[0];
	I[386] += q386*C_[0];
	I[387] += q387*C_[0];
	I[388] += q388*C_[0];
	I[389] += q389*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q390 = 0.0;
	T q391 = 0.0;
	T q392 = 0.0;
	T q393 = 0.0;
	T q394 = 0.0;
	T q395 = 0.0;
	T q396 = 0.0;
	T q397 = 0.0;
	T q398 = 0.0;
	T q399 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q390 += alpha*Ix(a,0,4)*Iy(a,3,0)*Iz(a,2,0)
                     - 2*Ix(a,0,4)*Iy(a,1,0)*Iz(a,2,0);  // d/dAy
	    q391 += alpha*Ix(a,0,0)*Iy(a,3,4)*Iz(a,2,0)
                     - 2*Ix(a,0,0)*Iy(a,1,4)*Iz(a,2,0);  // d/dAy
	    q392 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,4)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,4);  // d/dAy
	    q393 += alpha*Ix(a,0,3)*Iy(a,3,1)*Iz(a,2,0)
                     - 2*Ix(a,0,3)*Iy(a,1,1)*Iz(a,2,0);  // d/dAy
	    q394 += alpha*Ix(a,0,3)*Iy(a,3,0)*Iz(a,2,1)
                     - 2*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,1);  // d/dAy
	    q395 += alpha*Ix(a,0,1)*Iy(a,3,3)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,1,3)*Iz(a,2,0);  // d/dAy
	    q396 += alpha*Ix(a,0,0)*Iy(a,3,3)*Iz(a,2,1)
                     - 2*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,1);  // d/dAy
	    q397 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,2,3)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,3);  // d/dAy
	    q398 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,3);  // d/dAy
	    q399 += alpha*Ix(a,0,2)*Iy(a,3,2)*Iz(a,2,0)
                     - 2*Ix(a,0,2)*Iy(a,1,2)*Iz(a,2,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[390] += q390*C_[0];
	I[391] += q391*C_[0];
	I[392] += q392*C_[0];
	I[393] += q393*C_[0];
	I[394] += q394*C_[0];
	I[395] += q395*C_[0];
	I[396] += q396*C_[0];
	I[397] += q397*C_[0];
	I[398] += q398*C_[0];
	I[399] += q399*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q400 = 0.0;
	T q401 = 0.0;
	T q402 = 0.0;
	T q403 = 0.0;
	T q404 = 0.0;
	T q405 = 0.0;
	T q406 = 0.0;
	T q407 = 0.0;
	T q408 = 0.0;
	T q409 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q400 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,2,2)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,2);  // d/dAy
	    q401 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,2,2)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,2);  // d/dAy
	    q402 += alpha*Ix(a,0,2)*Iy(a,3,1)*Iz(a,2,1)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,1);  // d/dAy
	    q403 += alpha*Ix(a,0,1)*Iy(a,3,2)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,1);  // d/dAy
	    q404 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,2,2)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,2);  // d/dAy
	    q405 += alpha*Ix(a,2,4)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,2,4)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q406 += alpha*Ix(a,2,0)*Iy(a,2,4)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,4)*Iz(a,1,0);  // d/dAy
	    q407 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,4)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,4);  // d/dAy
	    q408 += alpha*Ix(a,2,3)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,2,3)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q409 += alpha*Ix(a,2,3)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[400] += q400*C_[0];
	I[401] += q401*C_[0];
	I[402] += q402*C_[0];
	I[403] += q403*C_[0];
	I[404] += q404*C_[0];
	I[405] += q405*C_[0];
	I[406] += q406*C_[0];
	I[407] += q407*C_[0];
	I[408] += q408*C_[0];
	I[409] += q409*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q410 = 0.0;
	T q411 = 0.0;
	T q412 = 0.0;
	T q413 = 0.0;
	T q414 = 0.0;
	T q415 = 0.0;
	T q416 = 0.0;
	T q417 = 0.0;
	T q418 = 0.0;
	T q419 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q410 += alpha*Ix(a,2,1)*Iy(a,2,3)*Iz(a,1,0)
                     - 1*Ix(a,2,1)*Iy(a,0,3)*Iz(a,1,0);  // d/dAy
	    q411 += alpha*Ix(a,2,0)*Iy(a,2,3)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,1);  // d/dAy
	    q412 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,3)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,3);  // d/dAy
	    q413 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,3)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,3);  // d/dAy
	    q414 += alpha*Ix(a,2,2)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,2,2)*Iy(a,0,2)*Iz(a,1,0);  // d/dAy
	    q415 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,2);  // d/dAy
	    q416 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,2);  // d/dAy
	    q417 += alpha*Ix(a,2,2)*Iy(a,2,1)*Iz(a,1,1)
                     - 1*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,1);  // d/dAy
	    q418 += alpha*Ix(a,2,1)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,1);  // d/dAy
	    q419 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[410] += q410*C_[0];
	I[411] += q411*C_[0];
	I[412] += q412*C_[0];
	I[413] += q413*C_[0];
	I[414] += q414*C_[0];
	I[415] += q415*C_[0];
	I[416] += q416*C_[0];
	I[417] += q417*C_[0];
	I[418] += q418*C_[0];
	I[419] += q419*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q420 = 0.0;
	T q421 = 0.0;
	T q422 = 0.0;
	T q423 = 0.0;
	T q424 = 0.0;
	T q425 = 0.0;
	T q426 = 0.0;
	T q427 = 0.0;
	T q428 = 0.0;
	T q429 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q420 += alpha*Ix(a,1,4)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,1,4)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q421 += alpha*Ix(a,1,0)*Iy(a,3,4)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,4)*Iz(a,1,0);  // d/dAy
	    q422 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,4)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,4);  // d/dAy
	    q423 += alpha*Ix(a,1,3)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,0);  // d/dAy
	    q424 += alpha*Ix(a,1,3)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,1);  // d/dAy
	    q425 += alpha*Ix(a,1,1)*Iy(a,3,3)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,0);  // d/dAy
	    q426 += alpha*Ix(a,1,0)*Iy(a,3,3)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,1);  // d/dAy
	    q427 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,3)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,3);  // d/dAy
	    q428 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,3);  // d/dAy
	    q429 += alpha*Ix(a,1,2)*Iy(a,3,2)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[420] += q420*C_[0];
	I[421] += q421*C_[0];
	I[422] += q422*C_[0];
	I[423] += q423*C_[0];
	I[424] += q424*C_[0];
	I[425] += q425*C_[0];
	I[426] += q426*C_[0];
	I[427] += q427*C_[0];
	I[428] += q428*C_[0];
	I[429] += q429*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q430 = 0.0;
	T q431 = 0.0;
	T q432 = 0.0;
	T q433 = 0.0;
	T q434 = 0.0;
	T q435 = 0.0;
	T q436 = 0.0;
	T q437 = 0.0;
	T q438 = 0.0;
	T q439 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q430 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,1,2)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,2);  // d/dAy
	    q431 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,2);  // d/dAy
	    q432 += alpha*Ix(a,1,2)*Iy(a,3,1)*Iz(a,1,1)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,1);  // d/dAy
	    q433 += alpha*Ix(a,1,1)*Iy(a,3,2)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,1);  // d/dAy
	    q434 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,1,2)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,2);  // d/dAy
	    q435 += alpha*Ix(a,1,4)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,4)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q436 += alpha*Ix(a,1,0)*Iy(a,2,4)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,4)*Iz(a,2,0);  // d/dAy
	    q437 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,4)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,4);  // d/dAy
	    q438 += alpha*Ix(a,1,3)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,1,3)*Iy(a,0,1)*Iz(a,2,0);  // d/dAy
	    q439 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[430] += q430*C_[0];
	I[431] += q431*C_[0];
	I[432] += q432*C_[0];
	I[433] += q433*C_[0];
	I[434] += q434*C_[0];
	I[435] += q435*C_[0];
	I[436] += q436*C_[0];
	I[437] += q437*C_[0];
	I[438] += q438*C_[0];
	I[439] += q439*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q440 = 0.0;
	T q441 = 0.0;
	T q442 = 0.0;
	T q443 = 0.0;
	T q444 = 0.0;
	T q445 = 0.0;
	T q446 = 0.0;
	T q447 = 0.0;
	T q448 = 0.0;
	T q449 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q440 += alpha*Ix(a,1,1)*Iy(a,2,3)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,3)*Iz(a,2,0);  // d/dAy
	    q441 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,1);  // d/dAy
	    q442 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,3)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,3);  // d/dAy
	    q443 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,3);  // d/dAy
	    q444 += alpha*Ix(a,1,2)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,0,2)*Iz(a,2,0);  // d/dAy
	    q445 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,2);  // d/dAy
	    q446 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,2);  // d/dAy
	    q447 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,1);  // d/dAy
	    q448 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,1);  // d/dAy
	    q449 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,2);  // d/dAy
	}
	    
	//contraction coefficients
	I[440] += q440*C_[0];
	I[441] += q441*C_[0];
	I[442] += q442*C_[0];
	I[443] += q443*C_[0];
	I[444] += q444*C_[0];
	I[445] += q445*C_[0];
	I[446] += q446*C_[0];
	I[447] += q447*C_[0];
	I[448] += q448*C_[0];
	I[449] += q449*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q450 = 0.0;
	T q451 = 0.0;
	T q452 = 0.0;
	T q453 = 0.0;
	T q454 = 0.0;
	T q455 = 0.0;
	T q456 = 0.0;
	T q457 = 0.0;
	T q458 = 0.0;
	T q459 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q450 += alpha*Ix(a,4,4)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q451 += alpha*Ix(a,4,0)*Iy(a,0,4)*Iz(a,1,0); // d/dAz
	    q452 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,4); // d/dAz
	    q453 += alpha*Ix(a,4,3)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q454 += alpha*Ix(a,4,3)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q455 += alpha*Ix(a,4,1)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q456 += alpha*Ix(a,4,0)*Iy(a,0,3)*Iz(a,1,1); // d/dAz
	    q457 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q458 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,1,3); // d/dAz
	    q459 += alpha*Ix(a,4,2)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[450] += q450*C_[0];
	I[451] += q451*C_[0];
	I[452] += q452*C_[0];
	I[453] += q453*C_[0];
	I[454] += q454*C_[0];
	I[455] += q455*C_[0];
	I[456] += q456*C_[0];
	I[457] += q457*C_[0];
	I[458] += q458*C_[0];
	I[459] += q459*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q460 = 0.0;
	T q461 = 0.0;
	T q462 = 0.0;
	T q463 = 0.0;
	T q464 = 0.0;
	T q465 = 0.0;
	T q466 = 0.0;
	T q467 = 0.0;
	T q468 = 0.0;
	T q469 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q460 += alpha*Ix(a,4,2)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q461 += alpha*Ix(a,4,0)*Iy(a,0,2)*Iz(a,1,2); // d/dAz
	    q462 += alpha*Ix(a,4,2)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q463 += alpha*Ix(a,4,1)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q464 += alpha*Ix(a,4,1)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q465 += alpha*Ix(a,0,4)*Iy(a,4,0)*Iz(a,1,0); // d/dAz
	    q466 += alpha*Ix(a,0,0)*Iy(a,4,4)*Iz(a,1,0); // d/dAz
	    q467 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,4); // d/dAz
	    q468 += alpha*Ix(a,0,3)*Iy(a,4,1)*Iz(a,1,0); // d/dAz
	    q469 += alpha*Ix(a,0,3)*Iy(a,4,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[460] += q460*C_[0];
	I[461] += q461*C_[0];
	I[462] += q462*C_[0];
	I[463] += q463*C_[0];
	I[464] += q464*C_[0];
	I[465] += q465*C_[0];
	I[466] += q466*C_[0];
	I[467] += q467*C_[0];
	I[468] += q468*C_[0];
	I[469] += q469*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q470 = 0.0;
	T q471 = 0.0;
	T q472 = 0.0;
	T q473 = 0.0;
	T q474 = 0.0;
	T q475 = 0.0;
	T q476 = 0.0;
	T q477 = 0.0;
	T q478 = 0.0;
	T q479 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q470 += alpha*Ix(a,0,1)*Iy(a,4,3)*Iz(a,1,0); // d/dAz
	    q471 += alpha*Ix(a,0,0)*Iy(a,4,3)*Iz(a,1,1); // d/dAz
	    q472 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,1,3); // d/dAz
	    q473 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,1,3); // d/dAz
	    q474 += alpha*Ix(a,0,2)*Iy(a,4,2)*Iz(a,1,0); // d/dAz
	    q475 += alpha*Ix(a,0,2)*Iy(a,4,0)*Iz(a,1,2); // d/dAz
	    q476 += alpha*Ix(a,0,0)*Iy(a,4,2)*Iz(a,1,2); // d/dAz
	    q477 += alpha*Ix(a,0,2)*Iy(a,4,1)*Iz(a,1,1); // d/dAz
	    q478 += alpha*Ix(a,0,1)*Iy(a,4,2)*Iz(a,1,1); // d/dAz
	    q479 += alpha*Ix(a,0,1)*Iy(a,4,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[470] += q470*C_[0];
	I[471] += q471*C_[0];
	I[472] += q472*C_[0];
	I[473] += q473*C_[0];
	I[474] += q474*C_[0];
	I[475] += q475*C_[0];
	I[476] += q476*C_[0];
	I[477] += q477*C_[0];
	I[478] += q478*C_[0];
	I[479] += q479*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q480 = 0.0;
	T q481 = 0.0;
	T q482 = 0.0;
	T q483 = 0.0;
	T q484 = 0.0;
	T q485 = 0.0;
	T q486 = 0.0;
	T q487 = 0.0;
	T q488 = 0.0;
	T q489 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q480 += alpha*Ix(a,0,4)*Iy(a,0,0)*Iz(a,5,0)
                     - 4*Ix(a,0,4)*Iy(a,0,0)*Iz(a,3,0);  // d/dAz
	    q481 += alpha*Ix(a,0,0)*Iy(a,0,4)*Iz(a,5,0)
                     - 4*Ix(a,0,0)*Iy(a,0,4)*Iz(a,3,0);  // d/dAz
	    q482 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,5,4)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,4);  // d/dAz
	    q483 += alpha*Ix(a,0,3)*Iy(a,0,1)*Iz(a,5,0)
                     - 4*Ix(a,0,3)*Iy(a,0,1)*Iz(a,3,0);  // d/dAz
	    q484 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,5,1)
                     - 4*Ix(a,0,3)*Iy(a,0,0)*Iz(a,3,1);  // d/dAz
	    q485 += alpha*Ix(a,0,1)*Iy(a,0,3)*Iz(a,5,0)
                     - 4*Ix(a,0,1)*Iy(a,0,3)*Iz(a,3,0);  // d/dAz
	    q486 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,5,1)
                     - 4*Ix(a,0,0)*Iy(a,0,3)*Iz(a,3,1);  // d/dAz
	    q487 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,5,3)
                     - 4*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,3);  // d/dAz
	    q488 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,5,3)
                     - 4*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,3);  // d/dAz
	    q489 += alpha*Ix(a,0,2)*Iy(a,0,2)*Iz(a,5,0)
                     - 4*Ix(a,0,2)*Iy(a,0,2)*Iz(a,3,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[480] += q480*C_[0];
	I[481] += q481*C_[0];
	I[482] += q482*C_[0];
	I[483] += q483*C_[0];
	I[484] += q484*C_[0];
	I[485] += q485*C_[0];
	I[486] += q486*C_[0];
	I[487] += q487*C_[0];
	I[488] += q488*C_[0];
	I[489] += q489*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q490 = 0.0;
	T q491 = 0.0;
	T q492 = 0.0;
	T q493 = 0.0;
	T q494 = 0.0;
	T q495 = 0.0;
	T q496 = 0.0;
	T q497 = 0.0;
	T q498 = 0.0;
	T q499 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q490 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,5,2)
                     - 4*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,2);  // d/dAz
	    q491 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,5,2)
                     - 4*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,2);  // d/dAz
	    q492 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,5,1)
                     - 4*Ix(a,0,2)*Iy(a,0,1)*Iz(a,3,1);  // d/dAz
	    q493 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,5,1)
                     - 4*Ix(a,0,1)*Iy(a,0,2)*Iz(a,3,1);  // d/dAz
	    q494 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,5,2)
                     - 4*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,2);  // d/dAz
	    q495 += alpha*Ix(a,3,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q496 += alpha*Ix(a,3,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAz
	    q497 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAz
	    q498 += alpha*Ix(a,3,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q499 += alpha*Ix(a,3,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[490] += q490*C_[0];
	I[491] += q491*C_[0];
	I[492] += q492*C_[0];
	I[493] += q493*C_[0];
	I[494] += q494*C_[0];
	I[495] += q495*C_[0];
	I[496] += q496*C_[0];
	I[497] += q497*C_[0];
	I[498] += q498*C_[0];
	I[499] += q499*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q500 = 0.0;
	T q501 = 0.0;
	T q502 = 0.0;
	T q503 = 0.0;
	T q504 = 0.0;
	T q505 = 0.0;
	T q506 = 0.0;
	T q507 = 0.0;
	T q508 = 0.0;
	T q509 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q500 += alpha*Ix(a,3,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAz
	    q501 += alpha*Ix(a,3,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAz
	    q502 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAz
	    q503 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAz
	    q504 += alpha*Ix(a,3,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	    q505 += alpha*Ix(a,3,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q506 += alpha*Ix(a,3,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAz
	    q507 += alpha*Ix(a,3,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	    q508 += alpha*Ix(a,3,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAz
	    q509 += alpha*Ix(a,3,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[500] += q500*C_[0];
	I[501] += q501*C_[0];
	I[502] += q502*C_[0];
	I[503] += q503*C_[0];
	I[504] += q504*C_[0];
	I[505] += q505*C_[0];
	I[506] += q506*C_[0];
	I[507] += q507*C_[0];
	I[508] += q508*C_[0];
	I[509] += q509*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q510 = 0.0;
	T q511 = 0.0;
	T q512 = 0.0;
	T q513 = 0.0;
	T q514 = 0.0;
	T q515 = 0.0;
	T q516 = 0.0;
	T q517 = 0.0;
	T q518 = 0.0;
	T q519 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q510 += alpha*Ix(a,3,4)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,3,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q511 += alpha*Ix(a,3,0)*Iy(a,0,4)*Iz(a,2,0)
                     - 1*Ix(a,3,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAz
	    q512 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,4)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAz
	    q513 += alpha*Ix(a,3,3)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,3,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q514 += alpha*Ix(a,3,3)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,3,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q515 += alpha*Ix(a,3,1)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,3,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAz
	    q516 += alpha*Ix(a,3,0)*Iy(a,0,3)*Iz(a,2,1)
                     - 1*Ix(a,3,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAz
	    q517 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAz
	    q518 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,2,3)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAz
	    q519 += alpha*Ix(a,3,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,3,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[510] += q510*C_[0];
	I[511] += q511*C_[0];
	I[512] += q512*C_[0];
	I[513] += q513*C_[0];
	I[514] += q514*C_[0];
	I[515] += q515*C_[0];
	I[516] += q516*C_[0];
	I[517] += q517*C_[0];
	I[518] += q518*C_[0];
	I[519] += q519*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q520 = 0.0;
	T q521 = 0.0;
	T q522 = 0.0;
	T q523 = 0.0;
	T q524 = 0.0;
	T q525 = 0.0;
	T q526 = 0.0;
	T q527 = 0.0;
	T q528 = 0.0;
	T q529 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q520 += alpha*Ix(a,3,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q521 += alpha*Ix(a,3,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAz
	    q522 += alpha*Ix(a,3,2)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,3,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	    q523 += alpha*Ix(a,3,1)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,3,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAz
	    q524 += alpha*Ix(a,3,1)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAz
	    q525 += alpha*Ix(a,1,4)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q526 += alpha*Ix(a,1,0)*Iy(a,3,4)*Iz(a,1,0); // d/dAz
	    q527 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,4); // d/dAz
	    q528 += alpha*Ix(a,1,3)*Iy(a,3,1)*Iz(a,1,0); // d/dAz
	    q529 += alpha*Ix(a,1,3)*Iy(a,3,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[520] += q520*C_[0];
	I[521] += q521*C_[0];
	I[522] += q522*C_[0];
	I[523] += q523*C_[0];
	I[524] += q524*C_[0];
	I[525] += q525*C_[0];
	I[526] += q526*C_[0];
	I[527] += q527*C_[0];
	I[528] += q528*C_[0];
	I[529] += q529*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q530 = 0.0;
	T q531 = 0.0;
	T q532 = 0.0;
	T q533 = 0.0;
	T q534 = 0.0;
	T q535 = 0.0;
	T q536 = 0.0;
	T q537 = 0.0;
	T q538 = 0.0;
	T q539 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q530 += alpha*Ix(a,1,1)*Iy(a,3,3)*Iz(a,1,0); // d/dAz
	    q531 += alpha*Ix(a,1,0)*Iy(a,3,3)*Iz(a,1,1); // d/dAz
	    q532 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,3); // d/dAz
	    q533 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,3); // d/dAz
	    q534 += alpha*Ix(a,1,2)*Iy(a,3,2)*Iz(a,1,0); // d/dAz
	    q535 += alpha*Ix(a,1,2)*Iy(a,3,0)*Iz(a,1,2); // d/dAz
	    q536 += alpha*Ix(a,1,0)*Iy(a,3,2)*Iz(a,1,2); // d/dAz
	    q537 += alpha*Ix(a,1,2)*Iy(a,3,1)*Iz(a,1,1); // d/dAz
	    q538 += alpha*Ix(a,1,1)*Iy(a,3,2)*Iz(a,1,1); // d/dAz
	    q539 += alpha*Ix(a,1,1)*Iy(a,3,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[530] += q530*C_[0];
	I[531] += q531*C_[0];
	I[532] += q532*C_[0];
	I[533] += q533*C_[0];
	I[534] += q534*C_[0];
	I[535] += q535*C_[0];
	I[536] += q536*C_[0];
	I[537] += q537*C_[0];
	I[538] += q538*C_[0];
	I[539] += q539*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q540 = 0.0;
	T q541 = 0.0;
	T q542 = 0.0;
	T q543 = 0.0;
	T q544 = 0.0;
	T q545 = 0.0;
	T q546 = 0.0;
	T q547 = 0.0;
	T q548 = 0.0;
	T q549 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q540 += alpha*Ix(a,0,4)*Iy(a,3,0)*Iz(a,2,0)
                     - 1*Ix(a,0,4)*Iy(a,3,0)*Iz(a,0,0);  // d/dAz
	    q541 += alpha*Ix(a,0,0)*Iy(a,3,4)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,3,4)*Iz(a,0,0);  // d/dAz
	    q542 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,4)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,4);  // d/dAz
	    q543 += alpha*Ix(a,0,3)*Iy(a,3,1)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,3,1)*Iz(a,0,0);  // d/dAz
	    q544 += alpha*Ix(a,0,3)*Iy(a,3,0)*Iz(a,2,1)
                     - 1*Ix(a,0,3)*Iy(a,3,0)*Iz(a,0,1);  // d/dAz
	    q545 += alpha*Ix(a,0,1)*Iy(a,3,3)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,3,3)*Iz(a,0,0);  // d/dAz
	    q546 += alpha*Ix(a,0,0)*Iy(a,3,3)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,3,3)*Iz(a,0,1);  // d/dAz
	    q547 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,2,3)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,3);  // d/dAz
	    q548 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,3);  // d/dAz
	    q549 += alpha*Ix(a,0,2)*Iy(a,3,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,3,2)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[540] += q540*C_[0];
	I[541] += q541*C_[0];
	I[542] += q542*C_[0];
	I[543] += q543*C_[0];
	I[544] += q544*C_[0];
	I[545] += q545*C_[0];
	I[546] += q546*C_[0];
	I[547] += q547*C_[0];
	I[548] += q548*C_[0];
	I[549] += q549*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q550 = 0.0;
	T q551 = 0.0;
	T q552 = 0.0;
	T q553 = 0.0;
	T q554 = 0.0;
	T q555 = 0.0;
	T q556 = 0.0;
	T q557 = 0.0;
	T q558 = 0.0;
	T q559 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q550 += alpha*Ix(a,0,2)*Iy(a,3,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,2);  // d/dAz
	    q551 += alpha*Ix(a,0,0)*Iy(a,3,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,2);  // d/dAz
	    q552 += alpha*Ix(a,0,2)*Iy(a,3,1)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,3,1)*Iz(a,0,1);  // d/dAz
	    q553 += alpha*Ix(a,0,1)*Iy(a,3,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,3,2)*Iz(a,0,1);  // d/dAz
	    q554 += alpha*Ix(a,0,1)*Iy(a,3,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,2);  // d/dAz
	    q555 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,1,4)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q556 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,4,0)
                     - 3*Ix(a,1,0)*Iy(a,0,4)*Iz(a,2,0);  // d/dAz
	    q557 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,4)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,4);  // d/dAz
	    q558 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,1,3)*Iy(a,0,1)*Iz(a,2,0);  // d/dAz
	    q559 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,1,3)*Iy(a,0,0)*Iz(a,2,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[550] += q550*C_[0];
	I[551] += q551*C_[0];
	I[552] += q552*C_[0];
	I[553] += q553*C_[0];
	I[554] += q554*C_[0];
	I[555] += q555*C_[0];
	I[556] += q556*C_[0];
	I[557] += q557*C_[0];
	I[558] += q558*C_[0];
	I[559] += q559*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q560 = 0.0;
	T q561 = 0.0;
	T q562 = 0.0;
	T q563 = 0.0;
	T q564 = 0.0;
	T q565 = 0.0;
	T q566 = 0.0;
	T q567 = 0.0;
	T q568 = 0.0;
	T q569 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q560 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,4,0)
                     - 3*Ix(a,1,1)*Iy(a,0,3)*Iz(a,2,0);  // d/dAz
	    q561 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,4,1)
                     - 3*Ix(a,1,0)*Iy(a,0,3)*Iz(a,2,1);  // d/dAz
	    q562 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,4,3)
                     - 3*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,3);  // d/dAz
	    q563 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,4,3)
                     - 3*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,3);  // d/dAz
	    q564 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,4,0)
                     - 3*Ix(a,1,2)*Iy(a,0,2)*Iz(a,2,0);  // d/dAz
	    q565 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,4,2)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,2);  // d/dAz
	    q566 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,4,2)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,2);  // d/dAz
	    q567 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,4,1)
                     - 3*Ix(a,1,2)*Iy(a,0,1)*Iz(a,2,1);  // d/dAz
	    q568 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,4,1)
                     - 3*Ix(a,1,1)*Iy(a,0,2)*Iz(a,2,1);  // d/dAz
	    q569 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,4,2)
                     - 3*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,2);  // d/dAz
	}
	    
	//contraction coefficients
	I[560] += q560*C_[0];
	I[561] += q561*C_[0];
	I[562] += q562*C_[0];
	I[563] += q563*C_[0];
	I[564] += q564*C_[0];
	I[565] += q565*C_[0];
	I[566] += q566*C_[0];
	I[567] += q567*C_[0];
	I[568] += q568*C_[0];
	I[569] += q569*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q570 = 0.0;
	T q571 = 0.0;
	T q572 = 0.0;
	T q573 = 0.0;
	T q574 = 0.0;
	T q575 = 0.0;
	T q576 = 0.0;
	T q577 = 0.0;
	T q578 = 0.0;
	T q579 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q570 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,4,0)
                     - 3*Ix(a,0,4)*Iy(a,1,0)*Iz(a,2,0);  // d/dAz
	    q571 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,1,4)*Iz(a,2,0);  // d/dAz
	    q572 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,4)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,4);  // d/dAz
	    q573 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,4,0)
                     - 3*Ix(a,0,3)*Iy(a,1,1)*Iz(a,2,0);  // d/dAz
	    q574 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,4,1)
                     - 3*Ix(a,0,3)*Iy(a,1,0)*Iz(a,2,1);  // d/dAz
	    q575 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,1,3)*Iz(a,2,0);  // d/dAz
	    q576 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,1,3)*Iz(a,2,1);  // d/dAz
	    q577 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,4,3)
                     - 3*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,3);  // d/dAz
	    q578 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,4,3)
                     - 3*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,3);  // d/dAz
	    q579 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,4,0)
                     - 3*Ix(a,0,2)*Iy(a,1,2)*Iz(a,2,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[570] += q570*C_[0];
	I[571] += q571*C_[0];
	I[572] += q572*C_[0];
	I[573] += q573*C_[0];
	I[574] += q574*C_[0];
	I[575] += q575*C_[0];
	I[576] += q576*C_[0];
	I[577] += q577*C_[0];
	I[578] += q578*C_[0];
	I[579] += q579*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q580 = 0.0;
	T q581 = 0.0;
	T q582 = 0.0;
	T q583 = 0.0;
	T q584 = 0.0;
	T q585 = 0.0;
	T q586 = 0.0;
	T q587 = 0.0;
	T q588 = 0.0;
	T q589 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q580 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,4,2)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,2);  // d/dAz
	    q581 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,4,2)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,2);  // d/dAz
	    q582 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,4,1)
                     - 3*Ix(a,0,2)*Iy(a,1,1)*Iz(a,2,1);  // d/dAz
	    q583 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,4,1)
                     - 3*Ix(a,0,1)*Iy(a,1,2)*Iz(a,2,1);  // d/dAz
	    q584 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,4,2)
                     - 3*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,2);  // d/dAz
	    q585 += alpha*Ix(a,2,4)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q586 += alpha*Ix(a,2,0)*Iy(a,2,4)*Iz(a,1,0); // d/dAz
	    q587 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,4); // d/dAz
	    q588 += alpha*Ix(a,2,3)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q589 += alpha*Ix(a,2,3)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[580] += q580*C_[0];
	I[581] += q581*C_[0];
	I[582] += q582*C_[0];
	I[583] += q583*C_[0];
	I[584] += q584*C_[0];
	I[585] += q585*C_[0];
	I[586] += q586*C_[0];
	I[587] += q587*C_[0];
	I[588] += q588*C_[0];
	I[589] += q589*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q590 = 0.0;
	T q591 = 0.0;
	T q592 = 0.0;
	T q593 = 0.0;
	T q594 = 0.0;
	T q595 = 0.0;
	T q596 = 0.0;
	T q597 = 0.0;
	T q598 = 0.0;
	T q599 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q590 += alpha*Ix(a,2,1)*Iy(a,2,3)*Iz(a,1,0); // d/dAz
	    q591 += alpha*Ix(a,2,0)*Iy(a,2,3)*Iz(a,1,1); // d/dAz
	    q592 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,3); // d/dAz
	    q593 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,3); // d/dAz
	    q594 += alpha*Ix(a,2,2)*Iy(a,2,2)*Iz(a,1,0); // d/dAz
	    q595 += alpha*Ix(a,2,2)*Iy(a,2,0)*Iz(a,1,2); // d/dAz
	    q596 += alpha*Ix(a,2,0)*Iy(a,2,2)*Iz(a,1,2); // d/dAz
	    q597 += alpha*Ix(a,2,2)*Iy(a,2,1)*Iz(a,1,1); // d/dAz
	    q598 += alpha*Ix(a,2,1)*Iy(a,2,2)*Iz(a,1,1); // d/dAz
	    q599 += alpha*Ix(a,2,1)*Iy(a,2,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[590] += q590*C_[0];
	I[591] += q591*C_[0];
	I[592] += q592*C_[0];
	I[593] += q593*C_[0];
	I[594] += q594*C_[0];
	I[595] += q595*C_[0];
	I[596] += q596*C_[0];
	I[597] += q597*C_[0];
	I[598] += q598*C_[0];
	I[599] += q599*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q600 = 0.0;
	T q601 = 0.0;
	T q602 = 0.0;
	T q603 = 0.0;
	T q604 = 0.0;
	T q605 = 0.0;
	T q606 = 0.0;
	T q607 = 0.0;
	T q608 = 0.0;
	T q609 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q600 += alpha*Ix(a,2,4)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,2,4)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q601 += alpha*Ix(a,2,0)*Iy(a,0,4)*Iz(a,3,0)
                     - 2*Ix(a,2,0)*Iy(a,0,4)*Iz(a,1,0);  // d/dAz
	    q602 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,4)
                     - 2*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,4);  // d/dAz
	    q603 += alpha*Ix(a,2,3)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,2,3)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q604 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,2,3)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q605 += alpha*Ix(a,2,1)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,2,1)*Iy(a,0,3)*Iz(a,1,0);  // d/dAz
	    q606 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,3,1)
                     - 2*Ix(a,2,0)*Iy(a,0,3)*Iz(a,1,1);  // d/dAz
	    q607 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,3);  // d/dAz
	    q608 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,3,3)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,3);  // d/dAz
	    q609 += alpha*Ix(a,2,2)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,2,2)*Iy(a,0,2)*Iz(a,1,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[600] += q600*C_[0];
	I[601] += q601*C_[0];
	I[602] += q602*C_[0];
	I[603] += q603*C_[0];
	I[604] += q604*C_[0];
	I[605] += q605*C_[0];
	I[606] += q606*C_[0];
	I[607] += q607*C_[0];
	I[608] += q608*C_[0];
	I[609] += q609*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q610 = 0.0;
	T q611 = 0.0;
	T q612 = 0.0;
	T q613 = 0.0;
	T q614 = 0.0;
	T q615 = 0.0;
	T q616 = 0.0;
	T q617 = 0.0;
	T q618 = 0.0;
	T q619 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q610 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,2);  // d/dAz
	    q611 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,3,2)
                     - 2*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,2);  // d/dAz
	    q612 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,2,2)*Iy(a,0,1)*Iz(a,1,1);  // d/dAz
	    q613 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,3,1)
                     - 2*Ix(a,2,1)*Iy(a,0,2)*Iz(a,1,1);  // d/dAz
	    q614 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,3,2)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,2);  // d/dAz
	    q615 += alpha*Ix(a,0,4)*Iy(a,2,0)*Iz(a,3,0)
                     - 2*Ix(a,0,4)*Iy(a,2,0)*Iz(a,1,0);  // d/dAz
	    q616 += alpha*Ix(a,0,0)*Iy(a,2,4)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,2,4)*Iz(a,1,0);  // d/dAz
	    q617 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,4)
                     - 2*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,4);  // d/dAz
	    q618 += alpha*Ix(a,0,3)*Iy(a,2,1)*Iz(a,3,0)
                     - 2*Ix(a,0,3)*Iy(a,2,1)*Iz(a,1,0);  // d/dAz
	    q619 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,3,1)
                     - 2*Ix(a,0,3)*Iy(a,2,0)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[610] += q610*C_[0];
	I[611] += q611*C_[0];
	I[612] += q612*C_[0];
	I[613] += q613*C_[0];
	I[614] += q614*C_[0];
	I[615] += q615*C_[0];
	I[616] += q616*C_[0];
	I[617] += q617*C_[0];
	I[618] += q618*C_[0];
	I[619] += q619*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q620 = 0.0;
	T q621 = 0.0;
	T q622 = 0.0;
	T q623 = 0.0;
	T q624 = 0.0;
	T q625 = 0.0;
	T q626 = 0.0;
	T q627 = 0.0;
	T q628 = 0.0;
	T q629 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q620 += alpha*Ix(a,0,1)*Iy(a,2,3)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,2,3)*Iz(a,1,0);  // d/dAz
	    q621 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,2,3)*Iz(a,1,1);  // d/dAz
	    q622 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,3,3)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,3);  // d/dAz
	    q623 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,3);  // d/dAz
	    q624 += alpha*Ix(a,0,2)*Iy(a,2,2)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,2,2)*Iz(a,1,0);  // d/dAz
	    q625 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,3,2)
                     - 2*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,2);  // d/dAz
	    q626 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,2);  // d/dAz
	    q627 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,3,1)
                     - 2*Ix(a,0,2)*Iy(a,2,1)*Iz(a,1,1);  // d/dAz
	    q628 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,2,2)*Iz(a,1,1);  // d/dAz
	    q629 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,3,2)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,2);  // d/dAz
	}
	    
	//contraction coefficients
	I[620] += q620*C_[0];
	I[621] += q621*C_[0];
	I[622] += q622*C_[0];
	I[623] += q623*C_[0];
	I[624] += q624*C_[0];
	I[625] += q625*C_[0];
	I[626] += q626*C_[0];
	I[627] += q627*C_[0];
	I[628] += q628*C_[0];
	I[629] += q629*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q630 = 0.0;
	T q631 = 0.0;
	T q632 = 0.0;
	T q633 = 0.0;
	T q634 = 0.0;
	T q635 = 0.0;
	T q636 = 0.0;
	T q637 = 0.0;
	T q638 = 0.0;
	T q639 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q630 += alpha*Ix(a,2,4)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,2,4)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q631 += alpha*Ix(a,2,0)*Iy(a,1,4)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,1,4)*Iz(a,0,0);  // d/dAz
	    q632 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,4)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,4);  // d/dAz
	    q633 += alpha*Ix(a,2,3)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,2,3)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q634 += alpha*Ix(a,2,3)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,2,3)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q635 += alpha*Ix(a,2,1)*Iy(a,1,3)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,1,3)*Iz(a,0,0);  // d/dAz
	    q636 += alpha*Ix(a,2,0)*Iy(a,1,3)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,1,3)*Iz(a,0,1);  // d/dAz
	    q637 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,3)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,3);  // d/dAz
	    q638 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,3)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,3);  // d/dAz
	    q639 += alpha*Ix(a,2,2)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,2,2)*Iy(a,1,2)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[630] += q630*C_[0];
	I[631] += q631*C_[0];
	I[632] += q632*C_[0];
	I[633] += q633*C_[0];
	I[634] += q634*C_[0];
	I[635] += q635*C_[0];
	I[636] += q636*C_[0];
	I[637] += q637*C_[0];
	I[638] += q638*C_[0];
	I[639] += q639*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q640 = 0.0;
	T q641 = 0.0;
	T q642 = 0.0;
	T q643 = 0.0;
	T q644 = 0.0;
	T q645 = 0.0;
	T q646 = 0.0;
	T q647 = 0.0;
	T q648 = 0.0;
	T q649 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q640 += alpha*Ix(a,2,2)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,2);  // d/dAz
	    q641 += alpha*Ix(a,2,0)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,2);  // d/dAz
	    q642 += alpha*Ix(a,2,2)*Iy(a,1,1)*Iz(a,2,1)
                     - 1*Ix(a,2,2)*Iy(a,1,1)*Iz(a,0,1);  // d/dAz
	    q643 += alpha*Ix(a,2,1)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,2,1)*Iy(a,1,2)*Iz(a,0,1);  // d/dAz
	    q644 += alpha*Ix(a,2,1)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,2);  // d/dAz
	    q645 += alpha*Ix(a,1,4)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,4)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q646 += alpha*Ix(a,1,0)*Iy(a,2,4)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,2,4)*Iz(a,0,0);  // d/dAz
	    q647 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,4)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,4);  // d/dAz
	    q648 += alpha*Ix(a,1,3)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,1,3)*Iy(a,2,1)*Iz(a,0,0);  // d/dAz
	    q649 += alpha*Ix(a,1,3)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,1,3)*Iy(a,2,0)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[640] += q640*C_[0];
	I[641] += q641*C_[0];
	I[642] += q642*C_[0];
	I[643] += q643*C_[0];
	I[644] += q644*C_[0];
	I[645] += q645*C_[0];
	I[646] += q646*C_[0];
	I[647] += q647*C_[0];
	I[648] += q648*C_[0];
	I[649] += q649*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q650 = 0.0;
	T q651 = 0.0;
	T q652 = 0.0;
	T q653 = 0.0;
	T q654 = 0.0;
	T q655 = 0.0;
	T q656 = 0.0;
	T q657 = 0.0;
	T q658 = 0.0;
	T q659 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q650 += alpha*Ix(a,1,1)*Iy(a,2,3)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,2,3)*Iz(a,0,0);  // d/dAz
	    q651 += alpha*Ix(a,1,0)*Iy(a,2,3)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,2,3)*Iz(a,0,1);  // d/dAz
	    q652 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,3)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,3);  // d/dAz
	    q653 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,3);  // d/dAz
	    q654 += alpha*Ix(a,1,2)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,1,2)*Iy(a,2,2)*Iz(a,0,0);  // d/dAz
	    q655 += alpha*Ix(a,1,2)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,2);  // d/dAz
	    q656 += alpha*Ix(a,1,0)*Iy(a,2,2)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,2);  // d/dAz
	    q657 += alpha*Ix(a,1,2)*Iy(a,2,1)*Iz(a,2,1)
                     - 1*Ix(a,1,2)*Iy(a,2,1)*Iz(a,0,1);  // d/dAz
	    q658 += alpha*Ix(a,1,1)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,1,1)*Iy(a,2,2)*Iz(a,0,1);  // d/dAz
	    q659 += alpha*Ix(a,1,1)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,2);  // d/dAz
	}
	    
	//contraction coefficients
	I[650] += q650*C_[0];
	I[651] += q651*C_[0];
	I[652] += q652*C_[0];
	I[653] += q653*C_[0];
	I[654] += q654*C_[0];
	I[655] += q655*C_[0];
	I[656] += q656*C_[0];
	I[657] += q657*C_[0];
	I[658] += q658*C_[0];
	I[659] += q659*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q660 = 0.0;
	T q661 = 0.0;
	T q662 = 0.0;
	T q663 = 0.0;
	T q664 = 0.0;
	T q665 = 0.0;
	T q666 = 0.0;
	T q667 = 0.0;
	T q668 = 0.0;
	T q669 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q660 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,1,4)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q661 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,1,4)*Iz(a,1,0);  // d/dAz
	    q662 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,4)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,4);  // d/dAz
	    q663 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,1,3)*Iy(a,1,1)*Iz(a,1,0);  // d/dAz
	    q664 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,1,3)*Iy(a,1,0)*Iz(a,1,1);  // d/dAz
	    q665 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,1,3)*Iz(a,1,0);  // d/dAz
	    q666 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,1,3)*Iz(a,1,1);  // d/dAz
	    q667 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,3)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,3);  // d/dAz
	    q668 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,3)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,3);  // d/dAz
	    q669 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,3,0)
                     - 2*Ix(a,1,2)*Iy(a,1,2)*Iz(a,1,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[660] += q660*C_[0];
	I[661] += q661*C_[0];
	I[662] += q662*C_[0];
	I[663] += q663*C_[0];
	I[664] += q664*C_[0];
	I[665] += q665*C_[0];
	I[666] += q666*C_[0];
	I[667] += q667*C_[0];
	I[668] += q668*C_[0];
	I[669] += q669*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q670 = 0.0;
	T q671 = 0.0;
	T q672 = 0.0;
	T q673 = 0.0;
	T q674 = 0.0;
	T q675 = 0.0;
	T q676 = 0.0;
	T q677 = 0.0;
	T q678 = 0.0;
	T q679 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q670 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,3,2)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,2);  // d/dAz
	    q671 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,3,2)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,2);  // d/dAz
	    q672 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,3,1)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,1,1);  // d/dAz
	    q673 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,3,1)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,1,1);  // d/dAz
	    q674 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,3,2)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,2);  // d/dAz
	    q675 += beta*Ix(a,4,5)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,4,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q676 += beta*Ix(a,4,1)*Iy(a,0,4)*Iz(a,0,0); // d/dBx
	    q677 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,4); // d/dBx
	    q678 += beta*Ix(a,4,4)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q679 += beta*Ix(a,4,4)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[670] += q670*C_[0];
	I[671] += q671*C_[0];
	I[672] += q672*C_[0];
	I[673] += q673*C_[0];
	I[674] += q674*C_[0];
	I[675] += q675*C_[0];
	I[676] += q676*C_[0];
	I[677] += q677*C_[0];
	I[678] += q678*C_[0];
	I[679] += q679*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q680 = 0.0;
	T q681 = 0.0;
	T q682 = 0.0;
	T q683 = 0.0;
	T q684 = 0.0;
	T q685 = 0.0;
	T q686 = 0.0;
	T q687 = 0.0;
	T q688 = 0.0;
	T q689 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q680 += beta*Ix(a,4,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,4,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBx
	    q681 += beta*Ix(a,4,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBx
	    q682 += beta*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBx
	    q683 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBx
	    q684 += beta*Ix(a,4,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 2*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q685 += beta*Ix(a,4,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 2*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q686 += beta*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,2); // d/dBx
	    q687 += beta*Ix(a,4,3)*Iy(a,0,1)*Iz(a,0,1)
                     - 2*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	    q688 += beta*Ix(a,4,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBx
	    q689 += beta*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[680] += q680*C_[0];
	I[681] += q681*C_[0];
	I[682] += q682*C_[0];
	I[683] += q683*C_[0];
	I[684] += q684*C_[0];
	I[685] += q685*C_[0];
	I[686] += q686*C_[0];
	I[687] += q687*C_[0];
	I[688] += q688*C_[0];
	I[689] += q689*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q690 = 0.0;
	T q691 = 0.0;
	T q692 = 0.0;
	T q693 = 0.0;
	T q694 = 0.0;
	T q695 = 0.0;
	T q696 = 0.0;
	T q697 = 0.0;
	T q698 = 0.0;
	T q699 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q690 += beta*Ix(a,0,5)*Iy(a,4,0)*Iz(a,0,0)
                     - 4*Ix(a,0,3)*Iy(a,4,0)*Iz(a,0,0);  // d/dBx
	    q691 += beta*Ix(a,0,1)*Iy(a,4,4)*Iz(a,0,0); // d/dBx
	    q692 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,4); // d/dBx
	    q693 += beta*Ix(a,0,4)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,0);  // d/dBx
	    q694 += beta*Ix(a,0,4)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,1);  // d/dBx
	    q695 += beta*Ix(a,0,2)*Iy(a,4,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,4,3)*Iz(a,0,0);  // d/dBx
	    q696 += beta*Ix(a,0,1)*Iy(a,4,3)*Iz(a,0,1); // d/dBx
	    q697 += beta*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,3);  // d/dBx
	    q698 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,3); // d/dBx
	    q699 += beta*Ix(a,0,3)*Iy(a,4,2)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[690] += q690*C_[0];
	I[691] += q691*C_[0];
	I[692] += q692*C_[0];
	I[693] += q693*C_[0];
	I[694] += q694*C_[0];
	I[695] += q695*C_[0];
	I[696] += q696*C_[0];
	I[697] += q697*C_[0];
	I[698] += q698*C_[0];
	I[699] += q699*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q700 = 0.0;
	T q701 = 0.0;
	T q702 = 0.0;
	T q703 = 0.0;
	T q704 = 0.0;
	T q705 = 0.0;
	T q706 = 0.0;
	T q707 = 0.0;
	T q708 = 0.0;
	T q709 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q700 += beta*Ix(a,0,3)*Iy(a,4,0)*Iz(a,0,2)
                     - 2*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,2);  // d/dBx
	    q701 += beta*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,2); // d/dBx
	    q702 += beta*Ix(a,0,3)*Iy(a,4,1)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,1);  // d/dBx
	    q703 += beta*Ix(a,0,2)*Iy(a,4,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,1);  // d/dBx
	    q704 += beta*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,2);  // d/dBx
	    q705 += beta*Ix(a,0,5)*Iy(a,0,0)*Iz(a,4,0)
                     - 4*Ix(a,0,3)*Iy(a,0,0)*Iz(a,4,0);  // d/dBx
	    q706 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,4,0); // d/dBx
	    q707 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,4); // d/dBx
	    q708 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,0);  // d/dBx
	    q709 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[700] += q700*C_[0];
	I[701] += q701*C_[0];
	I[702] += q702*C_[0];
	I[703] += q703*C_[0];
	I[704] += q704*C_[0];
	I[705] += q705*C_[0];
	I[706] += q706*C_[0];
	I[707] += q707*C_[0];
	I[708] += q708*C_[0];
	I[709] += q709*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q710 = 0.0;
	T q711 = 0.0;
	T q712 = 0.0;
	T q713 = 0.0;
	T q714 = 0.0;
	T q715 = 0.0;
	T q716 = 0.0;
	T q717 = 0.0;
	T q718 = 0.0;
	T q719 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q710 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,4,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,4,0);  // d/dBx
	    q711 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,4,1); // d/dBx
	    q712 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,3);  // d/dBx
	    q713 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,3); // d/dBx
	    q714 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,4,0)
                     - 2*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,0);  // d/dBx
	    q715 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,4,2)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,2);  // d/dBx
	    q716 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,2); // d/dBx
	    q717 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,4,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,1);  // d/dBx
	    q718 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,4,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,1);  // d/dBx
	    q719 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[710] += q710*C_[0];
	I[711] += q711*C_[0];
	I[712] += q712*C_[0];
	I[713] += q713*C_[0];
	I[714] += q714*C_[0];
	I[715] += q715*C_[0];
	I[716] += q716*C_[0];
	I[717] += q717*C_[0];
	I[718] += q718*C_[0];
	I[719] += q719*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q720 = 0.0;
	T q721 = 0.0;
	T q722 = 0.0;
	T q723 = 0.0;
	T q724 = 0.0;
	T q725 = 0.0;
	T q726 = 0.0;
	T q727 = 0.0;
	T q728 = 0.0;
	T q729 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q720 += beta*Ix(a,3,5)*Iy(a,1,0)*Iz(a,0,0)
                     - 4*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q721 += beta*Ix(a,3,1)*Iy(a,1,4)*Iz(a,0,0); // d/dBx
	    q722 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,4); // d/dBx
	    q723 += beta*Ix(a,3,4)*Iy(a,1,1)*Iz(a,0,0)
                     - 3*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q724 += beta*Ix(a,3,4)*Iy(a,1,0)*Iz(a,0,1)
                     - 3*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q725 += beta*Ix(a,3,2)*Iy(a,1,3)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBx
	    q726 += beta*Ix(a,3,1)*Iy(a,1,3)*Iz(a,0,1); // d/dBx
	    q727 += beta*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,3)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBx
	    q728 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,3); // d/dBx
	    q729 += beta*Ix(a,3,3)*Iy(a,1,2)*Iz(a,0,0)
                     - 2*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[720] += q720*C_[0];
	I[721] += q721*C_[0];
	I[722] += q722*C_[0];
	I[723] += q723*C_[0];
	I[724] += q724*C_[0];
	I[725] += q725*C_[0];
	I[726] += q726*C_[0];
	I[727] += q727*C_[0];
	I[728] += q728*C_[0];
	I[729] += q729*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q730 = 0.0;
	T q731 = 0.0;
	T q732 = 0.0;
	T q733 = 0.0;
	T q734 = 0.0;
	T q735 = 0.0;
	T q736 = 0.0;
	T q737 = 0.0;
	T q738 = 0.0;
	T q739 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q730 += beta*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,2)
                     - 2*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBx
	    q731 += beta*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,2); // d/dBx
	    q732 += beta*Ix(a,3,3)*Iy(a,1,1)*Iz(a,0,1)
                     - 2*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBx
	    q733 += beta*Ix(a,3,2)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBx
	    q734 += beta*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBx
	    q735 += beta*Ix(a,3,5)*Iy(a,0,0)*Iz(a,1,0)
                     - 4*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q736 += beta*Ix(a,3,1)*Iy(a,0,4)*Iz(a,1,0); // d/dBx
	    q737 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,4); // d/dBx
	    q738 += beta*Ix(a,3,4)*Iy(a,0,1)*Iz(a,1,0)
                     - 3*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q739 += beta*Ix(a,3,4)*Iy(a,0,0)*Iz(a,1,1)
                     - 3*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[730] += q730*C_[0];
	I[731] += q731*C_[0];
	I[732] += q732*C_[0];
	I[733] += q733*C_[0];
	I[734] += q734*C_[0];
	I[735] += q735*C_[0];
	I[736] += q736*C_[0];
	I[737] += q737*C_[0];
	I[738] += q738*C_[0];
	I[739] += q739*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q740 = 0.0;
	T q741 = 0.0;
	T q742 = 0.0;
	T q743 = 0.0;
	T q744 = 0.0;
	T q745 = 0.0;
	T q746 = 0.0;
	T q747 = 0.0;
	T q748 = 0.0;
	T q749 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q740 += beta*Ix(a,3,2)*Iy(a,0,3)*Iz(a,1,0)
                     - 1*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBx
	    q741 += beta*Ix(a,3,1)*Iy(a,0,3)*Iz(a,1,1); // d/dBx
	    q742 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,3)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBx
	    q743 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,3); // d/dBx
	    q744 += beta*Ix(a,3,3)*Iy(a,0,2)*Iz(a,1,0)
                     - 2*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBx
	    q745 += beta*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,2)
                     - 2*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBx
	    q746 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,2); // d/dBx
	    q747 += beta*Ix(a,3,3)*Iy(a,0,1)*Iz(a,1,1)
                     - 2*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBx
	    q748 += beta*Ix(a,3,2)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBx
	    q749 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[740] += q740*C_[0];
	I[741] += q741*C_[0];
	I[742] += q742*C_[0];
	I[743] += q743*C_[0];
	I[744] += q744*C_[0];
	I[745] += q745*C_[0];
	I[746] += q746*C_[0];
	I[747] += q747*C_[0];
	I[748] += q748*C_[0];
	I[749] += q749*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q750 = 0.0;
	T q751 = 0.0;
	T q752 = 0.0;
	T q753 = 0.0;
	T q754 = 0.0;
	T q755 = 0.0;
	T q756 = 0.0;
	T q757 = 0.0;
	T q758 = 0.0;
	T q759 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q750 += beta*Ix(a,1,5)*Iy(a,3,0)*Iz(a,0,0)
                     - 4*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,0);  // d/dBx
	    q751 += beta*Ix(a,1,1)*Iy(a,3,4)*Iz(a,0,0); // d/dBx
	    q752 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,4); // d/dBx
	    q753 += beta*Ix(a,1,4)*Iy(a,3,1)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,0);  // d/dBx
	    q754 += beta*Ix(a,1,4)*Iy(a,3,0)*Iz(a,0,1)
                     - 3*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,1);  // d/dBx
	    q755 += beta*Ix(a,1,2)*Iy(a,3,3)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,0);  // d/dBx
	    q756 += beta*Ix(a,1,1)*Iy(a,3,3)*Iz(a,0,1); // d/dBx
	    q757 += beta*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,3);  // d/dBx
	    q758 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,3); // d/dBx
	    q759 += beta*Ix(a,1,3)*Iy(a,3,2)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[750] += q750*C_[0];
	I[751] += q751*C_[0];
	I[752] += q752*C_[0];
	I[753] += q753*C_[0];
	I[754] += q754*C_[0];
	I[755] += q755*C_[0];
	I[756] += q756*C_[0];
	I[757] += q757*C_[0];
	I[758] += q758*C_[0];
	I[759] += q759*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q760 = 0.0;
	T q761 = 0.0;
	T q762 = 0.0;
	T q763 = 0.0;
	T q764 = 0.0;
	T q765 = 0.0;
	T q766 = 0.0;
	T q767 = 0.0;
	T q768 = 0.0;
	T q769 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q760 += beta*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,2);  // d/dBx
	    q761 += beta*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,2); // d/dBx
	    q762 += beta*Ix(a,1,3)*Iy(a,3,1)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,1);  // d/dBx
	    q763 += beta*Ix(a,1,2)*Iy(a,3,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,1);  // d/dBx
	    q764 += beta*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,2);  // d/dBx
	    q765 += beta*Ix(a,0,5)*Iy(a,3,0)*Iz(a,1,0)
                     - 4*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,0);  // d/dBx
	    q766 += beta*Ix(a,0,1)*Iy(a,3,4)*Iz(a,1,0); // d/dBx
	    q767 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,4); // d/dBx
	    q768 += beta*Ix(a,0,4)*Iy(a,3,1)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,0);  // d/dBx
	    q769 += beta*Ix(a,0,4)*Iy(a,3,0)*Iz(a,1,1)
                     - 3*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[760] += q760*C_[0];
	I[761] += q761*C_[0];
	I[762] += q762*C_[0];
	I[763] += q763*C_[0];
	I[764] += q764*C_[0];
	I[765] += q765*C_[0];
	I[766] += q766*C_[0];
	I[767] += q767*C_[0];
	I[768] += q768*C_[0];
	I[769] += q769*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q770 = 0.0;
	T q771 = 0.0;
	T q772 = 0.0;
	T q773 = 0.0;
	T q774 = 0.0;
	T q775 = 0.0;
	T q776 = 0.0;
	T q777 = 0.0;
	T q778 = 0.0;
	T q779 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q770 += beta*Ix(a,0,2)*Iy(a,3,3)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,0);  // d/dBx
	    q771 += beta*Ix(a,0,1)*Iy(a,3,3)*Iz(a,1,1); // d/dBx
	    q772 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,3);  // d/dBx
	    q773 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,3); // d/dBx
	    q774 += beta*Ix(a,0,3)*Iy(a,3,2)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,0);  // d/dBx
	    q775 += beta*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,2)
                     - 2*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,2);  // d/dBx
	    q776 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,2); // d/dBx
	    q777 += beta*Ix(a,0,3)*Iy(a,3,1)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,1);  // d/dBx
	    q778 += beta*Ix(a,0,2)*Iy(a,3,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,1);  // d/dBx
	    q779 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[770] += q770*C_[0];
	I[771] += q771*C_[0];
	I[772] += q772*C_[0];
	I[773] += q773*C_[0];
	I[774] += q774*C_[0];
	I[775] += q775*C_[0];
	I[776] += q776*C_[0];
	I[777] += q777*C_[0];
	I[778] += q778*C_[0];
	I[779] += q779*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q780 = 0.0;
	T q781 = 0.0;
	T q782 = 0.0;
	T q783 = 0.0;
	T q784 = 0.0;
	T q785 = 0.0;
	T q786 = 0.0;
	T q787 = 0.0;
	T q788 = 0.0;
	T q789 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q780 += beta*Ix(a,1,5)*Iy(a,0,0)*Iz(a,3,0)
                     - 4*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,0);  // d/dBx
	    q781 += beta*Ix(a,1,1)*Iy(a,0,4)*Iz(a,3,0); // d/dBx
	    q782 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,4); // d/dBx
	    q783 += beta*Ix(a,1,4)*Iy(a,0,1)*Iz(a,3,0)
                     - 3*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,0);  // d/dBx
	    q784 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,3,1)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,1);  // d/dBx
	    q785 += beta*Ix(a,1,2)*Iy(a,0,3)*Iz(a,3,0)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,0);  // d/dBx
	    q786 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,3,1); // d/dBx
	    q787 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,3);  // d/dBx
	    q788 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,3); // d/dBx
	    q789 += beta*Ix(a,1,3)*Iy(a,0,2)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[780] += q780*C_[0];
	I[781] += q781*C_[0];
	I[782] += q782*C_[0];
	I[783] += q783*C_[0];
	I[784] += q784*C_[0];
	I[785] += q785*C_[0];
	I[786] += q786*C_[0];
	I[787] += q787*C_[0];
	I[788] += q788*C_[0];
	I[789] += q789*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q790 = 0.0;
	T q791 = 0.0;
	T q792 = 0.0;
	T q793 = 0.0;
	T q794 = 0.0;
	T q795 = 0.0;
	T q796 = 0.0;
	T q797 = 0.0;
	T q798 = 0.0;
	T q799 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q790 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,2)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,2);  // d/dBx
	    q791 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,2); // d/dBx
	    q792 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,3,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,1);  // d/dBx
	    q793 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,3,1)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,1);  // d/dBx
	    q794 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,2);  // d/dBx
	    q795 += beta*Ix(a,0,5)*Iy(a,1,0)*Iz(a,3,0)
                     - 4*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,0);  // d/dBx
	    q796 += beta*Ix(a,0,1)*Iy(a,1,4)*Iz(a,3,0); // d/dBx
	    q797 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,4); // d/dBx
	    q798 += beta*Ix(a,0,4)*Iy(a,1,1)*Iz(a,3,0)
                     - 3*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,0);  // d/dBx
	    q799 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,3,1)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[790] += q790*C_[0];
	I[791] += q791*C_[0];
	I[792] += q792*C_[0];
	I[793] += q793*C_[0];
	I[794] += q794*C_[0];
	I[795] += q795*C_[0];
	I[796] += q796*C_[0];
	I[797] += q797*C_[0];
	I[798] += q798*C_[0];
	I[799] += q799*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q800 = 0.0;
	T q801 = 0.0;
	T q802 = 0.0;
	T q803 = 0.0;
	T q804 = 0.0;
	T q805 = 0.0;
	T q806 = 0.0;
	T q807 = 0.0;
	T q808 = 0.0;
	T q809 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q800 += beta*Ix(a,0,2)*Iy(a,1,3)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,0);  // d/dBx
	    q801 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,3,1); // d/dBx
	    q802 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,3);  // d/dBx
	    q803 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,3); // d/dBx
	    q804 += beta*Ix(a,0,3)*Iy(a,1,2)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,0);  // d/dBx
	    q805 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,2)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,2);  // d/dBx
	    q806 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,2); // d/dBx
	    q807 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,1);  // d/dBx
	    q808 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,1);  // d/dBx
	    q809 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[800] += q800*C_[0];
	I[801] += q801*C_[0];
	I[802] += q802*C_[0];
	I[803] += q803*C_[0];
	I[804] += q804*C_[0];
	I[805] += q805*C_[0];
	I[806] += q806*C_[0];
	I[807] += q807*C_[0];
	I[808] += q808*C_[0];
	I[809] += q809*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q810 = 0.0;
	T q811 = 0.0;
	T q812 = 0.0;
	T q813 = 0.0;
	T q814 = 0.0;
	T q815 = 0.0;
	T q816 = 0.0;
	T q817 = 0.0;
	T q818 = 0.0;
	T q819 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q810 += beta*Ix(a,2,5)*Iy(a,2,0)*Iz(a,0,0)
                     - 4*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q811 += beta*Ix(a,2,1)*Iy(a,2,4)*Iz(a,0,0); // d/dBx
	    q812 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,4); // d/dBx
	    q813 += beta*Ix(a,2,4)*Iy(a,2,1)*Iz(a,0,0)
                     - 3*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dBx
	    q814 += beta*Ix(a,2,4)*Iy(a,2,0)*Iz(a,0,1)
                     - 3*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dBx
	    q815 += beta*Ix(a,2,2)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dBx
	    q816 += beta*Ix(a,2,1)*Iy(a,2,3)*Iz(a,0,1); // d/dBx
	    q817 += beta*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dBx
	    q818 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,3); // d/dBx
	    q819 += beta*Ix(a,2,3)*Iy(a,2,2)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[810] += q810*C_[0];
	I[811] += q811*C_[0];
	I[812] += q812*C_[0];
	I[813] += q813*C_[0];
	I[814] += q814*C_[0];
	I[815] += q815*C_[0];
	I[816] += q816*C_[0];
	I[817] += q817*C_[0];
	I[818] += q818*C_[0];
	I[819] += q819*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q820 = 0.0;
	T q821 = 0.0;
	T q822 = 0.0;
	T q823 = 0.0;
	T q824 = 0.0;
	T q825 = 0.0;
	T q826 = 0.0;
	T q827 = 0.0;
	T q828 = 0.0;
	T q829 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q820 += beta*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,2)
                     - 2*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dBx
	    q821 += beta*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,2); // d/dBx
	    q822 += beta*Ix(a,2,3)*Iy(a,2,1)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dBx
	    q823 += beta*Ix(a,2,2)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dBx
	    q824 += beta*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dBx
	    q825 += beta*Ix(a,2,5)*Iy(a,0,0)*Iz(a,2,0)
                     - 4*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q826 += beta*Ix(a,2,1)*Iy(a,0,4)*Iz(a,2,0); // d/dBx
	    q827 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,4); // d/dBx
	    q828 += beta*Ix(a,2,4)*Iy(a,0,1)*Iz(a,2,0)
                     - 3*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dBx
	    q829 += beta*Ix(a,2,4)*Iy(a,0,0)*Iz(a,2,1)
                     - 3*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[820] += q820*C_[0];
	I[821] += q821*C_[0];
	I[822] += q822*C_[0];
	I[823] += q823*C_[0];
	I[824] += q824*C_[0];
	I[825] += q825*C_[0];
	I[826] += q826*C_[0];
	I[827] += q827*C_[0];
	I[828] += q828*C_[0];
	I[829] += q829*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q830 = 0.0;
	T q831 = 0.0;
	T q832 = 0.0;
	T q833 = 0.0;
	T q834 = 0.0;
	T q835 = 0.0;
	T q836 = 0.0;
	T q837 = 0.0;
	T q838 = 0.0;
	T q839 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q830 += beta*Ix(a,2,2)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dBx
	    q831 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,2,1); // d/dBx
	    q832 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dBx
	    q833 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,3); // d/dBx
	    q834 += beta*Ix(a,2,3)*Iy(a,0,2)*Iz(a,2,0)
                     - 2*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dBx
	    q835 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,2)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dBx
	    q836 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,2); // d/dBx
	    q837 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,2,1)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dBx
	    q838 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dBx
	    q839 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[830] += q830*C_[0];
	I[831] += q831*C_[0];
	I[832] += q832*C_[0];
	I[833] += q833*C_[0];
	I[834] += q834*C_[0];
	I[835] += q835*C_[0];
	I[836] += q836*C_[0];
	I[837] += q837*C_[0];
	I[838] += q838*C_[0];
	I[839] += q839*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q840 = 0.0;
	T q841 = 0.0;
	T q842 = 0.0;
	T q843 = 0.0;
	T q844 = 0.0;
	T q845 = 0.0;
	T q846 = 0.0;
	T q847 = 0.0;
	T q848 = 0.0;
	T q849 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q840 += beta*Ix(a,0,5)*Iy(a,2,0)*Iz(a,2,0)
                     - 4*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,0);  // d/dBx
	    q841 += beta*Ix(a,0,1)*Iy(a,2,4)*Iz(a,2,0); // d/dBx
	    q842 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,4); // d/dBx
	    q843 += beta*Ix(a,0,4)*Iy(a,2,1)*Iz(a,2,0)
                     - 3*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,0);  // d/dBx
	    q844 += beta*Ix(a,0,4)*Iy(a,2,0)*Iz(a,2,1)
                     - 3*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,1);  // d/dBx
	    q845 += beta*Ix(a,0,2)*Iy(a,2,3)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,0);  // d/dBx
	    q846 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,2,1); // d/dBx
	    q847 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,3);  // d/dBx
	    q848 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,3); // d/dBx
	    q849 += beta*Ix(a,0,3)*Iy(a,2,2)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[840] += q840*C_[0];
	I[841] += q841*C_[0];
	I[842] += q842*C_[0];
	I[843] += q843*C_[0];
	I[844] += q844*C_[0];
	I[845] += q845*C_[0];
	I[846] += q846*C_[0];
	I[847] += q847*C_[0];
	I[848] += q848*C_[0];
	I[849] += q849*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q850 = 0.0;
	T q851 = 0.0;
	T q852 = 0.0;
	T q853 = 0.0;
	T q854 = 0.0;
	T q855 = 0.0;
	T q856 = 0.0;
	T q857 = 0.0;
	T q858 = 0.0;
	T q859 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q850 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,2)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,2);  // d/dBx
	    q851 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,2); // d/dBx
	    q852 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,1);  // d/dBx
	    q853 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,1);  // d/dBx
	    q854 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,2);  // d/dBx
	    q855 += beta*Ix(a,2,5)*Iy(a,1,0)*Iz(a,1,0)
                     - 4*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q856 += beta*Ix(a,2,1)*Iy(a,1,4)*Iz(a,1,0); // d/dBx
	    q857 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,4); // d/dBx
	    q858 += beta*Ix(a,2,4)*Iy(a,1,1)*Iz(a,1,0)
                     - 3*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dBx
	    q859 += beta*Ix(a,2,4)*Iy(a,1,0)*Iz(a,1,1)
                     - 3*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[850] += q850*C_[0];
	I[851] += q851*C_[0];
	I[852] += q852*C_[0];
	I[853] += q853*C_[0];
	I[854] += q854*C_[0];
	I[855] += q855*C_[0];
	I[856] += q856*C_[0];
	I[857] += q857*C_[0];
	I[858] += q858*C_[0];
	I[859] += q859*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q860 = 0.0;
	T q861 = 0.0;
	T q862 = 0.0;
	T q863 = 0.0;
	T q864 = 0.0;
	T q865 = 0.0;
	T q866 = 0.0;
	T q867 = 0.0;
	T q868 = 0.0;
	T q869 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q860 += beta*Ix(a,2,2)*Iy(a,1,3)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dBx
	    q861 += beta*Ix(a,2,1)*Iy(a,1,3)*Iz(a,1,1); // d/dBx
	    q862 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,3)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dBx
	    q863 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,3); // d/dBx
	    q864 += beta*Ix(a,2,3)*Iy(a,1,2)*Iz(a,1,0)
                     - 2*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dBx
	    q865 += beta*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,2)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dBx
	    q866 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,2); // d/dBx
	    q867 += beta*Ix(a,2,3)*Iy(a,1,1)*Iz(a,1,1)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dBx
	    q868 += beta*Ix(a,2,2)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dBx
	    q869 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[860] += q860*C_[0];
	I[861] += q861*C_[0];
	I[862] += q862*C_[0];
	I[863] += q863*C_[0];
	I[864] += q864*C_[0];
	I[865] += q865*C_[0];
	I[866] += q866*C_[0];
	I[867] += q867*C_[0];
	I[868] += q868*C_[0];
	I[869] += q869*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q870 = 0.0;
	T q871 = 0.0;
	T q872 = 0.0;
	T q873 = 0.0;
	T q874 = 0.0;
	T q875 = 0.0;
	T q876 = 0.0;
	T q877 = 0.0;
	T q878 = 0.0;
	T q879 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q870 += beta*Ix(a,1,5)*Iy(a,2,0)*Iz(a,1,0)
                     - 4*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,0);  // d/dBx
	    q871 += beta*Ix(a,1,1)*Iy(a,2,4)*Iz(a,1,0); // d/dBx
	    q872 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,4); // d/dBx
	    q873 += beta*Ix(a,1,4)*Iy(a,2,1)*Iz(a,1,0)
                     - 3*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,0);  // d/dBx
	    q874 += beta*Ix(a,1,4)*Iy(a,2,0)*Iz(a,1,1)
                     - 3*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,1);  // d/dBx
	    q875 += beta*Ix(a,1,2)*Iy(a,2,3)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,0);  // d/dBx
	    q876 += beta*Ix(a,1,1)*Iy(a,2,3)*Iz(a,1,1); // d/dBx
	    q877 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,3)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,3);  // d/dBx
	    q878 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,3); // d/dBx
	    q879 += beta*Ix(a,1,3)*Iy(a,2,2)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[870] += q870*C_[0];
	I[871] += q871*C_[0];
	I[872] += q872*C_[0];
	I[873] += q873*C_[0];
	I[874] += q874*C_[0];
	I[875] += q875*C_[0];
	I[876] += q876*C_[0];
	I[877] += q877*C_[0];
	I[878] += q878*C_[0];
	I[879] += q879*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q880 = 0.0;
	T q881 = 0.0;
	T q882 = 0.0;
	T q883 = 0.0;
	T q884 = 0.0;
	T q885 = 0.0;
	T q886 = 0.0;
	T q887 = 0.0;
	T q888 = 0.0;
	T q889 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q880 += beta*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,2)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,2);  // d/dBx
	    q881 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,2); // d/dBx
	    q882 += beta*Ix(a,1,3)*Iy(a,2,1)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,1);  // d/dBx
	    q883 += beta*Ix(a,1,2)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,1);  // d/dBx
	    q884 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,2);  // d/dBx
	    q885 += beta*Ix(a,1,5)*Iy(a,1,0)*Iz(a,2,0)
                     - 4*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,0);  // d/dBx
	    q886 += beta*Ix(a,1,1)*Iy(a,1,4)*Iz(a,2,0); // d/dBx
	    q887 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,4); // d/dBx
	    q888 += beta*Ix(a,1,4)*Iy(a,1,1)*Iz(a,2,0)
                     - 3*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,0);  // d/dBx
	    q889 += beta*Ix(a,1,4)*Iy(a,1,0)*Iz(a,2,1)
                     - 3*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[880] += q880*C_[0];
	I[881] += q881*C_[0];
	I[882] += q882*C_[0];
	I[883] += q883*C_[0];
	I[884] += q884*C_[0];
	I[885] += q885*C_[0];
	I[886] += q886*C_[0];
	I[887] += q887*C_[0];
	I[888] += q888*C_[0];
	I[889] += q889*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q890 = 0.0;
	T q891 = 0.0;
	T q892 = 0.0;
	T q893 = 0.0;
	T q894 = 0.0;
	T q895 = 0.0;
	T q896 = 0.0;
	T q897 = 0.0;
	T q898 = 0.0;
	T q899 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q890 += beta*Ix(a,1,2)*Iy(a,1,3)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,0);  // d/dBx
	    q891 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,2,1); // d/dBx
	    q892 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,3);  // d/dBx
	    q893 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,3); // d/dBx
	    q894 += beta*Ix(a,1,3)*Iy(a,1,2)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,0);  // d/dBx
	    q895 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,2)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,2);  // d/dBx
	    q896 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,2); // d/dBx
	    q897 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,2,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,1);  // d/dBx
	    q898 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,1);  // d/dBx
	    q899 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[890] += q890*C_[0];
	I[891] += q891*C_[0];
	I[892] += q892*C_[0];
	I[893] += q893*C_[0];
	I[894] += q894*C_[0];
	I[895] += q895*C_[0];
	I[896] += q896*C_[0];
	I[897] += q897*C_[0];
	I[898] += q898*C_[0];
	I[899] += q899*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q900 = 0.0;
	T q901 = 0.0;
	T q902 = 0.0;
	T q903 = 0.0;
	T q904 = 0.0;
	T q905 = 0.0;
	T q906 = 0.0;
	T q907 = 0.0;
	T q908 = 0.0;
	T q909 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q900 += beta*Ix(a,4,4)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q901 += beta*Ix(a,4,0)*Iy(a,0,5)*Iz(a,0,0)
                     - 4*Ix(a,4,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBy
	    q902 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,4); // d/dBy
	    q903 += beta*Ix(a,4,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,4,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q904 += beta*Ix(a,4,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q905 += beta*Ix(a,4,1)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q906 += beta*Ix(a,4,0)*Iy(a,0,4)*Iz(a,0,1)
                     - 3*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBy
	    q907 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q908 += beta*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBy
	    q909 += beta*Ix(a,4,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[900] += q900*C_[0];
	I[901] += q901*C_[0];
	I[902] += q902*C_[0];
	I[903] += q903*C_[0];
	I[904] += q904*C_[0];
	I[905] += q905*C_[0];
	I[906] += q906*C_[0];
	I[907] += q907*C_[0];
	I[908] += q908*C_[0];
	I[909] += q909*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q910 = 0.0;
	T q911 = 0.0;
	T q912 = 0.0;
	T q913 = 0.0;
	T q914 = 0.0;
	T q915 = 0.0;
	T q916 = 0.0;
	T q917 = 0.0;
	T q918 = 0.0;
	T q919 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q910 += beta*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q911 += beta*Ix(a,4,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 2*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBy
	    q912 += beta*Ix(a,4,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q913 += beta*Ix(a,4,1)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q914 += beta*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q915 += beta*Ix(a,0,4)*Iy(a,4,1)*Iz(a,0,0); // d/dBy
	    q916 += beta*Ix(a,0,0)*Iy(a,4,5)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,4,3)*Iz(a,0,0);  // d/dBy
	    q917 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,4); // d/dBy
	    q918 += beta*Ix(a,0,3)*Iy(a,4,2)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,4,0)*Iz(a,0,0);  // d/dBy
	    q919 += beta*Ix(a,0,3)*Iy(a,4,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[910] += q910*C_[0];
	I[911] += q911*C_[0];
	I[912] += q912*C_[0];
	I[913] += q913*C_[0];
	I[914] += q914*C_[0];
	I[915] += q915*C_[0];
	I[916] += q916*C_[0];
	I[917] += q917*C_[0];
	I[918] += q918*C_[0];
	I[919] += q919*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q920 = 0.0;
	T q921 = 0.0;
	T q922 = 0.0;
	T q923 = 0.0;
	T q924 = 0.0;
	T q925 = 0.0;
	T q926 = 0.0;
	T q927 = 0.0;
	T q928 = 0.0;
	T q929 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q920 += beta*Ix(a,0,1)*Iy(a,4,4)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,0);  // d/dBy
	    q921 += beta*Ix(a,0,0)*Iy(a,4,4)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,1);  // d/dBy
	    q922 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,3); // d/dBy
	    q923 += beta*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,3);  // d/dBy
	    q924 += beta*Ix(a,0,2)*Iy(a,4,3)*Iz(a,0,0)
                     - 2*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,0);  // d/dBy
	    q925 += beta*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,2); // d/dBy
	    q926 += beta*Ix(a,0,0)*Iy(a,4,3)*Iz(a,0,2)
                     - 2*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,2);  // d/dBy
	    q927 += beta*Ix(a,0,2)*Iy(a,4,2)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,1);  // d/dBy
	    q928 += beta*Ix(a,0,1)*Iy(a,4,3)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,1);  // d/dBy
	    q929 += beta*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[920] += q920*C_[0];
	I[921] += q921*C_[0];
	I[922] += q922*C_[0];
	I[923] += q923*C_[0];
	I[924] += q924*C_[0];
	I[925] += q925*C_[0];
	I[926] += q926*C_[0];
	I[927] += q927*C_[0];
	I[928] += q928*C_[0];
	I[929] += q929*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q930 = 0.0;
	T q931 = 0.0;
	T q932 = 0.0;
	T q933 = 0.0;
	T q934 = 0.0;
	T q935 = 0.0;
	T q936 = 0.0;
	T q937 = 0.0;
	T q938 = 0.0;
	T q939 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q930 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,4,0); // d/dBy
	    q931 += beta*Ix(a,0,0)*Iy(a,0,5)*Iz(a,4,0)
                     - 4*Ix(a,0,0)*Iy(a,0,3)*Iz(a,4,0);  // d/dBy
	    q932 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,4); // d/dBy
	    q933 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,4,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,4,0);  // d/dBy
	    q934 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,4,1); // d/dBy
	    q935 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,0);  // d/dBy
	    q936 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,1);  // d/dBy
	    q937 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,3); // d/dBy
	    q938 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,3);  // d/dBy
	    q939 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,4,0)
                     - 2*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[930] += q930*C_[0];
	I[931] += q931*C_[0];
	I[932] += q932*C_[0];
	I[933] += q933*C_[0];
	I[934] += q934*C_[0];
	I[935] += q935*C_[0];
	I[936] += q936*C_[0];
	I[937] += q937*C_[0];
	I[938] += q938*C_[0];
	I[939] += q939*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q940 = 0.0;
	T q941 = 0.0;
	T q942 = 0.0;
	T q943 = 0.0;
	T q944 = 0.0;
	T q945 = 0.0;
	T q946 = 0.0;
	T q947 = 0.0;
	T q948 = 0.0;
	T q949 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q940 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,2); // d/dBy
	    q941 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,4,2)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,2);  // d/dBy
	    q942 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,4,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,1);  // d/dBy
	    q943 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,4,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,1);  // d/dBy
	    q944 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,2);  // d/dBy
	    q945 += beta*Ix(a,3,4)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q946 += beta*Ix(a,3,0)*Iy(a,1,5)*Iz(a,0,0)
                     - 4*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBy
	    q947 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,4); // d/dBy
	    q948 += beta*Ix(a,3,3)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q949 += beta*Ix(a,3,3)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[940] += q940*C_[0];
	I[941] += q941*C_[0];
	I[942] += q942*C_[0];
	I[943] += q943*C_[0];
	I[944] += q944*C_[0];
	I[945] += q945*C_[0];
	I[946] += q946*C_[0];
	I[947] += q947*C_[0];
	I[948] += q948*C_[0];
	I[949] += q949*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q950 = 0.0;
	T q951 = 0.0;
	T q952 = 0.0;
	T q953 = 0.0;
	T q954 = 0.0;
	T q955 = 0.0;
	T q956 = 0.0;
	T q957 = 0.0;
	T q958 = 0.0;
	T q959 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q950 += beta*Ix(a,3,1)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBy
	    q951 += beta*Ix(a,3,0)*Iy(a,1,4)*Iz(a,0,1)
                     - 3*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBy
	    q952 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,3); // d/dBy
	    q953 += beta*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,3)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBy
	    q954 += beta*Ix(a,3,2)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	    q955 += beta*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q956 += beta*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,2)
                     - 2*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBy
	    q957 += beta*Ix(a,3,2)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	    q958 += beta*Ix(a,3,1)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBy
	    q959 += beta*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[950] += q950*C_[0];
	I[951] += q951*C_[0];
	I[952] += q952*C_[0];
	I[953] += q953*C_[0];
	I[954] += q954*C_[0];
	I[955] += q955*C_[0];
	I[956] += q956*C_[0];
	I[957] += q957*C_[0];
	I[958] += q958*C_[0];
	I[959] += q959*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q960 = 0.0;
	T q961 = 0.0;
	T q962 = 0.0;
	T q963 = 0.0;
	T q964 = 0.0;
	T q965 = 0.0;
	T q966 = 0.0;
	T q967 = 0.0;
	T q968 = 0.0;
	T q969 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q960 += beta*Ix(a,3,4)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q961 += beta*Ix(a,3,0)*Iy(a,0,5)*Iz(a,1,0)
                     - 4*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBy
	    q962 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,4); // d/dBy
	    q963 += beta*Ix(a,3,3)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q964 += beta*Ix(a,3,3)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q965 += beta*Ix(a,3,1)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBy
	    q966 += beta*Ix(a,3,0)*Iy(a,0,4)*Iz(a,1,1)
                     - 3*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBy
	    q967 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,3); // d/dBy
	    q968 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,3)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBy
	    q969 += beta*Ix(a,3,2)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[960] += q960*C_[0];
	I[961] += q961*C_[0];
	I[962] += q962*C_[0];
	I[963] += q963*C_[0];
	I[964] += q964*C_[0];
	I[965] += q965*C_[0];
	I[966] += q966*C_[0];
	I[967] += q967*C_[0];
	I[968] += q968*C_[0];
	I[969] += q969*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q970 = 0.0;
	T q971 = 0.0;
	T q972 = 0.0;
	T q973 = 0.0;
	T q974 = 0.0;
	T q975 = 0.0;
	T q976 = 0.0;
	T q977 = 0.0;
	T q978 = 0.0;
	T q979 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q970 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q971 += beta*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,2)
                     - 2*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBy
	    q972 += beta*Ix(a,3,2)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	    q973 += beta*Ix(a,3,1)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBy
	    q974 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBy
	    q975 += beta*Ix(a,1,4)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q976 += beta*Ix(a,1,0)*Iy(a,3,5)*Iz(a,0,0)
                     - 4*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,0);  // d/dBy
	    q977 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,4); // d/dBy
	    q978 += beta*Ix(a,1,3)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,0);  // d/dBy
	    q979 += beta*Ix(a,1,3)*Iy(a,3,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[970] += q970*C_[0];
	I[971] += q971*C_[0];
	I[972] += q972*C_[0];
	I[973] += q973*C_[0];
	I[974] += q974*C_[0];
	I[975] += q975*C_[0];
	I[976] += q976*C_[0];
	I[977] += q977*C_[0];
	I[978] += q978*C_[0];
	I[979] += q979*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q980 = 0.0;
	T q981 = 0.0;
	T q982 = 0.0;
	T q983 = 0.0;
	T q984 = 0.0;
	T q985 = 0.0;
	T q986 = 0.0;
	T q987 = 0.0;
	T q988 = 0.0;
	T q989 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q980 += beta*Ix(a,1,1)*Iy(a,3,4)*Iz(a,0,0)
                     - 3*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,0);  // d/dBy
	    q981 += beta*Ix(a,1,0)*Iy(a,3,4)*Iz(a,0,1)
                     - 3*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,1);  // d/dBy
	    q982 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,3); // d/dBy
	    q983 += beta*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,3);  // d/dBy
	    q984 += beta*Ix(a,1,2)*Iy(a,3,3)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,0);  // d/dBy
	    q985 += beta*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,2); // d/dBy
	    q986 += beta*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,2);  // d/dBy
	    q987 += beta*Ix(a,1,2)*Iy(a,3,2)*Iz(a,0,1)
                     - 1*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,1);  // d/dBy
	    q988 += beta*Ix(a,1,1)*Iy(a,3,3)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,1);  // d/dBy
	    q989 += beta*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[980] += q980*C_[0];
	I[981] += q981*C_[0];
	I[982] += q982*C_[0];
	I[983] += q983*C_[0];
	I[984] += q984*C_[0];
	I[985] += q985*C_[0];
	I[986] += q986*C_[0];
	I[987] += q987*C_[0];
	I[988] += q988*C_[0];
	I[989] += q989*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q990 = 0.0;
	T q991 = 0.0;
	T q992 = 0.0;
	T q993 = 0.0;
	T q994 = 0.0;
	T q995 = 0.0;
	T q996 = 0.0;
	T q997 = 0.0;
	T q998 = 0.0;
	T q999 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q990 += beta*Ix(a,0,4)*Iy(a,3,1)*Iz(a,1,0); // d/dBy
	    q991 += beta*Ix(a,0,0)*Iy(a,3,5)*Iz(a,1,0)
                     - 4*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,0);  // d/dBy
	    q992 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,4); // d/dBy
	    q993 += beta*Ix(a,0,3)*Iy(a,3,2)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,0);  // d/dBy
	    q994 += beta*Ix(a,0,3)*Iy(a,3,1)*Iz(a,1,1); // d/dBy
	    q995 += beta*Ix(a,0,1)*Iy(a,3,4)*Iz(a,1,0)
                     - 3*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,0);  // d/dBy
	    q996 += beta*Ix(a,0,0)*Iy(a,3,4)*Iz(a,1,1)
                     - 3*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,1);  // d/dBy
	    q997 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,3); // d/dBy
	    q998 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,3);  // d/dBy
	    q999 += beta*Ix(a,0,2)*Iy(a,3,3)*Iz(a,1,0)
                     - 2*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[990] += q990*C_[0];
	I[991] += q991*C_[0];
	I[992] += q992*C_[0];
	I[993] += q993*C_[0];
	I[994] += q994*C_[0];
	I[995] += q995*C_[0];
	I[996] += q996*C_[0];
	I[997] += q997*C_[0];
	I[998] += q998*C_[0];
	I[999] += q999*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1000 = 0.0;
	T q1001 = 0.0;
	T q1002 = 0.0;
	T q1003 = 0.0;
	T q1004 = 0.0;
	T q1005 = 0.0;
	T q1006 = 0.0;
	T q1007 = 0.0;
	T q1008 = 0.0;
	T q1009 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1000 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,2); // d/dBy
	    q1001 += beta*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,2)
                     - 2*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,2);  // d/dBy
	    q1002 += beta*Ix(a,0,2)*Iy(a,3,2)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,1);  // d/dBy
	    q1003 += beta*Ix(a,0,1)*Iy(a,3,3)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,1);  // d/dBy
	    q1004 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,2);  // d/dBy
	    q1005 += beta*Ix(a,1,4)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q1006 += beta*Ix(a,1,0)*Iy(a,0,5)*Iz(a,3,0)
                     - 4*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,0);  // d/dBy
	    q1007 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,4); // d/dBy
	    q1008 += beta*Ix(a,1,3)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,0);  // d/dBy
	    q1009 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,3,1); // d/dBy
	}
	    
	//contraction coefficients
	I[1000] += q1000*C_[0];
	I[1001] += q1001*C_[0];
	I[1002] += q1002*C_[0];
	I[1003] += q1003*C_[0];
	I[1004] += q1004*C_[0];
	I[1005] += q1005*C_[0];
	I[1006] += q1006*C_[0];
	I[1007] += q1007*C_[0];
	I[1008] += q1008*C_[0];
	I[1009] += q1009*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1010 = 0.0;
	T q1011 = 0.0;
	T q1012 = 0.0;
	T q1013 = 0.0;
	T q1014 = 0.0;
	T q1015 = 0.0;
	T q1016 = 0.0;
	T q1017 = 0.0;
	T q1018 = 0.0;
	T q1019 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1010 += beta*Ix(a,1,1)*Iy(a,0,4)*Iz(a,3,0)
                     - 3*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,0);  // d/dBy
	    q1011 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,3,1)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,1);  // d/dBy
	    q1012 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,3); // d/dBy
	    q1013 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,3);  // d/dBy
	    q1014 += beta*Ix(a,1,2)*Iy(a,0,3)*Iz(a,3,0)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,0);  // d/dBy
	    q1015 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,2); // d/dBy
	    q1016 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,2)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,2);  // d/dBy
	    q1017 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,3,1)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,1);  // d/dBy
	    q1018 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,3,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,1);  // d/dBy
	    q1019 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[1010] += q1010*C_[0];
	I[1011] += q1011*C_[0];
	I[1012] += q1012*C_[0];
	I[1013] += q1013*C_[0];
	I[1014] += q1014*C_[0];
	I[1015] += q1015*C_[0];
	I[1016] += q1016*C_[0];
	I[1017] += q1017*C_[0];
	I[1018] += q1018*C_[0];
	I[1019] += q1019*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1020 = 0.0;
	T q1021 = 0.0;
	T q1022 = 0.0;
	T q1023 = 0.0;
	T q1024 = 0.0;
	T q1025 = 0.0;
	T q1026 = 0.0;
	T q1027 = 0.0;
	T q1028 = 0.0;
	T q1029 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1020 += beta*Ix(a,0,4)*Iy(a,1,1)*Iz(a,3,0); // d/dBy
	    q1021 += beta*Ix(a,0,0)*Iy(a,1,5)*Iz(a,3,0)
                     - 4*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,0);  // d/dBy
	    q1022 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,4); // d/dBy
	    q1023 += beta*Ix(a,0,3)*Iy(a,1,2)*Iz(a,3,0)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,0);  // d/dBy
	    q1024 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,3,1); // d/dBy
	    q1025 += beta*Ix(a,0,1)*Iy(a,1,4)*Iz(a,3,0)
                     - 3*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,0);  // d/dBy
	    q1026 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,3,1)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,1);  // d/dBy
	    q1027 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,3); // d/dBy
	    q1028 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,3);  // d/dBy
	    q1029 += beta*Ix(a,0,2)*Iy(a,1,3)*Iz(a,3,0)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[1020] += q1020*C_[0];
	I[1021] += q1021*C_[0];
	I[1022] += q1022*C_[0];
	I[1023] += q1023*C_[0];
	I[1024] += q1024*C_[0];
	I[1025] += q1025*C_[0];
	I[1026] += q1026*C_[0];
	I[1027] += q1027*C_[0];
	I[1028] += q1028*C_[0];
	I[1029] += q1029*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1030 = 0.0;
	T q1031 = 0.0;
	T q1032 = 0.0;
	T q1033 = 0.0;
	T q1034 = 0.0;
	T q1035 = 0.0;
	T q1036 = 0.0;
	T q1037 = 0.0;
	T q1038 = 0.0;
	T q1039 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1030 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,2); // d/dBy
	    q1031 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,2)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,2);  // d/dBy
	    q1032 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,3,1)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,1);  // d/dBy
	    q1033 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,3,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,1);  // d/dBy
	    q1034 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,2);  // d/dBy
	    q1035 += beta*Ix(a,2,4)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q1036 += beta*Ix(a,2,0)*Iy(a,2,5)*Iz(a,0,0)
                     - 4*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dBy
	    q1037 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,4); // d/dBy
	    q1038 += beta*Ix(a,2,3)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q1039 += beta*Ix(a,2,3)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[1030] += q1030*C_[0];
	I[1031] += q1031*C_[0];
	I[1032] += q1032*C_[0];
	I[1033] += q1033*C_[0];
	I[1034] += q1034*C_[0];
	I[1035] += q1035*C_[0];
	I[1036] += q1036*C_[0];
	I[1037] += q1037*C_[0];
	I[1038] += q1038*C_[0];
	I[1039] += q1039*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1040 = 0.0;
	T q1041 = 0.0;
	T q1042 = 0.0;
	T q1043 = 0.0;
	T q1044 = 0.0;
	T q1045 = 0.0;
	T q1046 = 0.0;
	T q1047 = 0.0;
	T q1048 = 0.0;
	T q1049 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1040 += beta*Ix(a,2,1)*Iy(a,2,4)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dBy
	    q1041 += beta*Ix(a,2,0)*Iy(a,2,4)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dBy
	    q1042 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,3); // d/dBy
	    q1043 += beta*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,3)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dBy
	    q1044 += beta*Ix(a,2,2)*Iy(a,2,3)*Iz(a,0,0)
                     - 2*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dBy
	    q1045 += beta*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,2); // d/dBy
	    q1046 += beta*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,2)
                     - 2*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dBy
	    q1047 += beta*Ix(a,2,2)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dBy
	    q1048 += beta*Ix(a,2,1)*Iy(a,2,3)*Iz(a,0,1)
                     - 2*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dBy
	    q1049 += beta*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[1040] += q1040*C_[0];
	I[1041] += q1041*C_[0];
	I[1042] += q1042*C_[0];
	I[1043] += q1043*C_[0];
	I[1044] += q1044*C_[0];
	I[1045] += q1045*C_[0];
	I[1046] += q1046*C_[0];
	I[1047] += q1047*C_[0];
	I[1048] += q1048*C_[0];
	I[1049] += q1049*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1050 = 0.0;
	T q1051 = 0.0;
	T q1052 = 0.0;
	T q1053 = 0.0;
	T q1054 = 0.0;
	T q1055 = 0.0;
	T q1056 = 0.0;
	T q1057 = 0.0;
	T q1058 = 0.0;
	T q1059 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1050 += beta*Ix(a,2,4)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q1051 += beta*Ix(a,2,0)*Iy(a,0,5)*Iz(a,2,0)
                     - 4*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dBy
	    q1052 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,4); // d/dBy
	    q1053 += beta*Ix(a,2,3)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q1054 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q1055 += beta*Ix(a,2,1)*Iy(a,0,4)*Iz(a,2,0)
                     - 3*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dBy
	    q1056 += beta*Ix(a,2,0)*Iy(a,0,4)*Iz(a,2,1)
                     - 3*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dBy
	    q1057 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,3); // d/dBy
	    q1058 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,3)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dBy
	    q1059 += beta*Ix(a,2,2)*Iy(a,0,3)*Iz(a,2,0)
                     - 2*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[1050] += q1050*C_[0];
	I[1051] += q1051*C_[0];
	I[1052] += q1052*C_[0];
	I[1053] += q1053*C_[0];
	I[1054] += q1054*C_[0];
	I[1055] += q1055*C_[0];
	I[1056] += q1056*C_[0];
	I[1057] += q1057*C_[0];
	I[1058] += q1058*C_[0];
	I[1059] += q1059*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1060 = 0.0;
	T q1061 = 0.0;
	T q1062 = 0.0;
	T q1063 = 0.0;
	T q1064 = 0.0;
	T q1065 = 0.0;
	T q1066 = 0.0;
	T q1067 = 0.0;
	T q1068 = 0.0;
	T q1069 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1060 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,2); // d/dBy
	    q1061 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,2)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dBy
	    q1062 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dBy
	    q1063 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,2,1)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dBy
	    q1064 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dBy
	    q1065 += beta*Ix(a,0,4)*Iy(a,2,1)*Iz(a,2,0); // d/dBy
	    q1066 += beta*Ix(a,0,0)*Iy(a,2,5)*Iz(a,2,0)
                     - 4*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,0);  // d/dBy
	    q1067 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,4); // d/dBy
	    q1068 += beta*Ix(a,0,3)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,0);  // d/dBy
	    q1069 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,2,1); // d/dBy
	}
	    
	//contraction coefficients
	I[1060] += q1060*C_[0];
	I[1061] += q1061*C_[0];
	I[1062] += q1062*C_[0];
	I[1063] += q1063*C_[0];
	I[1064] += q1064*C_[0];
	I[1065] += q1065*C_[0];
	I[1066] += q1066*C_[0];
	I[1067] += q1067*C_[0];
	I[1068] += q1068*C_[0];
	I[1069] += q1069*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1070 = 0.0;
	T q1071 = 0.0;
	T q1072 = 0.0;
	T q1073 = 0.0;
	T q1074 = 0.0;
	T q1075 = 0.0;
	T q1076 = 0.0;
	T q1077 = 0.0;
	T q1078 = 0.0;
	T q1079 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1070 += beta*Ix(a,0,1)*Iy(a,2,4)*Iz(a,2,0)
                     - 3*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,0);  // d/dBy
	    q1071 += beta*Ix(a,0,0)*Iy(a,2,4)*Iz(a,2,1)
                     - 3*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,1);  // d/dBy
	    q1072 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,3); // d/dBy
	    q1073 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,3);  // d/dBy
	    q1074 += beta*Ix(a,0,2)*Iy(a,2,3)*Iz(a,2,0)
                     - 2*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,0);  // d/dBy
	    q1075 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,2); // d/dBy
	    q1076 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,2)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,2);  // d/dBy
	    q1077 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,1);  // d/dBy
	    q1078 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,2,1)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,1);  // d/dBy
	    q1079 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[1070] += q1070*C_[0];
	I[1071] += q1071*C_[0];
	I[1072] += q1072*C_[0];
	I[1073] += q1073*C_[0];
	I[1074] += q1074*C_[0];
	I[1075] += q1075*C_[0];
	I[1076] += q1076*C_[0];
	I[1077] += q1077*C_[0];
	I[1078] += q1078*C_[0];
	I[1079] += q1079*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1080 = 0.0;
	T q1081 = 0.0;
	T q1082 = 0.0;
	T q1083 = 0.0;
	T q1084 = 0.0;
	T q1085 = 0.0;
	T q1086 = 0.0;
	T q1087 = 0.0;
	T q1088 = 0.0;
	T q1089 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1080 += beta*Ix(a,2,4)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q1081 += beta*Ix(a,2,0)*Iy(a,1,5)*Iz(a,1,0)
                     - 4*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dBy
	    q1082 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,4); // d/dBy
	    q1083 += beta*Ix(a,2,3)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q1084 += beta*Ix(a,2,3)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	    q1085 += beta*Ix(a,2,1)*Iy(a,1,4)*Iz(a,1,0)
                     - 3*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dBy
	    q1086 += beta*Ix(a,2,0)*Iy(a,1,4)*Iz(a,1,1)
                     - 3*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dBy
	    q1087 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,3); // d/dBy
	    q1088 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,3)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dBy
	    q1089 += beta*Ix(a,2,2)*Iy(a,1,3)*Iz(a,1,0)
                     - 2*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[1080] += q1080*C_[0];
	I[1081] += q1081*C_[0];
	I[1082] += q1082*C_[0];
	I[1083] += q1083*C_[0];
	I[1084] += q1084*C_[0];
	I[1085] += q1085*C_[0];
	I[1086] += q1086*C_[0];
	I[1087] += q1087*C_[0];
	I[1088] += q1088*C_[0];
	I[1089] += q1089*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1090 = 0.0;
	T q1091 = 0.0;
	T q1092 = 0.0;
	T q1093 = 0.0;
	T q1094 = 0.0;
	T q1095 = 0.0;
	T q1096 = 0.0;
	T q1097 = 0.0;
	T q1098 = 0.0;
	T q1099 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1090 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,2); // d/dBy
	    q1091 += beta*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,2)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dBy
	    q1092 += beta*Ix(a,2,2)*Iy(a,1,2)*Iz(a,1,1)
                     - 1*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dBy
	    q1093 += beta*Ix(a,2,1)*Iy(a,1,3)*Iz(a,1,1)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dBy
	    q1094 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dBy
	    q1095 += beta*Ix(a,1,4)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q1096 += beta*Ix(a,1,0)*Iy(a,2,5)*Iz(a,1,0)
                     - 4*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,0);  // d/dBy
	    q1097 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,4); // d/dBy
	    q1098 += beta*Ix(a,1,3)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,0);  // d/dBy
	    q1099 += beta*Ix(a,1,3)*Iy(a,2,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[1090] += q1090*C_[0];
	I[1091] += q1091*C_[0];
	I[1092] += q1092*C_[0];
	I[1093] += q1093*C_[0];
	I[1094] += q1094*C_[0];
	I[1095] += q1095*C_[0];
	I[1096] += q1096*C_[0];
	I[1097] += q1097*C_[0];
	I[1098] += q1098*C_[0];
	I[1099] += q1099*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1100 = 0.0;
	T q1101 = 0.0;
	T q1102 = 0.0;
	T q1103 = 0.0;
	T q1104 = 0.0;
	T q1105 = 0.0;
	T q1106 = 0.0;
	T q1107 = 0.0;
	T q1108 = 0.0;
	T q1109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1100 += beta*Ix(a,1,1)*Iy(a,2,4)*Iz(a,1,0)
                     - 3*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,0);  // d/dBy
	    q1101 += beta*Ix(a,1,0)*Iy(a,2,4)*Iz(a,1,1)
                     - 3*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,1);  // d/dBy
	    q1102 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,3); // d/dBy
	    q1103 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,3)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,3);  // d/dBy
	    q1104 += beta*Ix(a,1,2)*Iy(a,2,3)*Iz(a,1,0)
                     - 2*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,0);  // d/dBy
	    q1105 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,2); // d/dBy
	    q1106 += beta*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,2)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,2);  // d/dBy
	    q1107 += beta*Ix(a,1,2)*Iy(a,2,2)*Iz(a,1,1)
                     - 1*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,1);  // d/dBy
	    q1108 += beta*Ix(a,1,1)*Iy(a,2,3)*Iz(a,1,1)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,1);  // d/dBy
	    q1109 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[1100] += q1100*C_[0];
	I[1101] += q1101*C_[0];
	I[1102] += q1102*C_[0];
	I[1103] += q1103*C_[0];
	I[1104] += q1104*C_[0];
	I[1105] += q1105*C_[0];
	I[1106] += q1106*C_[0];
	I[1107] += q1107*C_[0];
	I[1108] += q1108*C_[0];
	I[1109] += q1109*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1110 = 0.0;
	T q1111 = 0.0;
	T q1112 = 0.0;
	T q1113 = 0.0;
	T q1114 = 0.0;
	T q1115 = 0.0;
	T q1116 = 0.0;
	T q1117 = 0.0;
	T q1118 = 0.0;
	T q1119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1110 += beta*Ix(a,1,4)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q1111 += beta*Ix(a,1,0)*Iy(a,1,5)*Iz(a,2,0)
                     - 4*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,0);  // d/dBy
	    q1112 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,4); // d/dBy
	    q1113 += beta*Ix(a,1,3)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,0);  // d/dBy
	    q1114 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,2,1); // d/dBy
	    q1115 += beta*Ix(a,1,1)*Iy(a,1,4)*Iz(a,2,0)
                     - 3*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,0);  // d/dBy
	    q1116 += beta*Ix(a,1,0)*Iy(a,1,4)*Iz(a,2,1)
                     - 3*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,1);  // d/dBy
	    q1117 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,3); // d/dBy
	    q1118 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,3)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,3);  // d/dBy
	    q1119 += beta*Ix(a,1,2)*Iy(a,1,3)*Iz(a,2,0)
                     - 2*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[1110] += q1110*C_[0];
	I[1111] += q1111*C_[0];
	I[1112] += q1112*C_[0];
	I[1113] += q1113*C_[0];
	I[1114] += q1114*C_[0];
	I[1115] += q1115*C_[0];
	I[1116] += q1116*C_[0];
	I[1117] += q1117*C_[0];
	I[1118] += q1118*C_[0];
	I[1119] += q1119*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1120 = 0.0;
	T q1121 = 0.0;
	T q1122 = 0.0;
	T q1123 = 0.0;
	T q1124 = 0.0;
	T q1125 = 0.0;
	T q1126 = 0.0;
	T q1127 = 0.0;
	T q1128 = 0.0;
	T q1129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1120 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,2); // d/dBy
	    q1121 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,2)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,2);  // d/dBy
	    q1122 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,2,1)
                     - 1*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,1);  // d/dBy
	    q1123 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,2,1)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,1);  // d/dBy
	    q1124 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,2);  // d/dBy
	    q1125 += beta*Ix(a,4,4)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q1126 += beta*Ix(a,4,0)*Iy(a,0,4)*Iz(a,0,1); // d/dBz
	    q1127 += beta*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,5)
                     - 4*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBz
	    q1128 += beta*Ix(a,4,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q1129 += beta*Ix(a,4,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,4,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[1120] += q1120*C_[0];
	I[1121] += q1121*C_[0];
	I[1122] += q1122*C_[0];
	I[1123] += q1123*C_[0];
	I[1124] += q1124*C_[0];
	I[1125] += q1125*C_[0];
	I[1126] += q1126*C_[0];
	I[1127] += q1127*C_[0];
	I[1128] += q1128*C_[0];
	I[1129] += q1129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1130 = 0.0;
	T q1131 = 0.0;
	T q1132 = 0.0;
	T q1133 = 0.0;
	T q1134 = 0.0;
	T q1135 = 0.0;
	T q1136 = 0.0;
	T q1137 = 0.0;
	T q1138 = 0.0;
	T q1139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1130 += beta*Ix(a,4,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q1131 += beta*Ix(a,4,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 1*Ix(a,4,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBz
	    q1132 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q1133 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,4)
                     - 3*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBz
	    q1134 += beta*Ix(a,4,2)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q1135 += beta*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q1136 += beta*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 2*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBz
	    q1137 += beta*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,4,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q1138 += beta*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,4,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q1139 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[1130] += q1130*C_[0];
	I[1131] += q1131*C_[0];
	I[1132] += q1132*C_[0];
	I[1133] += q1133*C_[0];
	I[1134] += q1134*C_[0];
	I[1135] += q1135*C_[0];
	I[1136] += q1136*C_[0];
	I[1137] += q1137*C_[0];
	I[1138] += q1138*C_[0];
	I[1139] += q1139*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1140 = 0.0;
	T q1141 = 0.0;
	T q1142 = 0.0;
	T q1143 = 0.0;
	T q1144 = 0.0;
	T q1145 = 0.0;
	T q1146 = 0.0;
	T q1147 = 0.0;
	T q1148 = 0.0;
	T q1149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1140 += beta*Ix(a,0,4)*Iy(a,4,0)*Iz(a,0,1); // d/dBz
	    q1141 += beta*Ix(a,0,0)*Iy(a,4,4)*Iz(a,0,1); // d/dBz
	    q1142 += beta*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,5)
                     - 4*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,3);  // d/dBz
	    q1143 += beta*Ix(a,0,3)*Iy(a,4,1)*Iz(a,0,1); // d/dBz
	    q1144 += beta*Ix(a,0,3)*Iy(a,4,0)*Iz(a,0,2)
                     - 1*Ix(a,0,3)*Iy(a,4,0)*Iz(a,0,0);  // d/dBz
	    q1145 += beta*Ix(a,0,1)*Iy(a,4,3)*Iz(a,0,1); // d/dBz
	    q1146 += beta*Ix(a,0,0)*Iy(a,4,3)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,4,3)*Iz(a,0,0);  // d/dBz
	    q1147 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,4)
                     - 3*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,2);  // d/dBz
	    q1148 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,2);  // d/dBz
	    q1149 += beta*Ix(a,0,2)*Iy(a,4,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[1140] += q1140*C_[0];
	I[1141] += q1141*C_[0];
	I[1142] += q1142*C_[0];
	I[1143] += q1143*C_[0];
	I[1144] += q1144*C_[0];
	I[1145] += q1145*C_[0];
	I[1146] += q1146*C_[0];
	I[1147] += q1147*C_[0];
	I[1148] += q1148*C_[0];
	I[1149] += q1149*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1150 = 0.0;
	T q1151 = 0.0;
	T q1152 = 0.0;
	T q1153 = 0.0;
	T q1154 = 0.0;
	T q1155 = 0.0;
	T q1156 = 0.0;
	T q1157 = 0.0;
	T q1158 = 0.0;
	T q1159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1150 += beta*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,3)
                     - 2*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,1);  // d/dBz
	    q1151 += beta*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,1);  // d/dBz
	    q1152 += beta*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,4,1)*Iz(a,0,0);  // d/dBz
	    q1153 += beta*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,4,2)*Iz(a,0,0);  // d/dBz
	    q1154 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,1);  // d/dBz
	    q1155 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,4,1); // d/dBz
	    q1156 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,4,1); // d/dBz
	    q1157 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,5)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,3);  // d/dBz
	    q1158 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,4,1); // d/dBz
	    q1159 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,4,2)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,4,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[1150] += q1150*C_[0];
	I[1151] += q1151*C_[0];
	I[1152] += q1152*C_[0];
	I[1153] += q1153*C_[0];
	I[1154] += q1154*C_[0];
	I[1155] += q1155*C_[0];
	I[1156] += q1156*C_[0];
	I[1157] += q1157*C_[0];
	I[1158] += q1158*C_[0];
	I[1159] += q1159*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1160 = 0.0;
	T q1161 = 0.0;
	T q1162 = 0.0;
	T q1163 = 0.0;
	T q1164 = 0.0;
	T q1165 = 0.0;
	T q1166 = 0.0;
	T q1167 = 0.0;
	T q1168 = 0.0;
	T q1169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1160 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,4,1); // d/dBz
	    q1161 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,4,2)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,4,0);  // d/dBz
	    q1162 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,4)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,2);  // d/dBz
	    q1163 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,4)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,2);  // d/dBz
	    q1164 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,4,1); // d/dBz
	    q1165 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,3)
                     - 2*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,1);  // d/dBz
	    q1166 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,3)
                     - 2*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,1);  // d/dBz
	    q1167 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,2)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,4,0);  // d/dBz
	    q1168 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,2)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,4,0);  // d/dBz
	    q1169 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,3)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[1160] += q1160*C_[0];
	I[1161] += q1161*C_[0];
	I[1162] += q1162*C_[0];
	I[1163] += q1163*C_[0];
	I[1164] += q1164*C_[0];
	I[1165] += q1165*C_[0];
	I[1166] += q1166*C_[0];
	I[1167] += q1167*C_[0];
	I[1168] += q1168*C_[0];
	I[1169] += q1169*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1170 = 0.0;
	T q1171 = 0.0;
	T q1172 = 0.0;
	T q1173 = 0.0;
	T q1174 = 0.0;
	T q1175 = 0.0;
	T q1176 = 0.0;
	T q1177 = 0.0;
	T q1178 = 0.0;
	T q1179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1170 += beta*Ix(a,3,4)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q1171 += beta*Ix(a,3,0)*Iy(a,1,4)*Iz(a,0,1); // d/dBz
	    q1172 += beta*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,5)
                     - 4*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBz
	    q1173 += beta*Ix(a,3,3)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q1174 += beta*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,3,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q1175 += beta*Ix(a,3,1)*Iy(a,1,3)*Iz(a,0,1); // d/dBz
	    q1176 += beta*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBz
	    q1177 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBz
	    q1178 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,4)
                     - 3*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBz
	    q1179 += beta*Ix(a,3,2)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[1170] += q1170*C_[0];
	I[1171] += q1171*C_[0];
	I[1172] += q1172*C_[0];
	I[1173] += q1173*C_[0];
	I[1174] += q1174*C_[0];
	I[1175] += q1175*C_[0];
	I[1176] += q1176*C_[0];
	I[1177] += q1177*C_[0];
	I[1178] += q1178*C_[0];
	I[1179] += q1179*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1180 = 0.0;
	T q1181 = 0.0;
	T q1182 = 0.0;
	T q1183 = 0.0;
	T q1184 = 0.0;
	T q1185 = 0.0;
	T q1186 = 0.0;
	T q1187 = 0.0;
	T q1188 = 0.0;
	T q1189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1180 += beta*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q1181 += beta*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,3)
                     - 2*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBz
	    q1182 += beta*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,3,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	    q1183 += beta*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,3,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBz
	    q1184 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBz
	    q1185 += beta*Ix(a,3,4)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q1186 += beta*Ix(a,3,0)*Iy(a,0,4)*Iz(a,1,1); // d/dBz
	    q1187 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,5)
                     - 4*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBz
	    q1188 += beta*Ix(a,3,3)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q1189 += beta*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,3,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[1180] += q1180*C_[0];
	I[1181] += q1181*C_[0];
	I[1182] += q1182*C_[0];
	I[1183] += q1183*C_[0];
	I[1184] += q1184*C_[0];
	I[1185] += q1185*C_[0];
	I[1186] += q1186*C_[0];
	I[1187] += q1187*C_[0];
	I[1188] += q1188*C_[0];
	I[1189] += q1189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1190 = 0.0;
	T q1191 = 0.0;
	T q1192 = 0.0;
	T q1193 = 0.0;
	T q1194 = 0.0;
	T q1195 = 0.0;
	T q1196 = 0.0;
	T q1197 = 0.0;
	T q1198 = 0.0;
	T q1199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1190 += beta*Ix(a,3,1)*Iy(a,0,3)*Iz(a,1,1); // d/dBz
	    q1191 += beta*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,2)
                     - 1*Ix(a,3,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBz
	    q1192 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBz
	    q1193 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,4)
                     - 3*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBz
	    q1194 += beta*Ix(a,3,2)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q1195 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q1196 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,3)
                     - 2*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBz
	    q1197 += beta*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,3,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	    q1198 += beta*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,3,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBz
	    q1199 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[1190] += q1190*C_[0];
	I[1191] += q1191*C_[0];
	I[1192] += q1192*C_[0];
	I[1193] += q1193*C_[0];
	I[1194] += q1194*C_[0];
	I[1195] += q1195*C_[0];
	I[1196] += q1196*C_[0];
	I[1197] += q1197*C_[0];
	I[1198] += q1198*C_[0];
	I[1199] += q1199*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1200 = 0.0;
	T q1201 = 0.0;
	T q1202 = 0.0;
	T q1203 = 0.0;
	T q1204 = 0.0;
	T q1205 = 0.0;
	T q1206 = 0.0;
	T q1207 = 0.0;
	T q1208 = 0.0;
	T q1209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1200 += beta*Ix(a,1,4)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q1201 += beta*Ix(a,1,0)*Iy(a,3,4)*Iz(a,0,1); // d/dBz
	    q1202 += beta*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,5)
                     - 4*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,3);  // d/dBz
	    q1203 += beta*Ix(a,1,3)*Iy(a,3,1)*Iz(a,0,1); // d/dBz
	    q1204 += beta*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,1,3)*Iy(a,3,0)*Iz(a,0,0);  // d/dBz
	    q1205 += beta*Ix(a,1,1)*Iy(a,3,3)*Iz(a,0,1); // d/dBz
	    q1206 += beta*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,3,3)*Iz(a,0,0);  // d/dBz
	    q1207 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,4)
                     - 3*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,2);  // d/dBz
	    q1208 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,2);  // d/dBz
	    q1209 += beta*Ix(a,1,2)*Iy(a,3,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[1200] += q1200*C_[0];
	I[1201] += q1201*C_[0];
	I[1202] += q1202*C_[0];
	I[1203] += q1203*C_[0];
	I[1204] += q1204*C_[0];
	I[1205] += q1205*C_[0];
	I[1206] += q1206*C_[0];
	I[1207] += q1207*C_[0];
	I[1208] += q1208*C_[0];
	I[1209] += q1209*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1210 = 0.0;
	T q1211 = 0.0;
	T q1212 = 0.0;
	T q1213 = 0.0;
	T q1214 = 0.0;
	T q1215 = 0.0;
	T q1216 = 0.0;
	T q1217 = 0.0;
	T q1218 = 0.0;
	T q1219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1210 += beta*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,3)
                     - 2*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,1);  // d/dBz
	    q1211 += beta*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,1);  // d/dBz
	    q1212 += beta*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,3,1)*Iz(a,0,0);  // d/dBz
	    q1213 += beta*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,3,2)*Iz(a,0,0);  // d/dBz
	    q1214 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,1);  // d/dBz
	    q1215 += beta*Ix(a,0,4)*Iy(a,3,0)*Iz(a,1,1); // d/dBz
	    q1216 += beta*Ix(a,0,0)*Iy(a,3,4)*Iz(a,1,1); // d/dBz
	    q1217 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,5)
                     - 4*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,3);  // d/dBz
	    q1218 += beta*Ix(a,0,3)*Iy(a,3,1)*Iz(a,1,1); // d/dBz
	    q1219 += beta*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,2)
                     - 1*Ix(a,0,3)*Iy(a,3,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[1210] += q1210*C_[0];
	I[1211] += q1211*C_[0];
	I[1212] += q1212*C_[0];
	I[1213] += q1213*C_[0];
	I[1214] += q1214*C_[0];
	I[1215] += q1215*C_[0];
	I[1216] += q1216*C_[0];
	I[1217] += q1217*C_[0];
	I[1218] += q1218*C_[0];
	I[1219] += q1219*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1220 = 0.0;
	T q1221 = 0.0;
	T q1222 = 0.0;
	T q1223 = 0.0;
	T q1224 = 0.0;
	T q1225 = 0.0;
	T q1226 = 0.0;
	T q1227 = 0.0;
	T q1228 = 0.0;
	T q1229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1220 += beta*Ix(a,0,1)*Iy(a,3,3)*Iz(a,1,1); // d/dBz
	    q1221 += beta*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,3,3)*Iz(a,1,0);  // d/dBz
	    q1222 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,4)
                     - 3*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,2);  // d/dBz
	    q1223 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,2);  // d/dBz
	    q1224 += beta*Ix(a,0,2)*Iy(a,3,2)*Iz(a,1,1); // d/dBz
	    q1225 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,3)
                     - 2*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,1);  // d/dBz
	    q1226 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,1);  // d/dBz
	    q1227 += beta*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,3,1)*Iz(a,1,0);  // d/dBz
	    q1228 += beta*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,3,2)*Iz(a,1,0);  // d/dBz
	    q1229 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[1220] += q1220*C_[0];
	I[1221] += q1221*C_[0];
	I[1222] += q1222*C_[0];
	I[1223] += q1223*C_[0];
	I[1224] += q1224*C_[0];
	I[1225] += q1225*C_[0];
	I[1226] += q1226*C_[0];
	I[1227] += q1227*C_[0];
	I[1228] += q1228*C_[0];
	I[1229] += q1229*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1230 = 0.0;
	T q1231 = 0.0;
	T q1232 = 0.0;
	T q1233 = 0.0;
	T q1234 = 0.0;
	T q1235 = 0.0;
	T q1236 = 0.0;
	T q1237 = 0.0;
	T q1238 = 0.0;
	T q1239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1230 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q1231 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,3,1); // d/dBz
	    q1232 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,5)
                     - 4*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,3);  // d/dBz
	    q1233 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,3,1); // d/dBz
	    q1234 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,3,0);  // d/dBz
	    q1235 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,3,1); // d/dBz
	    q1236 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,2)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,3,0);  // d/dBz
	    q1237 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,4)
                     - 3*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,2);  // d/dBz
	    q1238 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,4)
                     - 3*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,2);  // d/dBz
	    q1239 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,3,1); // d/dBz
	}
	    
	//contraction coefficients
	I[1230] += q1230*C_[0];
	I[1231] += q1231*C_[0];
	I[1232] += q1232*C_[0];
	I[1233] += q1233*C_[0];
	I[1234] += q1234*C_[0];
	I[1235] += q1235*C_[0];
	I[1236] += q1236*C_[0];
	I[1237] += q1237*C_[0];
	I[1238] += q1238*C_[0];
	I[1239] += q1239*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1240 = 0.0;
	T q1241 = 0.0;
	T q1242 = 0.0;
	T q1243 = 0.0;
	T q1244 = 0.0;
	T q1245 = 0.0;
	T q1246 = 0.0;
	T q1247 = 0.0;
	T q1248 = 0.0;
	T q1249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1240 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,3)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,1);  // d/dBz
	    q1241 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,3)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,1);  // d/dBz
	    q1242 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,2)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,3,0);  // d/dBz
	    q1243 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,2)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,3,0);  // d/dBz
	    q1244 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,3)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,1);  // d/dBz
	    q1245 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,3,1); // d/dBz
	    q1246 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,3,1); // d/dBz
	    q1247 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,5)
                     - 4*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,3);  // d/dBz
	    q1248 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,3,1); // d/dBz
	    q1249 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,2)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,3,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[1240] += q1240*C_[0];
	I[1241] += q1241*C_[0];
	I[1242] += q1242*C_[0];
	I[1243] += q1243*C_[0];
	I[1244] += q1244*C_[0];
	I[1245] += q1245*C_[0];
	I[1246] += q1246*C_[0];
	I[1247] += q1247*C_[0];
	I[1248] += q1248*C_[0];
	I[1249] += q1249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1250 = 0.0;
	T q1251 = 0.0;
	T q1252 = 0.0;
	T q1253 = 0.0;
	T q1254 = 0.0;
	T q1255 = 0.0;
	T q1256 = 0.0;
	T q1257 = 0.0;
	T q1258 = 0.0;
	T q1259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1250 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,3,1); // d/dBz
	    q1251 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,3,0);  // d/dBz
	    q1252 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,4)
                     - 3*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,2);  // d/dBz
	    q1253 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,4)
                     - 3*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,2);  // d/dBz
	    q1254 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,3,1); // d/dBz
	    q1255 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,3)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,1);  // d/dBz
	    q1256 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,3)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,1);  // d/dBz
	    q1257 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,2)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,3,0);  // d/dBz
	    q1258 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,2)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,3,0);  // d/dBz
	    q1259 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,3)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[1250] += q1250*C_[0];
	I[1251] += q1251*C_[0];
	I[1252] += q1252*C_[0];
	I[1253] += q1253*C_[0];
	I[1254] += q1254*C_[0];
	I[1255] += q1255*C_[0];
	I[1256] += q1256*C_[0];
	I[1257] += q1257*C_[0];
	I[1258] += q1258*C_[0];
	I[1259] += q1259*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1260 = 0.0;
	T q1261 = 0.0;
	T q1262 = 0.0;
	T q1263 = 0.0;
	T q1264 = 0.0;
	T q1265 = 0.0;
	T q1266 = 0.0;
	T q1267 = 0.0;
	T q1268 = 0.0;
	T q1269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1260 += beta*Ix(a,2,4)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q1261 += beta*Ix(a,2,0)*Iy(a,2,4)*Iz(a,0,1); // d/dBz
	    q1262 += beta*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,5)
                     - 4*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,3);  // d/dBz
	    q1263 += beta*Ix(a,2,3)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q1264 += beta*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,2,3)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q1265 += beta*Ix(a,2,1)*Iy(a,2,3)*Iz(a,0,1); // d/dBz
	    q1266 += beta*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,2,3)*Iz(a,0,0);  // d/dBz
	    q1267 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,4)
                     - 3*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,2);  // d/dBz
	    q1268 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,4)
                     - 3*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,2);  // d/dBz
	    q1269 += beta*Ix(a,2,2)*Iy(a,2,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[1260] += q1260*C_[0];
	I[1261] += q1261*C_[0];
	I[1262] += q1262*C_[0];
	I[1263] += q1263*C_[0];
	I[1264] += q1264*C_[0];
	I[1265] += q1265*C_[0];
	I[1266] += q1266*C_[0];
	I[1267] += q1267*C_[0];
	I[1268] += q1268*C_[0];
	I[1269] += q1269*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1270 = 0.0;
	T q1271 = 0.0;
	T q1272 = 0.0;
	T q1273 = 0.0;
	T q1274 = 0.0;
	T q1275 = 0.0;
	T q1276 = 0.0;
	T q1277 = 0.0;
	T q1278 = 0.0;
	T q1279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1270 += beta*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,3)
                     - 2*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,1);  // d/dBz
	    q1271 += beta*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,3)
                     - 2*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,1);  // d/dBz
	    q1272 += beta*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,2,2)*Iy(a,2,1)*Iz(a,0,0);  // d/dBz
	    q1273 += beta*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,2,1)*Iy(a,2,2)*Iz(a,0,0);  // d/dBz
	    q1274 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,3)
                     - 2*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,1);  // d/dBz
	    q1275 += beta*Ix(a,2,4)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q1276 += beta*Ix(a,2,0)*Iy(a,0,4)*Iz(a,2,1); // d/dBz
	    q1277 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,5)
                     - 4*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,3);  // d/dBz
	    q1278 += beta*Ix(a,2,3)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q1279 += beta*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,2,3)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[1270] += q1270*C_[0];
	I[1271] += q1271*C_[0];
	I[1272] += q1272*C_[0];
	I[1273] += q1273*C_[0];
	I[1274] += q1274*C_[0];
	I[1275] += q1275*C_[0];
	I[1276] += q1276*C_[0];
	I[1277] += q1277*C_[0];
	I[1278] += q1278*C_[0];
	I[1279] += q1279*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1280 = 0.0;
	T q1281 = 0.0;
	T q1282 = 0.0;
	T q1283 = 0.0;
	T q1284 = 0.0;
	T q1285 = 0.0;
	T q1286 = 0.0;
	T q1287 = 0.0;
	T q1288 = 0.0;
	T q1289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1280 += beta*Ix(a,2,1)*Iy(a,0,3)*Iz(a,2,1); // d/dBz
	    q1281 += beta*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,3)*Iz(a,2,0);  // d/dBz
	    q1282 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,4)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,2);  // d/dBz
	    q1283 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,4)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,2);  // d/dBz
	    q1284 += beta*Ix(a,2,2)*Iy(a,0,2)*Iz(a,2,1); // d/dBz
	    q1285 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,3)
                     - 2*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,1);  // d/dBz
	    q1286 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,3)
                     - 2*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,1);  // d/dBz
	    q1287 += beta*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,2,2)*Iy(a,0,1)*Iz(a,2,0);  // d/dBz
	    q1288 += beta*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,2,1)*Iy(a,0,2)*Iz(a,2,0);  // d/dBz
	    q1289 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,3)
                     - 2*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[1280] += q1280*C_[0];
	I[1281] += q1281*C_[0];
	I[1282] += q1282*C_[0];
	I[1283] += q1283*C_[0];
	I[1284] += q1284*C_[0];
	I[1285] += q1285*C_[0];
	I[1286] += q1286*C_[0];
	I[1287] += q1287*C_[0];
	I[1288] += q1288*C_[0];
	I[1289] += q1289*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1290 = 0.0;
	T q1291 = 0.0;
	T q1292 = 0.0;
	T q1293 = 0.0;
	T q1294 = 0.0;
	T q1295 = 0.0;
	T q1296 = 0.0;
	T q1297 = 0.0;
	T q1298 = 0.0;
	T q1299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1290 += beta*Ix(a,0,4)*Iy(a,2,0)*Iz(a,2,1); // d/dBz
	    q1291 += beta*Ix(a,0,0)*Iy(a,2,4)*Iz(a,2,1); // d/dBz
	    q1292 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,5)
                     - 4*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,3);  // d/dBz
	    q1293 += beta*Ix(a,0,3)*Iy(a,2,1)*Iz(a,2,1); // d/dBz
	    q1294 += beta*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,3)*Iy(a,2,0)*Iz(a,2,0);  // d/dBz
	    q1295 += beta*Ix(a,0,1)*Iy(a,2,3)*Iz(a,2,1); // d/dBz
	    q1296 += beta*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,3)*Iz(a,2,0);  // d/dBz
	    q1297 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,4)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,2);  // d/dBz
	    q1298 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,4)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,2);  // d/dBz
	    q1299 += beta*Ix(a,0,2)*Iy(a,2,2)*Iz(a,2,1); // d/dBz
	}
	    
	//contraction coefficients
	I[1290] += q1290*C_[0];
	I[1291] += q1291*C_[0];
	I[1292] += q1292*C_[0];
	I[1293] += q1293*C_[0];
	I[1294] += q1294*C_[0];
	I[1295] += q1295*C_[0];
	I[1296] += q1296*C_[0];
	I[1297] += q1297*C_[0];
	I[1298] += q1298*C_[0];
	I[1299] += q1299*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1300 = 0.0;
	T q1301 = 0.0;
	T q1302 = 0.0;
	T q1303 = 0.0;
	T q1304 = 0.0;
	T q1305 = 0.0;
	T q1306 = 0.0;
	T q1307 = 0.0;
	T q1308 = 0.0;
	T q1309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1300 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,3)
                     - 2*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,1);  // d/dBz
	    q1301 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,3)
                     - 2*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,1);  // d/dBz
	    q1302 += beta*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,2,1)*Iz(a,2,0);  // d/dBz
	    q1303 += beta*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,2,2)*Iz(a,2,0);  // d/dBz
	    q1304 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,3)
                     - 2*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,1);  // d/dBz
	    q1305 += beta*Ix(a,2,4)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q1306 += beta*Ix(a,2,0)*Iy(a,1,4)*Iz(a,1,1); // d/dBz
	    q1307 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,5)
                     - 4*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,3);  // d/dBz
	    q1308 += beta*Ix(a,2,3)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q1309 += beta*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,2,3)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[1300] += q1300*C_[0];
	I[1301] += q1301*C_[0];
	I[1302] += q1302*C_[0];
	I[1303] += q1303*C_[0];
	I[1304] += q1304*C_[0];
	I[1305] += q1305*C_[0];
	I[1306] += q1306*C_[0];
	I[1307] += q1307*C_[0];
	I[1308] += q1308*C_[0];
	I[1309] += q1309*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1310 = 0.0;
	T q1311 = 0.0;
	T q1312 = 0.0;
	T q1313 = 0.0;
	T q1314 = 0.0;
	T q1315 = 0.0;
	T q1316 = 0.0;
	T q1317 = 0.0;
	T q1318 = 0.0;
	T q1319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1310 += beta*Ix(a,2,1)*Iy(a,1,3)*Iz(a,1,1); // d/dBz
	    q1311 += beta*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,1,3)*Iz(a,1,0);  // d/dBz
	    q1312 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,4)
                     - 3*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,2);  // d/dBz
	    q1313 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,4)
                     - 3*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,2);  // d/dBz
	    q1314 += beta*Ix(a,2,2)*Iy(a,1,2)*Iz(a,1,1); // d/dBz
	    q1315 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,3)
                     - 2*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,1);  // d/dBz
	    q1316 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,3)
                     - 2*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,1);  // d/dBz
	    q1317 += beta*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,2)
                     - 1*Ix(a,2,2)*Iy(a,1,1)*Iz(a,1,0);  // d/dBz
	    q1318 += beta*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,2)
                     - 1*Ix(a,2,1)*Iy(a,1,2)*Iz(a,1,0);  // d/dBz
	    q1319 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,3)
                     - 2*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[1310] += q1310*C_[0];
	I[1311] += q1311*C_[0];
	I[1312] += q1312*C_[0];
	I[1313] += q1313*C_[0];
	I[1314] += q1314*C_[0];
	I[1315] += q1315*C_[0];
	I[1316] += q1316*C_[0];
	I[1317] += q1317*C_[0];
	I[1318] += q1318*C_[0];
	I[1319] += q1319*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1320 = 0.0;
	T q1321 = 0.0;
	T q1322 = 0.0;
	T q1323 = 0.0;
	T q1324 = 0.0;
	T q1325 = 0.0;
	T q1326 = 0.0;
	T q1327 = 0.0;
	T q1328 = 0.0;
	T q1329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1320 += beta*Ix(a,1,4)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q1321 += beta*Ix(a,1,0)*Iy(a,2,4)*Iz(a,1,1); // d/dBz
	    q1322 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,5)
                     - 4*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,3);  // d/dBz
	    q1323 += beta*Ix(a,1,3)*Iy(a,2,1)*Iz(a,1,1); // d/dBz
	    q1324 += beta*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,1,3)*Iy(a,2,0)*Iz(a,1,0);  // d/dBz
	    q1325 += beta*Ix(a,1,1)*Iy(a,2,3)*Iz(a,1,1); // d/dBz
	    q1326 += beta*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,2,3)*Iz(a,1,0);  // d/dBz
	    q1327 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,4)
                     - 3*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,2);  // d/dBz
	    q1328 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,4)
                     - 3*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,2);  // d/dBz
	    q1329 += beta*Ix(a,1,2)*Iy(a,2,2)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[1320] += q1320*C_[0];
	I[1321] += q1321*C_[0];
	I[1322] += q1322*C_[0];
	I[1323] += q1323*C_[0];
	I[1324] += q1324*C_[0];
	I[1325] += q1325*C_[0];
	I[1326] += q1326*C_[0];
	I[1327] += q1327*C_[0];
	I[1328] += q1328*C_[0];
	I[1329] += q1329*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1330 = 0.0;
	T q1331 = 0.0;
	T q1332 = 0.0;
	T q1333 = 0.0;
	T q1334 = 0.0;
	T q1335 = 0.0;
	T q1336 = 0.0;
	T q1337 = 0.0;
	T q1338 = 0.0;
	T q1339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1330 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,3)
                     - 2*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,1);  // d/dBz
	    q1331 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,3)
                     - 2*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,1);  // d/dBz
	    q1332 += beta*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,2)
                     - 1*Ix(a,1,2)*Iy(a,2,1)*Iz(a,1,0);  // d/dBz
	    q1333 += beta*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,2)
                     - 1*Ix(a,1,1)*Iy(a,2,2)*Iz(a,1,0);  // d/dBz
	    q1334 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,3)
                     - 2*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,1);  // d/dBz
	    q1335 += beta*Ix(a,1,4)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q1336 += beta*Ix(a,1,0)*Iy(a,1,4)*Iz(a,2,1); // d/dBz
	    q1337 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,5)
                     - 4*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,3);  // d/dBz
	    q1338 += beta*Ix(a,1,3)*Iy(a,1,1)*Iz(a,2,1); // d/dBz
	    q1339 += beta*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,1,3)*Iy(a,1,0)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[1330] += q1330*C_[0];
	I[1331] += q1331*C_[0];
	I[1332] += q1332*C_[0];
	I[1333] += q1333*C_[0];
	I[1334] += q1334*C_[0];
	I[1335] += q1335*C_[0];
	I[1336] += q1336*C_[0];
	I[1337] += q1337*C_[0];
	I[1338] += q1338*C_[0];
	I[1339] += q1339*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[1];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 1; ++ i) C_[i] = C[k*1 + i];

	// function registers
	T q1340 = 0.0;
	T q1341 = 0.0;
	T q1342 = 0.0;
	T q1343 = 0.0;
	T q1344 = 0.0;
	T q1345 = 0.0;
	T q1346 = 0.0;
	T q1347 = 0.0;
	T q1348 = 0.0;
	T q1349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q1340 += beta*Ix(a,1,1)*Iy(a,1,3)*Iz(a,2,1); // d/dBz
	    q1341 += beta*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,3)*Iz(a,2,0);  // d/dBz
	    q1342 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,4)
                     - 3*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,2);  // d/dBz
	    q1343 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,4)
                     - 3*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,2);  // d/dBz
	    q1344 += beta*Ix(a,1,2)*Iy(a,1,2)*Iz(a,2,1); // d/dBz
	    q1345 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,3)
                     - 2*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,1);  // d/dBz
	    q1346 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,3)
                     - 2*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,1);  // d/dBz
	    q1347 += beta*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,2)
                     - 1*Ix(a,1,2)*Iy(a,1,1)*Iz(a,2,0);  // d/dBz
	    q1348 += beta*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,2)
                     - 1*Ix(a,1,1)*Iy(a,1,2)*Iz(a,2,0);  // d/dBz
	    q1349 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,3)
                     - 2*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[1340] += q1340*C_[0];
	I[1341] += q1341*C_[0];
	I[1342] += q1342*C_[0];
	I[1343] += q1343*C_[0];
	I[1344] += q1344*C_[0];
	I[1345] += q1345*C_[0];
	I[1346] += q1346*C_[0];
	I[1347] += q1347*C_[0];
	I[1348] += q1348*C_[0];
	I[1349] += q1349*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <spg| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::SP,rysq::G> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::SP,rysq::G> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,4); // d/dAx
	    q3 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,0); // d/dAx
	    q4 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,1); // d/dAx
	    q5 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,0); // d/dAx
	    q6 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,1); // d/dAx
	    q7 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,3); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,3); // d/dAx
	    q9 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[0];
	I[2] += q2*C_[0];
	I[3] += q3*C_[0];
	I[4] += q4*C_[0];
	I[5] += q5*C_[0];
	I[6] += q6*C_[0];
	I[7] += q7*C_[0];
	I[8] += q8*C_[0];
	I[9] += q9*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,2); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,2); // d/dAx
	    q12 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,1); // d/dAx
	    q13 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,1); // d/dAx
	    q14 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,2); // d/dAx
	    q15 += alpha*Ix(a,2,4)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q16 += alpha*Ix(a,2,0)*Iy(a,0,4)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAx
	    q17 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAx
	    q18 += alpha*Ix(a,2,3)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q19 += alpha*Ix(a,2,3)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[0];
	I[11] += q11*C_[0];
	I[12] += q12*C_[0];
	I[13] += q13*C_[0];
	I[14] += q14*C_[0];
	I[15] += q15*C_[1];
	I[16] += q16*C_[1];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,2,1)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAx
	    q21 += alpha*Ix(a,2,0)*Iy(a,0,3)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAx
	    q22 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAx
	    q23 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAx
	    q24 += alpha*Ix(a,2,2)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAx
	    q25 += alpha*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAx
	    q26 += alpha*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAx
	    q27 += alpha*Ix(a,2,2)*Iy(a,0,1)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAx
	    q28 += alpha*Ix(a,2,1)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAx
	    q29 += alpha*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[1];
	I[21] += q21*C_[1];
	I[22] += q22*C_[1];
	I[23] += q23*C_[1];
	I[24] += q24*C_[1];
	I[25] += q25*C_[1];
	I[26] += q26*C_[1];
	I[27] += q27*C_[1];
	I[28] += q28*C_[1];
	I[29] += q29*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q31 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,0,0); // d/dAx
	    q32 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,4); // d/dAx
	    q33 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,0); // d/dAx
	    q34 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,1); // d/dAx
	    q35 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,0); // d/dAx
	    q36 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,1); // d/dAx
	    q37 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,3); // d/dAx
	    q38 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,3); // d/dAx
	    q39 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,0); // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[1];
	I[31] += q31*C_[1];
	I[32] += q32*C_[1];
	I[33] += q33*C_[1];
	I[34] += q34*C_[1];
	I[35] += q35*C_[1];
	I[36] += q36*C_[1];
	I[37] += q37*C_[1];
	I[38] += q38*C_[1];
	I[39] += q39*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,2); // d/dAx
	    q41 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,2); // d/dAx
	    q42 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,1); // d/dAx
	    q43 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,1); // d/dAx
	    q44 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,2); // d/dAx
	    q45 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q46 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,1,0); // d/dAx
	    q47 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,4); // d/dAx
	    q48 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,0); // d/dAx
	    q49 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,1); // d/dAx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[1];
	I[41] += q41*C_[1];
	I[42] += q42*C_[1];
	I[43] += q43*C_[1];
	I[44] += q44*C_[1];
	I[45] += q45*C_[1];
	I[46] += q46*C_[1];
	I[47] += q47*C_[1];
	I[48] += q48*C_[1];
	I[49] += q49*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,0); // d/dAx
	    q51 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,1); // d/dAx
	    q52 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,3); // d/dAx
	    q53 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,3); // d/dAx
	    q54 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,0); // d/dAx
	    q55 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,2); // d/dAx
	    q56 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,2); // d/dAx
	    q57 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,1); // d/dAx
	    q58 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,1); // d/dAx
	    q59 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,2); // d/dAx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[1];
	I[51] += q51*C_[1];
	I[52] += q52*C_[1];
	I[53] += q53*C_[1];
	I[54] += q54*C_[1];
	I[55] += q55*C_[1];
	I[56] += q56*C_[1];
	I[57] += q57*C_[1];
	I[58] += q58*C_[1];
	I[59] += q59*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q61 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,0); // d/dAy
	    q62 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,4); // d/dAy
	    q63 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q64 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q65 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q66 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,1); // d/dAy
	    q67 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q68 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,3); // d/dAy
	    q69 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[0];
	I[62] += q62*C_[0];
	I[63] += q63*C_[0];
	I[64] += q64*C_[0];
	I[65] += q65*C_[0];
	I[66] += q66*C_[0];
	I[67] += q67*C_[0];
	I[68] += q68*C_[0];
	I[69] += q69*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q71 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,2); // d/dAy
	    q72 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q73 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q74 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	    q75 += alpha*Ix(a,1,4)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q76 += alpha*Ix(a,1,0)*Iy(a,1,4)*Iz(a,0,0); // d/dAy
	    q77 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,4); // d/dAy
	    q78 += alpha*Ix(a,1,3)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q79 += alpha*Ix(a,1,3)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[0];
	I[71] += q71*C_[0];
	I[72] += q72*C_[0];
	I[73] += q73*C_[0];
	I[74] += q74*C_[0];
	I[75] += q75*C_[1];
	I[76] += q76*C_[1];
	I[77] += q77*C_[1];
	I[78] += q78*C_[1];
	I[79] += q79*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,1,1)*Iy(a,1,3)*Iz(a,0,0); // d/dAy
	    q81 += alpha*Ix(a,1,0)*Iy(a,1,3)*Iz(a,0,1); // d/dAy
	    q82 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,3); // d/dAy
	    q83 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,3); // d/dAy
	    q84 += alpha*Ix(a,1,2)*Iy(a,1,2)*Iz(a,0,0); // d/dAy
	    q85 += alpha*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,2); // d/dAy
	    q86 += alpha*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,2); // d/dAy
	    q87 += alpha*Ix(a,1,2)*Iy(a,1,1)*Iz(a,0,1); // d/dAy
	    q88 += alpha*Ix(a,1,1)*Iy(a,1,2)*Iz(a,0,1); // d/dAy
	    q89 += alpha*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,2); // d/dAy
	}
	    
	//contraction coefficients
	I[80] += q80*C_[1];
	I[81] += q81*C_[1];
	I[82] += q82*C_[1];
	I[83] += q83*C_[1];
	I[84] += q84*C_[1];
	I[85] += q85*C_[1];
	I[86] += q86*C_[1];
	I[87] += q87*C_[1];
	I[88] += q88*C_[1];
	I[89] += q89*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,0,4)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q91 += alpha*Ix(a,0,0)*Iy(a,2,4)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAy
	    q92 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAy
	    q93 += alpha*Ix(a,0,3)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q94 += alpha*Ix(a,0,3)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q95 += alpha*Ix(a,0,1)*Iy(a,2,3)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAy
	    q96 += alpha*Ix(a,0,0)*Iy(a,2,3)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAy
	    q97 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAy
	    q98 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAy
	    q99 += alpha*Ix(a,0,2)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[90] += q90*C_[1];
	I[91] += q91*C_[1];
	I[92] += q92*C_[1];
	I[93] += q93*C_[1];
	I[94] += q94*C_[1];
	I[95] += q95*C_[1];
	I[96] += q96*C_[1];
	I[97] += q97*C_[1];
	I[98] += q98*C_[1];
	I[99] += q99*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAy
	    q101 += alpha*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAy
	    q102 += alpha*Ix(a,0,2)*Iy(a,2,1)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAy
	    q103 += alpha*Ix(a,0,1)*Iy(a,2,2)*Iz(a,0,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAy
	    q104 += alpha*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAy
	    q105 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q106 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAy
	    q107 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAy
	    q108 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q109 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[100] += q100*C_[1];
	I[101] += q101*C_[1];
	I[102] += q102*C_[1];
	I[103] += q103*C_[1];
	I[104] += q104*C_[1];
	I[105] += q105*C_[1];
	I[106] += q106*C_[1];
	I[107] += q107*C_[1];
	I[108] += q108*C_[1];
	I[109] += q109*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAy
	    q111 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAy
	    q112 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAy
	    q113 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAy
	    q114 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAy
	    q115 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAy
	    q116 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAy
	    q117 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAy
	    q118 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAy
	    q119 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAy
	}
	    
	//contraction coefficients
	I[110] += q110*C_[1];
	I[111] += q111*C_[1];
	I[112] += q112*C_[1];
	I[113] += q113*C_[1];
	I[114] += q114*C_[1];
	I[115] += q115*C_[1];
	I[116] += q116*C_[1];
	I[117] += q117*C_[1];
	I[118] += q118*C_[1];
	I[119] += q119*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q121 += alpha*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,0); // d/dAz
	    q122 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,4); // d/dAz
	    q123 += alpha*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q124 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q125 += alpha*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q126 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,1); // d/dAz
	    q127 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q128 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,3); // d/dAz
	    q129 += alpha*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[0];
	I[122] += q122*C_[0];
	I[123] += q123*C_[0];
	I[124] += q124*C_[0];
	I[125] += q125*C_[0];
	I[126] += q126*C_[0];
	I[127] += q127*C_[0];
	I[128] += q128*C_[0];
	I[129] += q129*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q131 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,2); // d/dAz
	    q132 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q133 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q134 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	    q135 += alpha*Ix(a,1,4)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q136 += alpha*Ix(a,1,0)*Iy(a,0,4)*Iz(a,1,0); // d/dAz
	    q137 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,4); // d/dAz
	    q138 += alpha*Ix(a,1,3)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q139 += alpha*Ix(a,1,3)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[130] += q130*C_[0];
	I[131] += q131*C_[0];
	I[132] += q132*C_[0];
	I[133] += q133*C_[0];
	I[134] += q134*C_[0];
	I[135] += q135*C_[1];
	I[136] += q136*C_[1];
	I[137] += q137*C_[1];
	I[138] += q138*C_[1];
	I[139] += q139*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += alpha*Ix(a,1,1)*Iy(a,0,3)*Iz(a,1,0); // d/dAz
	    q141 += alpha*Ix(a,1,0)*Iy(a,0,3)*Iz(a,1,1); // d/dAz
	    q142 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,3); // d/dAz
	    q143 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,3); // d/dAz
	    q144 += alpha*Ix(a,1,2)*Iy(a,0,2)*Iz(a,1,0); // d/dAz
	    q145 += alpha*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,2); // d/dAz
	    q146 += alpha*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,2); // d/dAz
	    q147 += alpha*Ix(a,1,2)*Iy(a,0,1)*Iz(a,1,1); // d/dAz
	    q148 += alpha*Ix(a,1,1)*Iy(a,0,2)*Iz(a,1,1); // d/dAz
	    q149 += alpha*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,2); // d/dAz
	}
	    
	//contraction coefficients
	I[140] += q140*C_[1];
	I[141] += q141*C_[1];
	I[142] += q142*C_[1];
	I[143] += q143*C_[1];
	I[144] += q144*C_[1];
	I[145] += q145*C_[1];
	I[146] += q146*C_[1];
	I[147] += q147*C_[1];
	I[148] += q148*C_[1];
	I[149] += q149*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += alpha*Ix(a,0,4)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q151 += alpha*Ix(a,0,0)*Iy(a,1,4)*Iz(a,1,0); // d/dAz
	    q152 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,4); // d/dAz
	    q153 += alpha*Ix(a,0,3)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q154 += alpha*Ix(a,0,3)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q155 += alpha*Ix(a,0,1)*Iy(a,1,3)*Iz(a,1,0); // d/dAz
	    q156 += alpha*Ix(a,0,0)*Iy(a,1,3)*Iz(a,1,1); // d/dAz
	    q157 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,3); // d/dAz
	    q158 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,3); // d/dAz
	    q159 += alpha*Ix(a,0,2)*Iy(a,1,2)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[150] += q150*C_[1];
	I[151] += q151*C_[1];
	I[152] += q152*C_[1];
	I[153] += q153*C_[1];
	I[154] += q154*C_[1];
	I[155] += q155*C_[1];
	I[156] += q156*C_[1];
	I[157] += q157*C_[1];
	I[158] += q158*C_[1];
	I[159] += q159*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += alpha*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,2); // d/dAz
	    q161 += alpha*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,2); // d/dAz
	    q162 += alpha*Ix(a,0,2)*Iy(a,1,1)*Iz(a,1,1); // d/dAz
	    q163 += alpha*Ix(a,0,1)*Iy(a,1,2)*Iz(a,1,1); // d/dAz
	    q164 += alpha*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,2); // d/dAz
	    q165 += alpha*Ix(a,0,4)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q166 += alpha*Ix(a,0,0)*Iy(a,0,4)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,0);  // d/dAz
	    q167 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,4)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,4);  // d/dAz
	    q168 += alpha*Ix(a,0,3)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q169 += alpha*Ix(a,0,3)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[160] += q160*C_[1];
	I[161] += q161*C_[1];
	I[162] += q162*C_[1];
	I[163] += q163*C_[1];
	I[164] += q164*C_[1];
	I[165] += q165*C_[1];
	I[166] += q166*C_[1];
	I[167] += q167*C_[1];
	I[168] += q168*C_[1];
	I[169] += q169*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += alpha*Ix(a,0,1)*Iy(a,0,3)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,0);  // d/dAz
	    q171 += alpha*Ix(a,0,0)*Iy(a,0,3)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,1);  // d/dAz
	    q172 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,3)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,3);  // d/dAz
	    q173 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,3)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,3);  // d/dAz
	    q174 += alpha*Ix(a,0,2)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,0);  // d/dAz
	    q175 += alpha*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,2);  // d/dAz
	    q176 += alpha*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,2);  // d/dAz
	    q177 += alpha*Ix(a,0,2)*Iy(a,0,1)*Iz(a,2,1)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,1);  // d/dAz
	    q178 += alpha*Ix(a,0,1)*Iy(a,0,2)*Iz(a,2,1)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,1);  // d/dAz
	    q179 += alpha*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,2)
                     - 1*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,2);  // d/dAz
	}
	    
	//contraction coefficients
	I[170] += q170*C_[1];
	I[171] += q171*C_[1];
	I[172] += q172*C_[1];
	I[173] += q173*C_[1];
	I[174] += q174*C_[1];
	I[175] += q175*C_[1];
	I[176] += q176*C_[1];
	I[177] += q177*C_[1];
	I[178] += q178*C_[1];
	I[179] += q179*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += beta*Ix(a,0,5)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q181 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,0,0); // d/dBx
	    q182 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,4); // d/dBx
	    q183 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q184 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	    q185 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBx
	    q186 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBx
	    q187 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBx
	    q188 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBx
	    q189 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[0];
	I[182] += q182*C_[0];
	I[183] += q183*C_[0];
	I[184] += q184*C_[0];
	I[185] += q185*C_[0];
	I[186] += q186*C_[0];
	I[187] += q187*C_[0];
	I[188] += q188*C_[0];
	I[189] += q189*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q191 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,2); // d/dBx
	    q192 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	    q193 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBx
	    q194 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBx
	    q195 += beta*Ix(a,1,5)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q196 += beta*Ix(a,1,1)*Iy(a,0,4)*Iz(a,0,0); // d/dBx
	    q197 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,4); // d/dBx
	    q198 += beta*Ix(a,1,4)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBx
	    q199 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[190] += q190*C_[0];
	I[191] += q191*C_[0];
	I[192] += q192*C_[0];
	I[193] += q193*C_[0];
	I[194] += q194*C_[0];
	I[195] += q195*C_[1];
	I[196] += q196*C_[1];
	I[197] += q197*C_[1];
	I[198] += q198*C_[1];
	I[199] += q199*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += beta*Ix(a,1,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBx
	    q201 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBx
	    q202 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBx
	    q203 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBx
	    q204 += beta*Ix(a,1,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBx
	    q205 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBx
	    q206 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,2); // d/dBx
	    q207 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBx
	    q208 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBx
	    q209 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[200] += q200*C_[1];
	I[201] += q201*C_[1];
	I[202] += q202*C_[1];
	I[203] += q203*C_[1];
	I[204] += q204*C_[1];
	I[205] += q205*C_[1];
	I[206] += q206*C_[1];
	I[207] += q207*C_[1];
	I[208] += q208*C_[1];
	I[209] += q209*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += beta*Ix(a,0,5)*Iy(a,1,0)*Iz(a,0,0)
                     - 4*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q211 += beta*Ix(a,0,1)*Iy(a,1,4)*Iz(a,0,0); // d/dBx
	    q212 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,4); // d/dBx
	    q213 += beta*Ix(a,0,4)*Iy(a,1,1)*Iz(a,0,0)
                     - 3*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBx
	    q214 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,1)
                     - 3*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBx
	    q215 += beta*Ix(a,0,2)*Iy(a,1,3)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBx
	    q216 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,1); // d/dBx
	    q217 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBx
	    q218 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,3); // d/dBx
	    q219 += beta*Ix(a,0,3)*Iy(a,1,2)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[210] += q210*C_[1];
	I[211] += q211*C_[1];
	I[212] += q212*C_[1];
	I[213] += q213*C_[1];
	I[214] += q214*C_[1];
	I[215] += q215*C_[1];
	I[216] += q216*C_[1];
	I[217] += q217*C_[1];
	I[218] += q218*C_[1];
	I[219] += q219*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,2)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBx
	    q221 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,2); // d/dBx
	    q222 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBx
	    q223 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBx
	    q224 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBx
	    q225 += beta*Ix(a,0,5)*Iy(a,0,0)*Iz(a,1,0)
                     - 4*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q226 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,1,0); // d/dBx
	    q227 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,4); // d/dBx
	    q228 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,1,0)
                     - 3*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBx
	    q229 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,1)
                     - 3*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBx
	}
	    
	//contraction coefficients
	I[220] += q220*C_[1];
	I[221] += q221*C_[1];
	I[222] += q222*C_[1];
	I[223] += q223*C_[1];
	I[224] += q224*C_[1];
	I[225] += q225*C_[1];
	I[226] += q226*C_[1];
	I[227] += q227*C_[1];
	I[228] += q228*C_[1];
	I[229] += q229*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBx
	    q231 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,1); // d/dBx
	    q232 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBx
	    q233 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,3); // d/dBx
	    q234 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBx
	    q235 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,2)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBx
	    q236 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,2); // d/dBx
	    q237 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBx
	    q238 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBx
	    q239 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBx
	}
	    
	//contraction coefficients
	I[230] += q230*C_[1];
	I[231] += q231*C_[1];
	I[232] += q232*C_[1];
	I[233] += q233*C_[1];
	I[234] += q234*C_[1];
	I[235] += q235*C_[1];
	I[236] += q236*C_[1];
	I[237] += q237*C_[1];
	I[238] += q238*C_[1];
	I[239] += q239*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q241 += beta*Ix(a,0,0)*Iy(a,0,5)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBy
	    q242 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,4); // d/dBy
	    q243 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q244 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q245 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q246 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBy
	    q247 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q248 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBy
	    q249 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[0];
	I[242] += q242*C_[0];
	I[243] += q243*C_[0];
	I[244] += q244*C_[0];
	I[245] += q245*C_[0];
	I[246] += q246*C_[0];
	I[247] += q247*C_[0];
	I[248] += q248*C_[0];
	I[249] += q249*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q251 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBy
	    q252 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q253 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q254 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	    q255 += beta*Ix(a,1,4)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q256 += beta*Ix(a,1,0)*Iy(a,0,5)*Iz(a,0,0)
                     - 4*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBy
	    q257 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,4); // d/dBy
	    q258 += beta*Ix(a,1,3)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q259 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[250] += q250*C_[0];
	I[251] += q251*C_[0];
	I[252] += q252*C_[0];
	I[253] += q253*C_[0];
	I[254] += q254*C_[0];
	I[255] += q255*C_[1];
	I[256] += q256*C_[1];
	I[257] += q257*C_[1];
	I[258] += q258*C_[1];
	I[259] += q259*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += beta*Ix(a,1,1)*Iy(a,0,4)*Iz(a,0,0)
                     - 3*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBy
	    q261 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,1)
                     - 3*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBy
	    q262 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,3); // d/dBy
	    q263 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBy
	    q264 += beta*Ix(a,1,2)*Iy(a,0,3)*Iz(a,0,0)
                     - 2*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBy
	    q265 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,2); // d/dBy
	    q266 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBy
	    q267 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,1)
                     - 1*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBy
	    q268 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,1)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBy
	    q269 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[260] += q260*C_[1];
	I[261] += q261*C_[1];
	I[262] += q262*C_[1];
	I[263] += q263*C_[1];
	I[264] += q264*C_[1];
	I[265] += q265*C_[1];
	I[266] += q266*C_[1];
	I[267] += q267*C_[1];
	I[268] += q268*C_[1];
	I[269] += q269*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q270 = 0.0;
	T q271 = 0.0;
	T q272 = 0.0;
	T q273 = 0.0;
	T q274 = 0.0;
	T q275 = 0.0;
	T q276 = 0.0;
	T q277 = 0.0;
	T q278 = 0.0;
	T q279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q270 += beta*Ix(a,0,4)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q271 += beta*Ix(a,0,0)*Iy(a,1,5)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBy
	    q272 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,4); // d/dBy
	    q273 += beta*Ix(a,0,3)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q274 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q275 += beta*Ix(a,0,1)*Iy(a,1,4)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBy
	    q276 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBy
	    q277 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,3); // d/dBy
	    q278 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,3)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBy
	    q279 += beta*Ix(a,0,2)*Iy(a,1,3)*Iz(a,0,0)
                     - 2*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBy
	}
	    
	//contraction coefficients
	I[270] += q270*C_[1];
	I[271] += q271*C_[1];
	I[272] += q272*C_[1];
	I[273] += q273*C_[1];
	I[274] += q274*C_[1];
	I[275] += q275*C_[1];
	I[276] += q276*C_[1];
	I[277] += q277*C_[1];
	I[278] += q278*C_[1];
	I[279] += q279*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q280 = 0.0;
	T q281 = 0.0;
	T q282 = 0.0;
	T q283 = 0.0;
	T q284 = 0.0;
	T q285 = 0.0;
	T q286 = 0.0;
	T q287 = 0.0;
	T q288 = 0.0;
	T q289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q280 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,2); // d/dBy
	    q281 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,2)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBy
	    q282 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,1)
                     - 1*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBy
	    q283 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,1)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBy
	    q284 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBy
	    q285 += beta*Ix(a,0,4)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q286 += beta*Ix(a,0,0)*Iy(a,0,5)*Iz(a,1,0)
                     - 4*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBy
	    q287 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,4); // d/dBy
	    q288 += beta*Ix(a,0,3)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q289 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[280] += q280*C_[1];
	I[281] += q281*C_[1];
	I[282] += q282*C_[1];
	I[283] += q283*C_[1];
	I[284] += q284*C_[1];
	I[285] += q285*C_[1];
	I[286] += q286*C_[1];
	I[287] += q287*C_[1];
	I[288] += q288*C_[1];
	I[289] += q289*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q290 = 0.0;
	T q291 = 0.0;
	T q292 = 0.0;
	T q293 = 0.0;
	T q294 = 0.0;
	T q295 = 0.0;
	T q296 = 0.0;
	T q297 = 0.0;
	T q298 = 0.0;
	T q299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q290 += beta*Ix(a,0,1)*Iy(a,0,4)*Iz(a,1,0)
                     - 3*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBy
	    q291 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,1)
                     - 3*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBy
	    q292 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,3); // d/dBy
	    q293 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,3)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBy
	    q294 += beta*Ix(a,0,2)*Iy(a,0,3)*Iz(a,1,0)
                     - 2*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBy
	    q295 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,2); // d/dBy
	    q296 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,2)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBy
	    q297 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,1)
                     - 1*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBy
	    q298 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,1)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBy
	    q299 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBy
	}
	    
	//contraction coefficients
	I[290] += q290*C_[1];
	I[291] += q291*C_[1];
	I[292] += q292*C_[1];
	I[293] += q293*C_[1];
	I[294] += q294*C_[1];
	I[295] += q295*C_[1];
	I[296] += q296*C_[1];
	I[297] += q297*C_[1];
	I[298] += q298*C_[1];
	I[299] += q299*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q300 = 0.0;
	T q301 = 0.0;
	T q302 = 0.0;
	T q303 = 0.0;
	T q304 = 0.0;
	T q305 = 0.0;
	T q306 = 0.0;
	T q307 = 0.0;
	T q308 = 0.0;
	T q309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q300 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q301 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,0,1); // d/dBz
	    q302 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,5)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBz
	    q303 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q304 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q305 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q306 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBz
	    q307 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q308 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBz
	    q309 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[300] += q300*C_[0];
	I[301] += q301*C_[0];
	I[302] += q302*C_[0];
	I[303] += q303*C_[0];
	I[304] += q304*C_[0];
	I[305] += q305*C_[0];
	I[306] += q306*C_[0];
	I[307] += q307*C_[0];
	I[308] += q308*C_[0];
	I[309] += q309*C_[0];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q310 = 0.0;
	T q311 = 0.0;
	T q312 = 0.0;
	T q313 = 0.0;
	T q314 = 0.0;
	T q315 = 0.0;
	T q316 = 0.0;
	T q317 = 0.0;
	T q318 = 0.0;
	T q319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q310 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q311 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBz
	    q312 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q313 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q314 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	    q315 += beta*Ix(a,1,4)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q316 += beta*Ix(a,1,0)*Iy(a,0,4)*Iz(a,0,1); // d/dBz
	    q317 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,5)
                     - 4*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,3);  // d/dBz
	    q318 += beta*Ix(a,1,3)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q319 += beta*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,3)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[310] += q310*C_[0];
	I[311] += q311*C_[0];
	I[312] += q312*C_[0];
	I[313] += q313*C_[0];
	I[314] += q314*C_[0];
	I[315] += q315*C_[1];
	I[316] += q316*C_[1];
	I[317] += q317*C_[1];
	I[318] += q318*C_[1];
	I[319] += q319*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q320 = 0.0;
	T q321 = 0.0;
	T q322 = 0.0;
	T q323 = 0.0;
	T q324 = 0.0;
	T q325 = 0.0;
	T q326 = 0.0;
	T q327 = 0.0;
	T q328 = 0.0;
	T q329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q320 += beta*Ix(a,1,1)*Iy(a,0,3)*Iz(a,0,1); // d/dBz
	    q321 += beta*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,3)*Iz(a,0,0);  // d/dBz
	    q322 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,4)
                     - 3*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,2);  // d/dBz
	    q323 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,4)
                     - 3*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,2);  // d/dBz
	    q324 += beta*Ix(a,1,2)*Iy(a,0,2)*Iz(a,0,1); // d/dBz
	    q325 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,3)
                     - 2*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,1);  // d/dBz
	    q326 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,3)
                     - 2*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,1);  // d/dBz
	    q327 += beta*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,2)
                     - 1*Ix(a,1,2)*Iy(a,0,1)*Iz(a,0,0);  // d/dBz
	    q328 += beta*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,2)
                     - 1*Ix(a,1,1)*Iy(a,0,2)*Iz(a,0,0);  // d/dBz
	    q329 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,3)
                     - 2*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[320] += q320*C_[1];
	I[321] += q321*C_[1];
	I[322] += q322*C_[1];
	I[323] += q323*C_[1];
	I[324] += q324*C_[1];
	I[325] += q325*C_[1];
	I[326] += q326*C_[1];
	I[327] += q327*C_[1];
	I[328] += q328*C_[1];
	I[329] += q329*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q330 = 0.0;
	T q331 = 0.0;
	T q332 = 0.0;
	T q333 = 0.0;
	T q334 = 0.0;
	T q335 = 0.0;
	T q336 = 0.0;
	T q337 = 0.0;
	T q338 = 0.0;
	T q339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q330 += beta*Ix(a,0,4)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q331 += beta*Ix(a,0,0)*Iy(a,1,4)*Iz(a,0,1); // d/dBz
	    q332 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,5)
                     - 4*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,3);  // d/dBz
	    q333 += beta*Ix(a,0,3)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q334 += beta*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,3)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q335 += beta*Ix(a,0,1)*Iy(a,1,3)*Iz(a,0,1); // d/dBz
	    q336 += beta*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,3)*Iz(a,0,0);  // d/dBz
	    q337 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,4)
                     - 3*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,2);  // d/dBz
	    q338 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,4)
                     - 3*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,2);  // d/dBz
	    q339 += beta*Ix(a,0,2)*Iy(a,1,2)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[330] += q330*C_[1];
	I[331] += q331*C_[1];
	I[332] += q332*C_[1];
	I[333] += q333*C_[1];
	I[334] += q334*C_[1];
	I[335] += q335*C_[1];
	I[336] += q336*C_[1];
	I[337] += q337*C_[1];
	I[338] += q338*C_[1];
	I[339] += q339*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q340 = 0.0;
	T q341 = 0.0;
	T q342 = 0.0;
	T q343 = 0.0;
	T q344 = 0.0;
	T q345 = 0.0;
	T q346 = 0.0;
	T q347 = 0.0;
	T q348 = 0.0;
	T q349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q340 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,3)
                     - 2*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,1);  // d/dBz
	    q341 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,3)
                     - 2*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,1);  // d/dBz
	    q342 += beta*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,2)
                     - 1*Ix(a,0,2)*Iy(a,1,1)*Iz(a,0,0);  // d/dBz
	    q343 += beta*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,2)
                     - 1*Ix(a,0,1)*Iy(a,1,2)*Iz(a,0,0);  // d/dBz
	    q344 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,3)
                     - 2*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,1);  // d/dBz
	    q345 += beta*Ix(a,0,4)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q346 += beta*Ix(a,0,0)*Iy(a,0,4)*Iz(a,1,1); // d/dBz
	    q347 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,5)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,3);  // d/dBz
	    q348 += beta*Ix(a,0,3)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q349 += beta*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,3)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[340] += q340*C_[1];
	I[341] += q341*C_[1];
	I[342] += q342*C_[1];
	I[343] += q343*C_[1];
	I[344] += q344*C_[1];
	I[345] += q345*C_[1];
	I[346] += q346*C_[1];
	I[347] += q347*C_[1];
	I[348] += q348*C_[1];
	I[349] += q349*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q350 = 0.0;
	T q351 = 0.0;
	T q352 = 0.0;
	T q353 = 0.0;
	T q354 = 0.0;
	T q355 = 0.0;
	T q356 = 0.0;
	T q357 = 0.0;
	T q358 = 0.0;
	T q359 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q350 += beta*Ix(a,0,1)*Iy(a,0,3)*Iz(a,1,1); // d/dBz
	    q351 += beta*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,3)*Iz(a,1,0);  // d/dBz
	    q352 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,4)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,2);  // d/dBz
	    q353 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,4)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,2);  // d/dBz
	    q354 += beta*Ix(a,0,2)*Iy(a,0,2)*Iz(a,1,1); // d/dBz
	    q355 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,3)
                     - 2*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,1);  // d/dBz
	    q356 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,3)
                     - 2*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,1);  // d/dBz
	    q357 += beta*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,2)
                     - 1*Ix(a,0,2)*Iy(a,0,1)*Iz(a,1,0);  // d/dBz
	    q358 += beta*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,2)
                     - 1*Ix(a,0,1)*Iy(a,0,2)*Iz(a,1,0);  // d/dBz
	    q359 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,3)
                     - 2*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,1);  // d/dBz
	}
	    
	//contraction coefficients
	I[350] += q350*C_[1];
	I[351] += q351*C_[1];
	I[352] += q352*C_[1];
	I[353] += q353*C_[1];
	I[354] += q354*C_[1];
	I[355] += q355*C_[1];
	I[356] += q356*C_[1];
	I[357] += q357*C_[1];
	I[358] += q358*C_[1];
	I[359] += q359*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <ssp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::S,rysq::SP> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::S,rysq::SP> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 2;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0); // d/dAx
	    q3 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1); // d/dAx
	    q4 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q5 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q6 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q7 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q8 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q9 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[1];
	I[2] += q2*C_[1];
	I[3] += q3*C_[1];
	I[4] += q4*C_[0];
	I[5] += q5*C_[1];
	I[6] += q6*C_[1];
	I[7] += q7*C_[1];
	I[8] += q8*C_[0];
	I[9] += q9*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q11 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q12 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q13 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q14 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q15 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q16 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q17 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q18 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q19 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[1];
	I[11] += q11*C_[1];
	I[12] += q12*C_[0];
	I[13] += q13*C_[1];
	I[14] += q14*C_[1];
	I[15] += q15*C_[1];
	I[16] += q16*C_[0];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q21 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q22 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q23 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[1];
	I[22] += q22*C_[1];
	I[23] += q23*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <psp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::P,rysq::SP> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::P,rysq::SP> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q3 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q4 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q5 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q6 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[1];
	I[2] += q2*C_[1];
	I[3] += q3*C_[1];
	I[4] += q4*C_[0];
	I[5] += q5*C_[1];
	I[6] += q6*C_[1];
	I[7] += q7*C_[1];
	I[8] += q8*C_[0];
	I[9] += q9*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAx
	    q12 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q13 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q14 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q15 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q16 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q17 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q18 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q19 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[1];
	I[11] += q11*C_[1];
	I[12] += q12*C_[0];
	I[13] += q13*C_[1];
	I[14] += q14*C_[1];
	I[15] += q15*C_[1];
	I[16] += q16*C_[0];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q21 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q22 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q23 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q24 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q25 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q26 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q27 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q28 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q29 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[1];
	I[22] += q22*C_[1];
	I[23] += q23*C_[1];
	I[24] += q24*C_[0];
	I[25] += q25*C_[1];
	I[26] += q26*C_[1];
	I[27] += q27*C_[1];
	I[28] += q28*C_[0];
	I[29] += q29*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q31 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q32 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q33 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q34 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q35 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q36 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q37 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q38 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q39 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[1];
	I[31] += q31*C_[1];
	I[32] += q32*C_[0];
	I[33] += q33*C_[1];
	I[34] += q34*C_[1];
	I[35] += q35*C_[1];
	I[36] += q36*C_[0];
	I[37] += q37*C_[1];
	I[38] += q38*C_[1];
	I[39] += q39*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0); // d/dBx
	    q41 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q42 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBx
	    q43 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBx
	    q44 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0); // d/dBx
	    q45 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q46 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBx
	    q47 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBx
	    q48 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q49 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[1];
	I[42] += q42*C_[1];
	I[43] += q43*C_[1];
	I[44] += q44*C_[0];
	I[45] += q45*C_[1];
	I[46] += q46*C_[1];
	I[47] += q47*C_[1];
	I[48] += q48*C_[0];
	I[49] += q49*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q51 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q52 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q53 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q54 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q55 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q56 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q57 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q58 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q59 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[50] += q50*C_[1];
	I[51] += q51*C_[1];
	I[52] += q52*C_[0];
	I[53] += q53*C_[1];
	I[54] += q54*C_[1];
	I[55] += q55*C_[1];
	I[56] += q56*C_[0];
	I[57] += q57*C_[1];
	I[58] += q58*C_[1];
	I[59] += q59*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q61 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q62 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q63 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q64 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q65 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q66 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q67 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q68 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q69 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[1];
	I[62] += q62*C_[1];
	I[63] += q63*C_[1];
	I[64] += q64*C_[0];
	I[65] += q65*C_[1];
	I[66] += q66*C_[1];
	I[67] += q67*C_[1];
	I[68] += q68*C_[0];
	I[69] += q69*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q71 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[70] += q70*C_[1];
	I[71] += q71*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <dsp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::D,rysq::SP> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::D,rysq::SP> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 4;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q3 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q4 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0); // d/dAx
	    q5 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0); // d/dAx
	    q6 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[1];
	I[2] += q2*C_[1];
	I[3] += q3*C_[1];
	I[4] += q4*C_[0];
	I[5] += q5*C_[1];
	I[6] += q6*C_[1];
	I[7] += q7*C_[1];
	I[8] += q8*C_[0];
	I[9] += q9*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1); // d/dAx
	    q12 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q13 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q14 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q15 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q16 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q17 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q18 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q19 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[1];
	I[11] += q11*C_[1];
	I[12] += q12*C_[0];
	I[13] += q13*C_[1];
	I[14] += q14*C_[1];
	I[15] += q15*C_[1];
	I[16] += q16*C_[0];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAx
	    q21 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAx
	    q22 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAx
	    q23 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAx
	    q24 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q25 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q26 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q27 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q28 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q29 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[1];
	I[22] += q22*C_[1];
	I[23] += q23*C_[1];
	I[24] += q24*C_[0];
	I[25] += q25*C_[1];
	I[26] += q26*C_[1];
	I[27] += q27*C_[1];
	I[28] += q28*C_[0];
	I[29] += q29*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q31 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q32 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q33 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q34 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q35 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q36 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q37 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q38 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q39 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[30] += q30*C_[1];
	I[31] += q31*C_[1];
	I[32] += q32*C_[0];
	I[33] += q33*C_[1];
	I[34] += q34*C_[1];
	I[35] += q35*C_[1];
	I[36] += q36*C_[0];
	I[37] += q37*C_[1];
	I[38] += q38*C_[1];
	I[39] += q39*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q41 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q42 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q43 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q44 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q45 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q46 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q47 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	    q48 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q49 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[1];
	I[42] += q42*C_[1];
	I[43] += q43*C_[1];
	I[44] += q44*C_[0];
	I[45] += q45*C_[1];
	I[46] += q46*C_[1];
	I[47] += q47*C_[1];
	I[48] += q48*C_[0];
	I[49] += q49*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q51 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q52 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q53 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q54 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q55 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	    q56 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q57 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q58 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q59 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[50] += q50*C_[1];
	I[51] += q51*C_[1];
	I[52] += q52*C_[0];
	I[53] += q53*C_[1];
	I[54] += q54*C_[1];
	I[55] += q55*C_[1];
	I[56] += q56*C_[0];
	I[57] += q57*C_[1];
	I[58] += q58*C_[1];
	I[59] += q59*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q61 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q62 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q63 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q64 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q65 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q66 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q67 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q68 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q69 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[1];
	I[62] += q62*C_[1];
	I[63] += q63*C_[1];
	I[64] += q64*C_[0];
	I[65] += q65*C_[1];
	I[66] += q66*C_[1];
	I[67] += q67*C_[1];
	I[68] += q68*C_[0];
	I[69] += q69*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q71 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q72 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q73 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q74 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q75 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q76 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0); // d/dBx
	    q77 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q78 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBx
	    q79 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBx
	}
	    
	//contraction coefficients
	I[70] += q70*C_[1];
	I[71] += q71*C_[1];
	I[72] += q72*C_[0];
	I[73] += q73*C_[1];
	I[74] += q74*C_[1];
	I[75] += q75*C_[1];
	I[76] += q76*C_[0];
	I[77] += q77*C_[1];
	I[78] += q78*C_[1];
	I[79] += q79*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0); // d/dBx
	    q81 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q82 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBx
	    q83 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBx
	    q84 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0); // d/dBx
	    q85 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q86 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBx
	    q87 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBx
	    q88 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0); // d/dBx
	    q89 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[1];
	I[82] += q82*C_[1];
	I[83] += q83*C_[1];
	I[84] += q84*C_[0];
	I[85] += q85*C_[1];
	I[86] += q86*C_[1];
	I[87] += q87*C_[1];
	I[88] += q88*C_[0];
	I[89] += q89*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBx
	    q91 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBx
	    q92 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0); // d/dBx
	    q93 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q94 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBx
	    q95 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBx
	    q96 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q97 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q98 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q99 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[90] += q90*C_[1];
	I[91] += q91*C_[1];
	I[92] += q92*C_[0];
	I[93] += q93*C_[1];
	I[94] += q94*C_[1];
	I[95] += q95*C_[1];
	I[96] += q96*C_[0];
	I[97] += q97*C_[1];
	I[98] += q98*C_[1];
	I[99] += q99*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q101 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q102 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q103 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	    q104 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q105 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q106 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q107 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q108 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q109 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[1];
	I[102] += q102*C_[1];
	I[103] += q103*C_[1];
	I[104] += q104*C_[0];
	I[105] += q105*C_[1];
	I[106] += q106*C_[1];
	I[107] += q107*C_[1];
	I[108] += q108*C_[0];
	I[109] += q109*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q111 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q112 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q113 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q114 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q115 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	    q116 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q117 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q118 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q119 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[110] += q110*C_[1];
	I[111] += q111*C_[1];
	I[112] += q112*C_[0];
	I[113] += q113*C_[1];
	I[114] += q114*C_[1];
	I[115] += q115*C_[1];
	I[116] += q116*C_[0];
	I[117] += q117*C_[1];
	I[118] += q118*C_[1];
	I[119] += q119*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q121 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q122 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q123 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q124 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q125 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q126 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q127 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q128 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q129 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[1];
	I[122] += q122*C_[1];
	I[123] += q123*C_[1];
	I[124] += q124*C_[0];
	I[125] += q125*C_[1];
	I[126] += q126*C_[1];
	I[127] += q127*C_[1];
	I[128] += q128*C_[0];
	I[129] += q129*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q131 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q132 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q133 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q134 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q135 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q136 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q137 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q138 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q139 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[130] += q130*C_[1];
	I[131] += q131*C_[1];
	I[132] += q132*C_[0];
	I[133] += q133*C_[1];
	I[134] += q134*C_[1];
	I[135] += q135*C_[1];
	I[136] += q136*C_[0];
	I[137] += q137*C_[1];
	I[138] += q138*C_[1];
	I[139] += q139*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q141 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q142 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q143 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[1];
	I[142] += q142*C_[1];
	I[143] += q143*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <fsp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::F,rysq::SP> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::F,rysq::SP> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 5;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q3 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q4 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,0); // d/dAx
	    q5 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,0); // d/dAx
	    q6 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,1); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,0); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[1];
	I[2] += q2*C_[1];
	I[3] += q3*C_[1];
	I[4] += q4*C_[0];
	I[5] += q5*C_[1];
	I[6] += q6*C_[1];
	I[7] += q7*C_[1];
	I[8] += q8*C_[0];
	I[9] += q9*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,0); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,1); // d/dAx
	    q12 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q13 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q14 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q15 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q16 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q17 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q18 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q19 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[1];
	I[11] += q11*C_[1];
	I[12] += q12*C_[0];
	I[13] += q13*C_[1];
	I[14] += q14*C_[1];
	I[15] += q15*C_[1];
	I[16] += q16*C_[0];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q21 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q22 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAx
	    q23 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAx
	    q24 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0); // d/dAx
	    q25 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0); // d/dAx
	    q27 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1); // d/dAx
	    q28 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q29 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[1];
	I[22] += q22*C_[1];
	I[23] += q23*C_[1];
	I[24] += q24*C_[0];
	I[25] += q25*C_[1];
	I[26] += q26*C_[1];
	I[27] += q27*C_[1];
	I[28] += q28*C_[0];
	I[29] += q29*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAx
	    q31 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAx
	    q32 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0); // d/dAx
	    q33 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0); // d/dAx
	    q34 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0); // d/dAx
	    q35 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1); // d/dAx
	    q36 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q37 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q38 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAx
	    q39 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[1];
	I[31] += q31*C_[1];
	I[32] += q32*C_[0];
	I[33] += q33*C_[1];
	I[34] += q34*C_[1];
	I[35] += q35*C_[1];
	I[36] += q36*C_[0];
	I[37] += q37*C_[1];
	I[38] += q38*C_[1];
	I[39] += q39*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q41 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q42 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q43 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q44 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q45 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q46 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAy
	    q47 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAy
	    q48 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q49 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[1];
	I[42] += q42*C_[1];
	I[43] += q43*C_[1];
	I[44] += q44*C_[0];
	I[45] += q45*C_[1];
	I[46] += q46*C_[1];
	I[47] += q47*C_[1];
	I[48] += q48*C_[0];
	I[49] += q49*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,0); // d/dAy
	    q51 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,1); // d/dAy
	    q52 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q53 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q54 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q55 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q56 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q57 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q58 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q59 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[50] += q50*C_[1];
	I[51] += q51*C_[1];
	I[52] += q52*C_[0];
	I[53] += q53*C_[1];
	I[54] += q54*C_[1];
	I[55] += q55*C_[1];
	I[56] += q56*C_[0];
	I[57] += q57*C_[1];
	I[58] += q58*C_[1];
	I[59] += q59*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q61 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q62 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q63 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	    q64 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q65 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q66 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAy
	    q67 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAy
	    q68 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q69 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[1];
	I[62] += q62*C_[1];
	I[63] += q63*C_[1];
	I[64] += q64*C_[0];
	I[65] += q65*C_[1];
	I[66] += q66*C_[1];
	I[67] += q67*C_[1];
	I[68] += q68*C_[0];
	I[69] += q69*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q71 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q72 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q73 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q74 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAy
	    q75 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAy
	    q76 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q77 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q78 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q79 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[1];
	I[71] += q71*C_[1];
	I[72] += q72*C_[0];
	I[73] += q73*C_[1];
	I[74] += q74*C_[1];
	I[75] += q75*C_[1];
	I[76] += q76*C_[0];
	I[77] += q77*C_[1];
	I[78] += q78*C_[1];
	I[79] += q79*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q81 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q82 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q83 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q84 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q85 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q86 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,0); // d/dAz
	    q87 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,1); // d/dAz
	    q88 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q89 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[1];
	I[82] += q82*C_[1];
	I[83] += q83*C_[1];
	I[84] += q84*C_[0];
	I[85] += q85*C_[1];
	I[86] += q86*C_[1];
	I[87] += q87*C_[1];
	I[88] += q88*C_[0];
	I[89] += q89*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAz
	    q91 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAz
	    q92 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q93 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q94 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q95 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q96 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q97 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q98 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q99 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[90] += q90*C_[1];
	I[91] += q91*C_[1];
	I[92] += q92*C_[0];
	I[93] += q93*C_[1];
	I[94] += q94*C_[1];
	I[95] += q95*C_[1];
	I[96] += q96*C_[0];
	I[97] += q97*C_[1];
	I[98] += q98*C_[1];
	I[99] += q99*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q101 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q102 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q103 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	    q104 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q105 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q106 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAz
	    q107 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAz
	    q108 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q109 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[1];
	I[102] += q102*C_[1];
	I[103] += q103*C_[1];
	I[104] += q104*C_[0];
	I[105] += q105*C_[1];
	I[106] += q106*C_[1];
	I[107] += q107*C_[1];
	I[108] += q108*C_[0];
	I[109] += q109*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q111 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q112 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q113 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q114 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAz
	    q115 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAz
	    q116 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q117 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q118 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q119 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[110] += q110*C_[1];
	I[111] += q111*C_[1];
	I[112] += q112*C_[0];
	I[113] += q113*C_[1];
	I[114] += q114*C_[1];
	I[115] += q115*C_[1];
	I[116] += q116*C_[0];
	I[117] += q117*C_[1];
	I[118] += q118*C_[1];
	I[119] += q119*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q121 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q122 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q123 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q124 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0); // d/dBx
	    q125 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBx
	    q126 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0); // d/dBx
	    q127 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1); // d/dBx
	    q128 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0); // d/dBx
	    q129 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[1];
	I[122] += q122*C_[1];
	I[123] += q123*C_[1];
	I[124] += q124*C_[0];
	I[125] += q125*C_[1];
	I[126] += q126*C_[1];
	I[127] += q127*C_[1];
	I[128] += q128*C_[0];
	I[129] += q129*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0); // d/dBx
	    q131 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1); // d/dBx
	    q132 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0); // d/dBx
	    q133 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q134 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBx
	    q135 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBx
	    q136 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0); // d/dBx
	    q137 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q138 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBx
	    q139 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBx
	}
	    
	//contraction coefficients
	I[130] += q130*C_[1];
	I[131] += q131*C_[1];
	I[132] += q132*C_[0];
	I[133] += q133*C_[1];
	I[134] += q134*C_[1];
	I[135] += q135*C_[1];
	I[136] += q136*C_[0];
	I[137] += q137*C_[1];
	I[138] += q138*C_[1];
	I[139] += q139*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0); // d/dBx
	    q141 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q142 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBx
	    q143 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBx
	    q144 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0); // d/dBx
	    q145 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBx
	    q146 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0); // d/dBx
	    q147 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1); // d/dBx
	    q148 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0); // d/dBx
	    q149 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[1];
	I[142] += q142*C_[1];
	I[143] += q143*C_[1];
	I[144] += q144*C_[0];
	I[145] += q145*C_[1];
	I[146] += q146*C_[1];
	I[147] += q147*C_[1];
	I[148] += q148*C_[0];
	I[149] += q149*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBx
	    q151 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBx
	    q152 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0); // d/dBx
	    q153 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBx
	    q154 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0); // d/dBx
	    q155 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1); // d/dBx
	    q156 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0); // d/dBx
	    q157 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	    q158 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBx
	    q159 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBx
	}
	    
	//contraction coefficients
	I[150] += q150*C_[1];
	I[151] += q151*C_[1];
	I[152] += q152*C_[0];
	I[153] += q153*C_[1];
	I[154] += q154*C_[1];
	I[155] += q155*C_[1];
	I[156] += q156*C_[0];
	I[157] += q157*C_[1];
	I[158] += q158*C_[1];
	I[159] += q159*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q161 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q162 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q163 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q164 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q165 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q166 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBy
	    q167 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1); // d/dBy
	    q168 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q169 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[1];
	I[162] += q162*C_[1];
	I[163] += q163*C_[1];
	I[164] += q164*C_[0];
	I[165] += q165*C_[1];
	I[166] += q166*C_[1];
	I[167] += q167*C_[1];
	I[168] += q168*C_[0];
	I[169] += q169*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBy
	    q171 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1); // d/dBy
	    q172 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q173 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q174 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q175 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q176 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q177 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q178 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q179 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[170] += q170*C_[1];
	I[171] += q171*C_[1];
	I[172] += q172*C_[0];
	I[173] += q173*C_[1];
	I[174] += q174*C_[1];
	I[175] += q175*C_[1];
	I[176] += q176*C_[0];
	I[177] += q177*C_[1];
	I[178] += q178*C_[1];
	I[179] += q179*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q181 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q182 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q183 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	    q184 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q185 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q186 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBy
	    q187 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1); // d/dBy
	    q188 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q189 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[1];
	I[182] += q182*C_[1];
	I[183] += q183*C_[1];
	I[184] += q184*C_[0];
	I[185] += q185*C_[1];
	I[186] += q186*C_[1];
	I[187] += q187*C_[1];
	I[188] += q188*C_[0];
	I[189] += q189*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q191 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q192 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q193 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q194 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBy
	    q195 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1); // d/dBy
	    q196 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q197 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q198 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q199 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[190] += q190*C_[1];
	I[191] += q191*C_[1];
	I[192] += q192*C_[0];
	I[193] += q193*C_[1];
	I[194] += q194*C_[1];
	I[195] += q195*C_[1];
	I[196] += q196*C_[0];
	I[197] += q197*C_[1];
	I[198] += q198*C_[1];
	I[199] += q199*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q201 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q202 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q203 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q204 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q205 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q206 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,1); // d/dBz
	    q207 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBz
	    q208 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q209 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[1];
	I[202] += q202*C_[1];
	I[203] += q203*C_[1];
	I[204] += q204*C_[0];
	I[205] += q205*C_[1];
	I[206] += q206*C_[1];
	I[207] += q207*C_[1];
	I[208] += q208*C_[0];
	I[209] += q209*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,1); // d/dBz
	    q211 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBz
	    q212 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q213 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q214 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q215 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q216 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q217 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q218 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q219 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[210] += q210*C_[1];
	I[211] += q211*C_[1];
	I[212] += q212*C_[0];
	I[213] += q213*C_[1];
	I[214] += q214*C_[1];
	I[215] += q215*C_[1];
	I[216] += q216*C_[0];
	I[217] += q217*C_[1];
	I[218] += q218*C_[1];
	I[219] += q219*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q221 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q222 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q223 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	    q224 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q225 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q226 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,1); // d/dBz
	    q227 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBz
	    q228 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q229 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[1];
	I[222] += q222*C_[1];
	I[223] += q223*C_[1];
	I[224] += q224*C_[0];
	I[225] += q225*C_[1];
	I[226] += q226*C_[1];
	I[227] += q227*C_[1];
	I[228] += q228*C_[0];
	I[229] += q229*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q231 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q232 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q233 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q234 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,1); // d/dBz
	    q235 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBz
	    q236 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q237 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q238 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q239 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[230] += q230*C_[1];
	I[231] += q231*C_[1];
	I[232] += q232*C_[0];
	I[233] += q233*C_[1];
	I[234] += q234*C_[1];
	I[235] += q235*C_[1];
	I[236] += q236*C_[0];
	I[237] += q237*C_[1];
	I[238] += q238*C_[1];
	I[239] += q239*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <gsp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::G,rysq::SP> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::G,rysq::SP> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 6;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,5,0)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q1 += alpha*Ix(a,5,1)*Iy(a,0,0)*Iz(a,0,0)
                     - 4*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q2 += alpha*Ix(a,5,0)*Iy(a,0,1)*Iz(a,0,0)
                     - 4*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q3 += alpha*Ix(a,5,0)*Iy(a,0,0)*Iz(a,0,1)
                     - 4*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q4 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,0); // d/dAx
	    q5 += alpha*Ix(a,1,1)*Iy(a,4,0)*Iz(a,0,0); // d/dAx
	    q6 += alpha*Ix(a,1,0)*Iy(a,4,1)*Iz(a,0,0); // d/dAx
	    q7 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,1); // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,0); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,4,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[1];
	I[2] += q2*C_[1];
	I[3] += q3*C_[1];
	I[4] += q4*C_[0];
	I[5] += q5*C_[1];
	I[6] += q6*C_[1];
	I[7] += q7*C_[1];
	I[8] += q8*C_[0];
	I[9] += q9*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,4,0); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,1); // d/dAx
	    q12 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q13 += alpha*Ix(a,4,1)*Iy(a,1,0)*Iz(a,0,0)
                     - 3*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAx
	    q14 += alpha*Ix(a,4,0)*Iy(a,1,1)*Iz(a,0,0)
                     - 3*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAx
	    q15 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,1)
                     - 3*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAx
	    q16 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q17 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,1,0)
                     - 3*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAx
	    q18 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,1,0)
                     - 3*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAx
	    q19 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,1)
                     - 3*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[10] += q10*C_[1];
	I[11] += q11*C_[1];
	I[12] += q12*C_[0];
	I[13] += q13*C_[1];
	I[14] += q14*C_[1];
	I[15] += q15*C_[1];
	I[16] += q16*C_[0];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dAx
	    q21 += alpha*Ix(a,2,1)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dAx
	    q22 += alpha*Ix(a,2,0)*Iy(a,3,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dAx
	    q23 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dAx
	    q24 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,0); // d/dAx
	    q25 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,0); // d/dAx
	    q26 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,0); // d/dAx
	    q27 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,1); // d/dAx
	    q28 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dAx
	    q29 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[20] += q20*C_[0];
	I[21] += q21*C_[1];
	I[22] += q22*C_[1];
	I[23] += q23*C_[1];
	I[24] += q24*C_[0];
	I[25] += q25*C_[1];
	I[26] += q26*C_[1];
	I[27] += q27*C_[1];
	I[28] += q28*C_[0];
	I[29] += q29*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dAx
	    q31 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dAx
	    q32 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,0); // d/dAx
	    q33 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,0); // d/dAx
	    q34 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,0); // d/dAx
	    q35 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,1); // d/dAx
	    q36 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q37 += alpha*Ix(a,3,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 2*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAx
	    q38 += alpha*Ix(a,3,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 2*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAx
	    q39 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 2*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[30] += q30*C_[1];
	I[31] += q31*C_[1];
	I[32] += q32*C_[0];
	I[33] += q33*C_[1];
	I[34] += q34*C_[1];
	I[35] += q35*C_[1];
	I[36] += q36*C_[0];
	I[37] += q37*C_[1];
	I[38] += q38*C_[1];
	I[39] += q39*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q41 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 2*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAx
	    q42 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 2*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAx
	    q43 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 2*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAx
	    q44 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,0); // d/dAx
	    q45 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,0); // d/dAx
	    q46 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,0); // d/dAx
	    q47 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,1); // d/dAx
	    q48 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	    q49 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[0];
	I[41] += q41*C_[1];
	I[42] += q42*C_[1];
	I[43] += q43*C_[1];
	I[44] += q44*C_[0];
	I[45] += q45*C_[1];
	I[46] += q46*C_[1];
	I[47] += q47*C_[1];
	I[48] += q48*C_[0];
	I[49] += q49*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAx
	    q51 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAx
	    q52 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dAx
	    q53 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dAx
	    q54 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dAx
	    q55 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dAx
	    q56 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dAx
	    q57 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dAx
	    q58 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dAx
	    q59 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dAx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[1];
	I[51] += q51*C_[1];
	I[52] += q52*C_[0];
	I[53] += q53*C_[1];
	I[54] += q54*C_[1];
	I[55] += q55*C_[1];
	I[56] += q56*C_[0];
	I[57] += q57*C_[1];
	I[58] += q58*C_[1];
	I[59] += q59*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q61 += alpha*Ix(a,4,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q62 += alpha*Ix(a,4,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q63 += alpha*Ix(a,4,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q64 += alpha*Ix(a,0,0)*Iy(a,5,0)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dAy
	    q65 += alpha*Ix(a,0,1)*Iy(a,5,0)*Iz(a,0,0)
                     - 4*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dAy
	    q66 += alpha*Ix(a,0,0)*Iy(a,5,1)*Iz(a,0,0)
                     - 4*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dAy
	    q67 += alpha*Ix(a,0,0)*Iy(a,5,0)*Iz(a,0,1)
                     - 4*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dAy
	    q68 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,0); // d/dAy
	    q69 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,4,0); // d/dAy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[0];
	I[61] += q61*C_[1];
	I[62] += q62*C_[1];
	I[63] += q63*C_[1];
	I[64] += q64*C_[0];
	I[65] += q65*C_[1];
	I[66] += q66*C_[1];
	I[67] += q67*C_[1];
	I[68] += q68*C_[0];
	I[69] += q69*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,4,0); // d/dAy
	    q71 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,1); // d/dAy
	    q72 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q73 += alpha*Ix(a,3,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q74 += alpha*Ix(a,3,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q75 += alpha*Ix(a,3,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q76 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q77 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q78 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q79 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[1];
	I[71] += q71*C_[1];
	I[72] += q72*C_[0];
	I[73] += q73*C_[1];
	I[74] += q74*C_[1];
	I[75] += q75*C_[1];
	I[76] += q76*C_[0];
	I[77] += q77*C_[1];
	I[78] += q78*C_[1];
	I[79] += q79*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q81 += alpha*Ix(a,1,1)*Iy(a,4,0)*Iz(a,0,0)
                     - 3*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAy
	    q82 += alpha*Ix(a,1,0)*Iy(a,4,1)*Iz(a,0,0)
                     - 3*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAy
	    q83 += alpha*Ix(a,1,0)*Iy(a,4,0)*Iz(a,0,1)
                     - 3*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAy
	    q84 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dAy
	    q85 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,1,0)
                     - 3*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dAy
	    q86 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,1,0)
                     - 3*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dAy
	    q87 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,1)
                     - 3*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dAy
	    q88 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	    q89 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,0); // d/dAy
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[1];
	I[82] += q82*C_[1];
	I[83] += q83*C_[1];
	I[84] += q84*C_[0];
	I[85] += q85*C_[1];
	I[86] += q86*C_[1];
	I[87] += q87*C_[1];
	I[88] += q88*C_[0];
	I[89] += q89*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
	T q96 = 0.0;
	T q97 = 0.0;
	T q98 = 0.0;
	T q99 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,0); // d/dAy
	    q91 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,1); // d/dAy
	    q92 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dAy
	    q93 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,3,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dAy
	    q94 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dAy
	    q95 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dAy
	    q96 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q97 += alpha*Ix(a,2,1)*Iy(a,3,0)*Iz(a,0,0)
                     - 2*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAy
	    q98 += alpha*Ix(a,2,0)*Iy(a,3,1)*Iz(a,0,0)
                     - 2*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAy
	    q99 += alpha*Ix(a,2,0)*Iy(a,3,0)*Iz(a,0,1)
                     - 2*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[90] += q90*C_[1];
	I[91] += q91*C_[1];
	I[92] += q92*C_[0];
	I[93] += q93*C_[1];
	I[94] += q94*C_[1];
	I[95] += q95*C_[1];
	I[96] += q96*C_[0];
	I[97] += q97*C_[1];
	I[98] += q98*C_[1];
	I[99] += q99*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q100 = 0.0;
	T q101 = 0.0;
	T q102 = 0.0;
	T q103 = 0.0;
	T q104 = 0.0;
	T q105 = 0.0;
	T q106 = 0.0;
	T q107 = 0.0;
	T q108 = 0.0;
	T q109 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q100 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q101 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,0); // d/dAy
	    q102 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,0); // d/dAy
	    q103 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,1); // d/dAy
	    q104 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,0)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dAy
	    q105 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,2,0)
                     - 2*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dAy
	    q106 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,2,0)
                     - 2*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dAy
	    q107 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,1)
                     - 2*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dAy
	    q108 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	    q109 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAy
	}
	    
	//contraction coefficients
	I[100] += q100*C_[0];
	I[101] += q101*C_[1];
	I[102] += q102*C_[1];
	I[103] += q103*C_[1];
	I[104] += q104*C_[0];
	I[105] += q105*C_[1];
	I[106] += q106*C_[1];
	I[107] += q107*C_[1];
	I[108] += q108*C_[0];
	I[109] += q109*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q110 = 0.0;
	T q111 = 0.0;
	T q112 = 0.0;
	T q113 = 0.0;
	T q114 = 0.0;
	T q115 = 0.0;
	T q116 = 0.0;
	T q117 = 0.0;
	T q118 = 0.0;
	T q119 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q110 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAy
	    q111 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,1)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAy
	    q112 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q113 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAy
	    q114 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAy
	    q115 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,1)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAy
	    q116 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q117 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAy
	    q118 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAy
	    q119 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAy
	}
	    
	//contraction coefficients
	I[110] += q110*C_[1];
	I[111] += q111*C_[1];
	I[112] += q112*C_[0];
	I[113] += q113*C_[1];
	I[114] += q114*C_[1];
	I[115] += q115*C_[1];
	I[116] += q116*C_[0];
	I[117] += q117*C_[1];
	I[118] += q118*C_[1];
	I[119] += q119*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q120 = 0.0;
	T q121 = 0.0;
	T q122 = 0.0;
	T q123 = 0.0;
	T q124 = 0.0;
	T q125 = 0.0;
	T q126 = 0.0;
	T q127 = 0.0;
	T q128 = 0.0;
	T q129 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q120 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q121 += alpha*Ix(a,4,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q122 += alpha*Ix(a,4,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q123 += alpha*Ix(a,4,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q124 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,0); // d/dAz
	    q125 += alpha*Ix(a,0,1)*Iy(a,4,0)*Iz(a,1,0); // d/dAz
	    q126 += alpha*Ix(a,0,0)*Iy(a,4,1)*Iz(a,1,0); // d/dAz
	    q127 += alpha*Ix(a,0,0)*Iy(a,4,0)*Iz(a,1,1); // d/dAz
	    q128 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,5,0)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dAz
	    q129 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,5,0)
                     - 4*Ix(a,0,1)*Iy(a,0,0)*Iz(a,3,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[120] += q120*C_[0];
	I[121] += q121*C_[1];
	I[122] += q122*C_[1];
	I[123] += q123*C_[1];
	I[124] += q124*C_[0];
	I[125] += q125*C_[1];
	I[126] += q126*C_[1];
	I[127] += q127*C_[1];
	I[128] += q128*C_[0];
	I[129] += q129*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q130 = 0.0;
	T q131 = 0.0;
	T q132 = 0.0;
	T q133 = 0.0;
	T q134 = 0.0;
	T q135 = 0.0;
	T q136 = 0.0;
	T q137 = 0.0;
	T q138 = 0.0;
	T q139 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q130 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,5,0)
                     - 4*Ix(a,0,0)*Iy(a,0,1)*Iz(a,3,0);  // d/dAz
	    q131 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,5,1)
                     - 4*Ix(a,0,0)*Iy(a,0,0)*Iz(a,3,1);  // d/dAz
	    q132 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q133 += alpha*Ix(a,3,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q134 += alpha*Ix(a,3,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q135 += alpha*Ix(a,3,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q136 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q137 += alpha*Ix(a,3,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,3,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q138 += alpha*Ix(a,3,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,3,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q139 += alpha*Ix(a,3,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[130] += q130*C_[1];
	I[131] += q131*C_[1];
	I[132] += q132*C_[0];
	I[133] += q133*C_[1];
	I[134] += q134*C_[1];
	I[135] += q135*C_[1];
	I[136] += q136*C_[0];
	I[137] += q137*C_[1];
	I[138] += q138*C_[1];
	I[139] += q139*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q140 = 0.0;
	T q141 = 0.0;
	T q142 = 0.0;
	T q143 = 0.0;
	T q144 = 0.0;
	T q145 = 0.0;
	T q146 = 0.0;
	T q147 = 0.0;
	T q148 = 0.0;
	T q149 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q140 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q141 += alpha*Ix(a,1,1)*Iy(a,3,0)*Iz(a,1,0); // d/dAz
	    q142 += alpha*Ix(a,1,0)*Iy(a,3,1)*Iz(a,1,0); // d/dAz
	    q143 += alpha*Ix(a,1,0)*Iy(a,3,0)*Iz(a,1,1); // d/dAz
	    q144 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dAz
	    q145 += alpha*Ix(a,0,1)*Iy(a,3,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,3,0)*Iz(a,0,0);  // d/dAz
	    q146 += alpha*Ix(a,0,0)*Iy(a,3,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,3,1)*Iz(a,0,0);  // d/dAz
	    q147 += alpha*Ix(a,0,0)*Iy(a,3,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,0,1);  // d/dAz
	    q148 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	    q149 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,4,0)
                     - 3*Ix(a,1,1)*Iy(a,0,0)*Iz(a,2,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[140] += q140*C_[0];
	I[141] += q141*C_[1];
	I[142] += q142*C_[1];
	I[143] += q143*C_[1];
	I[144] += q144*C_[0];
	I[145] += q145*C_[1];
	I[146] += q146*C_[1];
	I[147] += q147*C_[1];
	I[148] += q148*C_[0];
	I[149] += q149*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q150 = 0.0;
	T q151 = 0.0;
	T q152 = 0.0;
	T q153 = 0.0;
	T q154 = 0.0;
	T q155 = 0.0;
	T q156 = 0.0;
	T q157 = 0.0;
	T q158 = 0.0;
	T q159 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q150 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,4,0)
                     - 3*Ix(a,1,0)*Iy(a,0,1)*Iz(a,2,0);  // d/dAz
	    q151 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,4,1)
                     - 3*Ix(a,1,0)*Iy(a,0,0)*Iz(a,2,1);  // d/dAz
	    q152 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dAz
	    q153 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,4,0)
                     - 3*Ix(a,0,1)*Iy(a,1,0)*Iz(a,2,0);  // d/dAz
	    q154 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,4,0)
                     - 3*Ix(a,0,0)*Iy(a,1,1)*Iz(a,2,0);  // d/dAz
	    q155 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,4,1)
                     - 3*Ix(a,0,0)*Iy(a,1,0)*Iz(a,2,1);  // d/dAz
	    q156 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q157 += alpha*Ix(a,2,1)*Iy(a,2,0)*Iz(a,1,0); // d/dAz
	    q158 += alpha*Ix(a,2,0)*Iy(a,2,1)*Iz(a,1,0); // d/dAz
	    q159 += alpha*Ix(a,2,0)*Iy(a,2,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[150] += q150*C_[1];
	I[151] += q151*C_[1];
	I[152] += q152*C_[0];
	I[153] += q153*C_[1];
	I[154] += q154*C_[1];
	I[155] += q155*C_[1];
	I[156] += q156*C_[0];
	I[157] += q157*C_[1];
	I[158] += q158*C_[1];
	I[159] += q159*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q160 = 0.0;
	T q161 = 0.0;
	T q162 = 0.0;
	T q163 = 0.0;
	T q164 = 0.0;
	T q165 = 0.0;
	T q166 = 0.0;
	T q167 = 0.0;
	T q168 = 0.0;
	T q169 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q160 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q161 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,3,0)
                     - 2*Ix(a,2,1)*Iy(a,0,0)*Iz(a,1,0);  // d/dAz
	    q162 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,3,0)
                     - 2*Ix(a,2,0)*Iy(a,0,1)*Iz(a,1,0);  // d/dAz
	    q163 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,3,1)
                     - 2*Ix(a,2,0)*Iy(a,0,0)*Iz(a,1,1);  // d/dAz
	    q164 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dAz
	    q165 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,3,0)
                     - 2*Ix(a,0,1)*Iy(a,2,0)*Iz(a,1,0);  // d/dAz
	    q166 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,3,0)
                     - 2*Ix(a,0,0)*Iy(a,2,1)*Iz(a,1,0);  // d/dAz
	    q167 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,3,1)
                     - 2*Ix(a,0,0)*Iy(a,2,0)*Iz(a,1,1);  // d/dAz
	    q168 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	    q169 += alpha*Ix(a,2,1)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,2,1)*Iy(a,1,0)*Iz(a,0,0);  // d/dAz
	}
	    
	//contraction coefficients
	I[160] += q160*C_[0];
	I[161] += q161*C_[1];
	I[162] += q162*C_[1];
	I[163] += q163*C_[1];
	I[164] += q164*C_[0];
	I[165] += q165*C_[1];
	I[166] += q166*C_[1];
	I[167] += q167*C_[1];
	I[168] += q168*C_[0];
	I[169] += q169*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q170 = 0.0;
	T q171 = 0.0;
	T q172 = 0.0;
	T q173 = 0.0;
	T q174 = 0.0;
	T q175 = 0.0;
	T q176 = 0.0;
	T q177 = 0.0;
	T q178 = 0.0;
	T q179 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q170 += alpha*Ix(a,2,0)*Iy(a,1,1)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,1,1)*Iz(a,0,0);  // d/dAz
	    q171 += alpha*Ix(a,2,0)*Iy(a,1,0)*Iz(a,2,1)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,0,1);  // d/dAz
	    q172 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q173 += alpha*Ix(a,1,1)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,1,1)*Iy(a,2,0)*Iz(a,0,0);  // d/dAz
	    q174 += alpha*Ix(a,1,0)*Iy(a,2,1)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,2,1)*Iz(a,0,0);  // d/dAz
	    q175 += alpha*Ix(a,1,0)*Iy(a,2,0)*Iz(a,2,1)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,0,1);  // d/dAz
	    q176 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q177 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,3,0)
                     - 2*Ix(a,1,1)*Iy(a,1,0)*Iz(a,1,0);  // d/dAz
	    q178 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,3,0)
                     - 2*Ix(a,1,0)*Iy(a,1,1)*Iz(a,1,0);  // d/dAz
	    q179 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,3,1)
                     - 2*Ix(a,1,0)*Iy(a,1,0)*Iz(a,1,1);  // d/dAz
	}
	    
	//contraction coefficients
	I[170] += q170*C_[1];
	I[171] += q171*C_[1];
	I[172] += q172*C_[0];
	I[173] += q173*C_[1];
	I[174] += q174*C_[1];
	I[175] += q175*C_[1];
	I[176] += q176*C_[0];
	I[177] += q177*C_[1];
	I[178] += q178*C_[1];
	I[179] += q179*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q180 = 0.0;
	T q181 = 0.0;
	T q182 = 0.0;
	T q183 = 0.0;
	T q184 = 0.0;
	T q185 = 0.0;
	T q186 = 0.0;
	T q187 = 0.0;
	T q188 = 0.0;
	T q189 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q180 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q181 += beta*Ix(a,4,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q182 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q183 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q184 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,0); // d/dBx
	    q185 += beta*Ix(a,0,2)*Iy(a,4,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,0);  // d/dBx
	    q186 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,0); // d/dBx
	    q187 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,1); // d/dBx
	    q188 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,0); // d/dBx
	    q189 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,4,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[180] += q180*C_[0];
	I[181] += q181*C_[1];
	I[182] += q182*C_[1];
	I[183] += q183*C_[1];
	I[184] += q184*C_[0];
	I[185] += q185*C_[1];
	I[186] += q186*C_[1];
	I[187] += q187*C_[1];
	I[188] += q188*C_[0];
	I[189] += q189*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q190 = 0.0;
	T q191 = 0.0;
	T q192 = 0.0;
	T q193 = 0.0;
	T q194 = 0.0;
	T q195 = 0.0;
	T q196 = 0.0;
	T q197 = 0.0;
	T q198 = 0.0;
	T q199 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q190 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,0); // d/dBx
	    q191 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,1); // d/dBx
	    q192 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,0); // d/dBx
	    q193 += beta*Ix(a,3,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q194 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBx
	    q195 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBx
	    q196 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,0); // d/dBx
	    q197 += beta*Ix(a,3,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q198 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBx
	    q199 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBx
	}
	    
	//contraction coefficients
	I[190] += q190*C_[1];
	I[191] += q191*C_[1];
	I[192] += q192*C_[0];
	I[193] += q193*C_[1];
	I[194] += q194*C_[1];
	I[195] += q195*C_[1];
	I[196] += q196*C_[0];
	I[197] += q197*C_[1];
	I[198] += q198*C_[1];
	I[199] += q199*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q200 = 0.0;
	T q201 = 0.0;
	T q202 = 0.0;
	T q203 = 0.0;
	T q204 = 0.0;
	T q205 = 0.0;
	T q206 = 0.0;
	T q207 = 0.0;
	T q208 = 0.0;
	T q209 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q200 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,0); // d/dBx
	    q201 += beta*Ix(a,1,2)*Iy(a,3,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBx
	    q202 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,0); // d/dBx
	    q203 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,1); // d/dBx
	    q204 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,0); // d/dBx
	    q205 += beta*Ix(a,0,2)*Iy(a,3,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,0);  // d/dBx
	    q206 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,0); // d/dBx
	    q207 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,1); // d/dBx
	    q208 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,0); // d/dBx
	    q209 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,3,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[200] += q200*C_[0];
	I[201] += q201*C_[1];
	I[202] += q202*C_[1];
	I[203] += q203*C_[1];
	I[204] += q204*C_[0];
	I[205] += q205*C_[1];
	I[206] += q206*C_[1];
	I[207] += q207*C_[1];
	I[208] += q208*C_[0];
	I[209] += q209*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q210 = 0.0;
	T q211 = 0.0;
	T q212 = 0.0;
	T q213 = 0.0;
	T q214 = 0.0;
	T q215 = 0.0;
	T q216 = 0.0;
	T q217 = 0.0;
	T q218 = 0.0;
	T q219 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q210 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,0); // d/dBx
	    q211 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,1); // d/dBx
	    q212 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,0); // d/dBx
	    q213 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,0);  // d/dBx
	    q214 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,0); // d/dBx
	    q215 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,1); // d/dBx
	    q216 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,0); // d/dBx
	    q217 += beta*Ix(a,2,2)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBx
	    q218 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBx
	    q219 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBx
	}
	    
	//contraction coefficients
	I[210] += q210*C_[1];
	I[211] += q211*C_[1];
	I[212] += q212*C_[0];
	I[213] += q213*C_[1];
	I[214] += q214*C_[1];
	I[215] += q215*C_[1];
	I[216] += q216*C_[0];
	I[217] += q217*C_[1];
	I[218] += q218*C_[1];
	I[219] += q219*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q220 = 0.0;
	T q221 = 0.0;
	T q222 = 0.0;
	T q223 = 0.0;
	T q224 = 0.0;
	T q225 = 0.0;
	T q226 = 0.0;
	T q227 = 0.0;
	T q228 = 0.0;
	T q229 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q220 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,0); // d/dBx
	    q221 += beta*Ix(a,2,2)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBx
	    q222 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBx
	    q223 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBx
	    q224 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,0); // d/dBx
	    q225 += beta*Ix(a,0,2)*Iy(a,2,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,0);  // d/dBx
	    q226 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,0); // d/dBx
	    q227 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,1); // d/dBx
	    q228 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,0); // d/dBx
	    q229 += beta*Ix(a,2,2)*Iy(a,1,0)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[220] += q220*C_[0];
	I[221] += q221*C_[1];
	I[222] += q222*C_[1];
	I[223] += q223*C_[1];
	I[224] += q224*C_[0];
	I[225] += q225*C_[1];
	I[226] += q226*C_[1];
	I[227] += q227*C_[1];
	I[228] += q228*C_[0];
	I[229] += q229*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q230 = 0.0;
	T q231 = 0.0;
	T q232 = 0.0;
	T q233 = 0.0;
	T q234 = 0.0;
	T q235 = 0.0;
	T q236 = 0.0;
	T q237 = 0.0;
	T q238 = 0.0;
	T q239 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q230 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBx
	    q231 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBx
	    q232 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,0); // d/dBx
	    q233 += beta*Ix(a,1,2)*Iy(a,2,0)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBx
	    q234 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,0); // d/dBx
	    q235 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,1); // d/dBx
	    q236 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,0); // d/dBx
	    q237 += beta*Ix(a,1,2)*Iy(a,1,0)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBx
	    q238 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,0); // d/dBx
	    q239 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,1); // d/dBx
	}
	    
	//contraction coefficients
	I[230] += q230*C_[1];
	I[231] += q231*C_[1];
	I[232] += q232*C_[0];
	I[233] += q233*C_[1];
	I[234] += q234*C_[1];
	I[235] += q235*C_[1];
	I[236] += q236*C_[0];
	I[237] += q237*C_[1];
	I[238] += q238*C_[1];
	I[239] += q239*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q240 = 0.0;
	T q241 = 0.0;
	T q242 = 0.0;
	T q243 = 0.0;
	T q244 = 0.0;
	T q245 = 0.0;
	T q246 = 0.0;
	T q247 = 0.0;
	T q248 = 0.0;
	T q249 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q240 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q241 += beta*Ix(a,4,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q242 += beta*Ix(a,4,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q243 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q244 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,0); // d/dBy
	    q245 += beta*Ix(a,0,1)*Iy(a,4,1)*Iz(a,0,0); // d/dBy
	    q246 += beta*Ix(a,0,0)*Iy(a,4,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,0);  // d/dBy
	    q247 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,1); // d/dBy
	    q248 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,0); // d/dBy
	    q249 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,4,0); // d/dBy
	}
	    
	//contraction coefficients
	I[240] += q240*C_[0];
	I[241] += q241*C_[1];
	I[242] += q242*C_[1];
	I[243] += q243*C_[1];
	I[244] += q244*C_[0];
	I[245] += q245*C_[1];
	I[246] += q246*C_[1];
	I[247] += q247*C_[1];
	I[248] += q248*C_[0];
	I[249] += q249*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q250 = 0.0;
	T q251 = 0.0;
	T q252 = 0.0;
	T q253 = 0.0;
	T q254 = 0.0;
	T q255 = 0.0;
	T q256 = 0.0;
	T q257 = 0.0;
	T q258 = 0.0;
	T q259 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q250 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,4,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,0);  // d/dBy
	    q251 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,1); // d/dBy
	    q252 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q253 += beta*Ix(a,3,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q254 += beta*Ix(a,3,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q255 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q256 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q257 += beta*Ix(a,3,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q258 += beta*Ix(a,3,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q259 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[250] += q250*C_[1];
	I[251] += q251*C_[1];
	I[252] += q252*C_[0];
	I[253] += q253*C_[1];
	I[254] += q254*C_[1];
	I[255] += q255*C_[1];
	I[256] += q256*C_[0];
	I[257] += q257*C_[1];
	I[258] += q258*C_[1];
	I[259] += q259*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q260 = 0.0;
	T q261 = 0.0;
	T q262 = 0.0;
	T q263 = 0.0;
	T q264 = 0.0;
	T q265 = 0.0;
	T q266 = 0.0;
	T q267 = 0.0;
	T q268 = 0.0;
	T q269 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q260 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q261 += beta*Ix(a,1,1)*Iy(a,3,1)*Iz(a,0,0); // d/dBy
	    q262 += beta*Ix(a,1,0)*Iy(a,3,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBy
	    q263 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,1); // d/dBy
	    q264 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,0); // d/dBy
	    q265 += beta*Ix(a,0,1)*Iy(a,3,1)*Iz(a,1,0); // d/dBy
	    q266 += beta*Ix(a,0,0)*Iy(a,3,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,0);  // d/dBy
	    q267 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,1); // d/dBy
	    q268 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	    q269 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,3,0); // d/dBy
	}
	    
	//contraction coefficients
	I[260] += q260*C_[0];
	I[261] += q261*C_[1];
	I[262] += q262*C_[1];
	I[263] += q263*C_[1];
	I[264] += q264*C_[0];
	I[265] += q265*C_[1];
	I[266] += q266*C_[1];
	I[267] += q267*C_[1];
	I[268] += q268*C_[0];
	I[269] += q269*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q270 = 0.0;
	T q271 = 0.0;
	T q272 = 0.0;
	T q273 = 0.0;
	T q274 = 0.0;
	T q275 = 0.0;
	T q276 = 0.0;
	T q277 = 0.0;
	T q278 = 0.0;
	T q279 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q270 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,3,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBy
	    q271 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,1); // d/dBy
	    q272 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,0); // d/dBy
	    q273 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,3,0); // d/dBy
	    q274 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,3,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,0);  // d/dBy
	    q275 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,1); // d/dBy
	    q276 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q277 += beta*Ix(a,2,1)*Iy(a,2,1)*Iz(a,0,0); // d/dBy
	    q278 += beta*Ix(a,2,0)*Iy(a,2,2)*Iz(a,0,0)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBy
	    q279 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBy
	}
	    
	//contraction coefficients
	I[270] += q270*C_[1];
	I[271] += q271*C_[1];
	I[272] += q272*C_[0];
	I[273] += q273*C_[1];
	I[274] += q274*C_[1];
	I[275] += q275*C_[1];
	I[276] += q276*C_[0];
	I[277] += q277*C_[1];
	I[278] += q278*C_[1];
	I[279] += q279*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q280 = 0.0;
	T q281 = 0.0;
	T q282 = 0.0;
	T q283 = 0.0;
	T q284 = 0.0;
	T q285 = 0.0;
	T q286 = 0.0;
	T q287 = 0.0;
	T q288 = 0.0;
	T q289 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q280 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q281 += beta*Ix(a,2,1)*Iy(a,0,1)*Iz(a,2,0); // d/dBy
	    q282 += beta*Ix(a,2,0)*Iy(a,0,2)*Iz(a,2,0)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBy
	    q283 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBy
	    q284 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,0); // d/dBy
	    q285 += beta*Ix(a,0,1)*Iy(a,2,1)*Iz(a,2,0); // d/dBy
	    q286 += beta*Ix(a,0,0)*Iy(a,2,2)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,0);  // d/dBy
	    q287 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,1); // d/dBy
	    q288 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	    q289 += beta*Ix(a,2,1)*Iy(a,1,1)*Iz(a,1,0); // d/dBy
	}
	    
	//contraction coefficients
	I[280] += q280*C_[0];
	I[281] += q281*C_[1];
	I[282] += q282*C_[1];
	I[283] += q283*C_[1];
	I[284] += q284*C_[0];
	I[285] += q285*C_[1];
	I[286] += q286*C_[1];
	I[287] += q287*C_[1];
	I[288] += q288*C_[0];
	I[289] += q289*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q290 = 0.0;
	T q291 = 0.0;
	T q292 = 0.0;
	T q293 = 0.0;
	T q294 = 0.0;
	T q295 = 0.0;
	T q296 = 0.0;
	T q297 = 0.0;
	T q298 = 0.0;
	T q299 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q290 += beta*Ix(a,2,0)*Iy(a,1,2)*Iz(a,1,0)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBy
	    q291 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBy
	    q292 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q293 += beta*Ix(a,1,1)*Iy(a,2,1)*Iz(a,1,0); // d/dBy
	    q294 += beta*Ix(a,1,0)*Iy(a,2,2)*Iz(a,1,0)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBy
	    q295 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,1); // d/dBy
	    q296 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q297 += beta*Ix(a,1,1)*Iy(a,1,1)*Iz(a,2,0); // d/dBy
	    q298 += beta*Ix(a,1,0)*Iy(a,1,2)*Iz(a,2,0)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBy
	    q299 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,1); // d/dBy
	}
	    
	//contraction coefficients
	I[290] += q290*C_[1];
	I[291] += q291*C_[1];
	I[292] += q292*C_[0];
	I[293] += q293*C_[1];
	I[294] += q294*C_[1];
	I[295] += q295*C_[1];
	I[296] += q296*C_[0];
	I[297] += q297*C_[1];
	I[298] += q298*C_[1];
	I[299] += q299*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q300 = 0.0;
	T q301 = 0.0;
	T q302 = 0.0;
	T q303 = 0.0;
	T q304 = 0.0;
	T q305 = 0.0;
	T q306 = 0.0;
	T q307 = 0.0;
	T q308 = 0.0;
	T q309 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q300 += beta*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q301 += beta*Ix(a,4,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q302 += beta*Ix(a,4,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q303 += beta*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,4,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q304 += beta*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,1); // d/dBz
	    q305 += beta*Ix(a,0,1)*Iy(a,4,0)*Iz(a,0,1); // d/dBz
	    q306 += beta*Ix(a,0,0)*Iy(a,4,1)*Iz(a,0,1); // d/dBz
	    q307 += beta*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,4,0)*Iz(a,0,0);  // d/dBz
	    q308 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,1); // d/dBz
	    q309 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,4,1); // d/dBz
	}
	    
	//contraction coefficients
	I[300] += q300*C_[0];
	I[301] += q301*C_[1];
	I[302] += q302*C_[1];
	I[303] += q303*C_[1];
	I[304] += q304*C_[0];
	I[305] += q305*C_[1];
	I[306] += q306*C_[1];
	I[307] += q307*C_[1];
	I[308] += q308*C_[0];
	I[309] += q309*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q310 = 0.0;
	T q311 = 0.0;
	T q312 = 0.0;
	T q313 = 0.0;
	T q314 = 0.0;
	T q315 = 0.0;
	T q316 = 0.0;
	T q317 = 0.0;
	T q318 = 0.0;
	T q319 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q310 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,4,1); // d/dBz
	    q311 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,4,0);  // d/dBz
	    q312 += beta*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q313 += beta*Ix(a,3,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q314 += beta*Ix(a,3,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q315 += beta*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,3,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q316 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q317 += beta*Ix(a,3,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q318 += beta*Ix(a,3,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q319 += beta*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,3,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[310] += q310*C_[1];
	I[311] += q311*C_[1];
	I[312] += q312*C_[0];
	I[313] += q313*C_[1];
	I[314] += q314*C_[1];
	I[315] += q315*C_[1];
	I[316] += q316*C_[0];
	I[317] += q317*C_[1];
	I[318] += q318*C_[1];
	I[319] += q319*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q320 = 0.0;
	T q321 = 0.0;
	T q322 = 0.0;
	T q323 = 0.0;
	T q324 = 0.0;
	T q325 = 0.0;
	T q326 = 0.0;
	T q327 = 0.0;
	T q328 = 0.0;
	T q329 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q320 += beta*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q321 += beta*Ix(a,1,1)*Iy(a,3,0)*Iz(a,0,1); // d/dBz
	    q322 += beta*Ix(a,1,0)*Iy(a,3,1)*Iz(a,0,1); // d/dBz
	    q323 += beta*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,3,0)*Iz(a,0,0);  // d/dBz
	    q324 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,1); // d/dBz
	    q325 += beta*Ix(a,0,1)*Iy(a,3,0)*Iz(a,1,1); // d/dBz
	    q326 += beta*Ix(a,0,0)*Iy(a,3,1)*Iz(a,1,1); // d/dBz
	    q327 += beta*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,3,0)*Iz(a,1,0);  // d/dBz
	    q328 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	    q329 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,3,1); // d/dBz
	}
	    
	//contraction coefficients
	I[320] += q320*C_[0];
	I[321] += q321*C_[1];
	I[322] += q322*C_[1];
	I[323] += q323*C_[1];
	I[324] += q324*C_[0];
	I[325] += q325*C_[1];
	I[326] += q326*C_[1];
	I[327] += q327*C_[1];
	I[328] += q328*C_[0];
	I[329] += q329*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q330 = 0.0;
	T q331 = 0.0;
	T q332 = 0.0;
	T q333 = 0.0;
	T q334 = 0.0;
	T q335 = 0.0;
	T q336 = 0.0;
	T q337 = 0.0;
	T q338 = 0.0;
	T q339 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q330 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,3,1); // d/dBz
	    q331 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,3,0);  // d/dBz
	    q332 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,1); // d/dBz
	    q333 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,3,1); // d/dBz
	    q334 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,3,1); // d/dBz
	    q335 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,3,0);  // d/dBz
	    q336 += beta*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q337 += beta*Ix(a,2,1)*Iy(a,2,0)*Iz(a,0,1); // d/dBz
	    q338 += beta*Ix(a,2,0)*Iy(a,2,1)*Iz(a,0,1); // d/dBz
	    q339 += beta*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,2)
                     - 1*Ix(a,2,0)*Iy(a,2,0)*Iz(a,0,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[330] += q330*C_[1];
	I[331] += q331*C_[1];
	I[332] += q332*C_[0];
	I[333] += q333*C_[1];
	I[334] += q334*C_[1];
	I[335] += q335*C_[1];
	I[336] += q336*C_[0];
	I[337] += q337*C_[1];
	I[338] += q338*C_[1];
	I[339] += q339*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q340 = 0.0;
	T q341 = 0.0;
	T q342 = 0.0;
	T q343 = 0.0;
	T q344 = 0.0;
	T q345 = 0.0;
	T q346 = 0.0;
	T q347 = 0.0;
	T q348 = 0.0;
	T q349 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q340 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q341 += beta*Ix(a,2,1)*Iy(a,0,0)*Iz(a,2,1); // d/dBz
	    q342 += beta*Ix(a,2,0)*Iy(a,0,1)*Iz(a,2,1); // d/dBz
	    q343 += beta*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,2)
                     - 1*Ix(a,2,0)*Iy(a,0,0)*Iz(a,2,0);  // d/dBz
	    q344 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,1); // d/dBz
	    q345 += beta*Ix(a,0,1)*Iy(a,2,0)*Iz(a,2,1); // d/dBz
	    q346 += beta*Ix(a,0,0)*Iy(a,2,1)*Iz(a,2,1); // d/dBz
	    q347 += beta*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,2)
                     - 1*Ix(a,0,0)*Iy(a,2,0)*Iz(a,2,0);  // d/dBz
	    q348 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	    q349 += beta*Ix(a,2,1)*Iy(a,1,0)*Iz(a,1,1); // d/dBz
	}
	    
	//contraction coefficients
	I[340] += q340*C_[0];
	I[341] += q341*C_[1];
	I[342] += q342*C_[1];
	I[343] += q343*C_[1];
	I[344] += q344*C_[0];
	I[345] += q345*C_[1];
	I[346] += q346*C_[1];
	I[347] += q347*C_[1];
	I[348] += q348*C_[0];
	I[349] += q349*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[2];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 2; ++ i) C_[i] = C[k*2 + i];

	// function registers
	T q350 = 0.0;
	T q351 = 0.0;
	T q352 = 0.0;
	T q353 = 0.0;
	T q354 = 0.0;
	T q355 = 0.0;
	T q356 = 0.0;
	T q357 = 0.0;
	T q358 = 0.0;
	T q359 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q350 += beta*Ix(a,2,0)*Iy(a,1,1)*Iz(a,1,1); // d/dBz
	    q351 += beta*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,2)
                     - 1*Ix(a,2,0)*Iy(a,1,0)*Iz(a,1,0);  // d/dBz
	    q352 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q353 += beta*Ix(a,1,1)*Iy(a,2,0)*Iz(a,1,1); // d/dBz
	    q354 += beta*Ix(a,1,0)*Iy(a,2,1)*Iz(a,1,1); // d/dBz
	    q355 += beta*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,2)
                     - 1*Ix(a,1,0)*Iy(a,2,0)*Iz(a,1,0);  // d/dBz
	    q356 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q357 += beta*Ix(a,1,1)*Iy(a,1,0)*Iz(a,2,1); // d/dBz
	    q358 += beta*Ix(a,1,0)*Iy(a,1,1)*Iz(a,2,1); // d/dBz
	    q359 += beta*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,2)
                     - 1*Ix(a,1,0)*Iy(a,1,0)*Iz(a,2,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[350] += q350*C_[1];
	I[351] += q351*C_[1];
	I[352] += q352*C_[0];
	I[353] += q353*C_[1];
	I[354] += q354*C_[1];
	I[355] += q355*C_[1];
	I[356] += q356*C_[0];
	I[357] += q357*C_[1];
	I[358] += q358*C_[1];
	I[359] += q359*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}



/** 
    @brief <spsp| shell quadrature
    @param normalize
    @param tol tolerance
    @param K number of contractions
    @param C contraction coefficients
    @param dim2d 2-D integrals dimensions
    @param Ix 2-D integral, Ix(N,Li,Lj,K,Lk,Ll)
    @param Iy 2-D integral, Iy(N,Li,Lj,K,Lk,Ll)
    @param Iz 2-D integral, Iz(N,Li,Lj,K,Lk,Ll)
    @param scale scale factor
    @param[out] I integral batch
    @return number of screened integrals
*/


template<>
struct impl< meta::state<rysq::SP,rysq::SP> > {

    template<typename T>
    struct aligned {
#if (defined(__GNUC__) && ((__GNUC__ < 4) || (__GNUG__ == 4 && __GNUC_MINOR__ < 3)))
#warning "alignment not implemented for GNUC < 4.3"
	typedef T type;
#else
	typedef T type __attribute__((aligned (16)));
#endif
    };

    template<size_t N, typename T, size_t NT>
    static size_t apply(bool normalize,
			double tol, int K,
			const double *__restrict C,
			const double *__restrict AExp,
			const double *__restrict BExp,
			int dim2d,
			const typename aligned<T>::type *__restrict Ix,
			const typename aligned<T>::type *__restrict Iy, 
			const typename aligned<T>::type *__restrict Iz, 
			double scale,
			double *__restrict I);// __attribute__((pure));
};

template<size_t N, typename T, size_t NT>
size_t impl< meta::state<rysq::SP,rysq::SP> >::apply(bool normalize,
			     double tol, int K,
			     const double *__restrict C,
			     const double *__restrict AExp,
			     const double *__restrict BExp,
			     int dim2d,
			     const typename aligned<T>::type *__restrict Ix,
			     const typename aligned<T>::type *__restrict Iy, 
			     const typename aligned<T>::type *__restrict Iz, 
			     double scale,
			     double *__restrict I) {

    const int Li1 = 3;
    int num = 0;
    


#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[4];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 4; ++ i) C_[i] = C[k*4 + i];

	// function registers
	T q0 = 0.0;
	T q1 = 0.0;
	T q2 = 0.0;
	T q3 = 0.0;
	T q4 = 0.0;
	T q5 = 0.0;
	T q6 = 0.0;
	T q7 = 0.0;
	T q8 = 0.0;
	T q9 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q0 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q1 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0); // d/dAx
	    q2 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0); // d/dAx
	    q3 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1); // d/dAx
	    q4 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q5 += alpha*Ix(a,2,1)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAx
	    q6 += alpha*Ix(a,2,0)*Iy(a,0,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAx
	    q7 += alpha*Ix(a,2,0)*Iy(a,0,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAx
	    q8 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	    q9 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAx
	}
	    
	//contraction coefficients
	I[0] += q0*C_[0];
	I[1] += q1*C_[1];
	I[2] += q2*C_[1];
	I[3] += q3*C_[1];
	I[4] += q4*C_[2];
	I[5] += q5*C_[3];
	I[6] += q6*C_[3];
	I[7] += q7*C_[3];
	I[8] += q8*C_[2];
	I[9] += q9*C_[3];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[4];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 4; ++ i) C_[i] = C[k*4 + i];

	// function registers
	T q10 = 0.0;
	T q11 = 0.0;
	T q12 = 0.0;
	T q13 = 0.0;
	T q14 = 0.0;
	T q15 = 0.0;
	T q16 = 0.0;
	T q17 = 0.0;
	T q18 = 0.0;
	T q19 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q10 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAx
	    q11 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAx
	    q12 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q13 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAx
	    q14 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAx
	    q15 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAx
	    q16 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q17 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q18 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q19 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	}
	    
	//contraction coefficients
	I[10] += q10*C_[3];
	I[11] += q11*C_[3];
	I[12] += q12*C_[2];
	I[13] += q13*C_[3];
	I[14] += q14*C_[3];
	I[15] += q15*C_[3];
	I[16] += q16*C_[0];
	I[17] += q17*C_[1];
	I[18] += q18*C_[1];
	I[19] += q19*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[4];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 4; ++ i) C_[i] = C[k*4 + i];

	// function registers
	T q20 = 0.0;
	T q21 = 0.0;
	T q22 = 0.0;
	T q23 = 0.0;
	T q24 = 0.0;
	T q25 = 0.0;
	T q26 = 0.0;
	T q27 = 0.0;
	T q28 = 0.0;
	T q29 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q20 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q21 += alpha*Ix(a,1,1)*Iy(a,1,0)*Iz(a,0,0); // d/dAy
	    q22 += alpha*Ix(a,1,0)*Iy(a,1,1)*Iz(a,0,0); // d/dAy
	    q23 += alpha*Ix(a,1,0)*Iy(a,1,0)*Iz(a,0,1); // d/dAy
	    q24 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q25 += alpha*Ix(a,0,1)*Iy(a,2,0)*Iz(a,0,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAy
	    q26 += alpha*Ix(a,0,0)*Iy(a,2,1)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAy
	    q27 += alpha*Ix(a,0,0)*Iy(a,2,0)*Iz(a,0,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAy
	    q28 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	    q29 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAy
	}
	    
	//contraction coefficients
	I[20] += q20*C_[2];
	I[21] += q21*C_[3];
	I[22] += q22*C_[3];
	I[23] += q23*C_[3];
	I[24] += q24*C_[2];
	I[25] += q25*C_[3];
	I[26] += q26*C_[3];
	I[27] += q27*C_[3];
	I[28] += q28*C_[2];
	I[29] += q29*C_[3];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[4];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 4; ++ i) C_[i] = C[k*4 + i];

	// function registers
	T q30 = 0.0;
	T q31 = 0.0;
	T q32 = 0.0;
	T q33 = 0.0;
	T q34 = 0.0;
	T q35 = 0.0;
	T q36 = 0.0;
	T q37 = 0.0;
	T q38 = 0.0;
	T q39 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q30 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAy
	    q31 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAy
	    q32 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q33 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q34 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q35 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	    q36 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q37 += alpha*Ix(a,1,1)*Iy(a,0,0)*Iz(a,1,0); // d/dAz
	    q38 += alpha*Ix(a,1,0)*Iy(a,0,1)*Iz(a,1,0); // d/dAz
	    q39 += alpha*Ix(a,1,0)*Iy(a,0,0)*Iz(a,1,1); // d/dAz
	}
	    
	//contraction coefficients
	I[30] += q30*C_[3];
	I[31] += q31*C_[3];
	I[32] += q32*C_[0];
	I[33] += q33*C_[1];
	I[34] += q34*C_[1];
	I[35] += q35*C_[1];
	I[36] += q36*C_[2];
	I[37] += q37*C_[3];
	I[38] += q38*C_[3];
	I[39] += q39*C_[3];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[4];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 4; ++ i) C_[i] = C[k*4 + i];

	// function registers
	T q40 = 0.0;
	T q41 = 0.0;
	T q42 = 0.0;
	T q43 = 0.0;
	T q44 = 0.0;
	T q45 = 0.0;
	T q46 = 0.0;
	T q47 = 0.0;
	T q48 = 0.0;
	T q49 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q40 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q41 += alpha*Ix(a,0,1)*Iy(a,1,0)*Iz(a,1,0); // d/dAz
	    q42 += alpha*Ix(a,0,0)*Iy(a,1,1)*Iz(a,1,0); // d/dAz
	    q43 += alpha*Ix(a,0,0)*Iy(a,1,0)*Iz(a,1,1); // d/dAz
	    q44 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q45 += alpha*Ix(a,0,1)*Iy(a,0,0)*Iz(a,2,0)
                     - 1*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0);  // d/dAz
	    q46 += alpha*Ix(a,0,0)*Iy(a,0,1)*Iz(a,2,0)
                     - 1*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0);  // d/dAz
	    q47 += alpha*Ix(a,0,0)*Iy(a,0,0)*Iz(a,2,1)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1);  // d/dAz
	    q48 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q49 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	}
	    
	//contraction coefficients
	I[40] += q40*C_[2];
	I[41] += q41*C_[3];
	I[42] += q42*C_[3];
	I[43] += q43*C_[3];
	I[44] += q44*C_[2];
	I[45] += q45*C_[3];
	I[46] += q46*C_[3];
	I[47] += q47*C_[3];
	I[48] += q48*C_[0];
	I[49] += q49*C_[1];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[4];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 4; ++ i) C_[i] = C[k*4 + i];

	// function registers
	T q50 = 0.0;
	T q51 = 0.0;
	T q52 = 0.0;
	T q53 = 0.0;
	T q54 = 0.0;
	T q55 = 0.0;
	T q56 = 0.0;
	T q57 = 0.0;
	T q58 = 0.0;
	T q59 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q50 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q51 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q52 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,0); // d/dBx
	    q53 += beta*Ix(a,1,2)*Iy(a,0,0)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBx
	    q54 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBx
	    q55 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBx
	    q56 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,0); // d/dBx
	    q57 += beta*Ix(a,0,2)*Iy(a,1,0)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBx
	    q58 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBx
	    q59 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBx
	}
	    
	//contraction coefficients
	I[50] += q50*C_[1];
	I[51] += q51*C_[1];
	I[52] += q52*C_[2];
	I[53] += q53*C_[3];
	I[54] += q54*C_[3];
	I[55] += q55*C_[3];
	I[56] += q56*C_[2];
	I[57] += q57*C_[3];
	I[58] += q58*C_[3];
	I[59] += q59*C_[3];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[4];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 4; ++ i) C_[i] = C[k*4 + i];

	// function registers
	T q60 = 0.0;
	T q61 = 0.0;
	T q62 = 0.0;
	T q63 = 0.0;
	T q64 = 0.0;
	T q65 = 0.0;
	T q66 = 0.0;
	T q67 = 0.0;
	T q68 = 0.0;
	T q69 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q60 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,0); // d/dBx
	    q61 += beta*Ix(a,0,2)*Iy(a,0,0)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBx
	    q62 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBx
	    q63 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBx
	    q64 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q65 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q66 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q67 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q68 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	    q69 += beta*Ix(a,1,1)*Iy(a,0,1)*Iz(a,0,0); // d/dBy
	}
	    
	//contraction coefficients
	I[60] += q60*C_[2];
	I[61] += q61*C_[3];
	I[62] += q62*C_[3];
	I[63] += q63*C_[3];
	I[64] += q64*C_[0];
	I[65] += q65*C_[1];
	I[66] += q66*C_[1];
	I[67] += q67*C_[1];
	I[68] += q68*C_[2];
	I[69] += q69*C_[3];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[4];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 4; ++ i) C_[i] = C[k*4 + i];

	// function registers
	T q70 = 0.0;
	T q71 = 0.0;
	T q72 = 0.0;
	T q73 = 0.0;
	T q74 = 0.0;
	T q75 = 0.0;
	T q76 = 0.0;
	T q77 = 0.0;
	T q78 = 0.0;
	T q79 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q70 += beta*Ix(a,1,0)*Iy(a,0,2)*Iz(a,0,0)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBy
	    q71 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBy
	    q72 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q73 += beta*Ix(a,0,1)*Iy(a,1,1)*Iz(a,0,0); // d/dBy
	    q74 += beta*Ix(a,0,0)*Iy(a,1,2)*Iz(a,0,0)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBy
	    q75 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBy
	    q76 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q77 += beta*Ix(a,0,1)*Iy(a,0,1)*Iz(a,1,0); // d/dBy
	    q78 += beta*Ix(a,0,0)*Iy(a,0,2)*Iz(a,1,0)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBy
	    q79 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBy
	}
	    
	//contraction coefficients
	I[70] += q70*C_[3];
	I[71] += q71*C_[3];
	I[72] += q72*C_[2];
	I[73] += q73*C_[3];
	I[74] += q74*C_[3];
	I[75] += q75*C_[3];
	I[76] += q76*C_[2];
	I[77] += q77*C_[3];
	I[78] += q78*C_[3];
	I[79] += q79*C_[3];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[4];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 4; ++ i) C_[i] = C[k*4 + i];

	// function registers
	T q80 = 0.0;
	T q81 = 0.0;
	T q82 = 0.0;
	T q83 = 0.0;
	T q84 = 0.0;
	T q85 = 0.0;
	T q86 = 0.0;
	T q87 = 0.0;
	T q88 = 0.0;
	T q89 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q80 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q81 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q82 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q83 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q84 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q85 += beta*Ix(a,1,1)*Iy(a,0,0)*Iz(a,0,1); // d/dBz
	    q86 += beta*Ix(a,1,0)*Iy(a,0,1)*Iz(a,0,1); // d/dBz
	    q87 += beta*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,2)
                     - 1*Ix(a,1,0)*Iy(a,0,0)*Iz(a,0,0);  // d/dBz
	    q88 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	    q89 += beta*Ix(a,0,1)*Iy(a,1,0)*Iz(a,0,1); // d/dBz
	}
	    
	//contraction coefficients
	I[80] += q80*C_[0];
	I[81] += q81*C_[1];
	I[82] += q82*C_[1];
	I[83] += q83*C_[1];
	I[84] += q84*C_[2];
	I[85] += q85*C_[3];
	I[86] += q86*C_[3];
	I[87] += q87*C_[3];
	I[88] += q88*C_[2];
	I[89] += q89*C_[3];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    

#ifdef __GNUG__
     asm("#begin vector loop");
#endif

    for(int k = 0; k < K; k += 1) {
	double C_[4];
        const double alpha = AExp[k];
        const double beta  = BExp[k];
	for (int i = 0; i < 4; ++ i) C_[i] = C[k*4 + i];

	// function registers
	T q90 = 0.0;
	T q91 = 0.0;
	T q92 = 0.0;
	T q93 = 0.0;
	T q94 = 0.0;
	T q95 = 0.0;
#if defined (__INTEL_COMPILER) 
#pragma vector aligned
#endif // alignment attribute

	for (int a = 0; a < int(N); ++a) {
	    q90 += beta*Ix(a,0,0)*Iy(a,1,1)*Iz(a,0,1); // d/dBz
	    q91 += beta*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,2)
                     - 1*Ix(a,0,0)*Iy(a,1,0)*Iz(a,0,0);  // d/dBz
	    q92 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q93 += beta*Ix(a,0,1)*Iy(a,0,0)*Iz(a,1,1); // d/dBz
	    q94 += beta*Ix(a,0,0)*Iy(a,0,1)*Iz(a,1,1); // d/dBz
	    q95 += beta*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,2)
                     - 1*Ix(a,0,0)*Iy(a,0,0)*Iz(a,1,0);  // d/dBz
	}
	    
	//contraction coefficients
	I[90] += q90*C_[3];
	I[91] += q91*C_[3];
	I[92] += q92*C_[2];
	I[93] += q93*C_[3];
	I[94] += q94*C_[3];
	I[95] += q95*C_[3];

	Ix += 3*dim2d;
	Iy += 3*dim2d;
	Iz += 3*dim2d;
	
    }
    Ix = Ix - 3*dim2d*K;
    Iy = Iy - 3*dim2d*K;
    Iz = Iz - 3*dim2d*K;
    
    
    
    return num;
}





#undef Ix
#undef Iy
#undef Iz


} // namespace rysq
} // namespace kernel
} // namespace quadrature


#undef D128
#undef ZERO
#undef SET1

#undef LOAD
#undef LOADU
#undef LOAD1
#undef LOADDUP

#undef STORE
#undef STOREU
#undef STORE1

#undef MUL
#undef ADD
#undef HADD

#undef MUL1
#undef ADD1

#endif // RYSQ_KERNEL_DERIVATIVE_THREEC_QUADRATURE_IMPL_HPP_


